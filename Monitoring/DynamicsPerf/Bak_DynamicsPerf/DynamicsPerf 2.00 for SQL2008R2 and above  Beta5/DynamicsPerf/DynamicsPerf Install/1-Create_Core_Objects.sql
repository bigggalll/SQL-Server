/*
Deployment script for DynamicsPerf

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
USE [master];


GO

IF (DB_ID(N'DynamicsPerf') IS NOT NULL) 
BEGIN
    ALTER DATABASE [DynamicsPerf]
    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [DynamicsPerf];
END

GO
PRINT N'Creating DynamicsPerf...'
GO
CREATE DATABASE [DynamicsPerf] 
GO
USE [DynamicsPerf];


GO
/*
 Pre-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be executed before the build script.	
 Use SQLCMD syntax to include a file in the pre-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the pre-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
declare @n char(1)
set @n = char(10)

declare @stmt nvarchar(max)

select @stmt = isnull( @stmt + @n, '' ) +
'drop synonym [' + SCHEMA_NAME(schema_id) + '].[' + name + ']'
from sys.synonyms

exec sp_executesql @stmt

GO


ALTER DATABASE DynamicsPerf MODIFY FILE(NAME = N'DynamicsPerf', SIZE = 2000MB , MAXSIZE = UNLIMITED, FILEGROWTH = 500MB )

ALTER DATABASE DynamicsPerf MODIFY FILE(NAME = N'DynamicsPerf_log', SIZE = 500MB , MAXSIZE = 2048GB , FILEGROWTH = 100MB )

ALTER DATABASE [DynamicsPerf] SET ANSI_NULL_DEFAULT OFF 

ALTER DATABASE [DynamicsPerf] SET ANSI_NULLS OFF 

ALTER DATABASE [DynamicsPerf] SET ANSI_PADDING OFF 

ALTER DATABASE [DynamicsPerf] SET ANSI_WARNINGS OFF 

ALTER DATABASE [DynamicsPerf] SET ARITHABORT OFF 

ALTER DATABASE [DynamicsPerf] SET AUTO_CLOSE OFF 

ALTER DATABASE [DynamicsPerf] SET AUTO_CREATE_STATISTICS ON 

ALTER DATABASE [DynamicsPerf] SET AUTO_SHRINK OFF 

ALTER DATABASE [DynamicsPerf] SET AUTO_UPDATE_STATISTICS ON 

ALTER DATABASE [DynamicsPerf] SET CURSOR_CLOSE_ON_COMMIT OFF 

ALTER DATABASE [DynamicsPerf] SET CURSOR_DEFAULT  GLOBAL 

ALTER DATABASE [DynamicsPerf] SET CONCAT_NULL_YIELDS_NULL OFF 

ALTER DATABASE [DynamicsPerf] SET NUMERIC_ROUNDABORT OFF 

ALTER DATABASE [DynamicsPerf] SET QUOTED_IDENTIFIER OFF 

ALTER DATABASE [DynamicsPerf] SET RECURSIVE_TRIGGERS OFF 

ALTER DATABASE [DynamicsPerf] SET  ENABLE_BROKER 

ALTER DATABASE [DynamicsPerf] SET AUTO_UPDATE_STATISTICS_ASYNC OFF 

ALTER DATABASE [DynamicsPerf] SET DATE_CORRELATION_OPTIMIZATION OFF 

ALTER DATABASE [DynamicsPerf] SET TRUSTWORTHY OFF 

ALTER DATABASE [DynamicsPerf] SET READ_COMMITTED_SNAPSHOT ON

ALTER DATABASE [DynamicsPerf] SET ALLOW_SNAPSHOT_ISOLATION ON

ALTER DATABASE [DynamicsPerf] SET PARAMETERIZATION SIMPLE 

ALTER DATABASE [DynamicsPerf] SET  READ_WRITE 

ALTER DATABASE [DynamicsPerf] SET RECOVERY SIMPLE 

ALTER DATABASE [DynamicsPerf] SET  MULTI_USER 

ALTER DATABASE [DynamicsPerf] SET PAGE_VERIFY NONE  

ALTER DATABASE [DynamicsPerf] SET DB_CHAINING OFF 
GO

GO
PRINT N'Creating [dbo].[SQL_DATABASES]...';


GO
CREATE TABLE [dbo].[SQL_DATABASES] (
    [SERVER_NAME]                       NVARCHAR (128)   NOT NULL,
    [STATS_TIME]                        DATETIME         NOT NULL,
    [DATABASE_NAME]                     [sysname]        NOT NULL,
    [DATABASE_ID]                       INT              NOT NULL,
    [SOURCE_DATABASE_ID]                INT              NULL,
    [OWNER_SID]                         VARBINARY (85)   NULL,
    [CREATE_DATE]                       DATETIME         NOT NULL,
    [COMPATIBILITY_LEVEL]               TINYINT          NOT NULL,
    [COLLATION_NAME]                    [sysname]        NULL,
    [USER_ACCESS]                       TINYINT          NULL,
    [USER_ACCESS_DESC]                  NVARCHAR (60)    NULL,
    [IS_READ_ONLY]                      BIT              NULL,
    [IS_AUTO_CLOSE_ON]                  BIT              NOT NULL,
    [IS_AUTO_SHRINK_ON]                 BIT              NULL,
    [STATE]                             TINYINT          NULL,
    [STATE_DESC]                        NVARCHAR (60)    NULL,
    [IS_IN_STANDBY]                     BIT              NULL,
    [IS_CLEANLY_SHUTDOWN]               BIT              NULL,
    [IS_SUPPLEMENTAL_LOGGING_ENABLED]   BIT              NULL,
    [SNAPSHOT_ISOLATION_STATE]          TINYINT          NULL,
    [SNAPSHOT_ISOLATION_STATE_DESC]     NVARCHAR (60)    NULL,
    [IS_READ_COMMITTED_SNAPSHOT_ON]     BIT              NULL,
    [RECOVERY_MODEL]                    TINYINT          NULL,
    [RECOVERY_MODEL_DESC]               NVARCHAR (60)    NULL,
    [PAGE_VERIFY_OPTION]                TINYINT          NULL,
    [PAGE_VERIFY_OPTION_DESC]           NVARCHAR (60)    NULL,
    [IS_AUTO_CREATE_STATS_ON]           BIT              NULL,
    [IS_AUTO_UPDATE_STATS_ON]           BIT              NULL,
    [IS_AUTO_UPDATE_STATS_ASYNC_ON]     BIT              NULL,
    [IS_ANSI_NULL_DEFAULT_ON]           BIT              NULL,
    [IS_ANSI_NULLS_ON]                  BIT              NULL,
    [IS_ANSI_PADDING_ON]                BIT              NULL,
    [IS_ANSI_WARNINGS_ON]               BIT              NULL,
    [IS_ARITHABORT_ON]                  BIT              NULL,
    [IS_CONCAT_NULL_YIELDS_NULL_ON]     BIT              NULL,
    [IS_NUMERIC_ROUNDABORT_ON]          BIT              NULL,
    [IS_QUOTED_IDENTIFIER_ON]           BIT              NULL,
    [IS_RECURSIVE_TRIGGERS_ON]          BIT              NULL,
    [IS_CURSOR_CLOSE_ON_COMMIT_ON]      BIT              NULL,
    [IS_LOCAL_CURSOR_DEFAULT]           BIT              NULL,
    [IS_FULLTEXT_ENABLED]               BIT              NULL,
    [IS_TRUSTWORTHY_ON]                 BIT              NULL,
    [IS_DB_CHAINING_ON]                 BIT              NULL,
    [IS_PARAMETERIZATION_FORCED]        BIT              NULL,
    [IS_MASTER_KEY_ENCRYPTED_BY_SERVER] BIT              NOT NULL,
    [IS_PUBLISHED]                      BIT              NOT NULL,
    [IS_SUBSCRIBED]                     BIT              NOT NULL,
    [IS_MERGE_PUBLISHED]                BIT              NOT NULL,
    [IS_DISTRIBUTOR]                    BIT              NOT NULL,
    [IS_SYNC_WITH_BACKUP]               BIT              NOT NULL,
    [SERVICE_BROKER_GUID]               UNIQUEIDENTIFIER NOT NULL,
    [IS_BROKER_ENABLED]                 BIT              NOT NULL,
    [LOG_REUSE_WAIT]                    TINYINT          NULL,
    [LOG_REUSE_WAIT_DESC]               NVARCHAR (60)    NULL,
    [IS_DATE_CORRELATION_ON]            BIT              NOT NULL,
    [IS_CDC_ENABLED]                    BIT              NOT NULL
);


GO
PRINT N'Creating [dbo].[SQL_DATABASES].[IX_SQL_DBS]...';


GO
CREATE CLUSTERED INDEX [IX_SQL_DBS]
    ON [dbo].[SQL_DATABASES]([SERVER_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[CDC]...';


GO
CREATE TABLE [dbo].[CDC] (
    [SERVER_NAME]          NVARCHAR (128) NOT NULL,
    [STATS_TIME]           DATETIME       NOT NULL,
    [DATABASE_NAME]        NVARCHAR (128) NULL,
    [SOURCE_SCHEMA]        [sysname]      NOT NULL,
    [SOURCE_TABLE]         [sysname]      NOT NULL,
    [CAPTURE_INSTANCE]     [sysname]      NOT NULL,
    [OBJECT_ID]            INT            NULL,
    [SOURCE_OBJECT_ID]     INT            NULL,
    [START_LSN]            BINARY (10)    NULL,
    [END_LSN]              BINARY (10)    NULL,
    [SUPPORTS_NET_CHANGES] BIT            NULL,
    [HAS_DROP_PENDING]     BIT            NULL,
    [ROLE_NAME]            [sysname]      NOT NULL,
    [INDEX_NAME]           [sysname]      NOT NULL,
    [FILEGROUP_NAME]       [sysname]      NOT NULL,
    [CREATE_DATE]          DATETIME       NULL,
    [INDEX_COLUMN_LIST]    NVARCHAR (MAX) NULL,
    [CAPTURED_COLUMN_LIST] NVARCHAR (MAX) NULL
);


GO
PRINT N'Creating [dbo].[CDC].[IX_CDC]...';


GO
CREATE CLUSTERED INDEX [IX_CDC]
    ON [dbo].[CDC]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[SQL_JOBS]...';


GO
CREATE TABLE [dbo].[SQL_JOBS] (
    [SERVER_NAME]  NVARCHAR (128) NOT NULL,
    [STATS_TIME]   DATETIME       NOT NULL,
    [JOBNAME]      [sysname]      NOT NULL,
    [SCHEDULENAME] [sysname]      NOT NULL,
    [FREQUENCY]    NVARCHAR (MAX) NULL,
    [SUBFREQUENCY] VARCHAR (24)   NOT NULL,
    [SCHEDULETIME] VARCHAR (13)   NULL,
    [NEXTRUNDATE]  VARCHAR (16)   NULL,
    [STEP_ID]      INT            NOT NULL,
    [STEP_NAME]    [sysname]      NOT NULL,
    [SUBSYSTEM]    NVARCHAR (40)  NOT NULL,
    [COMMAND]      NVARCHAR (MAX) NULL
);


GO
PRINT N'Creating [dbo].[SQL_JOBS].[IX_SQL_JOBS]...';


GO
CREATE CLUSTERED INDEX [IX_SQL_JOBS]
    ON [dbo].[SQL_JOBS]([SERVER_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[SQLERRORLOG]...';


GO
CREATE TABLE [dbo].[SQLERRORLOG] (
    [SERVER_NAME] NVARCHAR (128) NOT NULL,
    [LOGDATE]     DATETIME       NULL,
    [PROCESSINFO] NVARCHAR (255) NULL,
    [LOGTEXT]     NVARCHAR (MAX) NULL
);


GO
PRINT N'Creating [dbo].[SQLERRORLOG].[IX_SQLERRORLOG_CLUSTER]...';


GO
CREATE CLUSTERED INDEX [IX_SQLERRORLOG_CLUSTER]
    ON [dbo].[SQLERRORLOG]([LOGDATE] ASC, [SERVER_NAME] ASC);


GO
PRINT N'Creating [dbo].[STATS_COLLECTION_SUMMARY]...';


GO
CREATE TABLE [dbo].[STATS_COLLECTION_SUMMARY] (
    [SERVER_NAME]          NVARCHAR (128) NOT NULL,
    [STATS_TIME]           DATETIME       NOT NULL,
    [RUN_NAME]             NVARCHAR (128) NOT NULL,
    [DATABASE_NAME]        NVARCHAR (128) NOT NULL,
    [SQL_VERSION]          NVARCHAR (128) NULL,
    [DYNAMICS_VERSION]     NVARCHAR (MAX) NULL,
    [RUN_DESCRIPTION]      VARCHAR (MAX)  NULL,
    [SQL_SERVER_STARTTIME] DATETIME       NULL,
    [SQL_SERVER_TZ_OFFSET] INT            NULL,
    [DPA_TZ_OFFSET]        INT            NULL
);


GO
PRINT N'Creating [dbo].[STATS_COLLECTION_SUMMARY].[IX_STATS_COLLECTION_SUMMARY]...';


GO
CREATE UNIQUE CLUSTERED INDEX [IX_STATS_COLLECTION_SUMMARY]
    ON [dbo].[STATS_COLLECTION_SUMMARY]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[TRACEFLAGS]...';


GO
CREATE TABLE [dbo].[TRACEFLAGS] (
    [SERVER_NAME]   NVARCHAR (128) NOT NULL,
    [STATS_TIME]    DATETIME       NOT NULL,
    [DATABASE_NAME] NVARCHAR (128) NULL,
    [TRACEFLAG]     INT            NULL,
    [STATUS]        BIT            NULL,
    [GLOBAL]        BIT            NULL,
    [SESSIONS]      BIT            NULL
);


GO
PRINT N'Creating [dbo].[TRACEFLAGS].[IX_TRACEFLAGS]...';


GO
CREATE UNIQUE CLUSTERED INDEX [IX_TRACEFLAGS]
    ON [dbo].[TRACEFLAGS]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC, [TRACEFLAG] ASC);


GO
PRINT N'Creating [dbo].[WAIT_STATS]...';


GO
CREATE TABLE [dbo].[WAIT_STATS] (
    [SERVER_NAME]         NVARCHAR (128) NOT NULL,
    [STATS_TIME]          DATETIME       NOT NULL,
    [WAIT_TYPE]           NVARCHAR (60)  NOT NULL,
    [WAITING_TASKS_COUNT] BIGINT         NOT NULL,
    [WAIT_TIME_MS]        BIGINT         NOT NULL,
    [MAX_WAIT_TIME_MS]    BIGINT         NOT NULL,
    [SIGNAL_WAIT_TIME_MS] BIGINT         NOT NULL
);


GO
PRINT N'Creating [dbo].[WAIT_STATS].[IX_WAIT_STATS]...';


GO
CREATE UNIQUE CLUSTERED INDEX [IX_WAIT_STATS]
    ON [dbo].[WAIT_STATS]([STATS_TIME] ASC, [SERVER_NAME] ASC, [WAIT_TYPE] ASC);


GO
PRINT N'Creating [dbo].[DYNAMICSPERF_SETUP]...';


GO
CREATE TABLE [dbo].[DYNAMICSPERF_SETUP] (
    [VERSION]              NVARCHAR (256) NULL,
    [INSTALLED_DATE]       SMALLDATETIME  NULL,
    [TRACE_FULL_PATH_NAME] NVARCHAR (512) NULL
);


GO
PRINT N'Creating [dbo].[COLLECTIONDATABASES]...';


GO
CREATE TABLE [dbo].[COLLECTIONDATABASES] (
    [LINKED_SERVER]    [sysname]    NULL,
    [DATABASE_NAME]    [sysname]    NOT NULL,
    [DYNAMICS_PRODUCT] VARCHAR (10) NULL,
    [AZURE_DB]         BIT          NULL,
    [ENABLED]          BIT          NULL,
    [TASK_TYPE]        VARCHAR (50) NULL
);


GO
PRINT N'Creating [dbo].[DYNPERF_TASK_HISTORY]...';


GO
CREATE TABLE [dbo].[DYNPERF_TASK_HISTORY] (
    [LINKEDSERVER_NAME]        [sysname]     NOT NULL,
    [DATABASE_NAME]            [sysname]     NOT NULL,
    [TASK_ID]                  INT           NOT NULL,
    [SCHEDULE_UNITS]           CHAR (2)      NULL,
    [SCHEDULE_QTY_PER_UNIT]    INT           NULL,
    [SCHEDULE_TIME]            INT           NULL,
    [LAST_RUN]                 SMALLDATETIME NOT NULL,
    [LAST_EXECUTION_TIME_SECS] BIGINT        NOT NULL
);


GO
PRINT N'Creating [dbo].[DYNPERF_TASK_HISTORY].[IX_TASK_HISTORY]...';


GO
CREATE CLUSTERED INDEX [IX_TASK_HISTORY]
    ON [dbo].[DYNPERF_TASK_HISTORY]([LINKEDSERVER_NAME] ASC, [DATABASE_NAME] ASC, [TASK_ID] ASC);


GO
PRINT N'Creating [dbo].[DYNPERF_TASK_SCHEDULER]...';


GO
CREATE TABLE [dbo].[DYNPERF_TASK_SCHEDULER] (
    [TASK_ID]                 INT             IDENTITY (10, 10) NOT NULL,
    [ENABLED]                 BIT             NOT NULL,
    [DYNAMICS_PRODUCT]        VARCHAR (10)    NOT NULL,
    [TASK_PROCEDURE]          [sysname]       NOT NULL,
    [TASK_PARAMETERS]         NVARCHAR (1024) NULL,
    [TASK_DESCRIPTION]        NVARCHAR (256)  NOT NULL,
    [SCHEDULE_UNITS]          CHAR (2)        NOT NULL,
    [SCHEDULE_QTY_PER_UNIT]   INT             NOT NULL,
    [SCHEDULE_TIME]           INT             NULL,
    [AZURE_DB_SUPPORTED]      BIT             NOT NULL,
    [LINKED_SERVER_SUPPORTED] BIT             NOT NULL,
    [SERVER_LEVEL_TASK]       BIT             NOT NULL,
    [TASK_TYPE]               VARCHAR (50)    NOT NULL
);


GO
PRINT N'Creating [dbo].[DYNPERF_TASK_SCHEDULER].[IX_TASK_SCHED]...';


GO
CREATE CLUSTERED INDEX [IX_TASK_SCHED]
    ON [dbo].[DYNPERF_TASK_SCHEDULER]([TASK_ID] ASC);


GO
PRINT N'Creating [dbo].[DATABASES_2_COLLECT]...';


GO
CREATE TABLE [dbo].[DATABASES_2_COLLECT] (
    [LINKED_SERVER]            [sysname]    NULL,
    [DATABASE_NAME]            [sysname]    NOT NULL,
    [DYNAMICS_PRODUCT]         VARCHAR (10) NULL,
    [AZURE_DB]                 BIT          NULL,
    [ENABLED]                  BIT          NULL,
    [RETAIN_HISTORY_MONTHS]    INT          NULL,
    [RETAIN_HISTORY_DAYS]      INT          NULL,
    [RETAIN_DETAILS_DAYS]      INT          NULL,
    [PURGE_STALE_QUERIES_DAYS] INT          NULL,
    [REFRESH_PLAN_DAYS]        INT          NULL
);


GO
PRINT N'Creating [dbo].[AX_INDEX_DETAIL]...';


GO
CREATE TABLE [dbo].[AX_INDEX_DETAIL] (
    [SERVER_NAME]         NVARCHAR (128) NOT NULL,
    [STATS_TIME]          DATETIME       NULL,
    [DATABASE_NAME]       NVARCHAR (128) NOT NULL,
    [TABLE_NAME]          NVARCHAR (40)  NOT NULL,
    [INDEX_NAME]          NVARCHAR (40)  NOT NULL,
    [INDEX_ID]            INT            NOT NULL,
    [INDEX_DESCRIPTION]   NVARCHAR (210) NOT NULL,
    [INDEX_KEYS]          NVARCHAR (MAX) NOT NULL,
    [ALLOW_DUPLICATES]    BIT            NOT NULL,
    [ALTERNATE_KEY]       BIT            NOT NULL,
    [VALIDTIME_STATE_KEY] BIT            NOT NULL,
    [APPLAYER]            NVARCHAR (3)   NOT NULL
);


GO
PRINT N'Creating [dbo].[AX_INDEX_DETAIL].[IX_INDEX_DETAIL]...';


GO
CREATE CLUSTERED INDEX [IX_INDEX_DETAIL]
    ON [dbo].[AX_INDEX_DETAIL]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[AX_SQLSTORAGE]...';


GO
CREATE TABLE [dbo].[AX_SQLSTORAGE] (
    [SERVER_NAME]   NVARCHAR (128) NOT NULL,
    [DATABASE_NAME] NVARCHAR (128) NOT NULL,
    [ID]            INT            NOT NULL,
    [OBJECTTYPE]    INT            NOT NULL,
    [TABLEID]       INT            NOT NULL,
    [INDEXID]       INT            NOT NULL,
    [OVERRIDE]      INT            NOT NULL,
    [PARM]          NVARCHAR (25)  NOT NULL,
    [VALUE]         NVARCHAR (255) NOT NULL,
    [RECVERSION]    INT            NOT NULL,
    [RECID]         BIGINT         NOT NULL
);


GO
PRINT N'Creating [dbo].[AX_SYSGLOBALCONFIGURATION]...';


GO
CREATE TABLE [dbo].[AX_SYSGLOBALCONFIGURATION] (
    [SERVER_NAME]   NVARCHAR (128) NOT NULL,
    [DATABASE_NAME] NVARCHAR (128) NOT NULL,
    [NAME]          NVARCHAR (255) NULL,
    [VALUE]         NVARCHAR (255) NULL
);


GO
PRINT N'Creating [dbo].[AX_SYSGLOBALCONFIGURATION].[IX_AX_SYSGLOBCONFIG]...';


GO
CREATE CLUSTERED INDEX [IX_AX_SYSGLOBCONFIG]
    ON [dbo].[AX_SYSGLOBALCONFIGURATION]([SERVER_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating [dbo].[AOS_EVENTLOG]...';


GO
CREATE TABLE [dbo].[AOS_EVENTLOG] (
    [TIME_WRITTEN] DATETIME       NULL,
    [SERVER_NAME]  NVARCHAR (255) NULL,
    [EVENT_CODE]   INT            NULL,
    [EVENT_TYPE]   NVARCHAR (255) NULL,
    [MESSAGE]      NVARCHAR (MAX) NULL,
    [SOURCE_NAME]  NVARCHAR (255) NULL
);


GO
PRINT N'Creating [dbo].[AOS_EVENTLOG].[IX_AOS_EVENTLOG]...';


GO
CREATE CLUSTERED INDEX [IX_AOS_EVENTLOG]
    ON [dbo].[AOS_EVENTLOG]([TIME_WRITTEN] ASC, [SERVER_NAME] ASC);


GO
PRINT N'Creating [dbo].[AOS_REGISTRY]...';


GO
CREATE TABLE [dbo].[AOS_REGISTRY] (
    [SERVER_NAME]             NVARCHAR (255) NOT NULL,
    [AX_MAJOR_VERSION]        NVARCHAR (5)   NOT NULL,
    [AOS_INSTANCE_NAME]       NVARCHAR (255) NOT NULL,
    [AX_BUILD_NUMBER]         NVARCHAR (25)  NOT NULL,
    [AOS_CONFIGURATION_NAME]  NVARCHAR (255) NOT NULL,
    [IS_CONFIGURATION_ACTIVE] NVARCHAR (1)   NOT NULL,
    [SETTING_NAME]            NVARCHAR (255) NOT NULL,
    [SETTING_VALUE]           NVARCHAR (MAX) NOT NULL
);


GO
PRINT N'Creating [dbo].[AOS_REGISTRY].[IX_AOS_REGISTRY]...';


GO
CREATE CLUSTERED INDEX [IX_AOS_REGISTRY]
    ON [dbo].[AOS_REGISTRY]([SERVER_NAME] ASC);


GO
PRINT N'Creating [dbo].[AX_BATCHSERVERGROUP_CONFIG]...';


GO
CREATE TABLE [dbo].[AX_BATCHSERVERGROUP_CONFIG] (
    [SERVER_NAME]            NVARCHAR (128) NOT NULL,
    [STATS_TIME]             DATETIME       NULL,
    [DATABASE_NAME]          NVARCHAR (128) NOT NULL,
    [BATCH_GROUPID]          NVARCHAR (40)  NOT NULL,
    [BATCH_GROUPDESC]        NVARCHAR (255) NOT NULL,
    [BATCH_SERVER_NAME]      NVARCHAR (128) NOT NULL,
    [MAX_BATCH_SESSIONS]     INT            NOT NULL,
    [BATCH_SERVER_STARTTIME] INT            NOT NULL,
    [BATCH_SERVER_ENDTIME]   INT            NOT NULL
);


GO
PRINT N'Creating [dbo].[AX_BATCHSERVERGROUP_CONFIG].[IX_BATCH_CONFIG]...';


GO
CREATE CLUSTERED INDEX [IX_BATCH_CONFIG]
    ON [dbo].[AX_BATCHSERVERGROUP_CONFIG]([SERVER_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating [dbo].[AX_NUM_SEQUENCES]...';


GO
CREATE TABLE [dbo].[AX_NUM_SEQUENCES] (
    [SERVER_NAME]         NVARCHAR (128)   NOT NULL,
    [STATS_TIME]          DATETIME         NOT NULL,
    [DATABASE_NAME]       NVARCHAR (128)   NULL,
    [RECID]               BIGINT           NULL,
    [NUMBERSEQUENCE]      NVARCHAR (40)    NULL,
    [TEXT]                NVARCHAR (120)   NULL,
    [LOWEST]              INT              NULL,
    [HIGHEST]             INT              NULL,
    [NEXTREC]             INT              NULL,
    [PERCENTREMAINING]    DECIMAL (5, 2)   NULL,
    [NUMBERSREMAINING]    INT              NULL,
    [CONTINUOUS]          VARCHAR (3)      NULL,
    [FETCHAHEAD]          INT              NULL,
    [FETCHAHEADQTY]       INT              NULL,
    [CLEANINTERVAL]       NUMERIC (32, 16) NULL,
    [CLEANATACCESS]       INT              NULL,
    [PARTITIONNAME]       NVARCHAR (40)    NULL,
    [NUMBERSEQUENCESCOPE] BIGINT           NULL,
    [COMPANYID]           NVARCHAR (8)     NULL,
    [COMPANYNAME]         NVARCHAR (40)    NULL,
    [SHARED]              VARCHAR (3)      NULL,
    [LEGALENTITYNAME]     NVARCHAR (4)     NULL,
    [OPERATINGUNITTYPE]   VARCHAR (19)     NULL,
    [OPERATINGUNITNUMBER] NVARCHAR (8)     NULL,
    [FISCALCALENDAR]      NVARCHAR (10)    NULL,
    [FISCALCALENDARYEAR]  NVARCHAR (10)    NULL,
    [PERIOD]              NVARCHAR (60)    NULL,
    [FORMAT]              NVARCHAR (80)    NOT NULL
);


GO
PRINT N'Creating [dbo].[AX_NUM_SEQUENCES].[IX_AX_NUM_SEQ]...';


GO
CREATE CLUSTERED INDEX [IX_AX_NUM_SEQ]
    ON [dbo].[AX_NUM_SEQUENCES]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[AX_SQLTRACE]...';


GO
CREATE TABLE [dbo].[AX_SQLTRACE] (
    [SERVER_NAME]                   NVARCHAR (128) NOT NULL,
    [STATS_TIME]                    DATETIME       NOT NULL,
    [DATABASE_NAME]                 NVARCHAR (128) NOT NULL,
    [SQL_DURATION]                  INT            NOT NULL,
    [TRACE_CATEGORY]                INT            NOT NULL,
    [SQL_TEXT]                      NVARCHAR (MAX) NULL,
    [CALL_STACK]                    NTEXT          NULL,
    [TRACE_EVENT_CODE]              INT            NOT NULL,
    [TRACE_EVENT_DESC]              NVARCHAR (MAX) NULL,
    [TRACE_EVENT_DETAILS]           NVARCHAR (MAX) NULL,
    [CONNECTION_TYPE]               NVARCHAR (50)  NOT NULL,
    [SQL_SESSION_ID]                INT            NOT NULL,
    [AX_CONNECTION_ID]              INT            NOT NULL,
    [IS_LOBS_INCLUDED]              INT            NOT NULL,
    [IS_MORE_DATA_PENDING]          INT            NOT NULL,
    [ROWS_AFFECTED]                 INT            NOT NULL,
    [ROW_SIZE]                      INT            NOT NULL,
    [ROWS_PER_FETCH]                INT            NOT NULL,
    [IS_SELECTED_FOR_UPDATE]        INT            NOT NULL,
    [IS_STARTED_WITHIN_TRANSACTION] INT            NOT NULL,
    [SQL_TYPE]                      INT            NOT NULL,
    [STATEMENT_ID]                  INT            NOT NULL,
    [STATEMENT_REUSE_COUNT]         INT            NOT NULL,
    [DETAIL_TYPE]                   INT            NOT NULL,
    [CREATED_DATETIME]              DATETIME       NOT NULL,
    [AX_USER_ID]                    NVARCHAR (50)  NOT NULL,
    [ROW_NUM]                       BIGINT         IDENTITY (1, 1) NOT NULL,
    [QUERY_HASH]                    VARBINARY (64) NULL,
    [COMMENT]                       NVARCHAR (MAX) NULL
);


GO
PRINT N'Creating [dbo].[AX_SQLTRACE].[IX_AX_SQLTRACE]...';


GO
CREATE CLUSTERED INDEX [IX_AX_SQLTRACE]
    ON [dbo].[AX_SQLTRACE]([STATS_TIME] ASC, [DATABASE_NAME] ASC, [SERVER_NAME] ASC, [CREATED_DATETIME] ASC, [TRACE_CATEGORY] ASC);


GO
PRINT N'Creating [dbo].[AX_SQLTRACE].[IX_AX_SQLTRACE_FT]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_AX_SQLTRACE_FT]
    ON [dbo].[AX_SQLTRACE]([ROW_NUM] ASC);


GO
PRINT N'Creating [dbo].[AX_TABLE_DETAIL]...';


GO
CREATE TABLE [dbo].[AX_TABLE_DETAIL] (
    [SERVER_NAME]              NVARCHAR (128) NOT NULL,
    [STATS_TIME]               DATETIME       NULL,
    [DATABASE_NAME]            NVARCHAR (128) NOT NULL,
    [TABLE_NAME]               NVARCHAR (128) NOT NULL,
    [TABLE_ID]                 INT            NOT NULL,
    [TABLE_TYPE]               NVARCHAR (20)  NOT NULL,
    [VALID_TIME_STATE_TABLE]   BIT            NOT NULL,
    [SUPPORT_INHERITANCE]      BIT            NOT NULL,
    [EXTENDS]                  NVARCHAR (128) NOT NULL,
    [TABLE_GROUP]              NVARCHAR (20)  NOT NULL,
    [OCC_ENABLED]              BIT            NOT NULL,
    [CACHE_LOOKUP]             NVARCHAR (40)  NOT NULL,
    [AOS_AUTHORIZATION]        NVARCHAR (25)  NOT NULL,
    [INSERT_METHOD_OVERRIDDEN] BIT            NOT NULL,
    [UPDATE_METHOD_OVERRIDDEN] BIT            NOT NULL,
    [DELETE_METHOD_OVERRIDDEN] BIT            NOT NULL,
    [AOS_VALIDATE_INSERT]      BIT            NOT NULL,
    [AOS_VALIDATE_UPDATE]      BIT            NOT NULL,
    [AOS_VALIDATE_DELETE]      BIT            NOT NULL,
    [AOS_VALIDATE_READ]        BIT            NOT NULL,
    [DATABASELOG_INSERT]       BIT            NOT NULL,
    [DATABASELOG_DELETE]       BIT            NOT NULL,
    [DATABASELOG_UPDATE]       BIT            NOT NULL,
    [DATABASELOG_RENAMEKEY]    BIT            NOT NULL,
    [EVENT_INSERT]             BIT            NOT NULL,
    [EVENT_DELETE]             BIT            NOT NULL,
    [EVENT_UPDATE]             BIT            NOT NULL,
    [EVENT_RENAMEKEY]          BIT            NOT NULL,
    [CLUSTERED_INDEX]          NVARCHAR (128) NOT NULL,
    [PRIMARY_KEY]              NVARCHAR (128) NOT NULL,
    [DATA_PER_COMPANY]         BIT            NOT NULL,
    [DATA_PER_PARTITION]       BIT            NOT NULL,
    [CONFIGURATION_KEY_ID]     INT            NOT NULL,
    [LICENSE_CODE_ID]          INT            NOT NULL,
    [APPLAYER]                 NVARCHAR (3)   NOT NULL,
    [COUNTRY_REGION_CODES]     NVARCHAR (100) NOT NULL
);


GO
PRINT N'Creating [dbo].[AX_TABLE_DETAIL].[IX_AX_TABLE_DETAIL]...';


GO
CREATE CLUSTERED INDEX [IX_AX_TABLE_DETAIL]
    ON [dbo].[AX_TABLE_DETAIL]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[COMMENTS]...';


GO
CREATE TABLE [dbo].[COMMENTS] (
    [SERVER_NAME]   NVARCHAR (128) NULL,
    [DATABASE_NAME] NVARCHAR (128) NOT NULL,
    [QUERY_HASH]    BINARY (8)     NOT NULL,
    [AX_ROW_NUM]    BIGINT         NOT NULL,
    [CREATED_ON]    SMALLDATETIME  NOT NULL,
    [MODIFIED_ON]   SMALLDATETIME  NOT NULL,
    [CREATEDBY]     NVARCHAR (128) NULL,
    [MODIFIEDBY]    NVARCHAR (128) NULL,
    [TICKET_NUM]    NVARCHAR (128) NULL,
    [COMPLETED]     NVARCHAR (1)   NULL,
    [COMPLETED_ON]  SMALLDATETIME  NULL,
    [STATUS]        NVARCHAR (MAX) NULL,
    [COMMENT]       NVARCHAR (MAX) NOT NULL
);


GO
PRINT N'Creating [dbo].[COMMENTS].[PK_COMMENTS]...';


GO
CREATE CLUSTERED INDEX [PK_COMMENTS]
    ON [dbo].[COMMENTS]([QUERY_HASH] ASC);


GO
PRINT N'Creating [dbo].[COMMENTS].[NC1_COMMENTS]...';


GO
CREATE NONCLUSTERED INDEX [NC1_COMMENTS]
    ON [dbo].[COMMENTS]([AX_ROW_NUM] ASC);


GO
PRINT N'Creating [dbo].[CAPTURE_LOG]...';


GO
CREATE TABLE [dbo].[CAPTURE_LOG] (
    [TASK_TYPE]  NVARCHAR (50)  NOT NULL,
    [STATS_TIME] DATETIME       NOT NULL,
    [TEXT]       NVARCHAR (MAX) NOT NULL
);


GO
PRINT N'Creating [dbo].[CAPTURE_LOG].[PK_CAPTURE_LOG]...';


GO
CREATE UNIQUE CLUSTERED INDEX [PK_CAPTURE_LOG]
    ON [dbo].[CAPTURE_LOG]([STATS_TIME] ASC, [TASK_TYPE] ASC);


GO
PRINT N'Creating [dbo].[SERVER_OS_VERSION]...';


GO
CREATE TABLE [dbo].[SERVER_OS_VERSION] (
    [SERVER_NAME]                NVARCHAR (128) NOT NULL,
    [WINDOWS_RELEASE]            NVARCHAR (256) NOT NULL,
    [WINDOWS_SERVICE_PACK_LEVEL] NVARCHAR (256) NOT NULL,
    [WINDOWS_SKU]                INT            NULL,
    [OS_LANGUAGE_VERSION]        INT            NOT NULL
);


GO
PRINT N'Creating [dbo].[SERVER_OS_VERSION].[IX_SERVER_OS]...';


GO
CREATE CLUSTERED INDEX [IX_SERVER_OS]
    ON [dbo].[SERVER_OS_VERSION]([SERVER_NAME] ASC);


GO
PRINT N'Creating [dbo].[SERVER_REGISTRY]...';


GO
CREATE TABLE [dbo].[SERVER_REGISTRY] (
    [SERVER_NAME]  NVARCHAR (128) NOT NULL,
    [REGISTRY_KEY] NVARCHAR (256) NULL,
    [VALUE_NAME]   NVARCHAR (256) NULL,
    [VALUE_DATA]   SQL_VARIANT    NULL
);


GO
PRINT N'Creating [dbo].[SERVER_REGISTRY].[IX_SERVER_REG]...';


GO
CREATE CLUSTERED INDEX [IX_SERVER_REG]
    ON [dbo].[SERVER_REGISTRY]([SERVER_NAME] ASC);


GO
PRINT N'Creating [dbo].[SERVER_DISKVOLUMES]...';


GO
CREATE TABLE [dbo].[SERVER_DISKVOLUMES] (
    [SERVER_NAME]                NVARCHAR (128) NOT NULL,
    [VOLUME_MOUNT_POINT]         NVARCHAR (256) NULL,
    [VOLUME_ID]                  NVARCHAR (256) NULL,
    [LOGICAL_VOLUME_NAME]        NVARCHAR (256) NULL,
    [FILE_SYSTEM_TYPE]           NVARCHAR (256) NULL,
    [DRIVE_SIZE_MB]              BIGINT         NULL,
    [DRIVE_FREE_SPACE_MB]        BIGINT         NULL,
    [DRIVE_PERCENT_FREE]         DECIMAL (5, 2) NULL,
    [SUPPORTS_COMPRESSION]       TINYINT        NULL,
    [SUPPORTS_ALTERNATE_STREAMS] TINYINT        NULL,
    [SUPPORTS_SPARSE_FILES]      TINYINT        NULL,
    [IS_READ_ONLY]               TINYINT        NULL,
    [IS_COMPRESSED]              TINYINT        NULL
);


GO
PRINT N'Creating [dbo].[SERVER_DISKVOLUMES].[IX_SERVER_DISKVOL]...';


GO
CREATE CLUSTERED INDEX [IX_SERVER_DISKVOL]
    ON [dbo].[SERVER_DISKVOLUMES]([SERVER_NAME] ASC);


GO
PRINT N'Creating [dbo].[BLOCKS]...';


GO
CREATE TABLE [dbo].[BLOCKS] (
    [SERVER_NAME]              NVARCHAR (128) NOT NULL,
    [BLOCKED_DTTM]             DATETIME       NOT NULL,
    [BLOCKER_LOGIN]            NVARCHAR (128) NULL,
    [BLOCKER_PROGRAM]          NVARCHAR (128) NULL,
    [BLOCKER_HOSTNAME]         NVARCHAR (128) NULL,
    [BLOCKED_LOGIN]            NVARCHAR (128) NULL,
    [BLOCKED_PROGRAM]          NVARCHAR (128) NULL,
    [BLOCKED_HOSTNAME]         NVARCHAR (128) NULL,
    [BLOCKER_SESSION_ID]       SMALLINT       NULL,
    [BLOCKER_CONTEXT_INFO]     BINARY (128)   NULL,
    [BLOCKER_CONTEXT]          NVARCHAR (MAX) NULL,
    [BLOCKER_TRAN_ISOLATION]   VARCHAR (20)   NULL,
    [BLOCKER_STATUS]           VARCHAR (18)   NULL,
    [BLOCKED_SESSION_ID]       SMALLINT       NULL,
    [BLOCKED_CONTEXT_INFO]     BINARY (128)   NULL,
    [BLOCKED_CONTEXT]          NVARCHAR (MAX) NULL,
    [BLOCKED_TRAN_ISOLATION]   VARCHAR (20)   NULL,
    [TRANSACTION_ID]           BIGINT         NULL,
    [WAIT_TIME]                BIGINT         NULL,
    [LOCK_MODE]                NVARCHAR (60)  NULL,
    [LOCK_SIZE]                NVARCHAR (6)   NULL,
    [DATABASE_NAME]            NVARCHAR (128) NULL,
    [ALLOW_SNAPSHOT_ISOLATION] NVARCHAR (60)  NULL,
    [READ_COMMITTED_SNAPSHOT]  NVARCHAR (3)   NULL,
    [OBJECT_NAME]              NVARCHAR (128) NULL,
    [INDEX_ID]                 INT            NULL,
    [BLOCKER_SQL]              NVARCHAR (MAX) NULL,
    [BLOCKER_PLAN]             XML            NULL,
    [BLOCKED_SQL]              NVARCHAR (MAX) NULL,
    [BLOCKED_PLAN]             XML            NULL
);


GO
PRINT N'Creating [dbo].[BLOCKS].[BLOCKS0]...';


GO
CREATE CLUSTERED INDEX [BLOCKS0]
    ON [dbo].[BLOCKS]([BLOCKED_DTTM] ASC);


GO
PRINT N'Creating [dbo].[BLOCKS].[BLOCKS1]...';


GO
CREATE NONCLUSTERED INDEX [BLOCKS1]
    ON [dbo].[BLOCKS]([BLOCKER_PROGRAM] ASC, [WAIT_TIME] ASC, [BLOCKER_STATUS] ASC);


GO
PRINT N'Creating [dbo].[BLOCKS].[BLOCKS2]...';


GO
CREATE NONCLUSTERED INDEX [BLOCKS2]
    ON [dbo].[BLOCKS]([BLOCKED_PROGRAM] ASC, [WAIT_TIME] ASC, [BLOCKER_STATUS] ASC);


GO
PRINT N'Creating [dbo].[BLOCKS].[BLOCKS3]...';


GO
CREATE NONCLUSTERED INDEX [BLOCKS3]
    ON [dbo].[BLOCKS]([DATABASE_NAME] ASC, [WAIT_TIME] ASC);


GO
PRINT N'Creating [dbo].[BLOCKS].[BLOCKS4]...';


GO
CREATE NONCLUSTERED INDEX [BLOCKS4]
    ON [dbo].[BLOCKS]([OBJECT_NAME] ASC, [WAIT_TIME] ASC);


GO
PRINT N'Creating [dbo].[BUFFER_DETAIL]...';


GO
CREATE TABLE [dbo].[BUFFER_DETAIL] (
    [SERVER_NAME]   NVARCHAR (128) NOT NULL,
    [STATS_TIME]    DATETIME       NOT NULL,
    [DATABASE_NAME] NVARCHAR (128) NULL,
    [SIZE_MB]       BIGINT         NULL
);


GO
PRINT N'Creating [dbo].[BUFFER_DETAIL].[IX_BUFFER_DETAIL]...';


GO
CREATE CLUSTERED INDEX [IX_BUFFER_DETAIL]
    ON [dbo].[BUFFER_DETAIL]([STATS_TIME] ASC, [DATABASE_NAME] ASC, [SERVER_NAME] ASC);


GO
PRINT N'Creating [dbo].[TRIGGER_TABLE]...';


GO
CREATE TABLE [dbo].[TRIGGER_TABLE] (
    [RUN_NAME]      NVARCHAR (128) NOT NULL,
    [DATABASE_NAME] NVARCHAR (128) NOT NULL,
    [TABLE_NAME]    NVARCHAR (128) NOT NULL,
    [TRIGGER_NAME]  NVARCHAR (128) NOT NULL
);


GO
PRINT N'Creating [dbo].[TRIGGER_TABLE].[IX_TRACEFLAGS]...';


GO
CREATE CLUSTERED INDEX [IX_TRACEFLAGS]
    ON [dbo].[TRIGGER_TABLE]([RUN_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating [dbo].[DISKSTATS]...';


GO
CREATE TABLE [dbo].[DISKSTATS] (
    [SERVER_NAME]          NVARCHAR (128) NOT NULL,
    [STATS_TIME]           DATETIME       NOT NULL,
    [DATABASE_NAME]        NVARCHAR (128) NULL,
    [DATABASE_ID]          SMALLINT       NOT NULL,
    [FILE_ID]              SMALLINT       NOT NULL,
    [SAMPLE_MS]            INT            NOT NULL,
    [NUM_OF_READS]         BIGINT         NOT NULL,
    [NUM_OF_BYTES_READ]    BIGINT         NOT NULL,
    [IO_STALL_READ_MS]     BIGINT         NOT NULL,
    [NUM_OF_WRITES]        BIGINT         NOT NULL,
    [NUM_OF_BYTES_WRITTEN] BIGINT         NOT NULL,
    [IO_STALL_WRITE_MS]    BIGINT         NOT NULL,
    [IO_STALL]             BIGINT         NOT NULL,
    [SIZE_ON_DISK_BYTES]   BIGINT         NOT NULL,
    [FILE_HANDLE]          VARBINARY (8)  NOT NULL
);


GO
PRINT N'Creating [dbo].[DISKSTATS].[IX_DISKSTATS]...';


GO
CREATE CLUSTERED INDEX [IX_DISKSTATS]
    ON [dbo].[DISKSTATS]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[INDEX_DENSITY_VECTOR]...';


GO
CREATE TABLE [dbo].[INDEX_DENSITY_VECTOR] (
    [SERVER_NAME]   NVARCHAR (128) NOT NULL,
    [DATABASE_NAME] [sysname]      NOT NULL,
    [TABLENAME]     [sysname]      NOT NULL,
    [INDEXNAME]     [sysname]      NOT NULL,
    [DENSITY]       FLOAT (53)     NULL,
    [LENGTH]        INT            NULL,
    [COLUMNS]       NVARCHAR (MAX) NULL
);


GO
PRINT N'Creating [dbo].[INDEX_DENSITY_VECTOR].[IX_INDEXDENSITY]...';


GO
CREATE CLUSTERED INDEX [IX_INDEXDENSITY]
    ON [dbo].[INDEX_DENSITY_VECTOR]([TABLENAME] ASC, [SERVER_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating [dbo].[INDEX_DETAIL]...';


GO
CREATE TABLE [dbo].[INDEX_DETAIL] (
    [SERVER_NAME]       NVARCHAR (128) NOT NULL,
    [STATS_TIME]        DATETIME       NOT NULL,
    [DATABASE_NAME]     NVARCHAR (128) NULL,
    [OBJECT_ID]         INT            NULL,
    [INDEX_ID]          INT            NULL,
    [TABLE_NAME]        NVARCHAR (128) NULL,
    [INDEX_NAME]        NVARCHAR (128) NULL,
    [INDEX_DESCRIPTION] NVARCHAR (210) NULL,
    [INDEX_KEYS]        NVARCHAR (MAX) NULL,
    [INCLUDED_COLUMNS]  NVARCHAR (MAX) NULL,
    [PAGE_COUNT]        BIGINT         NULL,
    [ROW_COUNT]         BIGINT         NULL,
    [DATA_COMPRESSION]  INT            NULL
);


GO
PRINT N'Creating [dbo].[INDEX_DETAIL].[IX_INDEX_DETAIL]...';


GO
CREATE CLUSTERED INDEX [IX_INDEX_DETAIL]
    ON [dbo].[INDEX_DETAIL]([STATS_TIME] ASC, [DATABASE_NAME] ASC, [SERVER_NAME] ASC, [TABLE_NAME] ASC, [INDEX_NAME] ASC);


GO
PRINT N'Creating [dbo].[INDEX_HISTOGRAM]...';


GO
CREATE TABLE [dbo].[INDEX_HISTOGRAM] (
    [SERVER_NAME]         NVARCHAR (128) NOT NULL,
    [DATABASE_NAME]       [sysname]      NOT NULL,
    [TABLE_NAME]          [sysname]      NOT NULL,
    [INDEX_NAME]          [sysname]      NOT NULL,
    [COLUMN_NAME]         [sysname]      NOT NULL,
    [RANGE_HI_KEY]        SQL_VARIANT    NULL,
    [RANGE_ROWS]          BIGINT         NULL,
    [EQ_ROWS]             BIGINT         NULL,
    [DISTINCT_RANGE_ROWS] BIGINT         NULL,
    [AVG_RANGE_ROWS]      BIGINT         NULL
);


GO
PRINT N'Creating [dbo].[INDEX_HISTOGRAM].[IX_INDEX_HISTOGRAM_CLUSTER]...';


GO
CREATE CLUSTERED INDEX [IX_INDEX_HISTOGRAM_CLUSTER]
    ON [dbo].[INDEX_HISTOGRAM]([TABLE_NAME] ASC, [COLUMN_NAME] ASC, [DATABASE_NAME] ASC, [SERVER_NAME] ASC);


GO
PRINT N'Creating [dbo].[INDEX_OPERATIONAL_STATS]...';


GO
CREATE TABLE [dbo].[INDEX_OPERATIONAL_STATS] (
    [SERVER_NAME]                        NVARCHAR (128) NOT NULL,
    [STATS_TIME]                         DATETIME       NOT NULL,
    [DATABASE_NAME]                      NVARCHAR (128) NOT NULL,
    [OBJECT_ID]                          INT            NOT NULL,
    [INDEX_ID]                           INT            NOT NULL,
    [LEAF_INSERT_COUNT]                  BIGINT         NOT NULL,
    [LEAF_DELETE_COUNT]                  BIGINT         NOT NULL,
    [LEAF_UPDATE_COUNT]                  BIGINT         NOT NULL,
    [LEAF_GHOST_COUNT]                   BIGINT         NOT NULL,
    [NONLEAF_INSERT_COUNT]               BIGINT         NOT NULL,
    [NONLEAF_DELETE_COUNT]               BIGINT         NOT NULL,
    [NONLEAF_UPDATE_COUNT]               BIGINT         NOT NULL,
    [LEAF_ALLOCATION_COUNT]              BIGINT         NOT NULL,
    [NONLEAF_ALLOCATION_COUNT]           BIGINT         NOT NULL,
    [LEAF_PAGE_MERGE_COUNT]              BIGINT         NOT NULL,
    [NONLEAF_PAGE_MERGE_COUNT]           BIGINT         NOT NULL,
    [RANGE_SCAN_COUNT]                   BIGINT         NOT NULL,
    [SINGLETON_LOOKUP_COUNT]             BIGINT         NOT NULL,
    [FORWARDED_FETCH_COUNT]              BIGINT         NOT NULL,
    [LOB_FETCH_IN_PAGES]                 BIGINT         NOT NULL,
    [LOB_FETCH_IN_BYTES]                 BIGINT         NOT NULL,
    [LOB_ORPHAN_CREATE_COUNT]            BIGINT         NOT NULL,
    [LOB_ORPHAN_INSERT_COUNT]            BIGINT         NOT NULL,
    [ROW_OVERFLOW_FETCH_IN_PAGES]        BIGINT         NOT NULL,
    [ROW_OVERFLOW_FETCH_IN_BYTES]        BIGINT         NOT NULL,
    [COLUMN_VALUE_PUSH_OFF_ROW_COUNT]    BIGINT         NOT NULL,
    [COLUMN_VALUE_PULL_IN_ROW_COUNT]     BIGINT         NOT NULL,
    [ROW_LOCK_COUNT]                     BIGINT         NOT NULL,
    [ROW_LOCK_WAIT_COUNT]                BIGINT         NOT NULL,
    [ROW_LOCK_WAIT_IN_MS]                BIGINT         NOT NULL,
    [PAGE_LOCK_COUNT]                    BIGINT         NOT NULL,
    [PAGE_LOCK_WAIT_COUNT]               BIGINT         NOT NULL,
    [PAGE_LOCK_WAIT_IN_MS]               BIGINT         NOT NULL,
    [INDEX_LOCK_PROMOTION_ATTEMPT_COUNT] BIGINT         NOT NULL,
    [INDEX_LOCK_PROMOTION_COUNT]         BIGINT         NOT NULL,
    [PAGE_LATCH_WAIT_COUNT]              BIGINT         NOT NULL,
    [PAGE_LATCH_WAIT_IN_MS]              BIGINT         NOT NULL,
    [PAGE_IO_LATCH_WAIT_COUNT]           BIGINT         NOT NULL,
    [PAGE_IO_LATCH_WAIT_IN_MS]           BIGINT         NOT NULL
);


GO
PRINT N'Creating [dbo].[INDEX_OPERATIONAL_STATS].[IX_OPERATIONAL_STATS]...';


GO
CREATE CLUSTERED INDEX [IX_OPERATIONAL_STATS]
    ON [dbo].[INDEX_OPERATIONAL_STATS]([STATS_TIME] ASC, [DATABASE_NAME] ASC, [SERVER_NAME] ASC, [OBJECT_ID] ASC, [INDEX_ID] ASC);


GO
PRINT N'Creating [dbo].[INDEX_PHYSICAL_STATS]...';


GO
CREATE TABLE [dbo].[INDEX_PHYSICAL_STATS] (
    [SERVER_NAME]                  NVARCHAR (128) NOT NULL,
    [STATS_TIME]                   DATETIME       NOT NULL,
    [DATABASE_NAME]                NVARCHAR (128) NOT NULL,
    [OBJECT_ID]                    INT            NOT NULL,
    [INDEX_ID]                     INT            NOT NULL,
    [PARTITION_NUMBER]             INT            NOT NULL,
    [INDEX_TYPE_DESC]              NVARCHAR (60)  NULL,
    [ALLOC_UNIT_TYPE_DESC]         NVARCHAR (60)  NULL,
    [INDEX_DEPTH]                  TINYINT        NULL,
    [AVG_FRAGMENTATION_IN_PERCENT] FLOAT (53)     NULL,
    [FRAGMENT_COUNT]               BIGINT         NULL,
    [AVG_FRAGMENT_SIZE_IN_PAGES]   FLOAT (53)     NULL
);


GO
PRINT N'Creating [dbo].[INDEX_PHYSICAL_STATS].[IX_INDEX_PHYSICAL_STATS]...';


GO
CREATE CLUSTERED INDEX [IX_INDEX_PHYSICAL_STATS]
    ON [dbo].[INDEX_PHYSICAL_STATS]([STATS_TIME] ASC, [DATABASE_NAME] ASC, [SERVER_NAME] ASC, [OBJECT_ID] ASC, [INDEX_ID] ASC, [PARTITION_NUMBER] ASC);


GO
PRINT N'Creating [dbo].[INDEX_USAGE_STATS]...';


GO
CREATE TABLE [dbo].[INDEX_USAGE_STATS] (
    [SERVER_NAME]        NVARCHAR (128) NOT NULL,
    [STATS_TIME]         DATETIME       NOT NULL,
    [DATABASE_NAME]      NVARCHAR (128) NOT NULL,
    [OBJECT_ID]          INT            NOT NULL,
    [INDEX_ID]           INT            NOT NULL,
    [USER_SEEKS]         BIGINT         NOT NULL,
    [USER_SCANS]         BIGINT         NOT NULL,
    [USER_LOOKUPS]       BIGINT         NOT NULL,
    [USER_UPDATES]       BIGINT         NOT NULL,
    [LAST_USER_SEEK]     DATETIME       NULL,
    [LAST_USER_SCAN]     DATETIME       NULL,
    [LAST_USER_LOOKUP]   DATETIME       NULL,
    [LAST_USER_UPDATE]   DATETIME       NULL,
    [SYSTEM_SEEKS]       BIGINT         NOT NULL,
    [SYSTEM_SCANS]       BIGINT         NOT NULL,
    [SYSTEM_LOOKUPS]     BIGINT         NOT NULL,
    [SYSTEM_UPDATES]     BIGINT         NOT NULL,
    [LAST_SYSTEM_SEEK]   DATETIME       NULL,
    [LAST_SYSTEM_SCAN]   DATETIME       NULL,
    [LAST_SYSTEM_LOOKUP] DATETIME       NULL,
    [LAST_SYSTEM_UPDATE] DATETIME       NULL
);


GO
PRINT N'Creating [dbo].[INDEX_USAGE_STATS].[IX_INDEX_USAGE_STATS]...';


GO
CREATE UNIQUE CLUSTERED INDEX [IX_INDEX_USAGE_STATS]
    ON [dbo].[INDEX_USAGE_STATS]([SERVER_NAME] ASC, [STATS_TIME] ASC, [DATABASE_NAME] ASC, [OBJECT_ID] ASC, [INDEX_ID] ASC);


GO
PRINT N'Creating [dbo].[QUERY_PLANS]...';


GO
CREATE TABLE [dbo].[QUERY_PLANS] (
    [SERVER_NAME]     NVARCHAR (128) NOT NULL,
    [DATABASE_NAME]   NVARCHAR (128) NOT NULL,
    [QUERY_PLAN_HASH] BINARY (8)     NOT NULL,
    [QUERY_PLAN]      XML            NULL,
    [SQL_PARMS]       NVARCHAR (MAX) NULL,
    [MI_FLAG]         BIT            NULL,
    [PARSED_FLAG]     BIT            NULL,
    [DATE_UPDATED]    DATETIME       NULL,
    [ROW_NUM]         BIGINT         IDENTITY (1, 1) NOT NULL,
    [C_QUERY_PLAN]    AS             (CONVERT (NVARCHAR (MAX), [QUERY_PLAN]))
);


GO
PRINT N'Creating [dbo].[QUERY_PLANS].[IX_QUERY_PLANS_HASH]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_QUERY_PLANS_HASH]
    ON [dbo].[QUERY_PLANS]([QUERY_PLAN_HASH] ASC, [SERVER_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating [dbo].[QUERY_PLANS].[IX_QUERY_MI_FLAG_PLAN_HANDLE]...';


GO
CREATE NONCLUSTERED INDEX [IX_QUERY_MI_FLAG_PLAN_HANDLE]
    ON [dbo].[QUERY_PLANS]([MI_FLAG] ASC, [QUERY_PLAN_HASH] ASC, [SERVER_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating [dbo].[QUERY_PLANS].[IX_QUERY_PLANS_FT]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_QUERY_PLANS_FT]
    ON [dbo].[QUERY_PLANS]([ROW_NUM] ASC);


GO
PRINT N'Creating [dbo].[QUERY_TEXT]...';


GO
CREATE TABLE [dbo].[QUERY_TEXT] (
    [SERVER_NAME]   NVARCHAR (128) NOT NULL,
    [DATABASE_NAME] NVARCHAR (128) NOT NULL,
    [QUERY_HASH]    BINARY (8)     NOT NULL,
    [SQL_TEXT]      NVARCHAR (MAX) NULL,
    [DATE_UPDATED]  DATETIME       NULL,
    [ROW_NUM]       BIGINT         IDENTITY (1, 1) NOT NULL
);


GO
PRINT N'Creating [dbo].[QUERY_TEXT].[IX_QUERY_TEXT]...';


GO
CREATE UNIQUE CLUSTERED INDEX [IX_QUERY_TEXT]
    ON [dbo].[QUERY_TEXT]([QUERY_HASH] ASC, [SERVER_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating [dbo].[QUERY_TEXT].[IX_QUERY_TEXT_FT]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_QUERY_TEXT_FT]
    ON [dbo].[QUERY_TEXT]([ROW_NUM] ASC);


GO
PRINT N'Creating [dbo].[QUERY_STATS]...';


GO
CREATE TABLE [dbo].[QUERY_STATS] (
    [SERVER_NAME]          NVARCHAR (128) NOT NULL,
    [STATS_TIME]           DATETIME       NOT NULL,
    [DATABASE_NAME]        NVARCHAR (128) NOT NULL,
    [PLAN_HANDLE]          BINARY (64)    NOT NULL,
    [PLAN_GENERATION_NUM]  BIGINT         NOT NULL,
    [CREATION_TIME]        DATETIME       NOT NULL,
    [LAST_EXECUTION_TIME]  DATETIME       NOT NULL,
    [EXECUTION_COUNT]      BIGINT         NOT NULL,
    [TOTAL_WORKER_TIME]    BIGINT         NOT NULL,
    [LAST_WORKER_TIME]     BIGINT         NOT NULL,
    [MIN_WORKER_TIME]      BIGINT         NOT NULL,
    [MAX_WORKER_TIME]      BIGINT         NOT NULL,
    [TOTAL_PHYSICAL_READS] BIGINT         NOT NULL,
    [LAST_PHYSICAL_READS]  BIGINT         NOT NULL,
    [MIN_PHYSICAL_READS]   BIGINT         NOT NULL,
    [MAX_PHYSICAL_READS]   BIGINT         NOT NULL,
    [TOTAL_LOGICAL_WRITES] BIGINT         NOT NULL,
    [LAST_LOGICAL_WRITES]  BIGINT         NOT NULL,
    [MIN_LOGICAL_WRITES]   BIGINT         NOT NULL,
    [MAX_LOGICAL_WRITES]   BIGINT         NOT NULL,
    [TOTAL_LOGICAL_READS]  BIGINT         NOT NULL,
    [LAST_LOGICAL_READS]   BIGINT         NOT NULL,
    [MIN_LOGICAL_READS]    BIGINT         NOT NULL,
    [MAX_LOGICAL_READS]    BIGINT         NOT NULL,
    [TOTAL_CLR_TIME]       BIGINT         NOT NULL,
    [LAST_CLR_TIME]        BIGINT         NOT NULL,
    [MIN_CLR_TIME]         BIGINT         NOT NULL,
    [MAX_CLR_TIME]         BIGINT         NOT NULL,
    [TOTAL_ELAPSED_TIME]   BIGINT         NOT NULL,
    [LAST_ELAPSED_TIME]    BIGINT         NOT NULL,
    [MIN_ELAPSED_TIME]     BIGINT         NOT NULL,
    [MAX_ELAPSED_TIME]     BIGINT         NOT NULL,
    [QUERY_HASH]           BINARY (8)     NOT NULL,
    [QUERY_PLAN_HASH]      BINARY (8)     NOT NULL,
    [ROW_NUM]              BIGINT         IDENTITY (1, 1) NOT NULL,
    [TOTAL_ROWS]           BIGINT         NOT NULL,
    [LAST_ROWS]            BIGINT         NOT NULL,
    [MAX_ROWS]             BIGINT         NOT NULL,
    [MIN_ROWS]             BIGINT         NOT NULL,
    [TOTAL_DOP]            BIGINT         NOT NULL,
    [LAST_DOP]             BIGINT         NOT NULL,
    [MIN_DOP]              BIGINT         NOT NULL,
    [MAX_DOP]              BIGINT         NOT NULL,
    [WAIT_TIME_MS]         AS             (CONVERT (DECIMAL (29, 3), ([TOTAL_ELAPSED_TIME] - [TOTAL_WORKER_TIME]) / (1000), 0)),
    [AVG_TIME_MS]          AS             (CASE WHEN [EXECUTION_COUNT] > (0) THEN CONVERT (DECIMAL (29, 3), ([TOTAL_ELAPSED_TIME] / [EXECUTION_COUNT]) / (1000.000), (0)) ELSE (0) END)
);


GO
PRINT N'Creating [dbo].[QUERY_STATS].[IX_QUERY_STATS]...';


GO
CREATE CLUSTERED INDEX [IX_QUERY_STATS]
    ON [dbo].[QUERY_STATS]([QUERY_HASH] ASC, [STATS_TIME] ASC, [QUERY_PLAN_HASH] ASC, [SERVER_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating [dbo].[QUERY_STATS].[IX_QUERY_STATS_PLAN_HASH]...';


GO
CREATE NONCLUSTERED INDEX [IX_QUERY_STATS_PLAN_HASH]
    ON [dbo].[QUERY_STATS]([STATS_TIME] ASC, [QUERY_PLAN_HASH] ASC, [QUERY_HASH] ASC);


GO
PRINT N'Creating [dbo].[QUERY_STATS].[IX_QUERY_STATS_PLAN_HASH2]...';


GO
CREATE NONCLUSTERED INDEX [IX_QUERY_STATS_PLAN_HASH2]
    ON [dbo].[QUERY_STATS]([QUERY_PLAN_HASH] ASC, [STATS_TIME] ASC, [QUERY_HASH] ASC);


GO
PRINT N'Creating [dbo].[QUERY_STATS].[IX_QUERY_STATS_HASH]...';


GO
CREATE NONCLUSTERED INDEX [IX_QUERY_STATS_HASH]
    ON [dbo].[QUERY_STATS]([QUERY_HASH] ASC, [STATS_TIME] ASC, [SERVER_NAME] ASC, [DATABASE_NAME] ASC, [LAST_EXECUTION_TIME] ASC);


GO
PRINT N'Creating [dbo].[QUERY_STATS].[IX_QUERY_STATS_FT]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_QUERY_STATS_FT]
    ON [dbo].[QUERY_STATS]([ROW_NUM] ASC);


GO
PRINT N'Creating [dbo].[QUERY_STATS].[IX_QUERY_STATS_SERVER]...';


GO
CREATE NONCLUSTERED INDEX [IX_QUERY_STATS_SERVER]
    ON [dbo].[QUERY_STATS]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC, [QUERY_HASH] ASC);


GO
PRINT N'Creating [dbo].[SERVERINFO]...';


GO
CREATE TABLE [dbo].[SERVERINFO] (
    [SERVER_NAME]            NVARCHAR (128) NOT NULL,
    [STATS_TIME]             DATETIME       NOT NULL,
    [SQL_SERVER_STARTTIME]   DATETIME       NOT NULL,
    [PHYSICALCOMPUTERNAME]   SQL_VARIANT    NULL,
    [ISCLUSTERED]            SQL_VARIANT    NULL,
    [MACHINENAME]            SQL_VARIANT    NULL,
    [INSTANCENAME]           SQL_VARIANT    NULL,
    [PRODUCTVERSION]         SQL_VARIANT    NULL,
    [PRODUCTLEVEL]           SQL_VARIANT    NULL,
    [EDITION]                SQL_VARIANT    NULL,
    [ENGINEEDITION]          SQL_VARIANT    NULL,
    [SQLCHARSET]             SQL_VARIANT    NULL,
    [SQLCHARSETNAME]         SQL_VARIANT    NULL,
    [SQLSORTORDER]           SQL_VARIANT    NULL,
    [SQLSORTORDERNAME]       SQL_VARIANT    NULL,
    [CPU_COUNT]              INT            NOT NULL,
    [HYPERTHREAD_RATIO]      INT            NOT NULL,
    [BPOOL_COMMITTED_MB]     INT            NULL,
    [BPOOL_COMMIT_TARGET_MB] INT            NULL,
    [BPOOL_VISIBLE_MB]       INT            NULL,
    [SQL_SCHEDULER_COUNT]    INT            NULL
);


GO
PRINT N'Creating [dbo].[SERVERINFO].[IX_SERVER_INFO]...';


GO
CREATE CLUSTERED INDEX [IX_SERVER_INFO]
    ON [dbo].[SERVERINFO]([STATS_TIME] ASC, [SERVER_NAME] ASC);


GO
PRINT N'Creating [dbo].[SQL_CONFIGURATION]...';


GO
CREATE TABLE [dbo].[SQL_CONFIGURATION] (
    [SERVER_NAME]  NVARCHAR (128) NOT NULL,
    [STATS_TIME]   DATETIME       NOT NULL,
    [NAME]         NVARCHAR (35)  NOT NULL,
    [MINIMUM]      INT            NULL,
    [MAXIMUM]      INT            NULL,
    [CONFIG_VALUE] INT            NULL,
    [RUN_VALUE]    INT            NULL
);


GO
PRINT N'Creating [dbo].[SQL_CONFIGURATION].[IX_SQL_CONFIGS]...';


GO
CREATE CLUSTERED INDEX [IX_SQL_CONFIGS]
    ON [dbo].[SQL_CONFIGURATION]([SERVER_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[LOGINFO]...';


GO
CREATE TABLE [dbo].[LOGINFO] (
    [SERVER_NAME]   NVARCHAR (128) NOT NULL,
    [STATS_TIME]    DATETIME       NOT NULL,
    [DATABASE_NAME] NVARCHAR (128) NOT NULL,
    [FILEID]        TINYINT        NULL,
    [VLF_COUNT]     BIGINT         NULL,
    [FREE]          BIGINT         NULL,
    [INUSE]         BIGINT         NULL
);


GO
PRINT N'Creating [dbo].[LOGINFO].[IX_INDEX_USE_HIST]...';


GO
CREATE CLUSTERED INDEX [IX_INDEX_USE_HIST]
    ON [dbo].[LOGINFO]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[SQL_DATABASEFILES]...';


GO
CREATE TABLE [dbo].[SQL_DATABASEFILES] (
    [SERVER_NAME]        NVARCHAR (128) NOT NULL,
    [STATS_TIME]         DATETIME       NOT NULL,
    [DATABASE_NAME]      [sysname]      NOT NULL,
    [FILE_ID]            INT            NOT NULL,
    [FILE_NAME]          [sysname]      NOT NULL,
    [PHYSICAL_NAME]      NVARCHAR (512) NULL,
    [FILE_TYPE]          VARCHAR (4)    NULL,
    [DB_SIZE(MB)]        INT            NULL,
    [DB_FREE(MB)]        INT            NULL,
    [FREE_SPACE_%]       DECIMAL (25)   NULL,
    [GROWTH_UNITS]       VARCHAR (15)   NULL,
    [GROW_MAX_SIZE(MB)]  INT            NULL,
    [DB_INITAL_SIZE(MB)] INT            NULL
);


GO
PRINT N'Creating [dbo].[SQL_DATABASEFILES].[IX_SQL_DBFILES]...';


GO
CREATE CLUSTERED INDEX [IX_SQL_DBFILES]
    ON [dbo].[SQL_DATABASEFILES]([SERVER_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[SQL_REPLICATION]...';


GO
CREATE TABLE [dbo].[SQL_REPLICATION] (
    [SERVER_NAME]            NVARCHAR (128) NOT NULL,
    [STATS_TIME]             DATETIME       NOT NULL,
    [DATABASE_NAME]          NVARCHAR (128) NULL,
    [PUBLISHER_DB]           [sysname]      NOT NULL,
    [PUBLISHER_NAME]         [sysname]      NOT NULL,
    [TABLE_NAME]             [sysname]      NOT NULL,
    [SUBSCRIBER_SERVER_NAME] [sysname]      NOT NULL
);


GO
PRINT N'Creating [dbo].[SQL_REPLICATION].[IX_SQL_REP]...';


GO
CREATE CLUSTERED INDEX [IX_SQL_REP]
    ON [dbo].[SQL_REPLICATION]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[SQL_CHANGETRACKING_TABLES]...';


GO
CREATE TABLE [dbo].[SQL_CHANGETRACKING_TABLES] (
    [SERVER_NAME]                 NVARCHAR (128) NOT NULL,
    [DATABASE_NAME]               NVARCHAR (128) NOT NULL,
    [NAME]                        [sysname]      NOT NULL,
    [OBJECT_ID]                   INT            NOT NULL,
    [IS_TRACK_COLUMNS_UPDATED_ON] BIT            NOT NULL,
    [MIN_VALID_VERSION]           BIGINT         NULL,
    [BEGIN_VERSION]               BIGINT         NULL,
    [CLEANUP_VERSION]             BIGINT         NULL
);


GO
PRINT N'Creating [dbo].[SQL_CHANGETRACKING_TABLES].[IX_SQL_CT_TABLES]...';


GO
CREATE CLUSTERED INDEX [IX_SQL_CT_TABLES]
    ON [dbo].[SQL_CHANGETRACKING_TABLES]([SERVER_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating [dbo].[SQL_CHANGETRACKING_DBS]...';


GO
CREATE TABLE [dbo].[SQL_CHANGETRACKING_DBS] (
    [SERVER_NAME]                 NVARCHAR (128) NOT NULL,
    [NAME]                        [sysname]      NOT NULL,
    [DATABASE_ID]                 INT            NOT NULL,
    [IS_AUTO_CLEANUP_ON]          TINYINT        NULL,
    [MAX_CLEANUP_VERSION]         BIGINT         NULL,
    [RETENTION_PERIOD]            INT            NULL,
    [RETENTION_PERIOD_UNITS]      TINYINT        NULL,
    [RETENTION_PERIOD_UNITS_DESC] NVARCHAR (60)  NULL
);


GO
PRINT N'Creating [dbo].[SQL_CHANGETRACKING_DBS].[IX_SQL_CT_DBS]...';


GO
CREATE CLUSTERED INDEX [IX_SQL_CT_DBS]
    ON [dbo].[SQL_CHANGETRACKING_DBS]([SERVER_NAME] ASC);


GO
PRINT N'Creating [dbo].[SSRS_EXECUTIONLOG]...';


GO
CREATE TABLE [dbo].[SSRS_EXECUTIONLOG] (
    [SERVER_NAME]        NVARCHAR (128) NOT NULL,
    [REPORTPATH]         NVARCHAR (425) NULL,
    [REPORTNAME]         NVARCHAR (512) NULL,
    [USERNAME]           NVARCHAR (260) NULL,
    [EXECUTIONID]        NVARCHAR (64)  NULL,
    [REQUESTTYPE]        VARCHAR (12)   NOT NULL,
    [FORMAT]             NVARCHAR (26)  NULL,
    [PARAMETERS]         NTEXT          NULL,
    [REPORTACTION]       VARCHAR (21)   NOT NULL,
    [TIMESTART]          DATETIME       NOT NULL,
    [TIMEEND]            DATETIME       NOT NULL,
    [TIME_DATARETRIEVAL] INT            NOT NULL,
    [TIME_PROCESSING]    INT            NOT NULL,
    [TIME_RENDERING]     INT            NOT NULL,
    [SOURCE]             VARCHAR (8)    NOT NULL,
    [STATUS]             NVARCHAR (40)  NOT NULL,
    [BYTECOUNT]          BIGINT         NOT NULL,
    [ROWCOUNT]           BIGINT         NOT NULL
);


GO
PRINT N'Creating [dbo].[SSRS_EXECUTIONLOG].[IX_SSRS_REPORT]...';


GO
CREATE CLUSTERED INDEX [IX_SSRS_REPORT]
    ON [dbo].[SSRS_EXECUTIONLOG]([TIMEEND] ASC, [SERVER_NAME] ASC);


GO
PRINT N'Creating [dbo].[DYNSYSPARTITIONS]...';


GO
CREATE TABLE [dbo].[DYNSYSPARTITIONS] (
    [RUN_NAME]                NVARCHAR (128) NOT NULL,
    [DATABASE_NAME]           [sysname]      NULL,
    [PARTITION_ID]            BIGINT         NOT NULL,
    [OBJECT_ID]               INT            NOT NULL,
    [INDEX_ID]                INT            NOT NULL,
    [PARTITION_NUMBER]        INT            NOT NULL,
    [HOBT_ID]                 BIGINT         NOT NULL,
    [ROWS]                    BIGINT         NOT NULL,
    [FILESTREAM_FILEGROUP_ID] SMALLINT       NOT NULL,
    [DATA_COMPRESSION]        TINYINT        NOT NULL,
    [DATA_COMPRESSION_DESC]   NVARCHAR (60)  NULL
);


GO
PRINT N'Creating [dbo].[DYNSYSPARTITIONS].[IX_DYNSYSPARTITIONS_CLUS]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_DYNSYSPARTITIONS_CLUS]
    ON [dbo].[DYNSYSPARTITIONS]([RUN_NAME] ASC, [DATABASE_NAME] ASC, [OBJECT_ID] ASC, [INDEX_ID] ASC, [PARTITION_ID] ASC);


GO
PRINT N'Creating [dbo].[DYNSYSCOLUMNS]...';


GO
CREATE TABLE [dbo].[DYNSYSCOLUMNS] (
    [RUN_NAME]      NVARCHAR (128) NOT NULL,
    [DATABASE_NAME] [sysname]      NOT NULL,
    [OBJECT_ID]     INT            NOT NULL,
    [NAME]          [sysname]      NOT NULL,
    [COLUMN_ID]     INT            NOT NULL,
    [DATATYPE]      [sysname]      NOT NULL,
    [MAX_LENGTH]    SMALLINT       NOT NULL
);


GO
PRINT N'Creating [dbo].[DYNSYSCOLUMNS].[IX_DYNSYSCOLS]...';


GO
CREATE CLUSTERED INDEX [IX_DYNSYSCOLS]
    ON [dbo].[DYNSYSCOLUMNS]([RUN_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating [dbo].[DYNSYSOBJECTS]...';


GO
CREATE TABLE [dbo].[DYNSYSOBJECTS] (
    [RUN_NAME]            NVARCHAR (128) NOT NULL,
    [DATABASE_NAME]       [sysname]      NULL,
    [NAME]                [sysname]      NOT NULL,
    [OBJECT_ID]           INT            NOT NULL,
    [PRINCIPAL_ID]        INT            NULL,
    [SCHEMA_ID]           INT            NOT NULL,
    [PARENT_OBJECT_ID]    INT            NOT NULL,
    [TYPE]                CHAR (2)       NOT NULL,
    [TYPE_DESC]           NVARCHAR (60)  NULL,
    [CREATE_DATE]         DATETIME       NOT NULL,
    [MODIFY_DATE]         DATETIME       NOT NULL,
    [IS_MS_SHIPPED]       BIT            NOT NULL,
    [IS_PUBLISHED]        BIT            NOT NULL,
    [IS_SCHEMA_PUBLISHED] BIT            NOT NULL
);


GO
PRINT N'Creating [dbo].[DYNSYSOBJECTS].[IX_DYNSYSOBJECTS_CLUS]...';


GO
CREATE CLUSTERED INDEX [IX_DYNSYSOBJECTS_CLUS]
    ON [dbo].[DYNSYSOBJECTS]([RUN_NAME] ASC, [DATABASE_NAME] ASC, [OBJECT_ID] ASC);


GO
PRINT N'Creating [dbo].[DYNSYSINDEXES]...';


GO
CREATE TABLE [dbo].[DYNSYSINDEXES] (
    [RUN_NAME]             NVARCHAR (128) NOT NULL,
    [DATABASE_NAME]        [sysname]      NULL,
    [OBJECT_ID]            INT            NOT NULL,
    [NAME]                 [sysname]      NULL,
    [INDEX_ID]             INT            NOT NULL,
    [TYPE]                 TINYINT        NOT NULL,
    [TYPE_DESC]            NVARCHAR (60)  NULL,
    [IS_UNIQUE]            BIT            NULL,
    [DATA_SPACE_ID]        INT            NOT NULL,
    [IGNORE_DUP_KEY]       BIT            NULL,
    [IS_PRIMARY_KEY]       BIT            NULL,
    [IS_UNIQUE_CONSTRAINT] BIT            NULL,
    [FILL_FACTOR]          TINYINT        NOT NULL,
    [IS_PADDED]            BIT            NULL,
    [IS_DISABLED]          BIT            NULL,
    [IS_HYPOTHETICAL]      BIT            NULL,
    [ALLOW_ROW_LOCKS]      BIT            NULL,
    [ALLOW_PAGE_LOCKS]     BIT            NULL,
    [HAS_FILTER]           BIT            NULL,
    [FILTER_DEFINITION]    NVARCHAR (MAX) NULL,
    [MAX_ROW_SIZE]         INT            NULL,
    [MAX_LOB_SIZE]         INT            NULL
);


GO
PRINT N'Creating [dbo].[DYNSYSINDEXES].[IX_DYNSYSINDEXES_CLUS]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_DYNSYSINDEXES_CLUS]
    ON [dbo].[DYNSYSINDEXES]([RUN_NAME] ASC, [DATABASE_NAME] ASC, [OBJECT_ID] ASC, [INDEX_ID] ASC);


GO
PRINT N'Creating [dbo].[QUERY_HISTORY]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[QUERY_HISTORY] (
    [SERVER_NAME]               NVARCHAR (128) NOT NULL,
    [DATABASE_NAME]             NVARCHAR (128) NOT NULL,
    [DATE]                      DATE           NULL,
    [QUERY_HASH]                BINARY (8)     NOT NULL,
    [QUERY_PLAN_HASH]           BINARY (8)     NOT NULL,
    [EXECUTION_COUNT_TODAY]     BIGINT         NULL,
    [ELAPSED_TIME_TODAY]        BIGINT         NULL,
    [MAX_ELAPSED_TIME]          BIGINT         NULL,
    [LAST_EXECUTION_TIME]       DATETIME       NULL,
    [TOTAL_LOGICAL_READS_TODAY] BIGINT         NULL,
    [TOTAL_ROWS_TODAY]          BIGINT         NULL,
    [TOTAL_WORKER_TIME_TODAY]   BIGINT         NULL,
    [FLAG]                      NCHAR (1)      NULL,
    [WAIT_TIME_TODAY_MS]        AS             (CONVERT (DECIMAL (29, 3), ([ELAPSED_TIME_TODAY] - [TOTAL_WORKER_TIME_TODAY]) / (1000), 0)),
    [AVG_TIME_TODAY_MS]         AS             (CASE WHEN [EXECUTION_COUNT_TODAY] > (0) THEN CONVERT (DECIMAL (29, 3), ([ELAPSED_TIME_TODAY] / [EXECUTION_COUNT_TODAY]) / (1000.000), (0)) ELSE (0) END)
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[QUERY_HISTORY].[IX_QUERY_HISTORY]...';


GO
CREATE CLUSTERED INDEX [IX_QUERY_HISTORY]
    ON [dbo].[QUERY_HISTORY]([DATE] ASC, [QUERY_HASH] ASC, [SERVER_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating [dbo].[CRM_POA_TOTALS]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[CRM_POA_TOTALS] (
    [SERVER_NAME]        NVARCHAR (128) NOT NULL,
    [STATS_TIME]         DATETIME       NOT NULL,
    [DATABASE_NAME]      NVARCHAR (128) NOT NULL,
    [ENTITYNAME]         NVARCHAR (64)  NULL,
    [DIRECTSHARES]       BIGINT         NULL,
    [INHERITEDSHARES]    BIGINT         NULL,
    [QUEUEDFORDELETION]  BIGINT         NULL,
    [INHERITEDANDDIRECT] BIGINT         NULL,
    [TOTALSHARES]        BIGINT         NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[CRM_POA_TOTALS].[IX_CRM_POA]...';


GO
CREATE CLUSTERED INDEX [IX_CRM_POA]
    ON [dbo].[CRM_POA_TOTALS]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[CRM_PLUGINS]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[CRM_PLUGINS] (
    [SERVER_NAME]         NVARCHAR (128) NOT NULL,
    [STATS_TIME]          DATETIME       NOT NULL,
    [DATABASE_NAME]       NVARCHAR (128) NOT NULL,
    [STATUSNAME]          VARCHAR (8)    NOT NULL,
    [ENTITYNAME]          NVARCHAR (64)  NOT NULL,
    [STAGENAME]           VARCHAR (17)   NOT NULL,
    [ISOLATIONMODENAME]   VARCHAR (16)   NOT NULL,
    [ISOLATIONMODE]       INT            NOT NULL,
    [VERSION]             NVARCHAR (48)  NOT NULL,
    [ISMANAGED]           BIT            NOT NULL,
    [MESSAGENAME]         NVARCHAR (256) NOT NULL,
    [ASSEMBLY]            INT            NOT NULL,
    [PLUGIN]              NVARCHAR (256) NOT NULL,
    [MODENAME]            VARCHAR (12)   NOT NULL,
    [ASYNCAUTODELETENAME] VARCHAR (3)    NOT NULL,
    [RANK]                INT            NOT NULL,
    [FILTERINGATTRIBUTES] NVARCHAR (MAX) NOT NULL,
    [STEPNAME]            NVARCHAR (256) NOT NULL,
    [ASYNCAUTODELETE]     BIT            NOT NULL,
    [MODE]                INT            NOT NULL,
    [STAGE]               INT            NOT NULL,
    [AVGEXECTIMEMS]       INT            NOT NULL,
    [EXECUTES]            INT            NOT NULL,
    [FAILURES]            INT            NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[CRM_PLUGINS].[IX_CRM_PLUGINS]...';


GO
CREATE CLUSTERED INDEX [IX_CRM_PLUGINS]
    ON [dbo].[CRM_PLUGINS]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[CRM_ORGANIZATION]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[CRM_ORGANIZATION] (
    [SERVER_NAME]                  NVARCHAR (128) NOT NULL,
    [STATS_TIME]                   DATETIME       NOT NULL,
    [DATABASE_NAME]                NVARCHAR (128) NOT NULL,
    [SHARETOPREVIOUSOWNERONASSIGN] BIT            NOT NULL,
    [MINOUTLOOKSYNCINTERVAL]       INT            NOT NULL,
    [TAGPOLLINGPERIOD]             INT            NOT NULL,
    [MINADDRESSBOOKSYNCINTERVAL]   INT            NOT NULL,
    [ALLOWADDRESSBOOKSYNCS]        BIT            NOT NULL,
    [EMAILSENDPOLLINGPERIOD]       INT            NOT NULL,
    [ISPRESENCEENABLED]            BIT            NULL,
    [GETSTARTEDPANECONTENTENABLED] BIT            NOT NULL,
    [ORGDBORGSETTINGS]             NVARCHAR (MAX) NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[CRM_ORGANIZATION].[IX_CRM_ORG]...';


GO
CREATE CLUSTERED INDEX [IX_CRM_ORG]
    ON [dbo].[CRM_ORGANIZATION]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[SQL_PLAN_GUIDES]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[SQL_PLAN_GUIDES] (
    [SERVER_NAME]     NVARCHAR (128) NOT NULL,
    [STATS_TIME]      DATETIME       NOT NULL,
    [DATABASE_NAME]   NVARCHAR (128) NOT NULL,
    [PLAN_GUIDE_ID]   INT            NOT NULL,
    [NAME]            [sysname]      NOT NULL,
    [CREATE_DATE]     DATETIME       NOT NULL,
    [MODIFY_DATE]     DATETIME       NOT NULL,
    [IS_DISABLED]     BIT            NOT NULL,
    [QUERY_TEXT]      NVARCHAR (MAX) NULL,
    [SCOPE_TYPE]      TINYINT        NOT NULL,
    [SCOPE_TYPE_DESC] NVARCHAR (60)  NULL,
    [SCOPE_OBJECT_ID] INT            NULL,
    [SCOPE_BATCH]     NVARCHAR (MAX) NULL,
    [PARAMETERS]      NVARCHAR (MAX) NULL,
    [HINTS]           NVARCHAR (MAX) NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[SQL_PLAN_GUIDES].[IX_PLAN_GUIDES]...';


GO
CREATE CLUSTERED INDEX [IX_PLAN_GUIDES]
    ON [dbo].[SQL_PLAN_GUIDES]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[DYNPERF_PURGETABLES]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[DYNPERF_PURGETABLES] (
    [TABLE_NAME]         NVARCHAR (128) NOT NULL,
    [TIME_COLUMN]        NVARCHAR (128) NOT NULL,
    [SERVER_NAME_FLAG]   BIT            NULL,
    [DATABASE_NAME_FLAG] BIT            NULL,
    [RETENTION_DAYS]     INT            NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[SSRS_CONFIG]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[SSRS_CONFIG] (
    [SERVER_NAME]    NVARCHAR (128) NOT NULL,
    [LAST_COLLECTED] DATETIME       NOT NULL,
    [DATABASE_NAME]  NVARCHAR (128) NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[SQL_AZURE_EVENTS]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[SQL_AZURE_EVENTS] (
    [SERVER_NAME]        NVARCHAR (128) NOT NULL,
    [DATABASE_NAME]      NVARCHAR (128) NULL,
    [START_TIME]         DATETIME       NULL,
    [END_TIME]           DATETIME       NULL,
    [EVENT_CATEGORY]     NVARCHAR (64)  NULL,
    [EVENT_TYPE]         NVARCHAR (64)  NULL,
    [EVENT_SUBTYPE]      INT            NULL,
    [EVENT_SUBTYPE_DESC] NVARCHAR (64)  NULL,
    [SEVERITY]           INT            NULL,
    [EVENT_COUNT]        INT            NULL,
    [DESCRIPTION]        NVARCHAR (MAX) NULL,
    [ADDITIONAL_DATA]    NVARCHAR (MAX) NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[SQL_AZURE_EVENTS].[IX_AZURE_EVENTS]...';


GO
CREATE CLUSTERED INDEX [IX_AZURE_EVENTS]
    ON [dbo].[SQL_AZURE_EVENTS]([END_TIME] ASC, [DATABASE_NAME] ASC, [SERVER_NAME] ASC);


GO
PRINT N'Creating [dbo].[PERF_COUNTER_DATA]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[PERF_COUNTER_DATA] (
    [SERVER_NAME]   NVARCHAR (128) NOT NULL,
    [STATS_TIME]    DATETIME       NOT NULL,
    [OBJECT_NAME]   NVARCHAR (128) NOT NULL,
    [COUNTER_NAME]  NVARCHAR (128) NOT NULL,
    [INSTANCE_NAME] NVARCHAR (128) NOT NULL,
    [CNTR_VALUE]    BIGINT         NULL,
    [CNTR_TYPE]     INT            NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[PERF_COUNTER_DATA].[IX_PERF_DATA]...';


GO
CREATE CLUSTERED INDEX [IX_PERF_DATA]
    ON [dbo].[PERF_COUNTER_DATA]([SERVER_NAME] ASC, [STATS_TIME] ASC, [OBJECT_NAME] ASC);


GO
PRINT N'Creating [dbo].[PERF_COUNTER_2_COLLECT]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[PERF_COUNTER_2_COLLECT] (
    [OBJECT_NAME]   NVARCHAR (128) NOT NULL,
    [COUNTER_NAME]  NVARCHAR (128) NOT NULL,
    [INSTANCE_NAME] NVARCHAR (128) NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[PERF_COUNTER_2_COLLECT].[IX_PERF_C_2_COLLECT]...';


GO
CREATE UNIQUE CLUSTERED INDEX [IX_PERF_C_2_COLLECT]
    ON [dbo].[PERF_COUNTER_2_COLLECT]([OBJECT_NAME] ASC, [COUNTER_NAME] ASC, [INSTANCE_NAME] ASC);


GO
PRINT N'Creating [dbo].[QUERY_ALERTS_CONFIG]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[QUERY_ALERTS_CONFIG] (
    [SERVER_NAME]               NVARCHAR (128) NOT NULL,
    [DATABASE_NAME]             NVARCHAR (128) NOT NULL,
    [PCT_AVG_TIME_CHANGE_DAY]   INT            NULL,
    [PCT_AVG_TIME_CHANGE_MONTH] INT            NULL,
    [MIN_EXECUTION_COUNTS]      INT            NULL,
    [MIN_AVG_TIME_MS]           INT            NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[QUERY_ALERTS]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[QUERY_ALERTS] (
    [SERVER_NAME]     NVARCHAR (128) NOT NULL,
    [STATS_TIME]      DATETIME       NOT NULL,
    [DATABASE_NAME]   NVARCHAR (128) NOT NULL,
    [QUERY_HASH]      BINARY (8)     NOT NULL,
    [QUERY_PLAN_HASH] BINARY (8)     NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[AX_SQLTRACE_CONFIG]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[AX_SQLTRACE_CONFIG] (
    [SERVER_NAME]        NVARCHAR (128) NOT NULL,
    [DATABASE_NAME]      NVARCHAR (128) NOT NULL,
    [SQL_DURATION]       INT            NOT NULL,
    [TRACE_ON]           BIT            NULL,
    [AXDB_DELETION_DAYS] INT            NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[INDEX_STAT_HEADER]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[INDEX_STAT_HEADER] (
    [SERVER_NAME]        NVARCHAR (128)  NOT NULL,
    [DATABASE_NAME]      NVARCHAR (128)  NOT NULL,
    [TABLENAME]          NVARCHAR (128)  NOT NULL,
    [INDEXNAME]          NVARCHAR (128)  NOT NULL,
    [NAME]               NVARCHAR (128)  NULL,
    [UPDATED]            DATETIME2 (7)   NULL,
    [ROWS]               INT             NULL,
    [ROWS SAMPLED]       INT             NULL,
    [STEPS]              INT             NULL,
    [DENSITY]            NUMERIC (10, 5) NULL,
    [AVERAGE KEY LENGTH] NUMERIC (10, 5) NULL,
    [STRING INDEX]       VARCHAR (10)    NULL,
    [FILTER_EXPRESSION]  NVARCHAR (MAX)  NULL,
    [UNFILTERED_ROWS]    INT             NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[SSRS_HISTORY]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[SSRS_HISTORY] (
    [SERVER_NAME]           NVARCHAR (128) NOT NULL,
    [REPORTPATH]            NVARCHAR (425) NULL,
    [REPORT_NAME]           NVARCHAR (512) NULL,
    [REPORT_DATE]           DATE           NULL,
    [TOTAL_TIME_DATA]       BIGINT         NULL,
    [TOTAL_TIME_PROCESSING] BIGINT         NULL,
    [TOTAL_TIME_RENDERING]  BIGINT         NULL,
    [MAX_REPORT_TIME_MS]    INT            NULL,
    [MIN_REPORT_TIME_MS]    INT            NULL,
    [EXECUTION_COUNT]       BIGINT         NULL,
    [MAX_SIZE_BYTES]        BIGINT         NULL,
    [MAX_ROW_COUNT]         BIGINT         NULL,
    [FLAG]                  CHAR (1)       NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[SSRS_HISTORY].[IX_SSRS_HIST]...';


GO
CREATE CLUSTERED INDEX [IX_SSRS_HIST]
    ON [dbo].[SSRS_HISTORY]([REPORT_DATE] ASC, [SERVER_NAME] ASC);


GO
PRINT N'Creating [dbo].[SYSTEM_COMMENTS]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[SYSTEM_COMMENTS] (
    [DATE]    SMALLDATETIME  NULL,
    [COMMENT] NVARCHAR (MAX) NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[SYSTEM_COMMENTS].[IX_SYS_COMMENTS]...';


GO
CREATE CLUSTERED INDEX [IX_SYS_COMMENTS]
    ON [dbo].[SYSTEM_COMMENTS]([DATE] ASC);


GO
PRINT N'Creating [dbo].[INDEX_HISTORY]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[INDEX_HISTORY] (
    [SERVER_NAME]            NVARCHAR (128) NOT NULL,
    [DATABASE_NAME]          NVARCHAR (128) NOT NULL,
    [DATE]                   DATE           NOT NULL,
    [TABLE_NAME]             NVARCHAR (128) NOT NULL,
    [INDEX_NAME]             NVARCHAR (128) NOT NULL,
    [INDEX_DESCRIPTION]      NVARCHAR (210) NULL,
    [INDEX_KEYS]             NVARCHAR (MAX) NULL,
    [COMPRESSION_TYPE]       INT            NULL,
    [USER_SEEKS_DELTA]       BIGINT         NULL,
    [USER_SCANS_DELTA]       BIGINT         NULL,
    [USER_LOOKUPS_DELTA]     BIGINT         NULL,
    [USER_UPDATES_DELTA]     BIGINT         NULL,
    [RANGE_SCAN_COUNT_DELTA] BIGINT         NULL,
    [PAGE_COUNT_DELTA]       BIGINT         NULL,
    [ROW_COUNT_DELTA]        BIGINT         NULL,
    [ROW_COUNT]              BIGINT         NULL,
    [PAGE_COUNT]             BIGINT         NULL,
    [SINGLETON_LOOKUP_COUNT] BIGINT         NULL,
    [FLAG]                   VARCHAR (1)    NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[INDEX_HISTORY].[IX_INDEX_HISTORY]...';


GO
CREATE CLUSTERED INDEX [IX_INDEX_HISTORY]
    ON [dbo].[INDEX_HISTORY]([DATE] ASC, [SERVER_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating [dbo].[WRK_PS_SQL_INFO]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[WRK_PS_SQL_INFO] (
    [SQL_STARTTIME] DATETIME      NULL,
    [SQL_BUILD]     NVARCHAR (20) NULL,
    [TZ_OFFSET]     INT           NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[WRK_CS_SQL_INFO]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[WRK_CS_SQL_INFO] (
    [SQL_STARTTIME] DATETIME      NULL,
    [SQL_BUILD]     NVARCHAR (20) NULL,
    [TZ_OFFSET]     INT           NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[AX_USERINFO]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[AX_USERINFO] (
    [SERVER_NAME]   NVARCHAR (128) NOT NULL,
    [STATS_TIME]    DATETIME       NOT NULL,
    [DATABASE_NAME] NVARCHAR (128) NOT NULL,
    [Id]            NVARCHAR (30)  NOT NULL,
    [NAME]          NVARCHAR (128) NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[AX_USERINFO].[IX_AX_USERINFO]...';


GO
CREATE CLUSTERED INDEX [IX_AX_USERINFO]
    ON [dbo].[AX_USERINFO]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[AZURE_EVENTS]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[AZURE_EVENTS] (
    [SERVER_NAME]        NVARCHAR (128) NOT NULL,
    [STATS_TIME]         DATETIME       NOT NULL,
    [DATABASE_NAME]      NVARCHAR (128) NULL,
    [DBNAME]             NVARCHAR (128) NULL,
    [START_TIME]         DATETIME2 (7)  NULL,
    [END_TIME]           DATETIME2 (7)  NULL,
    [EVENT_CATEGORY]     NVARCHAR (128) NULL,
    [EVENT_TYPE]         NVARCHAR (128) NULL,
    [EVENT_SUBTYPE]      INT            NULL,
    [EVENT_SUBTYPE_DESC] NVARCHAR (128) NULL,
    [SEVERITY]           INT            NULL,
    [EVENT_COUNT]        INT            NULL,
    [DESCRIPTION]        NVARCHAR (MAX) NULL,
    [ADDITIONAL_DATA]    XML            NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[AZURE_EVENTS].[IX_AZURE_EVENTS]...';


GO
CREATE CLUSTERED INDEX [IX_AZURE_EVENTS]
    ON [dbo].[AZURE_EVENTS]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[QUERY_PLANS_PARSED]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[QUERY_PLANS_PARSED] (
    [SERVER_NAME]               NVARCHAR (128)  NOT NULL,
    [DATABASE_NAME]             NVARCHAR (128)  NOT NULL,
    [QUERY_PLAN_HASH]           BINARY (8)      NOT NULL,
    [NODE_ID]                   INT             NULL,
    [TABLE_NAME]                NVARCHAR (128)  NULL,
    [INDEX_NAME]                NVARCHAR (128)  NULL,
    [LOOKUP]                    INT             NULL,
    [PARALLEL]                  INT             NULL,
    [PHYSICALOP]                NVARCHAR (128)  NULL,
    [LOGICALOP]                 NVARCHAR (128)  NULL,
    [ESTIMATEROWS]              DECIMAL (14)    NULL,
    [ESTIMATEIO]                DECIMAL (20, 7) NULL,
    [ESTIMATECPU]               DECIMAL (20, 7) NULL,
    [AVGROWSIZE]                DECIMAL (14)    NULL,
    [ESTIMATEDTOTALSUBTREECOST] DECIMAL (20, 7) NULL,
    [SEEK_COLUMNS]              NVARCHAR (MAX)  NULL,
    [PREDICATES]                NVARCHAR (MAX)  NULL,
    [PREDICATE_TEXT]            NVARCHAR (MAX)  NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[QUERY_PLANS_PARSED].[IX_QUERY_PLANS_PARSED_HASH]...';


GO
CREATE CLUSTERED INDEX [IX_QUERY_PLANS_PARSED_HASH]
    ON [dbo].[QUERY_PLANS_PARSED]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [QUERY_PLAN_HASH] ASC);


GO
PRINT N'Creating [dbo].[AX_BATCHJOB_DETAIL]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[AX_BATCHJOB_DETAIL] (
    [SERVER_NAME]               NVARCHAR (128) NOT NULL,
    [STATS_TIME]                DATETIME       NULL,
    [DATABASE_NAME]             NVARCHAR (128) NOT NULL,
    [JOB_STATUS]                NVARCHAR (20)  NOT NULL,
    [CAPTION]                   NVARCHAR (255) NOT NULL,
    [COMPANY]                   NVARCHAR (8)   NOT NULL,
    [LOG_LEVEL]                 NVARCHAR (60)  NOT NULL,
    [SCHED_START_DATETIME]      DATETIME       NOT NULL,
    [ACTUAL_START_DATETIME]     DATETIME       NOT NULL,
    [END_DATETIME]              DATETIME       NOT NULL,
    [DATA_PARTITION]            NVARCHAR (8)   NOT NULL,
    [RECUR_TIMEZONE]            NVARCHAR (100) NOT NULL,
    [RECUR_RANGE_STARTDATETIME] DATETIME       NOT NULL,
    [RECUR_RANGE_UNIT]          NVARCHAR (80)  NOT NULL,
    [RECUR_PATTERN_UNIT]        NVARCHAR (40)  NOT NULL,
    [RECUR_PATTERN_DESC]        NVARCHAR (255) NOT NULL,
    [CREATED_DATETIME]          DATETIME       NOT NULL,
    [CREATED_BY]                NVARCHAR (16)  NOT NULL,
    [BATCH_GROUPID]             NVARCHAR (20)  NOT NULL,
    [RUN_TYPE]                  NVARCHAR (20)  NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[AX_BATCHJOB_DETAIL].[IX_BATCH_JOBDETAIL]...';


GO
CREATE CLUSTERED INDEX [IX_BATCH_JOBDETAIL]
    ON [dbo].[AX_BATCHJOB_DETAIL]([SERVER_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating [dbo].[AX_SERVER_CONFIG]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[AX_SERVER_CONFIG] (
    [SERVER_NAME]            NVARCHAR (128) NOT NULL,
    [STATS_TIME]             DATETIME       NULL,
    [DATABASE_NAME]          NVARCHAR (128) NOT NULL,
    [AOS_SERVER_NAME]        NVARCHAR (100) NOT NULL,
    [ENABLE_BATCH]           BIT            NOT NULL,
    [LOAD_BALANCING_ENABLED] BIT            NOT NULL,
    [MAX_SESSIONS]           INT            NOT NULL,
    [CLUSTER_NAME]           NVARCHAR (100) NOT NULL,
    [CLUSTER_DESCRIPTION]    NVARCHAR (60)  NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[AX_SERVER_CONFIG].[IX_SERVERCONFIG]...';


GO
CREATE CLUSTERED INDEX [IX_SERVERCONFIG]
    ON [dbo].[AX_SERVER_CONFIG]([SERVER_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating [dbo].[AX_LICENSEKEY_DETAIL]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[AX_LICENSEKEY_DETAIL] (
    [SERVER_NAME]         NVARCHAR (128) NOT NULL,
    [STATS_TIME]          DATETIME       NULL,
    [DATABASE_NAME]       NVARCHAR (128) NOT NULL,
    [LICENSE_KEY_ID]      INT            NOT NULL,
    [LICENSE_KEY_NAME]    NVARCHAR (40)  NOT NULL,
    [LICENSE_KEY_LABEL]   NVARCHAR (255) NOT NULL,
    [LICENSE_GROUP]       NVARCHAR (100) NOT NULL,
    [LICENSE_TYPE]        NVARCHAR (20)  NOT NULL,
    [PACKAGE]             NVARCHAR (50)  NOT NULL,
    [PREREQUISITE1]       NVARCHAR (40)  NOT NULL,
    [PREREQUISITE2]       NVARCHAR (40)  NOT NULL,
    [PREREQUISITE3]       NVARCHAR (40)  NOT NULL,
    [PREREQUISITE4]       NVARCHAR (40)  NOT NULL,
    [PREREQUISITE5]       NVARCHAR (40)  NOT NULL,
    [LICENSE_KEY_ENABLED] BIT            NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[AX_LICENSEKEY_DETAIL].[IX_LICENSEKEY_DETAIL]...';


GO
CREATE CLUSTERED INDEX [IX_LICENSEKEY_DETAIL]
    ON [dbo].[AX_LICENSEKEY_DETAIL]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);


GO
PRINT N'Creating [dbo].[AX_CONFIGURATIONKEY_DETAIL]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE TABLE [dbo].[AX_CONFIGURATIONKEY_DETAIL] (
    [SERVER_NAME]      NVARCHAR (128) NOT NULL,
    [STATS_TIME]       DATETIME       NULL,
    [DATABASE_NAME]    NVARCHAR (128) NOT NULL,
    [CONFIG_KEY_ID]    INT            NOT NULL,
    [CONFIG_KEY_NAME]  NVARCHAR (40)  NOT NULL,
    [CONFIG_KEY_LABEL] NVARCHAR (255) NOT NULL,
    [PARENT_KEY_ID]    INT            NOT NULL,
    [LICENSE_KEY_ID]   INT            NOT NULL,
    [CONFIG_ENABLED]   BIT            NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[AX_CONFIGURATIONKEY_DETAIL].[IX_CONFIGKEY_DETAIL]...';


GO
CREATE CLUSTERED INDEX [IX_CONFIGKEY_DETAIL]
    ON [dbo].[AX_CONFIGURATIONKEY_DETAIL]([SERVER_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating unnamed constraint on [dbo].[DATABASES_2_COLLECT]...';


GO
ALTER TABLE [dbo].[DATABASES_2_COLLECT]
    ADD DEFAULT @@SERVERNAME FOR [LINKED_SERVER];


GO
PRINT N'Creating unnamed constraint on [dbo].[DATABASES_2_COLLECT]...';


GO
ALTER TABLE [dbo].[DATABASES_2_COLLECT]
    ADD DEFAULT 24 FOR [RETAIN_HISTORY_MONTHS];


GO
PRINT N'Creating unnamed constraint on [dbo].[DATABASES_2_COLLECT]...';


GO
ALTER TABLE [dbo].[DATABASES_2_COLLECT]
    ADD DEFAULT 60 FOR [RETAIN_HISTORY_DAYS];


GO
PRINT N'Creating unnamed constraint on [dbo].[DATABASES_2_COLLECT]...';


GO
ALTER TABLE [dbo].[DATABASES_2_COLLECT]
    ADD DEFAULT 2 FOR [RETAIN_DETAILS_DAYS];


GO
PRINT N'Creating unnamed constraint on [dbo].[DATABASES_2_COLLECT]...';


GO
ALTER TABLE [dbo].[DATABASES_2_COLLECT]
    ADD DEFAULT 90 FOR [PURGE_STALE_QUERIES_DAYS];


GO
PRINT N'Creating unnamed constraint on [dbo].[DATABASES_2_COLLECT]...';


GO
ALTER TABLE [dbo].[DATABASES_2_COLLECT]
    ADD DEFAULT 7 FOR [REFRESH_PLAN_DAYS];


GO
PRINT N'Creating [dbo].[DF_AX_INDEX_DETAIL_INDEX_ID]...';


GO
ALTER TABLE [dbo].[AX_INDEX_DETAIL]
    ADD CONSTRAINT [DF_AX_INDEX_DETAIL_INDEX_ID] DEFAULT ((0)) FOR [INDEX_ID];


GO
PRINT N'Creating [dbo].[HISTORY_INS_TASK_SCHEDULER_TABLE]...';


GO

CREATE TRIGGER HISTORY_INS_TASK_SCHEDULER_TABLE
ON [DYNPERF_TASK_SCHEDULER]
FOR INSERT
AS
    INSERT DYNPERF_TASK_HISTORY
    SELECT ISNULL(DTC.LINKED_SERVER, @@SERVERNAME),
           DTC.DATABASE_NAME,
           inserted.TASK_ID,
		   NULL,
		   NULL,
		   NULL,
           '1/1/1900',
		   0
    FROM   inserted,
           DATABASES_2_COLLECT DTC
		   WHERE NOT EXISTS (SELECT 'X' FROM DYNPERF_TASK_HISTORY DTH WHERE DTH.LINKEDSERVER_NAME = ISNULL(DTC.LINKED_SERVER, @@SERVERNAME) AND DTH.DATABASE_NAME = DTC.DATABASE_NAME)
			AND SERVER_LEVEL_TASK <> 1

				--REH For server level tasks, insert only 1 record for the Server with a DBname of N/A, this is so that we only do this task once especially in SP_PROCESS_STATS

	INSERT DYNPERF_TASK_HISTORY
    SELECT DISTINCT ISNULL(DTC.LINKED_SERVER, @@SERVERNAME),
           'N/A',
           inserted.TASK_ID,
		   NULL,
		   NULL,
		   NULL,
           '1/1/1900',
		   0
    FROM   inserted,
           DATABASES_2_COLLECT DTC
		   WHERE NOT EXISTS (SELECT 'X' FROM DYNPERF_TASK_HISTORY DTH WHERE DTH.LINKEDSERVER_NAME = ISNULL(DTC.LINKED_SERVER, @@SERVERNAME) AND DTH.DATABASE_NAME = 'N/A')
			AND SERVER_LEVEL_TASK = 1
GO
PRINT N'Creating [dbo].[FN_RETURN_AXSESSION_FROM_CONTEXT]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO




CREATE FUNCTION [dbo].[FN_RETURN_AXSESSION_FROM_CONTEXT] (@CONTEXT_INFO AS VARBINARY(128))
RETURNS NVARCHAR(8)
WITH EXECUTE AS CALLER
AS
	BEGIN
		DECLARE	@CONTEXT_INFO_CHAR	VARCHAR(128),
						@AXSESSION					NVARCHAR(8),
						@SESSION_START_POS	INT			

		SET @CONTEXT_INFO_CHAR = CAST(@CONTEXT_INFO AS VARCHAR(128))
		SET @CONTEXT_INFO_CHAR = LTRIM(@CONTEXT_INFO_CHAR)
		SET @SESSION_START_POS = CHARINDEX(' ', @CONTEXT_INFO_CHAR,1)+1

		IF @SESSION_START_POS > 1
			SET @AXSESSION = SUBSTRING(@CONTEXT_INFO_CHAR, @SESSION_START_POS, (CHARINDEX(' ', @CONTEXT_INFO_CHAR,@SESSION_START_POS)-(@SESSION_START_POS)))
		ELSE 
			SET @AXSESSION = 'N\A'

    RETURN ( @AXSESSION );
  END
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[FN_RETURN_AXID_FROM_CONTEXT]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO




CREATE FUNCTION [dbo].[FN_RETURN_AXID_FROM_CONTEXT] (@CONTEXT_INFO AS VARBINARY(128))
RETURNS NVARCHAR(8)
WITH EXECUTE AS CALLER
AS
	BEGIN
		DECLARE	@CONTEXT_INFO_CHAR	VARCHAR(128),
						@AXID								NVARCHAR(8)
		SET @CONTEXT_INFO_CHAR = CAST(@CONTEXT_INFO AS VARCHAR(128))
		SET @CONTEXT_INFO_CHAR = LTRIM(@CONTEXT_INFO_CHAR)

		IF CHARINDEX(' ', @CONTEXT_INFO_CHAR,1) > 1
			SET @AXID = SUBSTRING(@CONTEXT_INFO_CHAR, 1, (CHARINDEX(' ', @CONTEXT_INFO_CHAR,1)-1))
		ELSE
			SET @AXID='N\A'

      RETURN ( @AXID );
  END
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[Fn_getDBName]...';


GO


CREATE FUNCTION [dbo].[Fn_getDBName] (@DBID smallint)
RETURNS sysname
WITH EXECUTE AS CALLER
AS
BEGIN
return (select top 1 DATABASE_NAME from SQL_DATABASES where  DATABASE_ID = @DBID)
END;
GO
PRINT N'Creating [dbo].[FN_HASH_FROM_UINT64_TO_BINARY]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE FUNCTION [dbo].[FN_HASH_FROM_UINT64_TO_BINARY](@QUERY_PLAN_HASH DECIMAL(38,0))
RETURNS BINARY(8)
WITH EXECUTE AS CALLER
AS
	BEGIN
		DECLARE	@NEW_QUERY_PLAN_HASH BINARY(8),
				@BITMASK BIGINT

		SET @BITMASK = 0x8000000000000000
		IF @QUERY_PLAN_HASH < CONVERT(DECIMAL(38,0),@BITMASK)*-1
			SET @NEW_QUERY_PLAN_HASH = CONVERT(BINARY(8),CONVERT(BIGINT,@QUERY_PLAN_HASH))
		ELSE 
			SET @NEW_QUERY_PLAN_HASH = CONVERT(BINARY(8),CONVERT(BIGINT,@QUERY_PLAN_HASH - CONVERT(DECIMAL(38,0),@BITMASK)*-1)|@BITMASK)

		RETURN (@NEW_QUERY_PLAN_HASH);
	END
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[BUFFER_DETAIL_CURR_VW]...';


GO


CREATE VIEW [dbo].[BUFFER_DETAIL_CURR_VW]
AS

WITH MAX_STATS_CTE (RN,SERVER_NAME, STATS_TIME)
AS
(
SELECT * 
FROM   (SELECT TOP 100 PERCENT RN = ROW_NUMBER()
                                      OVER (
                                        PARTITION BY SERVER_NAME
                                        ORDER BY  SERVER_NAME,STATS_TIME DESC),
                               B.SERVER_NAME,
                               B.STATS_TIME
        FROM   BUFFER_DETAIL B
        GROUP  BY B.SERVER_NAME,
				  B.STATS_TIME 
        ORDER  BY B.STATS_TIME DESC,
                  B.SERVER_NAME) RH
WHERE  RN = 1 

)
	  SELECT  BD.SERVER_NAME,
      BD.STATS_TIME,
       DATABASE_NAME,
       0 AS PAGES,
       SIZE_MB
	   FROM BUFFER_DETAIL BD        
	   INNER JOIN MAX_STATS_CTE CTE
               ON CTE.SERVER_NAME = BD.SERVER_NAME
                  AND CTE.STATS_TIME = BD.STATS_TIME
GO
PRINT N'Creating [dbo].[INDEX_STATS_CURR_VW]...';


GO


CREATE VIEW [dbo].[INDEX_STATS_CURR_VW]
AS


WITH MAX_STATS_CTE (SERVER_NAME, DATABASE_NAME, STATS_TIME)
AS
(
SELECT SERVER_NAME,
       DATABASE_NAME,
       MAX(STATS_TIME)
FROM   INDEX_DETAIL
GROUP  BY SERVER_NAME,
          DATABASE_NAME 
)

SELECT D.SERVER_NAME,
       S.SQL_SERVER_STARTTIME,
       D.DATABASE_NAME,
       D.TABLE_NAME,
       D.INDEX_NAME,
       INDEX_DESCRIPTION,
       D.DATA_COMPRESSION,
       INDEX_KEYS,
       INCLUDED_COLUMNS,
       USER_SEEKS,
       USER_SCANS,
       USER_LOOKUPS,
       USER_UPDATES,
       RANGE_SCAN_COUNT,
       PAGE_COUNT,
       ROW_COUNT,
       SINGLETON_LOOKUP_COUNT,
       FORWARDED_FETCH_COUNT,
       INDEX_DEPTH,
       AVG_FRAGMENTATION_IN_PERCENT,
       FRAGMENT_COUNT,
       ROW_LOCK_WAIT_IN_MS,
       PAGE_LOCK_WAIT_IN_MS,
       INDEX_LOCK_PROMOTION_ATTEMPT_COUNT,
       INDEX_LOCK_PROMOTION_COUNT,
       PAGE_LATCH_WAIT_IN_MS,
       PAGE_IO_LATCH_WAIT_IN_MS,
       LEAF_INSERT_COUNT,
       LEAF_DELETE_COUNT,
       LEAF_UPDATE_COUNT,
       LEAF_GHOST_COUNT,
       NONLEAF_INSERT_COUNT,
       NONLEAF_DELETE_COUNT,
       NONLEAF_UPDATE_COUNT,
       LEAF_ALLOCATION_COUNT,
       NONLEAF_ALLOCATION_COUNT,
       LEAF_PAGE_MERGE_COUNT,
       NONLEAF_PAGE_MERGE_COUNT,
       LOB_FETCH_IN_PAGES,
       LOB_FETCH_IN_BYTES,
       LOB_ORPHAN_CREATE_COUNT,
       LOB_ORPHAN_INSERT_COUNT,
       ROW_OVERFLOW_FETCH_IN_PAGES,
       ROW_OVERFLOW_FETCH_IN_BYTES,
       COLUMN_VALUE_PUSH_OFF_ROW_COUNT,
       COLUMN_VALUE_PULL_IN_ROW_COUNT,
       ROW_LOCK_COUNT,
       ROW_LOCK_WAIT_COUNT,
       PAGE_LOCK_COUNT,
       PAGE_LOCK_WAIT_COUNT,
       PAGE_LATCH_WAIT_COUNT,
       PAGE_IO_LATCH_WAIT_COUNT,
       D.STATS_TIME, 
	   D.INDEX_ID
FROM   MAX_STATS_CTE CTE WITH (NOLOCK)
       JOIN INDEX_DETAIL D WITH (NOLOCK)
         ON CTE.STATS_TIME = D.STATS_TIME
            AND CTE.DATABASE_NAME = D.DATABASE_NAME
            AND CTE.SERVER_NAME = D.SERVER_NAME
       JOIN STATS_COLLECTION_SUMMARY S
         ON S.SERVER_NAME = D.SERVER_NAME
            AND S.STATS_TIME = D.STATS_TIME
            AND S.DATABASE_NAME = D.DATABASE_NAME
       LEFT JOIN INDEX_USAGE_STATS U WITH (NOLOCK)
              ON U.SERVER_NAME = D.SERVER_NAME
                 AND U.STATS_TIME = D.STATS_TIME
                 AND U.DATABASE_NAME = D.DATABASE_NAME
                 AND U.OBJECT_ID = D.OBJECT_ID
                 AND U.INDEX_ID = D.INDEX_ID
       LEFT JOIN INDEX_PHYSICAL_STATS P WITH (NOLOCK)
              ON D.SERVER_NAME = P.SERVER_NAME
                 AND D.STATS_TIME = P.STATS_TIME
                 AND D.DATABASE_NAME = P.DATABASE_NAME
                 AND D.OBJECT_ID = P.OBJECT_ID
                 AND D.INDEX_ID = P.INDEX_ID
       LEFT JOIN INDEX_OPERATIONAL_STATS O WITH (NOLOCK)
              ON D.SERVER_NAME = O.SERVER_NAME
                 AND D.STATS_TIME = O.STATS_TIME
                 AND D.DATABASE_NAME = O.DATABASE_NAME
                 AND D.OBJECT_ID = O.OBJECT_ID
                 AND D.INDEX_ID = O.INDEX_ID
GO
PRINT N'Creating [dbo].[INDEX_STATS_VW]...';


GO


CREATE VIEW [dbo].[INDEX_STATS_VW]
AS



SELECT D.SERVER_NAME,
       S.SQL_SERVER_STARTTIME,
       D.DATABASE_NAME,
       D.TABLE_NAME,
       D.INDEX_NAME,
       INDEX_DESCRIPTION,
       D.DATA_COMPRESSION,
       INDEX_KEYS,
       INCLUDED_COLUMNS,
       USER_SEEKS,
       USER_SCANS,
       USER_LOOKUPS,
       USER_UPDATES,
       RANGE_SCAN_COUNT,
       PAGE_COUNT,
       ROW_COUNT,
       SINGLETON_LOOKUP_COUNT,
       FORWARDED_FETCH_COUNT,
       INDEX_DEPTH,
       AVG_FRAGMENTATION_IN_PERCENT,
       FRAGMENT_COUNT,
       ROW_LOCK_WAIT_IN_MS,
       PAGE_LOCK_WAIT_IN_MS,
       INDEX_LOCK_PROMOTION_ATTEMPT_COUNT,
       INDEX_LOCK_PROMOTION_COUNT,
       PAGE_LATCH_WAIT_IN_MS,
       PAGE_IO_LATCH_WAIT_IN_MS,
       LEAF_INSERT_COUNT,
       LEAF_DELETE_COUNT,
       LEAF_UPDATE_COUNT,
       LEAF_GHOST_COUNT,
       NONLEAF_INSERT_COUNT,
       NONLEAF_DELETE_COUNT,
       NONLEAF_UPDATE_COUNT,
       LEAF_ALLOCATION_COUNT,
       NONLEAF_ALLOCATION_COUNT,
       LEAF_PAGE_MERGE_COUNT,
       NONLEAF_PAGE_MERGE_COUNT,
       LOB_FETCH_IN_PAGES,
       LOB_FETCH_IN_BYTES,
       LOB_ORPHAN_CREATE_COUNT,
       LOB_ORPHAN_INSERT_COUNT,
       ROW_OVERFLOW_FETCH_IN_PAGES,
       ROW_OVERFLOW_FETCH_IN_BYTES,
       COLUMN_VALUE_PUSH_OFF_ROW_COUNT,
       COLUMN_VALUE_PULL_IN_ROW_COUNT,
       ROW_LOCK_COUNT,
       ROW_LOCK_WAIT_COUNT,
       PAGE_LOCK_COUNT,
       PAGE_LOCK_WAIT_COUNT,
       PAGE_LATCH_WAIT_COUNT,
       PAGE_IO_LATCH_WAIT_COUNT,
       D.STATS_TIME,
	   D.INDEX_ID
FROM   INDEX_DETAIL D WITH (NOLOCK)
       JOIN STATS_COLLECTION_SUMMARY S
         ON S.SERVER_NAME = D.SERVER_NAME
            AND S.STATS_TIME = D.STATS_TIME
            AND S.DATABASE_NAME = D.DATABASE_NAME
       LEFT JOIN INDEX_USAGE_STATS U WITH (NOLOCK)
              ON U.SERVER_NAME = D.SERVER_NAME
                 AND U.STATS_TIME = D.STATS_TIME
                 AND U.DATABASE_NAME = D.DATABASE_NAME
                 AND U.OBJECT_ID = D.OBJECT_ID
                 AND U.INDEX_ID = D.INDEX_ID
       LEFT JOIN INDEX_PHYSICAL_STATS P WITH (NOLOCK)
              ON D.SERVER_NAME = P.SERVER_NAME
                 AND D.STATS_TIME = P.STATS_TIME
                 AND D.DATABASE_NAME = P.DATABASE_NAME
                 AND D.OBJECT_ID = P.OBJECT_ID
                 AND D.INDEX_ID = P.INDEX_ID
       LEFT JOIN INDEX_OPERATIONAL_STATS O WITH (NOLOCK)
              ON D.SERVER_NAME = O.SERVER_NAME
                 AND D.STATS_TIME = O.STATS_TIME
                 AND D.DATABASE_NAME = O.DATABASE_NAME
                 AND D.OBJECT_ID = O.OBJECT_ID
                 AND D.INDEX_ID = O.INDEX_ID
GO
PRINT N'Creating [dbo].[SQL_CONFIGURATION_CURR_VW]...';


GO



CREATE VIEW [dbo].[SQL_CONFIGURATION_CURR_VW]
AS



WITH MAX_STATS_CTE (SERVER_NAME, STATS_TIME)
AS
(
SELECT SERVER_NAME,
       max(STATS_TIME)
FROM   SQL_CONFIGURATION
GROUP  BY SERVER_NAME 

)

SELECT DISTINCT C.[SERVER_NAME],
                C.[STATS_TIME],
                S.SQL_SERVER_STARTTIME,
                [NAME],
                [MINIMUM],
                [MAXIMUM],
                [CONFIG_VALUE],
                [RUN_VALUE]
FROM   [dbo].[SQL_CONFIGURATION] C
       INNER JOIN MAX_STATS_CTE CTE
               ON CTE.SERVER_NAME = C.SERVER_NAME
                  AND CTE.STATS_TIME = C.STATS_TIME
       CROSS APPLY (SELECT TOP 1 SQL_SERVER_STARTTIME
                    FROM   STATS_COLLECTION_SUMMARY SCS
                    WHERE  SCS.SERVER_NAME = C.SERVER_NAME
                           AND SCS.STATS_TIME = C.STATS_TIME) AS S
GO
PRINT N'Creating [dbo].[SQL_CONFIGURATION_VW]...';


GO

CREATE VIEW [dbo].[SQL_CONFIGURATION_VW]
AS



SELECT DISTINCT [SERVER_NAME],
                [STATS_TIME],
                S.SQL_SERVER_STARTTIME,
                [NAME],
                [MINIMUM],
                [MAXIMUM],
                [CONFIG_VALUE],
                [RUN_VALUE]
FROM   [dbo].[SQL_CONFIGURATION] C
       CROSS APPLY (SELECT TOP 1 SQL_SERVER_STARTTIME
                    FROM   STATS_COLLECTION_SUMMARY SCS
                    WHERE  SCS.SERVER_NAME = C.SERVER_NAME
                           AND SCS.STATS_TIME = C.STATS_TIME) AS S
GO
PRINT N'Creating [dbo].[SQL_DATABASEFILES_CURR_VW]...';


GO



CREATE VIEW [dbo].[SQL_DATABASEFILES_CURR_VW]
AS


WITH MAX_STATS_CTE (SERVER_NAME, STATS_TIME)
AS
(
SELECT SERVER_NAME,
       max(STATS_TIME)
FROM   SQL_DATABASEFILES
GROUP  BY SERVER_NAME 

)



SELECT DISTINCT C.[SERVER_NAME],
                C.[DATABASE_NAME],
                [FILE_NAME],
                [PHYSICAL_NAME],
                [FILE_TYPE],
                [DB_SIZE(MB)],
                [DB_INITAL_SIZE(MB)],
                [DB_FREE(MB)],
                [FREE_SPACE_%],
                [GROWTH_UNITS],
                [GROW_MAX_SIZE(MB)],
                C.[STATS_TIME]
FROM   [dbo].[SQL_DATABASEFILES] C
       INNER JOIN MAX_STATS_CTE CTE
               ON CTE.SERVER_NAME = C.SERVER_NAME
                  AND CTE.STATS_TIME = C.STATS_TIME
GO
PRINT N'Creating [dbo].[SQL_DATABASEFILES_VW]...';


GO



CREATE VIEW [dbo].[SQL_DATABASEFILES_VW]
AS



SELECT DISTINCT C.[SERVER_NAME],
                C.[DATABASE_NAME],
                [FILE_NAME],
                [PHYSICAL_NAME],
                [FILE_TYPE],
                [DB_SIZE(MB)],
                [DB_INITAL_SIZE(MB)],
                [DB_FREE(MB)],
                [FREE_SPACE_%],
                [GROWTH_UNITS],
                [GROW_MAX_SIZE(MB)],
                [STATS_TIME]
FROM   [dbo].[SQL_DATABASEFILES] C
GO
PRINT N'Creating [dbo].[SQL_JOBS_CURR_VW]...';


GO

CREATE VIEW [dbo].[SQL_JOBS_CURR_VW]
AS


WITH MAX_STATS_CTE (SERVER_NAME, STATS_TIME)
AS
(
SELECT SERVER_NAME,
       max(STATS_TIME)
FROM   SQL_JOBS
GROUP  BY SERVER_NAME 

)


  SELECT DISTINCT C.[SERVER_NAME],
         [JOBNAME],
         [SCHEDULENAME],
         [FREQUENCY],
         [SUBFREQUENCY],
         [SCHEDULETIME],
         [NEXTRUNDATE],
         [STEP_ID],
         [STEP_NAME],
         [SUBSYSTEM],
         [COMMAND],
         C.[STATS_TIME]
  FROM   [dbo].[SQL_JOBS] C
            INNER JOIN MAX_STATS_CTE CTE
               ON CTE.SERVER_NAME = C.SERVER_NAME
                  AND CTE.STATS_TIME = C.STATS_TIME
GO
PRINT N'Creating [dbo].[SQL_JOBS_VW]...';


GO


CREATE VIEW [dbo].[SQL_JOBS_VW]
AS




  SELECT DISTINCT [SERVER_NAME],
         [JOBNAME],
         [SCHEDULENAME],
         [FREQUENCY],
         [SUBFREQUENCY],
         [SCHEDULETIME],
         [NEXTRUNDATE],
         [STEP_ID],
         [STEP_NAME],
         [SUBSYSTEM],
         [COMMAND],
         [STATS_TIME]
  FROM   [dbo].[SQL_JOBS] C
GO
PRINT N'Creating [dbo].[SQL_DATABASES_CURR_VW]...';


GO


CREATE VIEW [dbo].[SQL_DATABASES_CURR_VW]
AS


WITH MAX_STATS_CTE (SERVER_NAME, STATS_TIME)
AS
(
SELECT SERVER_NAME,
       max(STATS_TIME)
FROM   SQL_DATABASES
GROUP  BY SERVER_NAME 

)



  SELECT DISTINCT C.[SERVER_NAME],
         C.[DATABASE_NAME],
         [DATABASE_ID],
         [RECOVERY_MODEL_DESC],
         [IS_READ_COMMITTED_SNAPSHOT_ON],
         [CREATE_DATE],
         [COMPATIBILITY_LEVEL],
         [COLLATION_NAME],
         [IS_READ_ONLY],
         [IS_AUTO_CLOSE_ON],
         [IS_AUTO_SHRINK_ON],
         [STATE],
         [STATE_DESC],
         [IS_IN_STANDBY],
         [IS_CLEANLY_SHUTDOWN],
         [IS_SUPPLEMENTAL_LOGGING_ENABLED],
         [SNAPSHOT_ISOLATION_STATE],
         [SNAPSHOT_ISOLATION_STATE_DESC],
         [USER_ACCESS],
         [USER_ACCESS_DESC],
         [SOURCE_DATABASE_ID],
         [OWNER_SID],
         [RECOVERY_MODEL],
         [PAGE_VERIFY_OPTION],
         [PAGE_VERIFY_OPTION_DESC],
         [IS_AUTO_CREATE_STATS_ON],
         [IS_AUTO_UPDATE_STATS_ON],
         [IS_AUTO_UPDATE_STATS_ASYNC_ON],
         [IS_ANSI_NULL_DEFAULT_ON],
         [IS_ANSI_NULLS_ON],
         [IS_ANSI_PADDING_ON],
         [IS_ANSI_WARNINGS_ON],
         [IS_ARITHABORT_ON],
         [IS_CONCAT_NULL_YIELDS_NULL_ON],
         [IS_NUMERIC_ROUNDABORT_ON],
         [IS_QUOTED_IDENTIFIER_ON],
         [IS_RECURSIVE_TRIGGERS_ON],
         [IS_CURSOR_CLOSE_ON_COMMIT_ON],
         [IS_LOCAL_CURSOR_DEFAULT],
         [IS_FULLTEXT_ENABLED],
         [IS_TRUSTWORTHY_ON],
         [IS_DB_CHAINING_ON],
         [IS_PARAMETERIZATION_FORCED],
         [IS_MASTER_KEY_ENCRYPTED_BY_SERVER],
         [IS_PUBLISHED],
         [IS_SUBSCRIBED],
         [IS_MERGE_PUBLISHED],
         [IS_DISTRIBUTOR],
         [IS_SYNC_WITH_BACKUP],
         [SERVICE_BROKER_GUID],
         [IS_BROKER_ENABLED],
         [LOG_REUSE_WAIT],
         [LOG_REUSE_WAIT_DESC],
         [IS_DATE_CORRELATION_ON],
         C.[STATS_TIME]
  FROM   [dbo].[SQL_DATABASES] C
            INNER JOIN MAX_STATS_CTE CTE
               ON CTE.SERVER_NAME = C.SERVER_NAME
                  AND CTE.STATS_TIME = C.STATS_TIME
GO
PRINT N'Creating [dbo].[SQL_DATABASES_VW]...';


GO


CREATE VIEW [dbo].[SQL_DATABASES_VW]
AS


  SELECT DISTINCT [SERVER_NAME],
         C.[DATABASE_NAME],
         [DATABASE_ID],
         [RECOVERY_MODEL_DESC],
         [IS_READ_COMMITTED_SNAPSHOT_ON],
         [CREATE_DATE],
         [COMPATIBILITY_LEVEL],
         [COLLATION_NAME],
         [IS_READ_ONLY],
         [IS_AUTO_CLOSE_ON],
         [IS_AUTO_SHRINK_ON],
         [STATE],
         [STATE_DESC],
         [IS_IN_STANDBY],
         [IS_CLEANLY_SHUTDOWN],
         [IS_SUPPLEMENTAL_LOGGING_ENABLED],
         [SNAPSHOT_ISOLATION_STATE],
         [SNAPSHOT_ISOLATION_STATE_DESC],
         [USER_ACCESS],
         [USER_ACCESS_DESC],
         [SOURCE_DATABASE_ID],
         [OWNER_SID],
         [RECOVERY_MODEL],
         [PAGE_VERIFY_OPTION],
         [PAGE_VERIFY_OPTION_DESC],
         [IS_AUTO_CREATE_STATS_ON],
         [IS_AUTO_UPDATE_STATS_ON],
         [IS_AUTO_UPDATE_STATS_ASYNC_ON],
         [IS_ANSI_NULL_DEFAULT_ON],
         [IS_ANSI_NULLS_ON],
         [IS_ANSI_PADDING_ON],
         [IS_ANSI_WARNINGS_ON],
         [IS_ARITHABORT_ON],
         [IS_CONCAT_NULL_YIELDS_NULL_ON],
         [IS_NUMERIC_ROUNDABORT_ON],
         [IS_QUOTED_IDENTIFIER_ON],
         [IS_RECURSIVE_TRIGGERS_ON],
         [IS_CURSOR_CLOSE_ON_COMMIT_ON],
         [IS_LOCAL_CURSOR_DEFAULT],
         [IS_FULLTEXT_ENABLED],
         [IS_TRUSTWORTHY_ON],
         [IS_DB_CHAINING_ON],
         [IS_PARAMETERIZATION_FORCED],
         [IS_MASTER_KEY_ENCRYPTED_BY_SERVER],
         [IS_PUBLISHED],
         [IS_SUBSCRIBED],
         [IS_MERGE_PUBLISHED],
         [IS_DISTRIBUTOR],
         [IS_SYNC_WITH_BACKUP],
         [SERVICE_BROKER_GUID],
         [IS_BROKER_ENABLED],
         [LOG_REUSE_WAIT],
         [LOG_REUSE_WAIT_DESC],
         [IS_DATE_CORRELATION_ON],
         [STATS_TIME]
  FROM   [dbo].[SQL_DATABASES] C
GO
PRINT N'Creating [dbo].[DISKSTATS_CURR_VW]...';


GO


CREATE VIEW [dbo].[DISKSTATS_CURR_VW]
AS


WITH MAX_STATS_CTE (SERVER_NAME, STATS_TIME)
AS
(
SELECT SERVER_NAME,
       max(STATS_TIME)
FROM   DISKSTATS
GROUP  BY SERVER_NAME,
          DATABASE_NAME 

)


SELECT D.*
FROM   DISKSTATS D
       INNER JOIN MAX_STATS_CTE CTE
               ON CTE.SERVER_NAME = D.SERVER_NAME
                  AND CTE.STATS_TIME = D.STATS_TIME
GO
PRINT N'Creating [dbo].[DISKSTATS_VW]...';


GO



CREATE VIEW [dbo].[DISKSTATS_VW]
AS
SELECT D.*
FROM   DISKSTATS D
GO
PRINT N'Creating [dbo].[DEFAULT_TRC_VW]...';


GO


CREATE VIEW [dbo].[DEFAULT_TRC_VW] AS
SELECT E.name, F.*
	FROM fn_trace_gettable(
	ISNULL(
	(SELECT TRACE_FULL_PATH_NAME FROM DYNAMICSPERF_SETUP)
	,(SELECT TOP 1 path FROM sys.traces WHERE path like '%DYNAMICS_DEFAULT%'))
	, default) F,
      sys.trace_events E
      WHERE EventClass = trace_event_id
GO
PRINT N'Creating [dbo].[BLOCKED_PROCESS_VW]...';


GO

CREATE VIEW [dbo].[BLOCKED_PROCESS_VW]
AS
 SELECT
END_TIME,
BLOCKED_SQL,
BLOCKED_SPID,
[WAIT_TIME(MS)],
WAIT_RESOURCE,
LOCK_MODE_REQUESTED,
BLOCKED_TRANS_COUNT,
BLOCKED_CLIENT_APP,
BLOCKED_HOST_NAME,
BLOCKED_ISOLATION_LEVEL,
BLOCKING_SQL,
BLOCKING_SPID,
BLOCKING_SPID_STATUS,
BLOCKING_TRANS_COUNT,
BLOCKING_LAST_BATCH_STARTED,
BLOCKING_LAST_BATCH_COMPLETED,
BLOCKING_CLIENT_APP,
BLOCKING_HOST_NAME,
BLOCKING_ISOLATION_LEVEL,
ObjectID


 FROM 
(
	SELECT	
	CONVERT(DATETIME, F.EndTime) AS END_TIME,
	convert(xml, TextData).value('(blocked-process-report/blocked-process/process/@spid)[1]','INT')						AS BLOCKED_SPID,
	convert(xml, TextData).value('(blocked-process-report/blocked-process/process/inputbuf)[1]','nvarchar(max)')		AS BLOCKED_SQL,
	convert(xml, TextData).value('(blocked-process-report/blocked-process/process/@waittime)[1]','INT')					AS [WAIT_TIME(MS)],
	convert(xml, TextData).value('(blocked-process-report/blocked-process/process/@waitresource)[1]','nvarchar(50)')	AS WAIT_RESOURCE,
	convert(xml, TextData).value('(blocked-process-report/blocked-process/process/@lockMode)[1]','nvarchar(50)')		AS LOCK_MODE_REQUESTED,
	convert(xml, TextData).value('(blocked-process-report/blocked-process/process/@transcount)[1]','INT')				AS BLOCKED_TRANS_COUNT,
	convert(xml, TextData).value('(blocked-process-report/blocked-process/process/@clientapp)[1]','nvarchar(50)')		AS BLOCKED_CLIENT_APP,
	convert(xml, TextData).value('(blocked-process-report/blocked-process/process/@hostname)[1]','nvarchar(50)')		AS BLOCKED_HOST_NAME,
	convert(xml, TextData).value('(blocked-process-report/blocked-process/process/@isolationlevel)[1]','nvarchar(50)')	AS BLOCKED_ISOLATION_LEVEL,
	convert(xml, TextData).value('(blocked-process-report/blocked-process/process/executionStack/frame/@SQLhandle)[1]','NVARCHAR(64)') as BLOCKED_SQL_HANDLE,
	convert(xml, TextData).value('(blocked-process-report/blocking-process/process/@spid)[1]','INT')					AS BLOCKING_SPID,
	convert(xml, TextData).value('(blocked-process-report/blocking-process/process/inputbuf)[1]','nvarchar(max)')		AS BLOCKING_SQL,
	convert(xml, TextData).value('(blocked-process-report/blocking-process/process/@status)[1]','NVARCHAR(10)')			AS BLOCKING_SPID_STATUS,
	convert(xml, TextData).value('(blocked-process-report/blocking-process/process/@transcount)[1]','INT')				AS BLOCKING_TRANS_COUNT,
	convert(xml, TextData).value('(blocked-process-report/blocking-process/process/@lastbatchstarted)[1]','DATETIME')	AS BLOCKING_LAST_BATCH_STARTED,
	convert(xml, TextData).value('(blocked-process-report/blocking-process/process/@lastbatchcompleted)[1]','DATETIME') AS BLOCKING_LAST_BATCH_COMPLETED,
	convert(xml, TextData).value('(blocked-process-report/blocking-process/process/@clientapp)[1]','nvarchar(50)')		AS BLOCKING_CLIENT_APP,
	convert(xml, TextData).value('(blocked-process-report/blocking-process/process/@hostname)[1]','nvarchar(50)')		AS BLOCKING_HOST_NAME,
	convert(xml, TextData).value('(blocked-process-report/blocking-process/process/@isolationlevel)[1]','nvarchar(50)') AS BLOCKING_ISOLATION_LEVEL,
	convert(xml, TextData).value('(blocked-process-report/blocking-process/process/executionStack/frame/@SQLhandle)[1]','NVARCHAR(64)') as BLOCKING_SQL_HANDLE,
	ObjectID
	FROM fn_trace_gettable(
	ISNULL(
	(SELECT TRACE_FULL_PATH_NAME FROM DYNAMICSPERF_SETUP)
	,(SELECT TOP 1 path FROM sys.traces WHERE path like '%DYNAMICS_DEFAULT%'))
	, default) as F,
	sys.trace_events as E
	WHERE EventClass = trace_event_id
	and name = 'Blocked process report'
)	AS Trace
GO
PRINT N'Creating [dbo].[HIDDEN_SCANS_VW]...';


GO

CREATE VIEW [dbo].[HIDDEN_SCANS_VW] AS

select getdate() as [date]

/*
WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT *
FROM   (SELECT SERVER_NAME,
               ROW_NUM,
               SQL_TEXT,
               CONVERT (NVARCHAR(MAX), index_node2.query('for $qplan in //sp:QueryPlan, $plist in $qplan/sp:ParameterList, $colref in $plist/sp:ColumnReference  return concat(string($colref/@Column),":",string($colref/@ParameterCompiledValue),",   "),"  "')) AS QUERY_PARAMETER_VALUES,
               QUERY_PLAN,
               Replace(Replace(index_node.value('(.//@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                                                                                                                                                             AS TABLE_NAME,
               Replace(Replace(index_node.value('(.//@Index)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                                                                                                                                                             AS INDEX_NAME,
               CONVERT(NVARCHAR(MAX), index_node.query('for $seekpredicate in ./sp:SeekPredicates,
                                                            $rangecolumns in $seekpredicate//sp:RangeColumns,
                                                            $columnreference in $rangecolumns/sp:ColumnReference
                                        return string($columnreference/@Column)'))                                                                                                                                                                  AS SEEK_COLUMNS,
               EXECUTION_COUNT,
               TOTAL_ELAPSED_TIME,
               TOTAL_WORKER_TIME,
               AVG_ELAPSED_TIME,
               AVG_PHYSICAL_READS,
               AVG_LOGICAL_READS,
               AVG_LOGICAL_WRITES,
               LAST_ELAPSED_TIME,
               MIN_ELAPSED_TIME,
               MAX_ELAPSED_TIME,
               TOTAL_PHYSICAL_READS,
               LAST_PHYSICAL_READS,
               MIN_PHYSICAL_READS,
               MAX_PHYSICAL_READS,
               TOTAL_LOGICAL_READS,
               LAST_LOGICAL_READS,
               MIN_LOGICAL_READS,
               MAX_LOGICAL_READS,
               TOTAL_LOGICAL_WRITES,
               LAST_LOGICAL_WRITES,
               MIN_LOGICAL_WRITES,
               MAX_LOGICAL_WRITES,
               LAST_WORKER_TIME,
               MIN_WORKER_TIME,
               MAX_WORKER_TIME,
               QUERY_PLAN_TEXT,
               STATS_TIME,
               SQL_VERSION,
               COMMENT
        FROM   QUERY_STATS_VW
               OUTER APPLY QUERY_PLAN.nodes('//sp:RelOp/sp:IndexScan') AS SeekPredicates(index_node)
               CROSS APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node2)) A
		WHERE  SEEK_COLUMNS = 'DATAAREAID' OR SEEK_COLUMNS = 'PARTITION DATAAREAID' OR SEEK_COLUMNS = 'PARTITION'
 





 */
GO
PRINT N'Creating [dbo].[AX_BATCHJOB_CONFIGURATION_VW]...';


GO


CREATE VIEW [dbo].[AX_BATCHJOB_CONFIGURATION_VW]
AS 

SELECT  [SERVER_NAME]
      ,[STATS_TIME]
      ,[DATABASE_NAME]
      ,[JOB_STATUS]
      ,[CAPTION]
      ,[COMPANY]
	  ,[BATCH_GROUPID]
      ,[LOG_LEVEL]
      ,[SCHED_START_DATETIME]
      ,[ACTUAL_START_DATETIME]
      ,[END_DATETIME]
      ,[DATA_PARTITION]
      ,[RECUR_TIMEZONE]
      ,[RECUR_RANGE_STARTDATETIME]
      ,[RECUR_RANGE_UNIT]
      ,[RECUR_PATTERN_UNIT]
      ,[RECUR_PATTERN_DESC]
      ,[CREATED_DATETIME]
      ,[CREATED_BY]
  FROM [AX_BATCHJOB_DETAIL]
GO
PRINT N'Creating [dbo].[AX_DATABASELOGGING_VW]...';


GO


CREATE VIEW [dbo].[AX_DATABASELOGGING_VW] 
AS

SELECT T.SERVER_NAME,
       T.DATABASE_NAME,
       T.TABLE_NAME,
       H.EQ_ROWS AS ROWS_LOGGED,
       T.DATABASELOG_UPDATE,
       T.DATABASELOG_DELETE,
       T.DATABASELOG_INSERT
FROM   AX_TABLE_DETAIL T
       INNER JOIN INDEX_HISTOGRAM H
               ON T.TABLE_ID = H.RANGE_HI_KEY
                  AND T.SERVER_NAME = H.SERVER_NAME
                  AND T.DATABASE_NAME = H.DATABASE_NAME
                  AND H.COLUMN_NAME = 'TABLE_'
WHERE  H.TABLE_NAME = 'SYSDATABASELOG'
GO
PRINT N'Creating [dbo].[AX_NUM_SEQUENCES_CURR_VW]...';


GO



CREATE VIEW [dbo].[AX_NUM_SEQUENCES_CURR_VW] 
AS


WITH MAX_STATS_CTE (SERVER_NAME, DATABASE_NAME, STATS_TIME)
AS
(
SELECT SERVER_NAME,
       DATABASE_NAME,
       MAX(STATS_TIME)
FROM   AX_NUM_SEQUENCES
GROUP  BY SERVER_NAME,
          DATABASE_NAME 
)
SELECT SQ.[SERVER_NAME],
       SQ.[STATS_TIME],
       SQ.[DATABASE_NAME],
       [RECID],
       [NUMBERSEQUENCE],
       [TEXT],
       [FORMAT],
       [LOWEST],
       [HIGHEST],
       [NEXTREC],
       [PERCENTREMAINING],
       [NUMBERSREMAINING],
       [CONTINUOUS],
       [FETCHAHEAD],
       [FETCHAHEADQTY],
       [CLEANINTERVAL],
       [CLEANATACCESS],
       [PARTITIONNAME],
       [NUMBERSEQUENCESCOPE],
       [COMPANYID],
       [COMPANYNAME],
       [SHARED],
       [LEGALENTITYNAME],
       [OPERATINGUNITTYPE],
       [OPERATINGUNITNUMBER],
       [FISCALCALENDAR],
       [FISCALCALENDARYEAR],
       [PERIOD]
FROM   AX_NUM_SEQUENCES SQ
       INNER JOIN MAX_STATS_CTE CTE
               ON CTE.SERVER_NAME = SQ.SERVER_NAME
                  AND CTE.DATABASE_NAME = SQ.DATABASE_NAME
                  AND CTE.STATS_TIME = SQ.STATS_TIME
GO
PRINT N'Creating [dbo].[AX_NUM_SEQUENCES_VW]...';


GO


CREATE VIEW [dbo].[AX_NUM_SEQUENCES_VW] 
AS
SELECT SQ.[SERVER_NAME],
       SQ.[STATS_TIME],
       SQ.[DATABASE_NAME],
       [RECID],
       [NUMBERSEQUENCE],
       [TEXT],
       [FORMAT],
       [LOWEST],
       [HIGHEST],
       [NEXTREC],
       [PERCENTREMAINING],
       [NUMBERSREMAINING],
       [CONTINUOUS],
       [FETCHAHEAD],
       [FETCHAHEADQTY],
       [CLEANINTERVAL],
       [CLEANATACCESS],
       [PARTITIONNAME],
       [NUMBERSEQUENCESCOPE],
       [COMPANYID],
       [COMPANYNAME],
       [SHARED],
       [LEGALENTITYNAME],
       [OPERATINGUNITTYPE],
       [OPERATINGUNITNUMBER],
       [FISCALCALENDAR],
       [FISCALCALENDARYEAR],
       [PERIOD]
FROM   AX_NUM_SEQUENCES SQ
GO
PRINT N'Creating [dbo].[AX_BATCHSERVER_CONFIGURATION_VW]...';


GO


CREATE VIEW [dbo].[AX_BATCHSERVER_CONFIGURATION_VW] 
as


SELECT  [SERVER_NAME]
      ,[STATS_TIME]
      ,[DATABASE_NAME]
      ,[BATCH_GROUPID]
      ,[BATCH_GROUPDESC]
      ,[BATCH_SERVER_NAME]
      ,[MAX_BATCH_SESSIONS]
      ,[BATCH_SERVER_STARTTIME]
      ,[BATCH_SERVER_ENDTIME]
  FROM [AX_BATCHSERVERGROUP_CONFIG]
GO
PRINT N'Creating [dbo].[AX_SQLTRACE_VW]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO


CREATE VIEW [dbo].[AX_SQLTRACE_VW]
AS

SELECT SERVER_NAME,
       STATS_TIME,
       DATABASE_NAME,
       TRACE_CATEGORY = CASE TRACE_CATEGORY
                          WHEN 0 THEN 'Statement'
                          WHEN 1 THEN 'QueryTime'
                          WHEN 2 THEN 'Error'
                          WHEN 3 THEN 'Synchronize'
                          WHEN 4 THEN 'Deadlock'
                          WHEN 5 THEN 'Warning'
                          ELSE str(TRACE_CATEGORY)
                        END,
       SQL_TYPE = CASE SQL_TYPE
                    WHEN 0 THEN 'UPDATE'
                    WHEN 1 THEN 'DELETE'
                    WHEN 2 THEN 'INSERT'
                    WHEN 3 THEN 'SELECT'
                    WHEN 4 THEN 'DDL'
                    WHEN 5 THEN 'PROC'
                    WHEN 6 THEN 'Other'
                    ELSE str(SQL_TYPE)
                  END,
       SQL_TEXT,
       SQL_DURATION,
       CALL_STACK,
       TRACE_EVENT_CODE,
       TRACE_EVENT_DESC,
       TRACE_EVENT_DETAILS,
       CONNECTION_TYPE,
       SQL_SESSION_ID,
       AX_USER_ID,
       AX_CONNECTION_ID,
       IS_LOBS_INCLUDED,
       IS_MORE_DATA_PENDING,
       ROWS_AFFECTED,
       ROW_SIZE,
       ROWS_PER_FETCH,
       IS_SELECTED_FOR_UPDATE,
       IS_STARTED_WITHIN_TRANSACTION,
       STATEMENT_ID,
       STATEMENT_REUSE_COUNT,
       DETAIL_TYPE,
       CREATED_DATETIME
FROM   AX_SQLTRACE T
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[SERVERINFO_CURR_VW]...';


GO

CREATE VIEW [dbo].[SERVERINFO_CURR_VW]
AS



WITH MAX_STATS_CTE (SERVER_NAME, STATS_TIME)
AS
(
SELECT SERVER_NAME,
       max(STATS_TIME)
FROM   [SERVERINFO]
GROUP  BY SERVER_NAME 

)

SELECT S.[SERVER_NAME],
       S.[STATS_TIME],
       [SQL_SERVER_STARTTIME],
       [PHYSICALCOMPUTERNAME],
       CASE [ISCLUSTERED]
         WHEN 0 THEN 'N0'
         ELSE 'YES'
       END                             AS CLUSTERED_SERVER,
       [MACHINENAME],
       [INSTANCENAME],
       [PRODUCTVERSION],
       [PRODUCTLEVEL],
       [EDITION],
       [ENGINEEDITION],
       [SQLCHARSET],
       [SQLCHARSETNAME],
       [SQLSORTORDER],
       [SQLSORTORDERNAME],
       [SQL_SCHEDULER_COUNT],
       [CPU_COUNT]                     AS TOTAL_CORES,
       [HYPERTHREAD_RATIO]             AS CORES_PER_SOCKET,
       [CPU_COUNT] / HYPERTHREAD_RATIO AS TOTAL_SOCKECTS,
       [BPOOL_COMMITTED_MB],
       [BPOOL_COMMIT_TARGET_MB],
       [BPOOL_VISIBLE_MB]
FROM   [SERVERINFO] S
       INNER JOIN MAX_STATS_CTE CTE
               ON CTE.SERVER_NAME = S.SERVER_NAME
                  AND CTE.STATS_TIME = S.STATS_TIME
GO
PRINT N'Creating [dbo].[SERVERINFO_VW]...';


GO

CREATE VIEW [dbo].[SERVERINFO_VW]
AS

SELECT [SERVER_NAME],
       [STATS_TIME],
       [SQL_SERVER_STARTTIME],
       [PHYSICALCOMPUTERNAME],
       CASE [ISCLUSTERED]
         WHEN 0 THEN 'N0'
         ELSE 'YES'
       END                             AS CLUSTERED_SERVER,
       [MACHINENAME],
       [INSTANCENAME],
       [PRODUCTVERSION],
       [PRODUCTLEVEL],
       [EDITION],
       [ENGINEEDITION],
       [SQLCHARSET],
       [SQLCHARSETNAME],
       [SQLSORTORDER],
       [SQLSORTORDERNAME],
       [SQL_SCHEDULER_COUNT],
       [CPU_COUNT]                     AS TOTAL_CORES,
       [HYPERTHREAD_RATIO]             AS CORES_PER_SOCKET,
       [CPU_COUNT] / HYPERTHREAD_RATIO AS TOTAL_SOCKECTS,
       [BPOOL_COMMITTED_MB],
       [BPOOL_COMMIT_TARGET_MB],
       [BPOOL_VISIBLE_MB]
FROM   [SERVERINFO] S
GO
PRINT N'Creating [dbo].[CURSOR_ACTIVITY_VW]...';


GO

CREATE VIEW [dbo].[CURSOR_ACTIVITY_VW]
AS

SELECT A.updated_time                       AS UPDATED_TIME,
       A.creation_time                      AS CREATION_TIME,
       A.dormant_duration                   AS LAST_RUN_MS,
       A.reads                              AS READS,
       A.writes                             AS WRITES,
       A.hostname                           AS HOSTNAME,
       A.loginame                           AS LOGIN_NAME,
       A.text                               AS SQL_TEXT,
       A.collectiontime                     AS COLLECTION_TIME,
       --SQL_CURSORPLAN.query_plan,
       A.session_id                         AS SQL_SPID,
       A.cursor_id                          AS CURSOR_ID,
       A.name                               AS NAME,
       A.properties                         AS PROPERTIES,
       A.sql_handle                         AS SQL_HANDLE,
       A.statement_start_offset             AS STATEMENT_START_OFFSET,
       A.statement_end_offset               AS STATEMENT_END_OFFSET,
       A.plan_generation_num                AS PLAN_NUMBER,
       A.is_open                            AS OPEN_FLAG,
       A.is_async_population                AS IS_ASYNC_POP_FLAG,
       A.is_close_on_commit                 AS IS_CLOSE_ON_COMMIT_FLAG,
       A.fetch_status                       AS FETCH_STATUS,
       A.fetch_buffer_size                  AS FETCH_BUFFER_SIZE,
       A.fetch_buffer_start                 AS FETCH_BUFFER_START,
       A.ansi_position                      AS ANSI_POSITION,
       A.worker_time                        AS CPU_TIME,
       A.plan_handle                        AS PLAN_HANDLE,
       A.query_hash                         AS QUERY_HASH,
       A.query_plan_hash                    AS QUERY_PLAN_HASH,
       Cast(A.context_info AS VARCHAR(128)) AS CONTEXT_INFO
FROM   (SELECT DISTINCT Sysdatetime() AS updated_time,
                        s1.hostname as hostname,
                        s1.loginame as loginame,
                        s3.text,
                        Getdate()     AS collectiontime,
                        s2.*,
                        SQL_CURSORSTATS.plan_handle,
                        SQL_CURSORSTATS.query_hash,
                        SQL_CURSORSTATS.query_plan_hash,
                        s1.context_info as context_info
        FROM   master.sys.sysprocesses AS s1
               CROSS APPLY sys.dm_exec_cursors(s1.spid) AS s2
               CROSS APPLY sys.dm_exec_sql_text(s2.sql_handle) AS s3
               LEFT JOIN (SELECT DISTINCT QS.plan_handle,
                                          QS.sql_handle,
                                          QS.statement_start_offset,
                                          QS.statement_end_offset,
                                          QS.plan_generation_num,
                                          QS.query_hash,
                                          QS.query_plan_hash
                          FROM   sys.dm_exec_query_stats AS QS) AS SQL_CURSORSTATS
                      ON SQL_CURSORSTATS.sql_handle = s2.sql_handle
                         AND s2.statement_start_offset = SQL_CURSORSTATS.statement_start_offset
                         AND s2.statement_end_offset = SQL_CURSORSTATS.statement_end_offset
        WHERE  SQL_CURSORSTATS.plan_generation_num = s2.plan_generation_num) AS A --This we'll join to the correct plan in cache if more then 1 plan
GO
PRINT N'Creating [dbo].[SERVER_OS_VERSION_VW]...';


GO


CREATE VIEW [dbo].[SERVER_OS_VERSION_VW]
AS


SELECT [SERVER_NAME],
       [WINDOWS_RELEASE],
       [WINDOWS_SERVICE_PACK_LEVEL],
       CASE [WINDOWS_SKU]
         WHEN 1 THEN 'Ultimate'
         WHEN 2 THEN 'Home Basic'
         WHEN 3 THEN 'Home Premium'
         WHEN 4 THEN 'Client Enterprise'
         WHEN 5 THEN 'Home Basic N'
         WHEN 16 THEN 'Business N'
         WHEN 18 THEN 'HPC'
         WHEN 8 THEN 'SERVER DATACENTER(FULL EDITION)'
         WHEN 12 THEN 'SERVER DATACENTER(CORE INSTALL)'
         WHEN 39 THEN 'SERVER DATACENTER W/O Hyper-V(CORE INSTALL)'
         WHEN 37 THEN 'SERVER DATACENTER W/O Hyper-V(FULL INSTALL)'
         WHEN 27 THEN 'Enterprise N'
         WHEN 10 THEN 'Server Enterprise (full installation)'
         WHEN 14 THEN 'Server Enterprise (core installation)'
         WHEN 41 THEN 'Server Enterprise without Hyper-V (core installation) '
         WHEN 15 THEN 'Server Enterprise for Itanium-based Systems'
         WHEN 38 THEN 'Server Enterprise without Hyper-V (full installation)'
         WHEN 26 THEN 'Home Premium N'
         WHEN 42 THEN 'Microsoft Hyper-V Server'
         WHEN 30 THEN 'Windows Essential Business Server Management Server'
         WHEN 32 THEN 'Windows Essential Business Server Messaging Server'
         WHEN 31 THEN 'Windows Essential Business Server Security Server'
         WHEN 48 THEN 'Professional'
         WHEN 49 THEN 'Professional N'
         WHEN 24 THEN 'Windows Server 2008 for Windows Essential Server Solutions'
         WHEN 35 THEN 'Windows Server 2008 without Hyper-V for Windows Essential Server Solutions'
         WHEN 33 THEN 'Server Foundation'
         WHEN 34 THEN 'Windows Home Server 2011'
         WHEN 50 THEN 'Windows Small Business Server 2011 Essentials'
         WHEN 19 THEN 'Windows Storage Server 2008 R2 Essentials'
         WHEN 9 THEN 'Windows Small Business Server'
         WHEN 56 THEN 'Windows MultiPoint Server'
         WHEN 7 THEN 'Server Standard (full installation)'
         WHEN 13 THEN 'Server Standard (core installation)'
         WHEN 40 THEN 'Server Standard without Hyper-V (core installation)'
         WHEN 36 THEN 'Server Standard without Hyper-V (full installation)'
         WHEN 11 THEN 'Starter'
         WHEN 47 THEN 'Starter N'
         WHEN 23 THEN 'Storage Server Enterprise'
         WHEN 20 THEN 'Storage Server Express'
         WHEN 21 THEN 'Storage Server Standard'
         WHEN 22 THEN 'Storage Server Workgroup'
         WHEN 28 THEN 'Ultimate N'
         WHEN 17 THEN 'Web Server (full installation)'
         WHEN 29 THEN 'Web Server (core installation)'
         ELSE 'Unknown'
       END AS [WINDOWS_SKU],
       CASE [OS_LANGUAGE_VERSION]
         WHEN 1078 THEN 'Afrikaans - South Africa'
         WHEN 1052 THEN 'Albanian - Albania'
         WHEN 1156 THEN 'Alsatian'
         WHEN 1118 THEN 'Amharic - Ethiopia'
         WHEN 1025 THEN 'Arabic - Saudi Arabia'
         WHEN 5121 THEN 'Arabic - Algeria'
         WHEN 15361 THEN 'Arabic - Bahrain'
         WHEN 3073 THEN 'Arabic - Egypt'
         WHEN 2049 THEN 'Arabic - Iraq'
         WHEN 11265 THEN 'Arabic - Jordan'
         WHEN 13313 THEN 'Arabic - Kuwait'
         WHEN 12289 THEN 'Arabic - Lebanon'
         WHEN 4097 THEN 'Arabic - Libya'
         WHEN 6145 THEN 'Arabic - Morocco'
         WHEN 8193 THEN 'Arabic - Oman'
         WHEN 16385 THEN 'Arabic - Qatar'
         WHEN 10241 THEN 'Arabic - Syria'
         WHEN 7169 THEN 'Arabic - Tunisia'
         WHEN 14337 THEN 'Arabic - U.A.E.'
         WHEN 9217 THEN 'Arabic - Yemen'
         WHEN 1067 THEN 'Armenian - Armenia'
         WHEN 1101 THEN 'Assamese'
         WHEN 2092 THEN 'Azeri (Cyrillic)'
         WHEN 1068 THEN 'Azeri (Latin)'
         WHEN 1133 THEN 'Bashkir'
         WHEN 1069 THEN 'Basque'
         WHEN 1059 THEN 'Belarusian'
         WHEN 1093 THEN 'Bengali (India)'
         WHEN 2117 THEN 'Bengali (Bangladesh)'
         WHEN 5146 THEN 'Bosnian (Bosnia/Herzegovina)'
         WHEN 1150 THEN 'Breton'
         WHEN 1026 THEN 'Bulgarian'
         WHEN 1109 THEN 'Burmese'
         WHEN 1027 THEN 'Catalan'
         WHEN 1116 THEN 'Cherokee - United States'
         WHEN 2052 THEN 'Chinese - Peoples Republic of China'
         WHEN 4100 THEN 'Chinese - Singapore'
         WHEN 1028 THEN 'Chinese - Taiwan'
         WHEN 3076 THEN 'Chinese - Hong Kong SAR'
         WHEN 5124 THEN 'Chinese - Macao SAR'
         WHEN 1155 THEN 'Corsican'
         WHEN 1050 THEN 'Croatian'
         WHEN 4122 THEN 'Croatian (Bosnia/Herzegovina)'
         WHEN 1029 THEN 'Czech'
         WHEN 1030 THEN 'Danish'
         WHEN 1164 THEN 'Dari'
         WHEN 1125 THEN 'Divehi'
         WHEN 1043 THEN 'Dutch - Netherlands'
         WHEN 2067 THEN 'Dutch - Belgium'
         WHEN 1126 THEN 'Edo'
         WHEN 1033 THEN 'English - United States'
         WHEN 2057 THEN 'English - United Kingdom'
         WHEN 3081 THEN 'English - Australia'
         WHEN 10249 THEN 'English - Belize'
         WHEN 4105 THEN 'English - Canada'
         WHEN 9225 THEN 'English - Caribbean'
         WHEN 15369 THEN 'English - Hong Kong SAR'
         WHEN 16393 THEN 'English - India'
         WHEN 14345 THEN 'English - Indonesia'
         WHEN 6153 THEN 'English - Ireland'
         WHEN 8201 THEN 'English - Jamaica'
         WHEN 17417 THEN 'English - Malaysia'
         WHEN 5129 THEN 'English - New Zealand'
         WHEN 13321 THEN 'English - Philippines'
         WHEN 18441 THEN 'English - Singapore'
         WHEN 7177 THEN 'English - South Africa'
         WHEN 11273 THEN 'English - Trinidad'
         WHEN 12297 THEN 'English - Zimbabwe'
         WHEN 1061 THEN 'Estonian'
         WHEN 1080 THEN 'Faroese'
         WHEN 1065 THEN 'Farsi'
         WHEN 1124 THEN 'Filipino'
         WHEN 1035 THEN 'Finnish'
         WHEN 1036 THEN 'French - France'
         WHEN 2060 THEN 'French - Belgium'
         WHEN 11276 THEN 'French - Cameroon'
         WHEN 3084 THEN 'French - Canada'
         WHEN 9228 THEN 'French - Democratic Rep. of Congo'
         WHEN 12300 THEN 'French - Cote d Ivoire'
         WHEN 15372 THEN 'French - Haiti'
         WHEN 5132 THEN 'French - Luxembourg'
         WHEN 13324 THEN 'French - Mali'
         WHEN 6156 THEN 'French - Monaco'
         WHEN 14348 THEN 'French - Morocco'
         WHEN 58380 THEN 'French - North Africa'
         WHEN 8204 THEN 'French - Reunion'
         WHEN 10252 THEN 'French - Senegal'
         WHEN 4108 THEN 'French - Switzerland'
         WHEN 7180 THEN 'French - West Indies'
         WHEN 1122 THEN 'Frisian - Netherlands'
         WHEN 1127 THEN 'Fulfulde - Nigeria'
         WHEN 1071 THEN 'FYRO Macedonian'
         WHEN 1110 THEN 'Galician'
         WHEN 1079 THEN 'Georgian'
         WHEN 1031 THEN 'German - Germany'
         WHEN 3079 THEN 'German - Austria'
         WHEN 5127 THEN 'German - Liechtenstein'
         WHEN 4103 THEN 'German - Luxembourg'
         WHEN 2055 THEN 'German - Switzerland'
         WHEN 1032 THEN 'Greek'
         WHEN 1135 THEN 'Greenlandic'
         WHEN 1140 THEN 'Guarani - Paraguay'
         WHEN 1095 THEN 'Gujarati'
         WHEN 1128 THEN 'Hausa - Nigeria'
         WHEN 1141 THEN 'Hawaiian - United States'
         WHEN 1037 THEN 'Hebrew'
         WHEN 1081 THEN 'Hindi'
         WHEN 1038 THEN 'Hungarian'
         WHEN 1129 THEN 'Ibibio - Nigeria'
         WHEN 1039 THEN 'Icelandic'
         WHEN 1136 THEN 'Igbo - Nigeria'
         WHEN 1057 THEN 'Indonesian'
         WHEN 1117 THEN 'Inuktitut'
         WHEN 2108 THEN 'Irish'
         WHEN 1040 THEN 'Italian - Italy'
         WHEN 2064 THEN 'Italian - Switzerland'
         WHEN 1041 THEN 'Japanese'
         WHEN 1158 THEN 'K iche'
         WHEN 1099 THEN 'Kannada'
         WHEN 1137 THEN 'Kanuri - Nigeria'
         WHEN 2144 THEN 'Kashmiri'
         WHEN 1120 THEN 'Kashmiri (Arabic)'
         WHEN 1087 THEN 'Kazakh'
         WHEN 1107 THEN 'Khmer'
         WHEN 1159 THEN 'Kinyarwanda'
         WHEN 1111 THEN 'Konkani'
         WHEN 1042 THEN 'Korean'
         WHEN 1088 THEN 'Kyrgyz (Cyrillic)'
         WHEN 1108 THEN 'Lao'
         WHEN 1142 THEN 'Latin'
         WHEN 1062 THEN 'Latvian'
         WHEN 1063 THEN 'Lithuanian'
         WHEN 1134 THEN 'Luxembourgish'
         WHEN 1086 THEN 'Malay - Malaysia'
         WHEN 2110 THEN 'Malay - Brunei Darussalam'
         WHEN 1100 THEN 'Malayalam'
         WHEN 1082 THEN 'Maltese'
         WHEN 1112 THEN 'Manipuri'
         WHEN 1153 THEN 'Maori - New Zealand'
         WHEN 1146 THEN 'Mapudungun'
         WHEN 1102 THEN 'Marathi'
         WHEN 1148 THEN 'Mohawk'
         WHEN 1104 THEN 'Mongolian (Cyrillic)'
         WHEN 2128 THEN 'Mongolian (Mongolian)'
         WHEN 1121 THEN 'Nepali'
         WHEN 2145 THEN 'Nepali - India'
         WHEN 1044 THEN 'Norwegian (Bokml)'
         WHEN 2068 THEN 'Norwegian (Nynorsk)'
         WHEN 1154 THEN 'Occitan'
         WHEN 1096 THEN 'Oriya'
         WHEN 1138 THEN 'Oromo'
         WHEN 1145 THEN 'Papiamentu'
         WHEN 1123 THEN 'Pashto'
         WHEN 1045 THEN 'Polish'
         WHEN 1046 THEN 'Portuguese - Brazil'
         WHEN 2070 THEN 'Portuguese - Portugal'
         WHEN 1094 THEN 'Punjabi'
         WHEN 2118 THEN 'Punjabi (Pakistan)'
         WHEN 1131 THEN 'Quecha - Bolivia'
         WHEN 2155 THEN 'Quecha - Ecuador'
         WHEN 3179 THEN 'Quecha - Peru'
         WHEN 1047 THEN 'Rhaeto-Romanic'
         WHEN 1048 THEN 'Romanian'
         WHEN 2072 THEN 'Romanian - Moldava'
         WHEN 1049 THEN 'Russian'
         WHEN 2073 THEN 'Russian - Moldava'
         WHEN 1083 THEN 'Sami (Lappish)'
         WHEN 1103 THEN 'Sanskrit'
         WHEN 1084 THEN 'Scottish Gaelic'
         WHEN 1132 THEN 'Sepedi'
         WHEN 3098 THEN 'Serbian (Cyrillic)'
         WHEN 2074 THEN 'Serbian (Latin)'
         WHEN 1113 THEN 'Sindhi - India'
         WHEN 2137 THEN 'Sindhi - Pakistan'
         WHEN 1115 THEN 'Sinhalese - Sri Lanka'
         WHEN 1051 THEN 'Slovak'
         WHEN 1060 THEN 'Slovenian'
         WHEN 1143 THEN 'Somali'
         WHEN 1070 THEN 'Sorbian'
         WHEN 3082 THEN 'Spanish - Spain (Modern Sort)'
         WHEN 1034 THEN 'Spanish - Spain (Traditional Sort)'
         WHEN 11274 THEN 'Spanish - Argentina'
         WHEN 16394 THEN 'Spanish - Bolivia'
         WHEN 13322 THEN 'Spanish - Chile'
         WHEN 9226 THEN 'Spanish - Colombia'
         WHEN 5130 THEN 'Spanish - Costa Rica'
         WHEN 7178 THEN 'Spanish - Dominican Republic'
         WHEN 12298 THEN 'Spanish - Ecuador'
         WHEN 17418 THEN 'Spanish - El Salvador'
         WHEN 4106 THEN 'Spanish - Guatemala'
         WHEN 18442 THEN 'Spanish - Honduras'
         WHEN 22538 THEN 'Spanish - Latin America'
         WHEN 2058 THEN 'Spanish - Mexico'
         WHEN 19466 THEN 'Spanish - Nicaragua'
         WHEN 6154 THEN 'Spanish - Panama'
         WHEN 15370 THEN 'Spanish - Paraguay'
         WHEN 10250 THEN 'Spanish - Peru'
         WHEN 20490 THEN 'Spanish - Puerto Rico'
         WHEN 21514 THEN 'Spanish - United States'
         WHEN 14346 THEN 'Spanish - Uruguay'
         WHEN 8202 THEN 'Spanish - Venezuela'
         WHEN 1072 THEN 'Sutu'
         WHEN 1089 THEN 'Swahili'
         WHEN 1053 THEN 'Swedish'
         WHEN 2077 THEN 'Swedish - Finland'
         WHEN 1114 THEN 'Syriac'
         WHEN 1064 THEN 'Tajik'
         WHEN 1119 THEN 'Tamazight (Arabic)'
         WHEN 2143 THEN 'Tamazight (Latin)'
         WHEN 1097 THEN 'Tamil'
         WHEN 1092 THEN 'Tatar'
         WHEN 1098 THEN 'Telugu'
         WHEN 1054 THEN 'Thai'
         WHEN 2129 THEN 'Tibetan - Bhutan'
         WHEN 1105 THEN 'Tibetan - Peoples Republic of China'
         WHEN 2163 THEN 'Tigrigna - Eritrea'
         WHEN 1139 THEN 'Tigrigna - Ethiopia'
         WHEN 1073 THEN 'Tsonga'
         WHEN 1074 THEN 'Tswana'
         WHEN 1055 THEN 'Turkish'
         WHEN 1090 THEN 'Turkmen'
         WHEN 1152 THEN 'Uighur - China'
         WHEN 1058 THEN 'Ukrainian'
         WHEN 1056 THEN 'Urdu'
         WHEN 2080 THEN 'Urdu - India'
         WHEN 2115 THEN 'Uzbek (Cyrillic)'
         WHEN 1091 THEN 'Uzbek (Latin)'
         WHEN 1075 THEN 'Venda'
         WHEN 1066 THEN 'Vietnamese'
         WHEN 1106 THEN 'Welsh'
         WHEN 1160 THEN 'Wolof'
         WHEN 1076 THEN 'Xhosa'
         WHEN 1157 THEN 'Yakut'
         WHEN 1157 THEN 'Yakut'
         WHEN 1144 THEN 'Yi'
         WHEN 1085 THEN 'Yiddish'
         WHEN 1130 THEN 'Yoruba'
         WHEN 1077 THEN 'Zulu'
         WHEN 1279 THEN 'HID (Human Interface Device)'
       END AS OS_LANGUAGE
FROM   [SERVER_OS_VERSION]
GO
PRINT N'Creating [dbo].[PERF_HOURLY_ROWDATA_VW]...';


GO

/*********  PERF DATA Row Count change ************************/
CREATE VIEW [dbo].[PERF_HOURLY_ROWDATA_VW]
AS
  
  

  WITH MyCTE (SERVER_NAME, DATABASE_NAME, STATS_TIME, TABLE_NAME, ROW_COUNT, RowVersion)
     AS (SELECT SERVER_NAME,
     DATABASE_NAME,
                STATS_TIME,
                TABLE_NAME,
                ROW_COUNT,
                ROW_NUMBER()
                  OVER(
                    PARTITION BY SERVER_NAME, DATABASE_NAME, TABLE_NAME
                    ORDER BY STATS_TIME DESC) RowVersion
         FROM   INDEX_DETAIL ID 
         WHERE ID.INDEX_ID IN (0,1) )
         
         
         
SELECT TOP 100 PERCENT  ID.SERVER_NAME,
       ID.DATABASE_NAME,
       ID.STATS_TIME,
       ID.TABLE_NAME,
       ID.ROW_COUNT - PREV.ROW_COUNT AS ROWS_DELTA
FROM   MyCTE ID
       INNER JOIN MyCTE PREV
               ON ID.SERVER_NAME = PREV.SERVER_NAME
                  AND ID.DATABASE_NAME = PREV.DATABASE_NAME
                  AND ID.TABLE_NAME = PREV.TABLE_NAME
                  AND ID.RowVersion = PREV.RowVersion - 1
ORDER  BY STATS_TIME DESC,
          ID.ROW_COUNT - PREV.ROW_COUNT DESC,
          ID.TABLE_NAME
GO
PRINT N'Creating [dbo].[PERF_HOURLY_DISKSTATS_VW]...';


GO


/*********  PERF DATA Virtual I/O change ************************/
CREATE VIEW [dbo].[PERF_HOURLY_DISKSTATS_VW]

AS

WITH MyCTE (SERVER_NAME, DATABASE_NAME, STATS_TIME, FILE_ID,NUM_OF_READS, IO_STALL_READ_MS, NUM_OF_WRITES, IO_STALL_WRITE_MS,NUM_OF_BYTES_READ,NUM_OF_BYTES_WRITTEN, RowVersion)
     AS (SELECT DS.SERVER_NAME,
                DS.DATABASE_NAME,
                DS.STATS_TIME,
                DS.FILE_ID,
                DS.NUM_OF_READS,
                DS.IO_STALL_READ_MS,
                DS.NUM_OF_WRITES,
                DS.IO_STALL_WRITE_MS,
                DS.NUM_OF_BYTES_READ, 
                DS.NUM_OF_BYTES_WRITTEN,
                ROW_NUMBER()
                  OVER(
                    PARTITION BY DS.SERVER_NAME, DS.DATABASE_NAME, DS.FILE_ID
                    ORDER BY DS.STATS_TIME DESC) AS RowVersion
         FROM   DISKSTATS DS)
         
         
SELECT  TOP 100 PERCENT CTE.SERVER_NAME, CTE.DATABASE_NAME, CTE.STATS_TIME, CTE.FILE_ID,

 CASE
                    WHEN ( CTE.NUM_OF_READS - PREV.NUM_OF_READS ) = 0 THEN 0
                    ELSE ( CTE.IO_STALL_READ_MS - PREV.IO_STALL_READ_MS ) / ( CTE.NUM_OF_READS - PREV.NUM_OF_READS )
                  END                                                                                                                                           AS Read_Latency,
 CASE
                    WHEN ( CTE.NUM_OF_WRITES - PREV.NUM_OF_WRITES ) = 0 THEN 0
                    ELSE ( CTE.IO_STALL_WRITE_MS - PREV.IO_STALL_WRITE_MS ) / ( CTE.NUM_OF_WRITES - PREV.NUM_OF_WRITES )
                  END                                                                                                                                           AS Write_Latency,
  CASE
                    WHEN ( CTE.NUM_OF_READS - PREV.NUM_OF_READS ) = 0 THEN 0
                    ELSE ( CTE.NUM_OF_BYTES_READ - PREV.NUM_OF_BYTES_READ ) / ( CTE.NUM_OF_READS - PREV.NUM_OF_READS )
                  END                                                                                                                                           AS Avg_Bytes_Per_Read,
   CASE
                    WHEN ( CTE.NUM_OF_WRITES - PREV.NUM_OF_WRITES ) = 0 THEN 0
                    ELSE ( CTE.NUM_OF_BYTES_WRITTEN - PREV.NUM_OF_BYTES_WRITTEN ) / ( CTE.NUM_OF_WRITES - PREV.NUM_OF_WRITES )
                  END                                                                                                                                           AS Avg_Bytes_Per_Written,
       CONVERT(DEC(14, 2), ( CTE.NUM_OF_READS - PREV.NUM_OF_READS ) / datediff(S, PREV.STATS_TIME, CTE.STATS_TIME) * 1.00)                             AS [Mb_Reads/sec],-- Or divide by 3600 if we're sure of duration
                  CONVERT(DEC(14, 2), ( CTE.NUM_OF_BYTES_READ - PREV.NUM_OF_BYTES_READ ) / 1048576.0)                                                            AS Tot_MB_Read_Last_Hour,
                  CONVERT(DEC(14, 2), ( CTE.NUM_OF_BYTES_READ - PREV.NUM_OF_BYTES_READ ) / 1048576.0 / datediff(S, PREV.STATS_TIME, CTE.STATS_TIME) * 1.00)       AS [MB_Read_Last_Hour/sec],
                  CONVERT(DEC(14, 2), ( CTE.NUM_OF_WRITES - PREV.NUM_OF_WRITES ) / datediff(S, PREV.STATS_TIME, CTE.STATS_TIME) * 1.00)                           AS [Mb_Writes/sec],
                  CONVERT(DEC(14, 2), ( CTE.NUM_OF_BYTES_WRITTEN - PREV.NUM_OF_BYTES_WRITTEN ) / 1048576.0)                                                      AS Tot_MB_Written_Last_Hour,
                  CONVERT(DEC(14, 2), ( CTE.NUM_OF_BYTES_WRITTEN - PREV.NUM_OF_BYTES_WRITTEN ) / 1048576.0 / datediff(S, PREV.STATS_TIME, CTE.STATS_TIME) * 1.00) AS [MB_Written_Last_Hour/sec],
                  CTE.NUM_OF_READS - PREV.NUM_OF_READS                                                                                                           AS Num_of_Reads,
                  CTE.NUM_OF_WRITES - PREV.NUM_OF_WRITES                                                                                                         AS Num_of_Writes,
                  CTE.IO_STALL_READ_MS - PREV.IO_STALL_READ_MS                                                                                                   AS Read_IO_Stalls_MS_Last_Hour,
                  CTE.IO_STALL_WRITE_MS - PREV.IO_STALL_WRITE_MS                                                                                                 AS Write_IO_Stalls_MS_Last_Hour
                    
       
       
FROM   MyCTE CTE
       INNER JOIN MyCTE PREV
               ON CTE.SERVER_NAME = PREV.SERVER_NAME
                  AND CTE.DATABASE_NAME = PREV.DATABASE_NAME
                  AND CTE.FILE_ID = PREV.FILE_ID
                  AND CTE.RowVersion = PREV.RowVersion - 1 

ORDER BY STATS_TIME DESC, SERVER_NAME, DATABASE_NAME, FILE_ID
GO
PRINT N'Creating [dbo].[MISSING_INDEXES_CURR_VW]...';


GO

CREATE VIEW [dbo].[MISSING_INDEXES_CURR_VW] AS


WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT Q.SERVER_NAME,
       Q.DATABASE_NAME,
       CREATION_TIME                                                                                                  AS COMPILED_TIME,
       EXECUTION_COUNT,
       EXECUTION_COUNT / CASE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                           WHEN 0 THEN 1
                           ELSE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                         END                                                                                          AS EXECUTION_PER_HOUR,
       cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS TOTAL_ELAPSED_TIME,
       Q.AVG_TIME_MS                                                                                                  AS AVG_ELAPSED_TIME,
       cast(MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                            AS MAX_ELAPSED_TIME,
       AVG_LOGICAL_READS = TOTAL_LOGICAL_READS / EXECUTION_COUNT,
       cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3)) - cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))   AS TOTAL_WAIT_TIME,
       AVG_ROWS_RETURNED = TOTAL_ROWS / EXECUTION_COUNT,
       QT.SQL_TEXT                                                                                                    AS SQL_TEXT,
       QP.SQL_PARMS                                                                                                   AS QUERY_PARAMETER_VALUES,
       QUERY_PLAN,
       index_nodeS.value('(../@Impact)[1]', 'float')                                                                  AS INDEX_IMPACT,
       replace(replace(index_nodeS.value('(./@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                        AS TABLE_NAME,
       replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in ./sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "EQUALITY"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') AS EQUALITY_COLUMNS,
       replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in ./sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "INEQUALITY"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') AS INEQUALITY_COLUMNS,
       replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in .//sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "INCLUDE"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') AS INCLUDED_COLUMNS,
       Q.ROW_NUM,
       Q.QUERY_HASH,
       TOTAL_ROWS,
       MAX_ROWS,
       MIN_ROWS,
       PLAN_GENERATION_NUM,
       Q.LAST_EXECUTION_TIME,
       cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS TOTAL_WORKER_TIME,
       AVG_PHYSICAL_READS = TOTAL_PHYSICAL_READS / EXECUTION_COUNT,
       AVG_LOGICAL_WRITES = TOTAL_LOGICAL_WRITES / EXECUTION_COUNT,
       cast(LAST_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS LAST_ELAPSED_TIME,
       cast(MIN_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                            AS MIN_ELAPSED_TIME,
       TOTAL_PHYSICAL_READS,
       LAST_PHYSICAL_READS,
       MIN_PHYSICAL_READS,
       MAX_PHYSICAL_READS,
       TOTAL_LOGICAL_READS,
       LAST_LOGICAL_READS,
       MIN_LOGICAL_READS,
       MAX_LOGICAL_READS,
       TOTAL_LOGICAL_WRITES,
       LAST_LOGICAL_WRITES,
       MIN_LOGICAL_WRITES,
       MAX_LOGICAL_WRITES,
       cast(LAST_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                            AS LAST_WORKER_TIME,
       cast(MIN_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                             AS MIN_WORKER_TIME,
       cast(MAX_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                             AS MAX_WORKER_TIME,
       QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN),
       Q.STATS_TIME,
       SQL_VERSION,
       S.SQL_SERVER_STARTTIME,
       Q.QUERY_PLAN_HASH,
       C.COMMENT
FROM   (SELECT QS2.SERVER_NAME,
               QS2.DATABASE_NAME,
               QUERY_HASH,
               max(QS2.STATS_TIME)      AS STATS_TIME,
               max(LAST_EXECUTION_TIME) AS LAST_EXECUTION_TIME
        FROM   QUERY_STATS QS2
               INNER JOIN STATS_COLLECTION_SUMMARY S2 WITH (NOLOCK)
                       ON QS2.STATS_TIME = S2.STATS_TIME
                          AND QS2.DATABASE_NAME = S2.DATABASE_NAME
                          AND QS2.SERVER_NAME = S2.SERVER_NAME
                          AND S2.RUN_NAME NOT LIKE 'BASE%'
        GROUP  BY QS2.SERVER_NAME,
                  QS2.DATABASE_NAME,
                  QUERY_HASH) AS A
       INNER LOOP JOIN QUERY_STATS Q WITH (NOLOCK)
                    ON A.SERVER_NAME = Q.SERVER_NAME
                       AND A.DATABASE_NAME = Q.DATABASE_NAME
                       AND A.QUERY_HASH = Q.QUERY_HASH
                       AND A.LAST_EXECUTION_TIME = Q.LAST_EXECUTION_TIME
                       AND A.STATS_TIME = Q.STATS_TIME
       INNER JOIN QUERY_PLANS QP WITH (NOLOCK)
               ON QP.QUERY_PLAN_HASH = Q.QUERY_PLAN_HASH
                  AND QP.SERVER_NAME = Q.SERVER_NAME
                  AND QP.DATABASE_NAME = Q.DATABASE_NAME
       CROSS APPLY QP.QUERY_PLAN.nodes('//sp:MissingIndexes/sp:MissingIndexGroup/sp:MissingIndex') AS missing_indexes(index_nodeS)
       INNER JOIN STATS_COLLECTION_SUMMARY S WITH (NOLOCK)
               ON Q.STATS_TIME = S.STATS_TIME
                  AND Q.DATABASE_NAME = S.DATABASE_NAME
                  AND Q.SERVER_NAME = S.SERVER_NAME
       LEFT OUTER JOIN QUERY_TEXT AS QT
                    ON Q.QUERY_HASH = QT.QUERY_HASH
                       AND Q.DATABASE_NAME = QT.DATABASE_NAME
                       AND Q.SERVER_NAME = QT.SERVER_NAME
       LEFT OUTER JOIN COMMENTS C
                    ON Q.QUERY_HASH = C.QUERY_HASH
                       AND Q.SERVER_NAME = C.SERVER_NAME
                       AND Q.DATABASE_NAME = C.DATABASE_NAME
GO
PRINT N'Creating [dbo].[MISSING_INDEXES_VW]...';


GO

CREATE VIEW [dbo].[MISSING_INDEXES_VW] 
AS


WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT Q.SERVER_NAME,
       Q.DATABASE_NAME,
       CREATION_TIME                                                                                                  AS COMPILED_TIME,
       EXECUTION_COUNT,
       EXECUTION_COUNT / CASE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                           WHEN 0 THEN 1
                           ELSE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                         END                                                                                          AS EXECUTION_PER_HOUR,
       cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS TOTAL_ELAPSED_TIME,
       Q.AVG_TIME_MS                                                                                                  AS AVG_ELAPSED_TIME,
       cast(MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                            AS MAX_ELAPSED_TIME,
       AVG_LOGICAL_READS = TOTAL_LOGICAL_READS / EXECUTION_COUNT,
       cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3)) - cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))   AS TOTAL_WAIT_TIME,
       AVG_ROWS_RETURNED = TOTAL_ROWS / EXECUTION_COUNT,
       QT.SQL_TEXT                                                                                                    AS SQL_TEXT,
       QP.SQL_PARMS                                                                                                   AS QUERY_PARAMETER_VALUES,
       QUERY_PLAN,
       index_nodeS.value('(../@Impact)[1]', 'float')                                                                  AS INDEX_IMPACT,
       replace(replace(index_nodeS.value('(./@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                        AS TABLE_NAME,
       replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in ./sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "EQUALITY"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') AS EQUALITY_COLUMNS,
       replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in ./sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "INEQUALITY"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') AS INEQUALITY_COLUMNS,
       replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in .//sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "INCLUDE"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') AS INCLUDED_COLUMNS,
       Q.ROW_NUM,
       Q.QUERY_HASH,
       TOTAL_ROWS,
       MAX_ROWS,
       MIN_ROWS,
       PLAN_GENERATION_NUM,
       LAST_EXECUTION_TIME,
       cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS TOTAL_WORKER_TIME,
       AVG_PHYSICAL_READS = TOTAL_PHYSICAL_READS / EXECUTION_COUNT,
       AVG_LOGICAL_WRITES = TOTAL_LOGICAL_WRITES / EXECUTION_COUNT,
       cast(LAST_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS LAST_ELAPSED_TIME,
       cast(MIN_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                            AS MIN_ELAPSED_TIME,
       TOTAL_PHYSICAL_READS,
       LAST_PHYSICAL_READS,
       MIN_PHYSICAL_READS,
       MAX_PHYSICAL_READS,
       TOTAL_LOGICAL_READS,
       LAST_LOGICAL_READS,
       MIN_LOGICAL_READS,
       MAX_LOGICAL_READS,
       TOTAL_LOGICAL_WRITES,
       LAST_LOGICAL_WRITES,
       MIN_LOGICAL_WRITES,
       MAX_LOGICAL_WRITES,
       cast(LAST_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                            AS LAST_WORKER_TIME,
       cast(MIN_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                             AS MIN_WORKER_TIME,
       cast(MAX_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                             AS MAX_WORKER_TIME,
       QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN),
       S.STATS_TIME,
       SQL_VERSION,
       S.SQL_SERVER_STARTTIME,
       Q.QUERY_PLAN_HASH,
       C.COMMENT
FROM   QUERY_STATS Q WITH (NOLOCK)
       INNER JOIN QUERY_PLANS QP WITH (NOLOCK)
               ON QP.QUERY_PLAN_HASH = Q.QUERY_PLAN_HASH
                  AND QP.SERVER_NAME = Q.SERVER_NAME
                  AND QP.DATABASE_NAME = Q.DATABASE_NAME
       CROSS APPLY QP.QUERY_PLAN.nodes('//sp:MissingIndexes/sp:MissingIndexGroup/sp:MissingIndex') AS missing_indexes(index_nodeS)
       CROSS APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node)
       INNER JOIN STATS_COLLECTION_SUMMARY S WITH (NOLOCK)
               ON Q.STATS_TIME = S.STATS_TIME
                  AND Q.DATABASE_NAME = S.DATABASE_NAME
                  AND Q.SERVER_NAME = S.SERVER_NAME
       LEFT OUTER JOIN QUERY_TEXT AS QT
                    ON Q.QUERY_HASH = QT.QUERY_HASH
       LEFT OUTER JOIN COMMENTS C
                    ON Q.QUERY_HASH = C.QUERY_HASH
                       AND Q.SERVER_NAME = C.SERVER_NAME
                       AND Q.DATABASE_NAME = C.DATABASE_NAME
GO
PRINT N'Creating [dbo].[USER_SCANS_VW]...';


GO


CREATE VIEW [dbo].[USER_SCANS_VW] 
AS
select getdate() as [date]
/*

WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT *
FROM 
(
SELECT SERVER_NAME,
       DATABASE_NAME,
       ROW_NUM,
       QUERY_HASH,
       EXECUTION_COUNT,
       TOTAL_ELAPSED_TIME,
       AVG_ELAPSED_TIME,
       AVG_LOGICAL_READS,
       SQL_TEXT,
       CONVERT (NVARCHAR(MAX), index_node2.query('for $qplan in //sp:QueryPlan, $plist in $qplan/sp:ParameterList, $colref in $plist/sp:ColumnReference  return concat(string($colref/@Column),":",string($colref/@ParameterCompiledValue),",   "),"  "')) AS QUERY_PARAMETER_VALUES,
       QUERY_PLAN,
       index_node.value('(.//@PhysicalOp)[1]', 'NVARCHAR(128)')                                                                                                                                                                                            AS PHYSICAL_OPERATOR,
       Replace(Replace(index_node.value('(.//@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                                                                                                                                                             AS TABLE_NAME,
       Replace(Replace(index_node.value('(.//@Index)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                                                                                                                                                             AS INDEX_NAME,
       Replace(CONVERT(NVARCHAR(MAX), index_node.query('for $indexscan in ./sp:IndexScan,
										$predicate in $indexscan/sp:Predicate,
										$columnreference in $predicate//sp:ColumnReference
                                        return string($columnreference/@Column)')), ' ', ', ')                                                                                                                                                      AS PREDICATE_COLUMNS,
       TOTAL_WORKER_TIME,
       AVG_PHYSICAL_READS,
       AVG_LOGICAL_WRITES,
       LAST_ELAPSED_TIME,
       MIN_ELAPSED_TIME,
       MAX_ELAPSED_TIME,
       TOTAL_PHYSICAL_READS,
       LAST_PHYSICAL_READS,
       MIN_PHYSICAL_READS,
       MAX_PHYSICAL_READS,
       TOTAL_LOGICAL_READS,
       LAST_LOGICAL_READS,
       MIN_LOGICAL_READS,
       MAX_LOGICAL_READS,
       TOTAL_LOGICAL_WRITES,
       LAST_LOGICAL_WRITES,
       MIN_LOGICAL_WRITES,
       MAX_LOGICAL_WRITES,
       LAST_WORKER_TIME,
       MIN_WORKER_TIME,
       MAX_WORKER_TIME,
       QUERY_PLAN_TEXT,
       STATS_TIME,
       SQL_VERSION,
       COMMENT
FROM   QUERY_STATS_VW
       OUTER APPLY QUERY_PLAN.nodes('//sp:RelOp') AS Operators(index_node)
       CROSS APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node2) 

) A
WHERE PHYSICAL_OPERATOR LIKE '%Index_Scan%'
UNION ALL
SELECT *
FROM 
(
SELECT SERVER_NAME,
       DATABASE_NAME,
       ROW_NUM,
       QUERY_HASH,
       EXECUTION_COUNT,
       TOTAL_ELAPSED_TIME,
       AVG_ELAPSED_TIME,
       AVG_LOGICAL_READS,
       SQL_TEXT,
       CONVERT (NVARCHAR(MAX), index_node2.query('for $qplan in //sp:QueryPlan, $plist in $qplan/sp:ParameterList, $colref in $plist/sp:ColumnReference  return concat(string($colref/@Column),":",string($colref/@ParameterCompiledValue),",   "),"  "')) AS QUERY_PARAMETER_VALUES,
       QUERY_PLAN,
       index_node.value('(.//@PhysicalOp)[1]', 'NVARCHAR(128)')                                                                                                                                                                                            AS PHYSICAL_OPERATOR,
       Replace(Replace(index_node.value('(.//@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                                                                                                                                                             AS TABLE_NAME,
       Replace(Replace(index_node.value('(.//@Index)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                                                                                                                                                             AS INDEX_NAME,
       Replace(CONVERT(NVARCHAR(MAX), index_node.query('for $indexscan in ./sp:IndexScan,
										$predicate in $indexscan/sp:Predicate,
										$columnreference in $predicate//sp:ColumnReference
                                        return string($columnreference/@Column)')), ' ', ', ')                                                                                                                                                      AS PREDICATE_COLUMNS,
       TOTAL_WORKER_TIME,
       AVG_PHYSICAL_READS,
       AVG_LOGICAL_WRITES,
       LAST_ELAPSED_TIME,
       MIN_ELAPSED_TIME,
       MAX_ELAPSED_TIME,
       TOTAL_PHYSICAL_READS,
       LAST_PHYSICAL_READS,
       MIN_PHYSICAL_READS,
       MAX_PHYSICAL_READS,
       TOTAL_LOGICAL_READS,
       LAST_LOGICAL_READS,
       MIN_LOGICAL_READS,
       MAX_LOGICAL_READS,
       TOTAL_LOGICAL_WRITES,
       LAST_LOGICAL_WRITES,
       MIN_LOGICAL_WRITES,
       MAX_LOGICAL_WRITES,
       LAST_WORKER_TIME,
       MIN_WORKER_TIME,
       MAX_WORKER_TIME,
       QUERY_PLAN_TEXT,
       STATS_TIME,
       SQL_VERSION,
       COMMENT
FROM   QUERY_STATS_VW
       OUTER APPLY QUERY_PLAN.nodes('//sp:RelOp') AS Operators(index_node)
       CROSS APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node2) 

) A
WHERE PHYSICAL_OPERATOR LIKE '%Table Scan%'


*/
GO
PRINT N'Creating [dbo].[BLOCKS_VW]...';


GO

CREATE VIEW [dbo].[BLOCKS_VW]
AS

SELECT [BLOCKED_DTTM]
      ,[BLOCKER_LOGIN]
      ,[BLOCKER_PROGRAM]
      ,[BLOCKER_HOSTNAME]
      ,[BLOCKED_LOGIN]
      ,[BLOCKED_PROGRAM]
      ,[BLOCKED_HOSTNAME]
      ,[BLOCKER_SESSION_ID]
      ,dbo.FN_RETURN_AXSESSION_FROM_CONTEXT(BLOCKER_CONTEXT_INFO) AS BLOCKER_AX_SESSION_ID
      ,dbo.FN_RETURN_AXID_FROM_CONTEXT(BLOCKER_CONTEXT_INFO)      AS BLOCKER_AX_USER_ID
      ,cast([BLOCKER_CONTEXT_INFO]  as nvarchar(128)) as BLOCKER_CONTEXT_INFO
      ,[BLOCKER_CONTEXT]
      ,[BLOCKER_TRAN_ISOLATION]
      ,[BLOCKER_STATUS]
      ,[BLOCKED_SESSION_ID]
      ,dbo.FN_RETURN_AXSESSION_FROM_CONTEXT(BLOCKER_CONTEXT_INFO) AS BLOCKED_AX_SESSION_ID
      ,dbo.FN_RETURN_AXID_FROM_CONTEXT(BLOCKER_CONTEXT_INFO)      AS BLOCKED_AX_USER_ID
      ,cast([BLOCKED_CONTEXT_INFO]  as nvarchar(128)) as BLOCKED_CONTEXT_INFO
      ,[BLOCKED_CONTEXT]
      ,[BLOCKED_TRAN_ISOLATION]
      ,[TRANSACTION_ID]
      ,[WAIT_TIME]
      ,[LOCK_MODE]
      ,[LOCK_SIZE]
      ,[DATABASE_NAME]
      ,[ALLOW_SNAPSHOT_ISOLATION]
      ,[READ_COMMITTED_SNAPSHOT]
      ,[OBJECT_NAME]
      ,[INDEX_ID]
      ,[BLOCKER_SQL]
      ,[BLOCKER_PLAN]
      ,[BLOCKED_SQL]
      ,[BLOCKED_PLAN]
  FROM [BLOCKS]
GO
PRINT N'Creating [dbo].[AX_TABLE_DETAIL_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE VIEW [dbo].[AX_TABLE_DETAIL_VW]
AS
  SELECT AXL.LICENSE_KEY_NAME,
         AXC.CONFIG_KEY_NAME,
         AXT.TABLE_NAME,
         AXT.TABLE_ID,
         AXT.TABLE_TYPE,
         AXT.TABLE_GROUP,
         AXT.OCC_ENABLED,
         AXT.CACHE_LOOKUP,
         AXT.COUNTRY_REGION_CODES,
         AXT.AOS_AUTHORIZATION,
         AXT.INSERT_METHOD_OVERRIDDEN,
         AXT.UPDATE_METHOD_OVERRIDDEN,
         AXT.DELETE_METHOD_OVERRIDDEN,
         AXT.AOS_VALIDATE_INSERT,
         AXT.AOS_VALIDATE_UPDATE,
         AXT.AOS_VALIDATE_DELETE,
         AXT.DATABASELOG_INSERT,
         AXT.DATABASELOG_UPDATE,
         AXT.DATABASELOG_DELETE,
         AXT.DATABASELOG_RENAMEKEY,
         AXT.CLUSTERED_INDEX,
         AXT.PRIMARY_KEY,
         AXT.DATA_PER_COMPANY,
         AXT.DATA_PER_PARTITION,
         AXT.APPLAYER,
         AXT.EVENT_INSERT,
         AXT.EVENT_UPDATE,
         AXT.EVENT_DELETE,
         AXT.EVENT_RENAMEKEY,
         AXT.SERVER_NAME,
         AXT.DATABASE_NAME
  FROM   [dbo].[AX_TABLE_DETAIL] AXT
         LEFT OUTER JOIN [AX_CONFIGURATIONKEY_DETAIL] AXC
                 ON AXT.SERVER_NAME = AXC.SERVER_NAME
                    AND AXT.DATABASE_NAME = AXC.DATABASE_NAME
                    AND AXT.CONFIGURATION_KEY_ID = AXC.CONFIG_KEY_ID
         LEFT OUTER JOIN [dbo].[AX_LICENSEKEY_DETAIL] AXL
                 ON AXT.SERVER_NAME = AXL.SERVER_NAME
                    AND AXT.DATABASE_NAME = AXL.DATABASE_NAME
                    AND AXT.LICENSE_CODE_ID = AXL.LICENSE_KEY_ID
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[AX_INDEX_DETAIL_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE VIEW [dbo].[AX_INDEX_DETAIL_VW]
	AS 

SELECT AXL.LICENSE_KEY_NAME,
       AXC.CONFIG_KEY_NAME,
       AXT.TABLE_NAME,
       AXI.INDEX_NAME,
       AXI.INDEX_ID,
       AXI.INDEX_DESCRIPTION,
       AXI.INDEX_KEYS,
       AXI.APPLAYER,
       AXT.TABLE_ID,
       AXT.TABLE_TYPE,
       AXT.TABLE_GROUP,
       AXT.OCC_ENABLED,
       AXT.CACHE_LOOKUP,
       AXT.COUNTRY_REGION_CODES,
	   AXT.SERVER_NAME,
	   AXT.DATABASE_NAME
FROM   [dbo].[AX_TABLE_DETAIL] AXT
       INNER JOIN [AX_INDEX_DETAIL] AXI
               ON AXT.SERVER_NAME = AXI.SERVER_NAME
                  AND AXT.DATABASE_NAME = AXI.DATABASE_NAME
                  AND AXT.TABLE_NAME = AXI.TABLE_NAME
       LEFT OUTER JOIN [AX_CONFIGURATIONKEY_DETAIL] AXC
               ON AXT.SERVER_NAME = AXC.SERVER_NAME
                  AND AXT.DATABASE_NAME = AXC.DATABASE_NAME
                  AND AXT.CONFIGURATION_KEY_ID = AXC.CONFIG_KEY_ID
       LEFT OUTER JOIN [dbo].[AX_LICENSEKEY_DETAIL] AXL
               ON AXT.SERVER_NAME = AXL.SERVER_NAME
                  AND AXT.DATABASE_NAME = AXL.DATABASE_NAME
                  AND AXT.LICENSE_CODE_ID = AXL.LICENSE_KEY_ID
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[QUERY_STATS_CTE_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE VIEW [dbo].[QUERY_STATS_CTE_VW]
	AS 
	
	

WITH CTE_STATS (SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME, STATS_TIME, PREV_STATS_TIME, PREV_CREATION_TIME, PREV_ELAPSED_TIME, PREV_EXECUTION_COUNT, EXECUTION_COUNT, TOTAL_WORKER_TIME, TOTAL_ELAPSED_TIME, PREV_TOTAL_WORKER_TIME, TIME_THIS_PERIOD, WORKER_TIME_THIS_PERIOD, EXECUTIONS_THIS_PERIOD)
     AS (SELECT DISTINCT SERVER_NAME,
                         DATABASE_NAME,
                         QUERY_HASH,
                         QUERY_PLAN_HASH,
                         CREATION_TIME,
                         [STATS_TIME],
                         LAG(STATS_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_STATS_TIME,
                         LAG(CREATION_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_CREATION_TIME,
                         
                         LAG(TOTAL_ELAPSED_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_ELAPSED_TIME,
                         LAG(EXECUTION_COUNT, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_EXECUTION_COUNT,
                         EXECUTION_COUNT,
                         TOTAL_WORKER_TIME,
                         TOTAL_ELAPSED_TIME,
                         LAG(TOTAL_WORKER_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_TOTAL_WORKER_TIME,
                         TOTAL_ELAPSED_TIME - LAG(TOTAL_ELAPSED_TIME, 1, 0)
                                                OVER (
                                                  PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                                                  ORDER BY STATS_TIME ) AS TIME_THIS_PERIOD,
                         TOTAL_WORKER_TIME - LAG(TOTAL_WORKER_TIME, 1, 0)
                                               OVER (
                                                 PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                                                 ORDER BY STATS_TIME )  AS WORKER_TIME_THIS_PERIOD,
                         EXECUTION_COUNT - LAG(EXECUTION_COUNT, 1, 0)
                                             OVER (
                                               PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                                               ORDER BY STATS_TIME )    AS EXECUTIONS_THIS_PERIOD
         FROM   QUERY_STATS
         WHERE  QUERY_HASH <> 0x0000000000000000)
         
 SELECT * FROM CTE_STATS
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[QUERY_PLANS_MISSING_INDEX_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE VIEW [dbo].[QUERY_PLANS_MISSING_INDEX_VW]
	AS 
	
	
	
WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)

SELECT SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH,
ISNULL(STUFF((SELECT                                                                                                  
       --QUERY_PLAN,
       ' [IMPACT]= ' +cast(index_nodeS.value('(../@Impact)[1]', 'float')   as varchar(10))                                                            --  AS INDEX_IMPACT,
       + CHAR(9) + '[TABLE]= ' +replace(replace(index_nodeS.value('(./@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                      --  AS TABLE_NAME,
       + CHAR(10) + CHAR(9) + '[EQUALITY_COLUMNS]= ' +replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in ./sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "EQUALITY"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') 
       + CHAR(10) + CHAR(9) + '[INEQUALITY_COLUMNS]= ' +replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in ./sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "INEQUALITY"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') 
       + CHAR(10) + CHAR(9) + '[INCLUDED_COLUMNS]= ' +replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in .//sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "INCLUDE"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') 
		+CHAR(10) + CHAR(10)

FROM   QUERY_PLANS QP 
       CROSS APPLY QP.QUERY_PLAN.nodes('//sp:MissingIndexes/sp:MissingIndexGroup/sp:MissingIndex') AS missing_indexes(index_nodeS)
   where QP.MI_FLAG = 1 AND QP.SERVER_NAME = QP2.SERVER_NAME AND QP.DATABASE_NAME = QP2.DATABASE_NAME AND QP.QUERY_PLAN_HASH = QP2.QUERY_PLAN_HASH



   FOR xml path('')),1,1, ''),'') AS MISSING_INDEX_INFO

   FROM QUERY_PLANS QP2
   WHERE QP2.MI_FLAG = 1
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[QUERY_PLANS_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE VIEW [dbo].[QUERY_PLANS_VW]
	AS 
	
	
	
SELECT SERVER_NAME,DATABASE_NAME,QUERY_PLAN_HASH,QUERY_PLAN,SQL_PARMS, MI_FLAG,
ISNULL(STUFF(( select '| TABLE= ' + PP.TABLE_NAME + '  NODE_ID=' + cast(PP.NODE_ID AS VARCHAR(5)) + char(10) + char(9)
+ ' ||| INDEX= ' + PP.INDEX_NAME 
+ ' ||| INDEX_KEYS= ' + ISNULL((SELECT INDEX_KEYS FROM INDEX_STATS_CURR_VW IV WHERE IV.SERVER_NAME = PP.SERVER_NAME AND IV.DATABASE_NAME = PP.DATABASE_NAME AND IV.TABLE_NAME = PP.TABLE_NAME AND IV.INDEX_NAME = PP.INDEX_NAME),'')
+ ' ||| PHYSICAL_OP= ' + PP.PHYSICALOP 
+ ' ||| LOGICAL_OP= ' + PP.LOGICALOP 
+ char(10) + char(9)
+ ' ||| SEEK_COLUMNS= ' + replace(PP.SEEK_COLUMNS, ' ', ',')
+ char(10) + char(9)
+ ' ||| PREDICATE_COLUMNS= ' + PREDICATES 
+ ' ||| PREDICATE_TEXT= ' + PREDICATE_TEXT 
+ char(10) + char(9)
+ ' ||| LOOKUP= ' + CAST(PP.LOOKUP AS VARCHAR(1))
+ ' ||| ESTIMATED_ROWS = ' + CAST(PP.ESTIMATEROWS AS VARCHAR(30))
+ ' ||| AVG_ROW_SIZE = ' + CAST(PP.AVGROWSIZE  AS VARCHAR(30))
+ ' ||| ESTIMATED_TOTAL_COST ' + CAST(PP.ESTIMATEDTOTALSUBTREECOST AS VARCHAR(30))
+ ' ||| ESTIMATED_IO = ' + CAST(PP.ESTIMATEIO AS VARCHAR(30))
+ ' ||| ESTIMATED_CPU = ' + CAST(PP.ESTIMATECPU AS VARCHAR(30))

+char(10) +char(10) + ' ||| INDEXES FOR THIS TABLE |||' + char(10) + CHAR(10)
	+CASE PP.LOOKUP WHEN 0 THEN STUFF((SELECT CHAR(9) + CHAR(9) + 'NAME=['+ INDEX_NAME + ']  KEYS=['+  INDEX_KEYS + ']' + CHAR(9) + INDEX_DESCRIPTION +CHAR(10)  FROM INDEX_STATS_CURR_VW IV 
	WHERE IV.SERVER_NAME = PP.SERVER_NAME AND IV.DATABASE_NAME = PP.DATABASE_NAME AND IV.TABLE_NAME = PP.TABLE_NAME 
	FOR xml path('')),1,1, '') ELSE ' ' END + CHAR(10) + CHAR(10)

	from QUERY_PLANS_PARSED PP
	where QP.SERVER_NAME = PP.SERVER_NAME
		AND QP.DATABASE_NAME = PP.DATABASE_NAME
	AND QP.QUERY_PLAN_HASH = PP.QUERY_PLAN_HASH
	ORDER BY PP.ESTIMATEROWS DESC
	FOR xml path('')),1,1, ''),'')  AS QUERY_NODES



FROM QUERY_PLANS QP
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[PARSED_PLAN_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE VIEW [dbo].[PARSED_PLAN_VW]
	AS 

	
WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
select * --into rod 
FROM   (SELECT   SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH,
               

               --QUERY_PLAN,
			   CAST(isnull(index_node.value('(..//@NodeId)[1]', 'nvarchar(128)'),'0') AS INT) AS NodeID,
               CAST(Replace(Replace(index_node.value('(.//@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '') AS NVARCHAR(128))  AS TABLE_NAME,
               CAST(Replace(Replace(index_node.value('(.//@Index)[1]', 'NVARCHAR(128)'), '[', ''), ']', '') AS NVARCHAR(128)) AS INDEX_NAME,
			   CAST(isnull(index_node.value('(.//@Lookup)[1]', 'nvarchar(128)'),'0') AS INT) AS LOOKUP,
			   CAST(isnull(index_node.value('(..//@Parallel)[1]', 'nvarchar(128)'),'0') AS INT) AS PARALLEL,
			   CAST(index_node.value('(..//@PhysicalOp)[1]', 'nvarchar(128)') AS NVARCHAR(128)) AS PHYSICALOP,
			   CAST(index_node.value('(..//@LogicalOp)[1]', 'nvarchar(128)') AS NVARCHAR(128)) AS LOGICALOP,
			   CAST(str(ISNULL(index_node.value('(..//@EstimateRows)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(14,0)) AS ESTIMATEROWS,
			   CAST(str(ISNULL(index_node.value('(..//@EstimateIO)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(20,7)) AS EstimateIO,
			  CAST(str(ISNULL(index_node.value('(..//@EstimateCPU)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(20,7)) AS ESTIMATECPU,
			   CAST(str(ISNULL(index_node.value('(..//@AvgRowSize)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(14,0)) AS AVGROWSIZE,
			   CAST(str(isnull(index_node.value('(..//@EstimatedTotalSubtreeCost)[1]', 'nvarchar(128)') ,'0.0'),30,17) AS DECIMAL (20,7)) AS ESTIMATEDTOTALSUBTREECOST,
               CONVERT(NVARCHAR(MAX), index_node.query('for $seekpredicate in ./sp:SeekPredicates,
                                                            $rangecolumns in $seekpredicate//sp:RangeColumns,
                                                            $columnreference in $rangecolumns/sp:ColumnReference
                                        return string($columnreference/@Column)'))        AS SEEK_COLUMNS,

              CONVERT(NVARCHAR(MAX), index_node.query('for $predicate2 in ./sp:Predicate,
                                                           $Ident in  $predicate2//sp:Identifier,
														   $COLREF2 in  $Ident/sp:ColumnReference
                                                            
                                        return string($COLREF2/@Column)')) AS PREDICATES,

		    REPLACE( REPLACE( CONVERT(NVARCHAR(MAX), index_node.query('for $predicate in ./sp:Predicate,
                                                $rangecolumn in $predicate//sp:ScalarOperator
                                                            
                            return string($rangecolumn/@ScalarString)'))
							,'&lt;', '<')   ,'&gt;', '>')         AS PREDICATE_TEXT
        FROM   QUERY_PLANS
               OUTER APPLY QUERY_PLAN.nodes('//sp:RelOp/sp:IndexScan') AS SeekPredicates(index_node)
               --CROSS APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node2)

			   ) A
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[INDEX_KEY_ORDER_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE VIEW [dbo].[INDEX_KEY_ORDER_VW]
AS
	 WITH CTE (SERVER_NAME, DATABASE_NAME, TABLENAME, INDEXNAME, ROWS, KEYCOLUMN, COLUMNS, PREV_COL)
       AS (SELECT IDV.SERVER_NAME,
                  IDV.DATABASE_NAME,
                  TABLENAME,
                  INDEXNAME,
                  Cast(1 / DENSITY AS BIGINT)                                        AS ROWS,
                  Replace(Replace(COLUMNS, Lag(COLUMNS, 1, '')
                                             OVER (
                                               PARTITION BY TABLENAME, INDEXNAME
                                               ORDER BY Len(COLUMNS)), ''), ',', '') AS KEYCOLUMN,
                  COLUMNS,
                  Lag(COLUMNS, 1, '')
                    OVER (
                      PARTITION BY TABLENAME, INDEXNAME
                      ORDER BY Len(COLUMNS))                                         AS PREV_COL
           FROM   INDEX_DENSITY_VECTOR IDV
                  INNER JOIN INDEX_STATS_CURR_VW CV
                          ON IDV.DATABASE_NAME = CV.DATABASE_NAME
                             AND IDV.TABLENAME = CV.TABLE_NAME
                             AND IDV.INDEXNAME = CV.INDEX_NAME
                             --WHERE  IDV.TABLENAME = 'INVENTTRANS'
                             AND Len(IDV.COLUMNS) <= Len(CV.INDEX_KEYS) --REH for places where SQL has added the clustered index columns to the density vector
                             AND INDEXNAME NOT LIKE '_wa%') --REH Auto Stats indexes
  SELECT SERVER_NAME,
         DATABASE_NAME,
         TABLENAME,
         INDEXNAME,
         ROWS,
         KEYCOLUMN,
         COLUMNS,
         CASE KEYCOLUMN
           WHEN 'PARTITION' THEN -2
           WHEN 'DATAAREAID' THEN -1
           ELSE Cast (ROWS - Lag(ROWS, 1, 0)
                               OVER (
                                 PARTITION BY TABLENAME, INDEXNAME
                                 ORDER BY Len(COLUMNS)) AS BIGINT)
         END AS TOTAL_ROWS
  FROM   CTE
--ORDER BY TABLENAME,INDEXNAME, TOTAL_ROWS DESC
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[PERF_COUNTER_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE VIEW [dbo].[PERF_COUNTER_VW]
	AS 
	
	
	WITH MyCTE (SERVER_NAME, STATS_TIME, OBJECT_NAME, COUNTER_NAME, INSTANCE_NAME, CNTR_VALUE, RowVersion)
     AS (SELECT SERVER_NAME,
                STATS_TIME,
                OBJECT_NAME,
                COUNTER_NAME,
                INSTANCE_NAME,
                CNTR_VALUE,
                ROW_NUMBER()
                  OVER(
                    PARTITION BY SERVER_NAME, OBJECT_NAME, COUNTER_NAME, INSTANCE_NAME
                    ORDER BY STATS_TIME DESC) RowVersion
         FROM   PERF_COUNTER_DATA PDC
         WHERE  CNTR_TYPE = 272696576),

		 MyCTE2 (SERVER_NAME,  OBJECT_NAME, COUNTER_NAME, INSTANCE_NAME,STATS_TIME, CNTR_VALUE, BASE_CNTR_VALUE, RowVersion)
     AS (
SELECT PDC.SERVER_NAME,
       PDC.OBJECT_NAME,
       PDC.COUNTER_NAME,
       PDC.INSTANCE_NAME,
       PDC.STATS_TIME,
       PDC.CNTR_VALUE,
	   PDC_BASE.CNTR_VALUE AS BASE_CNTR_VALUE,
        ROW_NUMBER()
                  OVER(
                    PARTITION BY PDC.SERVER_NAME, PDC.OBJECT_NAME, PDC.COUNTER_NAME, PDC.INSTANCE_NAME
                    ORDER BY PDC.STATS_TIME DESC) RowVersion


FROM   PERF_COUNTER_DATA PDC
INNER JOIN PERF_COUNTER_DATA PDC_BASE ON PDC.SERVER_NAME = PDC_BASE.SERVER_NAME AND PDC.OBJECT_NAME = PDC_BASE.OBJECT_NAME
                  AND PDC.COUNTER_NAME LIKE REPLACE(PDC_BASE.COUNTER_NAME, ' BASE', '%')
                  AND PDC.STATS_TIME = PDC_BASE.STATS_TIME AND PDC.CNTR_TYPE <> 1073939712
WHERE  PDC_BASE.CNTR_TYPE = 1073939712) --REH All base type counters)

		 
		 
SELECT BASE.SERVER_NAME,
       BASE.OBJECT_NAME,
       BASE.COUNTER_NAME,
       BASE.INSTANCE_NAME,
       BASE.STATS_TIME,
       ( PDC.CNTR_VALUE - PREV.CNTR_VALUE ) / DATEDIFF(SS, PREV.STATS_TIME, PDC.STATS_TIME) AS CNTR_VALUE
FROM   PERF_COUNTER_DATA PDC
       INNER JOIN MyCTE BASE
               ON PDC.SERVER_NAME = BASE.SERVER_NAME
                  AND PDC.OBJECT_NAME = BASE.OBJECT_NAME
                  AND PDC.COUNTER_NAME = BASE.COUNTER_NAME
                  AND PDC.STATS_TIME = BASE.STATS_TIME
       INNER JOIN MyCTE PREV
               ON PDC.SERVER_NAME = PREV.SERVER_NAME
                  AND PDC.OBJECT_NAME = PREV.OBJECT_NAME
                  AND PDC.COUNTER_NAME = PREV.COUNTER_NAME
                  AND BASE.RowVersion = PREV.RowVersion - 1
UNION ALL
SELECT SERVER_NAME,
       OBJECT_NAME,
       COUNTER_NAME,
       INSTANCE_NAME,
       STATS_TIME,
       CNTR_VALUE
FROM   PERF_COUNTER_DATA PDC
WHERE  CNTR_TYPE = 65792 --REH per second stuff from above
       

UNION ALL




SELECT T1.SERVER_NAME,
       T1.OBJECT_NAME,
       T1.COUNTER_NAME,
       T1.INSTANCE_NAME,
	   T1.STATS_TIME,
       CASE T1.BASE_CNTR_VALUE-T2.BASE_CNTR_VALUE WHEN 0 THEN 0 ELSE 
	   ( T1.CNTR_VALUE - T2.CNTR_VALUE ) / ( T1.BASE_CNTR_VALUE - T2.BASE_CNTR_VALUE ) END AS CNTR_VALUE
FROM   MyCTE2 T1
       INNER JOIN MyCTE2 T2
               ON T1.SERVER_NAME = T2.SERVER_NAME
                  AND T1.OBJECT_NAME = T2.OBJECT_NAME
                  AND T1.INSTANCE_NAME = T2.INSTANCE_NAME
                  AND T1.RowVersion = T2.RowVersion - 1
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[PERF_HOURLY_WAITSTATS_VW]...';


GO


/*********  PERF DATA Wait Stats change ************************/
CREATE VIEW [dbo].[PERF_HOURLY_WAITSTATS_VW]
AS

WITH MyCTE (SERVER_NAME, STATS_TIME, WAIT_TYPE, WAITING_TASKS_COUNT, WAIT_TIME_MS, SIGNAL_WAIT_TIME_MS, RowVersion)
     AS (SELECT WS.SERVER_NAME,
                WS.STATS_TIME,
                WS.WAIT_TYPE,
                WS.WAITING_TASKS_COUNT,
                WS.WAIT_TIME_MS,
                WS.SIGNAL_WAIT_TIME_MS,
                Row_number()
                  OVER(
                    PARTITION BY SERVER_NAME, WAIT_TYPE
                    ORDER BY STATS_TIME DESC) RowVersion
         FROM   WAIT_STATS WS)
SELECT TOP 100 PERCENT WS.SERVER_NAME,WS.STATS_TIME,
                       WS.WAIT_TYPE,
                       WS.WAITING_TASKS_COUNT - PREV.WAITING_TASKS_COUNT                                                  AS WAITING_TASKS_LAST_HOUR,
                       WS.WAIT_TIME_MS - PREV.WAIT_TIME_MS                                                                AS WAIT_TIME_MS_LAST_HOUR,
                       Cast (( WS.WAIT_TIME_MS - PREV.WAIT_TIME_MS ) / ( CASE
                                                                           WHEN ( WS.WAITING_TASKS_COUNT = PREV.WAITING_TASKS_COUNT ) THEN 1.0
                                                                           ELSE ( WS.WAITING_TASKS_COUNT - PREV.WAITING_TASKS_COUNT ) * 1.0
                                                                         END ) AS NUMERIC (10, 0))                        AS AVG_WAIT_TIME_MS_LAST_HOUR,
                       WS.SIGNAL_WAIT_TIME_MS - PREV.SIGNAL_WAIT_TIME_MS                                                  AS SIGNAL_WAIT_TIME_MS_LAST_HOUR,
                       Cast (( WS.SIGNAL_WAIT_TIME_MS - PREV.SIGNAL_WAIT_TIME_MS ) / ( CASE
                                                                                         WHEN ( WS.WAITING_TASKS_COUNT = PREV.WAITING_TASKS_COUNT ) THEN 1.0
                                                                                         ELSE ( WS.WAITING_TASKS_COUNT - PREV.WAITING_TASKS_COUNT ) * 1.0
                                                                                       END ) AS NUMERIC (10, 0))          AS AVG_SIGNAL_WAIT_TIME_MS_LAST_HOUR,
                       Cast ((( WS.SIGNAL_WAIT_TIME_MS - PREV.SIGNAL_WAIT_TIME_MS )) * 100. / ( CASE
                                                                                                  WHEN ( WS.WAIT_TIME_MS = PREV.WAIT_TIME_MS ) THEN 1
                                                                                                  ELSE ( WS.WAIT_TIME_MS - PREV.WAIT_TIME_MS )
                                                                                                END ) AS NUMERIC (10, 0)) AS RATIO_SIGNAL_WAIT_TIME_TO_WAITTIME_LAST_HOUR,
                       Rank()
                         OVER (
                           partition BY WS.STATS_TIME
                           ORDER BY WS.STATS_TIME DESC, ( (WS.WAIT_TIME_MS)-(PREV.WAIT_TIME_MS)) DESC)                    AS RANK
FROM   MyCTE WS
       INNER JOIN MyCTE PREV
               ON WS.SERVER_NAME = PREV.SERVER_NAME
                  AND WS.WAIT_TYPE = PREV.WAIT_TYPE
                  AND WS.RowVersion = PREV.RowVersion - 1
ORDER  BY WS.STATS_TIME DESC,
          WS.WAIT_TIME_MS - PREV.WAIT_TIME_MS DESC,
          WS.WAIT_TYPE
GO
PRINT N'Creating [dbo].[fn_getnonclusteredcount]...';


GO

CREATE FUNCTION [dbo].[fn_getnonclusteredcount](@server_name NVARCHAR(128),@dbname AS NVARCHAR(128),@table_name AS NVARCHAR(128))
RETURNS @TABLERETURN TABLE (
  INDEX_NAME VARCHAR(128),
  COUNT      BIGINT)
AS
  BEGIN
      DECLARE @T2_NAME VARCHAR(128);
      DECLARE @T2_COUNT BIGINT;

      SET @T2_NAME = (SELECT TOP 1 INDEX_NAME
                      FROM   INDEX_STATS_VW O
                      WHERE  INDEX_ID > 1
                             AND TABLE_NAME = @table_name
                             AND DATABASE_NAME = @dbname
							 AND SERVER_NAME = @server_name
                             AND STATS_TIME > (SELECT MAX(SQL_SERVER_STARTTIME) FROM STATS_COLLECTION_SUMMARY WHERE SERVER_NAME= @server_name)
                      ORDER  BY USER_SEEKS + RANGE_SCAN_COUNT DESC);
      SET @T2_COUNT = (SELECT TOP 1 USER_SEEKS + RANGE_SCAN_COUNT
                       FROM   INDEX_STATS_VW O
                       WHERE  INDEX_ID > 1
                              AND TABLE_NAME = @table_name
                              AND DATABASE_NAME = @dbname
							  AND SERVER_NAME = @server_name
                              AND STATS_TIME > (SELECT MAX(SQL_SERVER_STARTTIME) FROM STATS_COLLECTION_SUMMARY WHERE SERVER_NAME= @server_name)
                       ORDER  BY USER_SEEKS + RANGE_SCAN_COUNT DESC);

      INSERT INTO @TABLERETURN
      VALUES      (@T2_NAME,
                   @T2_COUNT)

      RETURN;
  END
GO
PRINT N'Creating [dbo].[fn_getnonclusteredindexes]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO

CREATE FUNCTION [dbo].[fn_getnonclusteredindexes](@server_name NVARCHAR(128), @dbname AS NVARCHAR(128),@table_name AS VARCHAR(128))
RETURNS VARCHAR(128)
AS
  BEGIN
      DECLARE @T2_NAME VARCHAR(128);

      SET @T2_NAME = (SELECT TOP 1 INDEX_NAME
                      FROM   INDEX_STATS_VW O
                      WHERE  INDEX_ID < 2  -- clustered or heap
							 AND SERVER_NAME = @server_name
                             AND TABLE_NAME = @table_name
                             AND DATABASE_NAME = @dbname
							 AND STATS_TIME > (SELECT MAX(SQL_SERVER_STARTTIME) FROM STATS_COLLECTION_SUMMARY WHERE SERVER_NAME = @server_name)
                      ORDER  BY USER_SEEKS + RANGE_SCAN_COUNT DESC);

      RETURN ( @T2_NAME );
  END
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[QUERY_STATS_CURR_VW]...';


GO

CREATE VIEW [dbo].[QUERY_STATS_CURR_VW]
AS

WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT Q.SERVER_NAME,
       Q.DATABASE_NAME,
       CREATION_TIME                                                                                                AS COMPILED_TIME,
       EXECUTION_COUNT,
       EXECUTION_COUNT / CASE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                           WHEN 0 THEN 1
                           ELSE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                         END                                                                                        AS EXECUTION_PER_HOUR,
       cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                        AS TOTAL_ELAPSED_TIME,
       Q.AVG_TIME_MS                                                                                                AS AVG_ELAPSED_TIME,
       cast(MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS MAX_ELAPSED_TIME,
       AVG_LOGICAL_READS = TOTAL_LOGICAL_READS / EXECUTION_COUNT,
       AVG_LOGICAL_READS_MB = (TOTAL_LOGICAL_READS / EXECUTION_COUNT)*8/1024,
	   cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3)) - cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3)) AS TOTAL_WAIT_TIME,
       AVG_ROWS_RETURNED = TOTAL_ROWS / EXECUTION_COUNT,
       REPLACE(REPLACE(QT.SQL_TEXT,'SELECT ', CHAR(10)+'SELECT '), ' FROM', CHAR(10)+' FROM') + CHAR(10) + CHAR(10) + REPLICATE('-',50) + 'QUERY PARAMETERS'+ REPLICATE('-',61)+CHAR(10) +QP.SQL_PARMS + CHAR(10)+ CHAR(10)+
	   REPLICATE('-',50)+'TABLE NODES FROM QUERY PLAN' + REPLICATE('-',50) + CHAR(10) + ISNULL((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE Q.SERVER_NAME = QPV.SERVER_NAME AND Q.DATABASE_NAME = QPV.DATABASE_NAME AND Q.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS QUERY_PLAN_PARSED,
        ISNULL((SELECT MISSING_INDEX_INFO FROM QUERY_PLANS_MISSING_INDEX_VW QPV WHERE Q.SERVER_NAME = QPV.SERVER_NAME AND Q.DATABASE_NAME = QPV.DATABASE_NAME AND Q.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS MISSING_INDEXES,
	   QP.SQL_PARMS                                                                                                 AS QUERY_PARAMETER_VALUES,
       QUERY_PLAN,
       Q.ROW_NUM,
       Q.QUERY_HASH,
       QT.SQL_TEXT AS SQL_TEXT,
	   TOTAL_ROWS,
       MAX_ROWS,
       MIN_ROWS,
       PLAN_GENERATION_NUM,
       Q.LAST_EXECUTION_TIME,
       cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                         AS TOTAL_WORKER_TIME,
       AVG_PHYSICAL_READS = TOTAL_PHYSICAL_READS / EXECUTION_COUNT,
       AVG_LOGICAL_WRITES = TOTAL_LOGICAL_WRITES / EXECUTION_COUNT,
       cast(LAST_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                         AS LAST_ELAPSED_TIME,
       cast(MIN_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS MIN_ELAPSED_TIME,
       TOTAL_PHYSICAL_READS,
       LAST_PHYSICAL_READS,
       MIN_PHYSICAL_READS,
       MAX_PHYSICAL_READS,
       TOTAL_LOGICAL_READS,
       LAST_LOGICAL_READS,
       MIN_LOGICAL_READS,
       MAX_LOGICAL_READS,
       TOTAL_LOGICAL_WRITES,
       LAST_LOGICAL_WRITES,
       MIN_LOGICAL_WRITES,
       MAX_LOGICAL_WRITES,
       cast(LAST_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS LAST_WORKER_TIME,
       cast(MIN_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS MIN_WORKER_TIME,
       cast(MAX_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS MAX_WORKER_TIME,
       QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN),
       S.STATS_TIME,
       SQL_VERSION,
       S.SQL_SERVER_STARTTIME,
       Q.QUERY_PLAN_HASH,
       C.COMMENT
FROM   (SELECT QS2.SERVER_NAME,
               QS2.DATABASE_NAME,
               QUERY_HASH,
               max(QS2.STATS_TIME)      AS STATS_TIME,
               max(LAST_EXECUTION_TIME) AS LAST_EXECUTION_TIME
        FROM   QUERY_STATS QS2
               INNER JOIN STATS_COLLECTION_SUMMARY S2 WITH (NOLOCK)
                       ON QS2.STATS_TIME = S2.STATS_TIME
                          AND QS2.DATABASE_NAME = S2.DATABASE_NAME
                          AND QS2.SERVER_NAME = S2.SERVER_NAME
                          
        GROUP  BY QS2.SERVER_NAME,
                  QS2.DATABASE_NAME,
                  QUERY_HASH,
				  QUERY_PLAN_HASH) AS A
       INNER LOOP JOIN QUERY_STATS Q WITH (NOLOCK)
                    ON A.SERVER_NAME = Q.SERVER_NAME
                       AND A.DATABASE_NAME = Q.DATABASE_NAME
                       AND A.QUERY_HASH = Q.QUERY_HASH
                       AND A.LAST_EXECUTION_TIME = Q.LAST_EXECUTION_TIME
                       AND A.STATS_TIME = Q.STATS_TIME
       INNER JOIN QUERY_PLANS QP WITH (NOLOCK)
               ON QP.QUERY_PLAN_HASH = Q.QUERY_PLAN_HASH
                  AND QP.SERVER_NAME = Q.SERVER_NAME
                  AND QP.DATABASE_NAME = Q.DATABASE_NAME
       INNER JOIN STATS_COLLECTION_SUMMARY S WITH (NOLOCK)
               ON Q.STATS_TIME = S.STATS_TIME
                  AND Q.DATABASE_NAME = S.DATABASE_NAME
                  AND Q.SERVER_NAME = S.SERVER_NAME
       LEFT OUTER JOIN QUERY_TEXT AS QT
                    ON Q.QUERY_HASH = QT.QUERY_HASH
                       AND Q.DATABASE_NAME = QT.DATABASE_NAME
                       AND Q.SERVER_NAME = QT.SERVER_NAME
       LEFT OUTER JOIN COMMENTS C
                    ON Q.QUERY_HASH = C.QUERY_HASH
                       AND Q.SERVER_NAME = C.SERVER_NAME
                       AND Q.DATABASE_NAME = C.DATABASE_NAME
GO
PRINT N'Creating [dbo].[QUERY_STATS_VW]...';


GO

CREATE VIEW [dbo].[QUERY_STATS_VW]
AS


WITH STATS_CTE ( SERVER_NAME, DATABASE_NAME, STATS_TIME, COMPILED_TIME, EXECUTION_COUNT, TOTAL_ELAPSED_TIME, AVG_ELAPSED_TIME, MAX_ELAPSED_TIME, AVG_LOGICAL_READS, AVG_LOGICAL_READS_MB, TOTAL_WAIT_TIME, AVG_ROWS_RETURNED, QUERY_PLAN_HASH, QUERY_HASH, TOTAL_ROWS, MAX_ROWS, MIN_ROWS, PLAN_GENERATION_NUM, LAST_EXECUTION_TIME, TOTAL_WORKER_TIME, AVG_PHYSICAL_READS, AVG_LOGICAL_WRITES, LAST_ELAPSED_TIME, MIN_ELAPSED_TIME, TOTAL_PHYSICAL_READS, LAST_PHYSICAL_READS, MIN_PHYSICAL_READS, MAX_PHYSICAL_READS, TOTAL_LOGICAL_READS, LAST_LOGICAL_READS, MIN_LOGICAL_READS, MAX_LOGICAL_READS, TOTAL_LOGICAL_WRITES, LAST_LOGICAL_WRITES, MIN_LOGICAL_WRITES, MAX_LOGICAL_WRITES, LAST_WORKER_TIME, MIN_WORKER_TIME, MAX_WORKER_TIME )
     AS (SELECT QS.SERVER_NAME,
                QS.DATABASE_NAME,
                STATS_TIME,
                MIN(CREATION_TIME)                                                                                                     AS COMPILED_TIME,
                SUM(EXECUTION_COUNT)                                                                                                   AS EXECUTION_COUNT,
                CAST(SUM(TOTAL_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                             AS TOTAL_ELAPSED_TIME,
                AVG(QS.AVG_TIME_MS)                                                                                                    AS AVG_ELAPSED_TIME,
                CAST(SUM(MAX_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                               AS MAX_ELAPSED_TIME,
                AVG_LOGICAL_READS = SUM(TOTAL_LOGICAL_READS) / SUM(EXECUTION_COUNT),
                AVG_LOGICAL_READS_MB = (SUM(TOTAL_LOGICAL_READS) / SUM(EXECUTION_COUNT)) * 8 / 1024,
				CAST(SUM(TOTAL_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3)) - CAST(SUM(TOTAL_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3)) AS TOTAL_WAIT_TIME,
                AVG_ROWS_RETURNED = SUM(TOTAL_ROWS) / SUM(EXECUTION_COUNT),
                QS.QUERY_PLAN_HASH,
                QS.QUERY_HASH,
                SUM(TOTAL_ROWS)                                                                                                        AS TOTAL_ROWS,
                MAX(MAX_ROWS)                                                                                                          AS MAX_ROWS,
                MIN(MIN_ROWS)                                                                                                          AS MIN_ROWS,
                MAX(PLAN_GENERATION_NUM)                                                                                               AS PLAN_GENERATION_NUM,
                MAX(LAST_EXECUTION_TIME)                                                                                               AS LAST_EXECUTION_TIME,
                CAST(SUM(TOTAL_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                              AS TOTAL_WORKER_TIME,
                AVG_PHYSICAL_READS = SUM(TOTAL_PHYSICAL_READS) / SUM(EXECUTION_COUNT),
                AVG_LOGICAL_WRITES = SUM(TOTAL_LOGICAL_WRITES) / SUM(EXECUTION_COUNT),
                CAST(AVG(LAST_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                              AS LAST_ELAPSED_TIME,
                CAST(MIN(MIN_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                               AS MIN_ELAPSED_TIME,
                SUM(TOTAL_PHYSICAL_READS)                                                                                              AS TOTAL_PHYSICAL_READS,
                AVG(LAST_PHYSICAL_READS)                                                                                               AS LAST_PHYSICAL_READS,
                MIN(MIN_PHYSICAL_READS)                                                                                                AS MIN_PHYSICAL_READS,
                MAX(MAX_PHYSICAL_READS)                                                                                                AS MAX_PHYSICAL_READS,
                SUM(TOTAL_LOGICAL_READS)                                                                                               AS TOTAL_LOGICAL_READS,
                AVG(LAST_LOGICAL_READS)                                                                                                AS LAST_LOGICAL_READS,
                MIN(MIN_LOGICAL_READS)                                                                                                 AS MIN_LOGICAL_READS,
                MAX(MAX_LOGICAL_READS)                                                                                                 AS MAX_LOGICAL_READS,
                SUM(TOTAL_LOGICAL_WRITES)                                                                                              AS TOTAL_LOGICAL_WRITES,
                AVG(LAST_LOGICAL_WRITES)                                                                                               AS LAST_LOGICAL_WRITES,
                MIN(MIN_LOGICAL_WRITES)                                                                                                AS MIN_LOGICAL_WRITES,
                MAX(MAX_LOGICAL_WRITES)                                                                                                AS MAX_LOGICAL_WRITES,
                CAST(AVG(LAST_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                               AS LAST_WORKER_TIME,
                CAST(MIN(MIN_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                                AS MIN_WORKER_TIME,
                CAST(MAX(MAX_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                                AS MAX_WORKER_TIME
         FROM   QUERY_STATS QS WITH (NOLOCK)
         GROUP  BY QS.SERVER_NAME,
                   QS.DATABASE_NAME,
                   QS.STATS_TIME,
                   QS.QUERY_HASH,
                   QS.QUERY_PLAN_HASH)
-------------------------------------------------
SELECT CTE.SERVER_NAME,
       CTE.DATABASE_NAME,
       CTE.COMPILED_TIME,
       CTE.EXECUTION_COUNT,
       CTE.EXECUTION_COUNT / CASE ( Datediff(HOUR, CTE.COMPILED_TIME, CTE.STATS_TIME) )
                               WHEN 0 THEN 1
                               ELSE ( Datediff(HOUR, CTE.COMPILED_TIME, CTE.STATS_TIME) )
                             END                                                                                                                                                            AS EXECUTION_PER_HOUR,
       CTE.TOTAL_ELAPSED_TIME,
       CTE.AVG_ELAPSED_TIME,
       CTE.MAX_ELAPSED_TIME,
       CTE.AVG_LOGICAL_READS,
	   CTE.AVG_LOGICAL_READS_MB,
       CTE.TOTAL_WAIT_TIME,
       AVG_ROWS_RETURNED,
       Replace(Replace(QT.SQL_TEXT, 'SELECT ', Char(10)+'SELECT '), ' FROM', Char(10)+' FROM')
       + Char(10) + Char(10) + REPLICATE('-',50) + 'QUERY PARAMETERS'+ REPLICATE('-',61)+CHAR(10)  +QP.SQL_PARMS + CHAR(10)+ CHAR(10)+ 
	   REPLICATE('-',50)+'TABLE NODES FROM QUERY PLAN' + REPLICATE('-',50) + Char(10) + Isnull((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE CTE.SERVER_NAME = QPV.SERVER_NAME AND CTE.DATABASE_NAME = QPV.DATABASE_NAME AND CTE.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '') AS QUERY_PLAN_PARSED,
	    ISNULL((SELECT MISSING_INDEX_INFO FROM QUERY_PLANS_MISSING_INDEX_VW QPV WHERE CTE.SERVER_NAME = QPV.SERVER_NAME AND CTE.DATABASE_NAME = QPV.DATABASE_NAME AND CTE.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS MISSING_INDEXES,
       QP.SQL_PARMS                                                                                                                                                                         AS QUERY_PARAMETER_VALUES,
       QP.QUERY_PLAN,
       CTE.QUERY_HASH,
       CTE.QUERY_PLAN_HASH,
       QT.SQL_TEXT                                                                                                                                                                          AS SQL_TEXT,
       CTE.TOTAL_ROWS,
       CTE.MAX_ROWS,
       CTE.MIN_ROWS,
       CTE.PLAN_GENERATION_NUM,
       CTE.LAST_EXECUTION_TIME,
       CTE.TOTAL_WORKER_TIME,
       CTE.AVG_PHYSICAL_READS,
       CTE.AVG_LOGICAL_WRITES,
       CTE.LAST_ELAPSED_TIME,
       CTE.MIN_ELAPSED_TIME,
       CTE.TOTAL_PHYSICAL_READS,
       CTE.LAST_PHYSICAL_READS,
       CTE.MIN_PHYSICAL_READS,
       CTE.MAX_PHYSICAL_READS,
       CTE.TOTAL_LOGICAL_READS,
       CTE.LAST_LOGICAL_READS,
       CTE.MIN_LOGICAL_READS,
       CTE.MAX_LOGICAL_READS,
       CTE.TOTAL_LOGICAL_WRITES,
       CTE.LAST_LOGICAL_WRITES,
       CTE.MIN_LOGICAL_WRITES,
       CTE.MAX_LOGICAL_WRITES,
       CTE.LAST_WORKER_TIME,
       CTE.MIN_WORKER_TIME,
       CTE.MAX_WORKER_TIME,
       QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN),
	   CTE.STATS_TIME,
       C.COMMENT
FROM   STATS_CTE CTE
       INNER LOOP JOIN QUERY_PLANS QP WITH (NOLOCK)
                    ON QP.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH
                       AND QP.SERVER_NAME = CTE.SERVER_NAME
                       AND QP.DATABASE_NAME = CTE.DATABASE_NAME
       LEFT OUTER LOOP JOIN QUERY_TEXT AS QT
                         ON CTE.QUERY_HASH = QT.QUERY_HASH
                            AND CTE.SERVER_NAME = QT.SERVER_NAME
                            AND CTE.DATABASE_NAME = QT.DATABASE_NAME
       LEFT OUTER LOOP JOIN COMMENTS C
                         ON CTE.QUERY_HASH = C.QUERY_HASH
                            AND CTE.SERVER_NAME = C.SERVER_NAME
                            AND CTE.DATABASE_NAME = C.DATABASE_NAME
GO
PRINT N'Creating [dbo].[QUERY_HISTORY_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE VIEW [dbo].[QUERY_HISTORY_VW]
AS
  SELECT QH.SERVER_NAME,
         QH.DATABASE_NAME,
         QH.FLAG                                                                                                                                                                                 AS FLAG,
         DATE,
         EXECUTION_COUNT_TODAY                                                                                                                                                                   AS EXECUTION_COUNT,
         Cast(ELAPSED_TIME_TODAY / 1000.000 AS DECIMAL(29, 3))                                                                                                                                   AS TOTAL_ELAPSED_TIME,
         QH.AVG_TIME_TODAY_MS                                                                                                                                                                    AS AVG_ELAPSED_TIME,
         Cast(MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                                                                                                     AS MAX_ELAPSED_TIME,
         AVG_LOGICAL_READS = CASE EXECUTION_COUNT_TODAY
                               WHEN 0 THEN 0
                               ELSE TOTAL_LOGICAL_READS_TODAY / EXECUTION_COUNT_TODAY
                             END,
         AVG_LOGICAL_READS_MB = CASE EXECUTION_COUNT_TODAY
                                  WHEN 0 THEN 0
                                  ELSE ( TOTAL_LOGICAL_READS_TODAY / EXECUTION_COUNT_TODAY ) * 8 / 1024
                                END,
         Cast(ELAPSED_TIME_TODAY / 1000.000 AS DECIMAL(29, 3)) - Cast(TOTAL_WORKER_TIME_TODAY / 1000.000 AS DECIMAL(29, 3))                                                                      AS TOTAL_WAIT_TIME,
         AVG_ROWS_RETURNED = CASE EXECUTION_COUNT_TODAY
                               WHEN 0 THEN 0
                               ELSE TOTAL_ROWS_TODAY / EXECUTION_COUNT_TODAY
                             END,
         Replace(Replace(QT.SQL_TEXT, 'SELECT ', Char(10)+'SELECT '), ' FROM', Char(10)+' FROM')
         + Char(10) + Char(10) + Replicate('-', 50)
         + 'QUERY PARAMETERS' + Replicate('-', 61)
         + Char(10) + QP.SQL_PARMS + Char(10) + Char(10)
         + Replicate('-', 50)
         + 'TABLE NODES FROM QUERY PLAN'
         + Replicate('-', 50) + Char(10)
         + Isnull((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE QH.SERVER_NAME = QPV.SERVER_NAME AND QH.DATABASE_NAME = QPV.DATABASE_NAME AND QH.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '') AS QUERY_PLAN_PARSED,
         Isnull((SELECT MISSING_INDEX_INFO
                 FROM   QUERY_PLANS_MISSING_INDEX_VW QPV
                 WHERE  QH.SERVER_NAME = QPV.SERVER_NAME
                        AND QH.DATABASE_NAME = QPV.DATABASE_NAME
                        AND QH.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '')                                                                                                                       AS MISSING_INDEXES,
         QP.SQL_PARMS                                                                                                                                                                            AS QUERY_PARAMETER_VALUES,
         QP.QUERY_PLAN,
         QH.QUERY_PLAN_HASH,
         QH.QUERY_HASH,
         QT.SQL_TEXT                                                                                                                                                                             AS SQL_TEXT,
         TOTAL_ROWS_TODAY                                                                                                                                                                        AS TOTAL_ROWS,
         LAST_EXECUTION_TIME                                                                                                                                                                     AS LAST_EXECUTION_TIME,
         TOTAL_LOGICAL_READS_TODAY                                                                                                                                                               AS TOTAL_LOGICAL_READS,
         QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN)
  FROM   QUERY_HISTORY QH WITH (NOLOCK)
         INNER LOOP JOIN QUERY_PLANS QP WITH (NOLOCK)
                      ON QP.QUERY_PLAN_HASH = QH.QUERY_PLAN_HASH
                         AND QP.SERVER_NAME = QH.SERVER_NAME
                         AND QP.DATABASE_NAME = QH.DATABASE_NAME
         LEFT OUTER LOOP JOIN QUERY_TEXT AS QT
                           ON QH.QUERY_HASH = QT.QUERY_HASH
                              AND QH.SERVER_NAME = QT.SERVER_NAME
                              AND QH.DATABASE_NAME = QT.DATABASE_NAME
         LEFT OUTER LOOP JOIN COMMENTS C
                           ON QH.QUERY_HASH = C.QUERY_HASH
                              AND QH.SERVER_NAME = C.SERVER_NAME
                              AND QH.DATABASE_NAME = C.DATABASE_NAME
  WHERE  EXECUTION_COUNT_TODAY > 0
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[QUERY_ALERTS_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE VIEW [dbo].[QUERY_ALERTS_VW]
	AS 

	SELECT QA.SERVER_NAME,
       QA.DATABASE_NAME,
       QA.STATS_TIME                                                                                                                                                                           AS ALERT_TIME,
       QA.QUERY_HASH,
       QA.QUERY_PLAN_HASH,
       QHD.EXECUTION_COUNT_TODAY                                                                                                                                                               AS EXECUTIONS_TODAY,
       CAST(QHD.ELAPSED_TIME_TODAY / 1000.000 AS DECIMAL(29, 3))                                                                                                                               AS TOTAL_TIME_TODAY,
       QHD.AVG_TIME_TODAY_MS                                                                                                                                                                   AS AVG_TIME_TODAY,
       CAST(QHD.MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                                                                                                 AS MAX_ELAPSED_TIME,
       REPLACE(REPLACE(QT.SQL_TEXT, 'SELECT ', CHAR(10)+'SELECT '), ' FROM', CHAR(10)+' FROM')
       + CHAR(10) + CHAR(10) + REPLICATE('-', 50)
       + 'QUERY PARAMETERS' + REPLICATE('-', 61)
       + CHAR(10) + QP.SQL_PARMS + CHAR(10) + CHAR(10)
       + REPLICATE('-', 50)
       + 'TABLE NODES FROM QUERY PLAN'
       + REPLICATE('-', 50) + CHAR(10)
       + ISNULL((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE QA.SERVER_NAME = QPV.SERVER_NAME AND QA.DATABASE_NAME = QPV.DATABASE_NAME AND QA.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '') AS QUERY_PLAN_PARSED,
       ISNULL((SELECT MISSING_INDEX_INFO
               FROM   QUERY_PLANS_MISSING_INDEX_VW QPV
               WHERE  QA.SERVER_NAME = QPV.SERVER_NAME
                      AND QA.DATABASE_NAME = QPV.DATABASE_NAME
                      AND QA.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '')                                                                                                                       AS MISSING_INDEXES,
       QP.SQL_PARMS                                                                                                                                                                            AS QUERY_PARAMETER_VALUES,
       QP.QUERY_PLAN,
       QT.SQL_TEXT
FROM   QUERY_ALERTS QA WITH (NOLOCK)
       INNER JOIN QUERY_HISTORY QHD
               ON QA.SERVER_NAME = QHD.SERVER_NAME
                  AND QA.DATABASE_NAME = QHD.DATABASE_NAME
                  AND QA.QUERY_HASH = QHD.QUERY_HASH
                  AND QA.QUERY_PLAN_HASH = QHD.QUERY_PLAN_HASH
				  AND QHD.FLAG = 'D'
                  AND QHD.DATE = DATEADD(day, DATEDIFF(day, 0, QA.STATS_TIME), 0)
       INNER LOOP JOIN QUERY_PLANS QP WITH (NOLOCK)
                    ON QP.QUERY_PLAN_HASH = QA.QUERY_PLAN_HASH
                       AND QP.SERVER_NAME = QA.SERVER_NAME
                       AND QP.DATABASE_NAME = QA.DATABASE_NAME
       LEFT OUTER LOOP JOIN QUERY_TEXT AS QT
                         ON QA.QUERY_HASH = QT.QUERY_HASH
                            AND QA.SERVER_NAME = QT.SERVER_NAME
                            AND QA.DATABASE_NAME = QT.DATABASE_NAME
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[HIDDEN_SCANS_CURR_VW]...';


GO

CREATE VIEW [dbo].[HIDDEN_SCANS_CURR_VW] AS
WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT *
FROM   (SELECT SERVER_NAME,
               ROW_NUM,
               SQL_TEXT,
               CONVERT (NVARCHAR(MAX), index_node2.query('for $qplan in //sp:QueryPlan, $plist in $qplan/sp:ParameterList, $colref in $plist/sp:ColumnReference  return concat(string($colref/@Column),":",string($colref/@ParameterCompiledValue),",   "),"  "')) AS QUERY_PARAMETER_VALUES,
               QUERY_PLAN,
               Replace(Replace(index_node.value('(.//@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                                                                                                                                                             AS TABLE_NAME,
               Replace(Replace(index_node.value('(.//@Index)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                                                                                                                                                             AS INDEX_NAME,
               CONVERT(NVARCHAR(MAX), index_node.query('for $seekpredicate in ./sp:SeekPredicates,
                                                            $rangecolumns in $seekpredicate//sp:RangeColumns,
                                                            $columnreference in $rangecolumns/sp:ColumnReference
                                        return string($columnreference/@Column)'))                                                                                                                                                                  AS SEEK_COLUMNS,
               EXECUTION_COUNT,
               TOTAL_ELAPSED_TIME,
               TOTAL_WORKER_TIME,
               AVG_ELAPSED_TIME,
               AVG_PHYSICAL_READS,
               AVG_LOGICAL_READS,
               AVG_LOGICAL_WRITES,
               LAST_ELAPSED_TIME,
               MIN_ELAPSED_TIME,
               MAX_ELAPSED_TIME,
               TOTAL_PHYSICAL_READS,
               LAST_PHYSICAL_READS,
               MIN_PHYSICAL_READS,
               MAX_PHYSICAL_READS,
               TOTAL_LOGICAL_READS,
               LAST_LOGICAL_READS,
               MIN_LOGICAL_READS,
               MAX_LOGICAL_READS,
               TOTAL_LOGICAL_WRITES,
               LAST_LOGICAL_WRITES,
               MIN_LOGICAL_WRITES,
               MAX_LOGICAL_WRITES,
               LAST_WORKER_TIME,
               MIN_WORKER_TIME,
               MAX_WORKER_TIME,
               QUERY_PLAN_TEXT,
               STATS_TIME,
               SQL_VERSION,
               COMMENT
        FROM   QUERY_STATS_CURR_VW
               OUTER APPLY QUERY_PLAN.nodes('//sp:RelOp/sp:IndexScan') AS SeekPredicates(index_node)
               CROSS APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node2)
) A
		WHERE  SEEK_COLUMNS = 'DATAAREAID' OR SEEK_COLUMNS = 'PARTITION DATAAREAID' OR SEEK_COLUMNS = 'PARTITION'
GO
PRINT N'Creating [dbo].[USER_SCANS_CURR_VW]...';


GO


CREATE VIEW [dbo].[USER_SCANS_CURR_VW] 
AS



WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT *
FROM 
(
SELECT SERVER_NAME,
       DATABASE_NAME,
       ROW_NUM,
       QUERY_HASH,
       EXECUTION_COUNT,
       TOTAL_ELAPSED_TIME,
       AVG_ELAPSED_TIME,
       AVG_LOGICAL_READS,
       SQL_TEXT,
       CONVERT (NVARCHAR(MAX), index_node2.query('for $qplan in //sp:QueryPlan, $plist in $qplan/sp:ParameterList, $colref in $plist/sp:ColumnReference  return concat(string($colref/@Column),":",string($colref/@ParameterCompiledValue),",   "),"  "')) AS QUERY_PARAMETER_VALUES,
       QUERY_PLAN,
       index_node.value('(.//@PhysicalOp)[1]', 'NVARCHAR(128)')                                                                                                                                                                                            AS PHYSICAL_OPERATOR,
       Replace(Replace(index_node.value('(.//@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                                                                                                                                                             AS TABLE_NAME,
       Replace(Replace(index_node.value('(.//@Index)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                                                                                                                                                             AS INDEX_NAME,
       Replace(CONVERT(NVARCHAR(MAX), index_node.query('for $indexscan in ./sp:IndexScan,
										$predicate in $indexscan/sp:Predicate,
										$columnreference in $predicate//sp:ColumnReference
                                        return string($columnreference/@Column)')), ' ', ', ')                                                                                                                                                      AS PREDICATE_COLUMNS,
       TOTAL_WORKER_TIME,
       AVG_PHYSICAL_READS,
       AVG_LOGICAL_WRITES,
       LAST_ELAPSED_TIME,
       MIN_ELAPSED_TIME,
       MAX_ELAPSED_TIME,
       TOTAL_PHYSICAL_READS,
       LAST_PHYSICAL_READS,
       MIN_PHYSICAL_READS,
       MAX_PHYSICAL_READS,
       TOTAL_LOGICAL_READS,
       LAST_LOGICAL_READS,
       MIN_LOGICAL_READS,
       MAX_LOGICAL_READS,
       TOTAL_LOGICAL_WRITES,
       LAST_LOGICAL_WRITES,
       MIN_LOGICAL_WRITES,
       MAX_LOGICAL_WRITES,
       LAST_WORKER_TIME,
       MIN_WORKER_TIME,
       MAX_WORKER_TIME,
       QUERY_PLAN_TEXT,
       STATS_TIME,
       SQL_VERSION,
       COMMENT
FROM   QUERY_STATS_CURR_VW
       OUTER APPLY QUERY_PLAN.nodes('//sp:RelOp') AS Operators(index_node)
       CROSS APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node2) 


) A
WHERE PHYSICAL_OPERATOR LIKE '%Index_Scan%'
UNION ALL
SELECT *
FROM 
(
SELECT SERVER_NAME,
       DATABASE_NAME,
       ROW_NUM,
       QUERY_HASH,
       EXECUTION_COUNT,
       TOTAL_ELAPSED_TIME,
       AVG_ELAPSED_TIME,
       AVG_LOGICAL_READS,
       SQL_TEXT,
       CONVERT (NVARCHAR(MAX), index_node2.query('for $qplan in //sp:QueryPlan, $plist in $qplan/sp:ParameterList, $colref in $plist/sp:ColumnReference  return concat(string($colref/@Column),":",string($colref/@ParameterCompiledValue),",   "),"  "')) AS QUERY_PARAMETER_VALUES,
       QUERY_PLAN,
       index_node.value('(.//@PhysicalOp)[1]', 'NVARCHAR(128)')                                                                                                                                                                                            AS PHYSICAL_OPERATOR,
       Replace(Replace(index_node.value('(.//@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                                                                                                                                                             AS TABLE_NAME,
       Replace(Replace(index_node.value('(.//@Index)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                                                                                                                                                             AS INDEX_NAME,
       Replace(CONVERT(NVARCHAR(MAX), index_node.query('for $indexscan in ./sp:IndexScan,
										$predicate in $indexscan/sp:Predicate,
										$columnreference in $predicate//sp:ColumnReference
                                        return string($columnreference/@Column)')), ' ', ', ')                                                                                                                                                      AS PREDICATE_COLUMNS,
       TOTAL_WORKER_TIME,
       AVG_PHYSICAL_READS,
       AVG_LOGICAL_WRITES,
       LAST_ELAPSED_TIME,
       MIN_ELAPSED_TIME,
       MAX_ELAPSED_TIME,
       TOTAL_PHYSICAL_READS,
       LAST_PHYSICAL_READS,
       MIN_PHYSICAL_READS,
       MAX_PHYSICAL_READS,
       TOTAL_LOGICAL_READS,
       LAST_LOGICAL_READS,
       MIN_LOGICAL_READS,
       MAX_LOGICAL_READS,
       TOTAL_LOGICAL_WRITES,
       LAST_LOGICAL_WRITES,
       MIN_LOGICAL_WRITES,
       MAX_LOGICAL_WRITES,
       LAST_WORKER_TIME,
       MIN_WORKER_TIME,
       MAX_WORKER_TIME,
       QUERY_PLAN_TEXT,
       STATS_TIME,
       SQL_VERSION,
       COMMENT
FROM   QUERY_STATS_CURR_VW
       OUTER APPLY QUERY_PLAN.nodes('//sp:RelOp') AS Operators(index_node)
       CROSS APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node2) 


) A
WHERE PHYSICAL_OPERATOR LIKE '%Table Scan%'
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_TRIGGER_INFO]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_TRIGGER_INFO (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_TRIG_SYSOBJECTS')
  EXEC ('DROP SYNONYM [dbo].DYN_TRIG_SYSOBJECTS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_TRIG_SYSOBJECTS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.objects'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_TRIG_SYSOBJECTS
				FOR [' + @DATABASE_NAME + '].sys.objects'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_TRIG_SYS_SYSOBJECTS')
  EXEC ('DROP SYNONYM [dbo].DYN_TRIG_SYS_SYSOBJECTS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_TRIG_SYS_SYSOBJECTS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.sysobjects'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_TRIG_SYS_SYSOBJECTS
				FOR [' + @DATABASE_NAME + '].sys.sysobjects'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_TRIG_SYSSCHEMAS')
  EXEC ('DROP SYNONYM [dbo].DYN_TRIG_SYSSCHEMAS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_TRIG_SYSSCHEMAS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.schemas'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_TRIG_SYSSCHEMAS
				FOR [' + @DATABASE_NAME + '].sys.schemas'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

DELETE FROM [DynamicsPerf]..TRIGGER_TABLE WHERE DATABASE_NAME = @DATABASE_NAME AND RUN_NAME LIKE @SERVER_NAME + '%'

INSERT TRIGGER_TABLE
SELECT @RUN_NAME,
       @DATABASE_NAME,
       p.name,
       t.name
FROM   DYN_TRIG_SYS_SYSOBJECTS t
       INNER JOIN DYN_TRIG_SYSOBJECTS p
               ON t.parent_obj = p.object_id
       INNER JOIN DYN_TRIG_SYSSCHEMAS SCH
               ON t.uid = SCH.schema_id
WHERE  t.type = 'TR' 

    
  
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_WAITSTATS]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_WAITSTATS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @PREV_STATS_TIME DATETIME
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_WS_WAITSTATS')
  EXEC ('DROP SYNONYM [dbo].DYN_WS_WAITSTATS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_WS_WAITSTATS
				FOR [' + @SERVER_NAME + '].[master].sys.dm_os_wait_stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_WS_WAITSTATS
				FOR [master].sys.dm_os_wait_stats'
IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)






--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 





BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


INSERT 	INTO WAIT_STATS 
SELECT 	@SERVER_NAME, @STATS_DATE, *
FROM 	DYN_WS_WAITSTATS
WHERE WAIT_TYPE <> 'MISCELLANEOUS'


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[SET_AX_SQLTRACE]...';


GO


CREATE PROCEDURE [dbo].[SET_AX_SQLTRACE] @SERVER_NAME NVARCHAR(128) = @@SERVERNAME,
								@DATABASE_NAME    NVARCHAR(128),
                                 @QUERY_TIME_LIMIT INT = 5000,
                                 @AX_ID            NVARCHAR(10) = NULL,
                                 @TRACE_STATUS     NVARCHAR(3) = 'ON', 
                               --  @CLIENTACESSLOG   INT = 0,
								 @OVERRIDE		INT = 0
AS

  DECLARE @SQL NVARCHAR(1000),
          @RC  INT

  SET @RC = 0



         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_AXT_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_AXT_SYSDATABASES')

         IF @SERVER_NAME <> @@SERVERNAME
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_AXT_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_AXT_SYSDATABASES
				FOR master.sys.databases'


         EXEC (@SQL) -- CREATE SYNONYM

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_AXT_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

IF @OVERRIDE = 0 AND @QUERY_TIME_LIMIT < 5000 SET @QUERY_TIME_LIMIT = 5000

  IF @TRACE_STATUS = 'ON'
    BEGIN
        
          SET @SQL = 'UPDATE [' +@SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO
				SET QUERYTIMELIMIT = ' + Str(@QUERY_TIME_LIMIT) + ',
					DEBUGINFO =  268,
					TRACEINFO =  2048'
			IF @AX_ID IS NOT NULL	
			SET @SQL = @SQL + 	' WHERE ID = ''' + @AX_ID + ''''	
			

				MERGE AX_SQLTRACE_CONFIG AS target
				USING (SELECT @SERVER_NAME AS SERVER_NAME,
							  @DATABASE_NAME AS DATABASE_NAME,
							  @QUERY_TIME_LIMIT AS SQL_DURATION,
							  1                 AS TRACE_ON,		--REH Turns it ON
							  14 AS AXDB_DELETION_DAYS
) AS source
				ON ( source.SERVER_NAME = target.SERVER_NAME
					 AND source.DATABASE_NAME = target.DATABASE_NAME )
				WHEN MATCHED THEN
				  UPDATE SET SQL_DURATION = source.SQL_DURATION,
							 TRACE_ON = source.TRACE_ON
				WHEN NOT MATCHED THEN
				  INSERT ( [SERVER_NAME],
						   [DATABASE_NAME],
						   [SQL_DURATION],
						   [TRACE_ON],
						   [AXDB_DELETION_DAYS])
				  VALUES (source.[SERVER_NAME],
						  source.[DATABASE_NAME],
						  source.[SQL_DURATION],
						  source.[TRACE_ON],
						  14);		--REH default 14 days, DYNPERF_SET_AX_SQLTRACE sproc will delete from systracetable in the AX database using this value
									-- setting it to 0 disables this feature
			
			END
  ELSE
    IF @TRACE_STATUS = 'OFF'
      BEGIN
          IF @AX_ID IS NULL
            SET @SQL = 'UPDATE [' +@SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO
				SET QUERYTIMELIMIT = 0,
					DEBUGINFO =  12,
					TRACEINFO =  0'
					
			IF @AX_ID IS NOT NULL	
			SET @SQL = @SQL + 	' WHERE ID = ''' + @AX_ID + ''''	

        	--REH Insert a record so that our scheduled job auto updates it
MERGE AX_SQLTRACE_CONFIG AS target
				USING (SELECT @SERVER_NAME AS SERVER_NAME,
							  @DATABASE_NAME AS DATABASE_NAME,
							  @QUERY_TIME_LIMIT AS SQL_DURATION,
							  0                 AS TRACE_ON,		--REH Turns it OFF
							  14 AS AXDB_DELETION_DAYS
					  ) AS source
				ON ( source.SERVER_NAME = target.SERVER_NAME
					 AND source.DATABASE_NAME = target.DATABASE_NAME )
				WHEN MATCHED THEN
				  UPDATE SET SQL_DURATION = source.SQL_DURATION,
							 TRACE_ON = source.TRACE_ON
				WHEN NOT MATCHED THEN
				  INSERT ( [SERVER_NAME],
						   [DATABASE_NAME],
						   [SQL_DURATION],
						   [TRACE_ON],
						   [AXDB_DELETION_DAYS])
				  VALUES (source.[SERVER_NAME],
						  source.[DATABASE_NAME],
						  source.[SQL_DURATION],
						  source.[TRACE_ON],
						  14); --REH default 14 days, DYNPERF_SET_AX_SQLTRACE sproc will delete from systracetable in the AX database using this value
								-- setting it to 0 disables this feature
      END
    ELSE
      PRINT 'Invalid @TRACE_STATUS option; must be ON or OFF'

  PRINT @SQL
  EXEC (@SQL)
 

 
  ENDPROC:

  ERROR:

  RETURN @RC
GO
PRINT N'Creating [dbo].[DYNPERF_AX_VERSION_INFO]...';


GO

CREATE PROCEDURE DYNPERF_AX_VERSION_INFO (@AX_SERVER_NAME      NVARCHAR(128) = NULL,
                                          @AX_DATABASE_NAME    NVARCHAR(128),
                                          @DEBUG            NVARCHAR(1) = 'N')
                                      
AS
    /************************************************************************************************************
    *  SETUP
    *		DECLARE VARIABLES, CREATE SYNONYMS, ETC
    *
    *************************************************************************************************************/
    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL           NVARCHAR(MAX),
            @SQL2          NVARCHAR(MAX),
            @REMOTE_SERVER NVARCHAR(1),
			@AX_APP_BUILD_OUT NVARCHAR(120) ,
            @KERNEL_BUILD_OUT NVARCHAR(20),
			@AX_VERSION NVARCHAR(20)

    /*************************************************
    
    --REH Template for creating a synonym, 
    --Will help avoid having to use EXEC (@SQL) code
    -- and make the code more dynamic to the inputs
    
    
    ***************************************************/
    SET @REMOTE_SERVER = CASE @AX_SERVER_NAME
                           WHEN @@SERVERNAME THEN 'N'
                           ELSE 'Y'
                         END

    IF EXISTS (SELECT *
               FROM   sys.synonyms
               WHERE  name = 'DYN_AVI_AX_SYSSETUPLOG')
      DROP SYNONYM [dbo].DYN_AVI_AX_SYSSETUPLOG

    IF @REMOTE_SERVER = 'Y'
         BEGIN
             SET @SQL = '
				CREATE SYNONYM DYN_AVI_AX_SYSSETUPLOG
				FOR [' + @AX_SERVER_NAME + '].['
                        + @AX_DATABASE_NAME + '].dbo.SYSSETUPLOG'
         END
    ELSE
      SET @SQL = '
				CREATE SYNONYM DYN_AVI_AX_SYSSETUPLOG
				FOR [' + @AX_DATABASE_NAME
                 + '].dbo.SYSSETUPLOG'

    IF @DEBUG = 'Y'
         BEGIN
             PRINT '@SQL= ' + @SQL
         END

    EXEC (@SQL)

    IF EXISTS (SELECT *
               FROM   sys.synonyms
               WHERE  name = 'DYN_AVI_AX_SYSCONFIG')
      DROP SYNONYM [dbo].DYN_AVI_AX_SYSCONFIG

    IF @REMOTE_SERVER = 'Y'
         BEGIN
             SET @SQL = '
				CREATE SYNONYM DYN_AVI_AX_SYSCONFIG
				FOR [' + @AX_SERVER_NAME + '].['
                        + @AX_DATABASE_NAME + '].dbo.SYSCONFIG'
         END
    ELSE
      SET @SQL = '
				CREATE SYNONYM DYN_AVI_AX_SYSCONFIG
				FOR [' + @AX_DATABASE_NAME
                 + '].dbo.SYSCONFIG'

    IF @DEBUG = 'Y'
         BEGIN
             PRINT '@SQL= ' + @SQL
         END

    EXEC (@SQL)

     /********************************************************************************************************************************
     *   STARTING TASK
     *********************************************************************************************************************************/
     BEGIN TRY
         SELECT TOP 1 @KERNEL_BUILD_OUT = KERNELBUILD, @AX_VERSION = VERSION
         FROM   DYN_AVI_AX_SYSSETUPLOG WITH (NOLOCK)
         ORDER  BY RECID DESC

         SELECT TOP 1 @AX_APP_BUILD_OUT = VALUE
         FROM   DYN_AVI_AX_SYSCONFIG WITH (NOLOCK)
         WHERE  CONFIGTYPE = 4
                AND ID = 6

		IF ISNULL(@KERNEL_BUILD_OUT,'') = ''
			BEGIN
				SET @AX_APP_BUILD_OUT = @AX_VERSION  --REH work around for AX7 atm
				SET @KERNEL_BUILD_OUT = @AX_VERSION 
			END
		SELECT @AX_APP_BUILD_OUT AS AX_APP_BUILD, @KERNEL_BUILD_OUT AS AX_KERNEL_BUILD


		    IF EXISTS (SELECT *
               FROM   sys.synonyms
               WHERE  name = 'DYN_AVI_AX_SYSSETUPLOG')
      DROP SYNONYM [dbo].DYN_AVI_AX_SYSSETUPLOG

	      IF EXISTS (SELECT *
               FROM   sys.synonyms
               WHERE  name = 'DYN_AVI_AX_SYSCONFIG')
      DROP SYNONYM [dbo].DYN_AVI_AX_SYSCONFIG

     END TRY

     /********************************************************************************************************************************
     *   END OF TASK
     *********************************************************************************************************************************/
     BEGIN CATCH
         PRINT 'ERROR IN COLLECTING AX VERSION INFORAMTION '

		 		    IF EXISTS (SELECT *
               FROM   sys.synonyms
               WHERE  name = 'DYN_AVI_AX_SYSSETUPLOG')
      DROP SYNONYM [dbo].DYN_AVI_AX_SYSSETUPLOG

	      IF EXISTS (SELECT *
               FROM   sys.synonyms
               WHERE  name = 'DYN_AVI_AX_SYSCONFIG')
      DROP SYNONYM [dbo].DYN_AVI_AX_SYSCONFIG


     END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_AX_SYSGLOBALCONFIG]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_AX_SYSGLOBALCONFIG (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



DELETE FROM AX_SYSGLOBALCONFIGURATION WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME

--REH Get AX version

DECLARE @AX_SERVER_NAME   NVARCHAR(128) = NULL,
        @AX_DATABASE_NAME NVARCHAR(128),
        @AX_APP_BUILD     NVARCHAR(120),
        @KERNEL_BUILD     NVARCHAR(20)
   
   CREATE TABLE #AX_VERSION_SGC
     (
        AX_APP_BUILD NVARCHAR(120),
        KERNEL_BUILD NVARCHAR(20)
     )
   
   SET NOCOUNT ON
   
   INSERT #AX_VERSION_SGC
   EXECUTE DYNPERF_AX_VERSION_INFO
     @AX_SERVER_NAME = @SERVER_NAME,
     @AX_DATABASE_NAME = @DATABASE_NAME--, @DEBUG = 'N'
   SELECT @AX_APP_BUILD = AX_APP_BUILD,
          @KERNEL_BUILD = KERNEL_BUILD
   FROM   #AX_VERSION_SGC
   
   --PRINT 'AX BUILD = ' + ISNULL(@AX_APP_BUILD, '')
   
   --PRINT 'KERNEL BUILD = '+ ISNULL(@KERNEL_BUILD, '')
   
IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = '#AX_VERSION_SGC') 
 BEGIN 
	DROP TABLE  #AX_VERSION_SGC 
 END
   
   
  
IF Substring(@AX_APP_BUILD, 1, 1) BETWEEN N'4' AND N'5'
BEGIN

		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AXSGC_AX_SQLSYSTEMVARIABLES')
		  EXEC ('DROP SYNONYM [dbo].DYN_AXSGC_AX_SQLSYSTEMVARIABLES')

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL = '
						CREATE SYNONYM DYN_AXSGC_AX_SQLSYSTEMVARIABLES
						FOR [' + @SERVER_NAME + '].['
							+ @DATABASE_NAME
							+ '].dbo.SQLSYSTEMVARIABLES'
			 END
		ELSE
		  SET @SQL = '
						CREATE SYNONYM DYN_AXSGC_AX_SQLSYSTEMVARIABLES
						FOR [' + @DATABASE_NAME
					 + '].dbo.SQLSYSTEMVARIABLES'

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END

		EXEC (@SQL) 

	INSERT DynamicsPerf..AX_SYSGLOBALCONFIGURATION 
	SELECT @SERVER_NAME, @DATABASE_NAME,PARM, VALUE
	FROM DYN_AXSGC_AX_SQLSYSTEMVARIABLES
	






END

IF Substring(@AX_APP_BUILD, 1, 1) = N'6'  
    BEGIN	
		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')
		  EXEC('DROP SYNONYM [dbo].DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL = '
						CREATE SYNONYM DYN_AXSGC_AX_SYSGLOBALCONFIGURATION
						FOR [' + @SERVER_NAME + '].['
							+ @DATABASE_NAME
							+ '].dbo.SYSGLOBALCONFIGURATION'
			 END
		ELSE
		  SET @SQL = '
						CREATE SYNONYM DYN_AXSGC_AX_SYSGLOBALCONFIGURATION
						FOR [' + @DATABASE_NAME
					 + '].dbo.SYSGLOBALCONFIGURATION'

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END

		EXEC (@SQL) 

	INSERT DynamicsPerf..AX_SYSGLOBALCONFIGURATION 
	SELECT @SERVER_NAME, @DATABASE_NAME,NAME, VALUE
	FROM DYN_AXSGC_AX_SYSGLOBALCONFIGURATION
	
	
	END
	

	
IF Substring(@AX_APP_BUILD, 1, 1) = N'7'  
    BEGIN	
		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')
		  EXEC('DROP SYNONYM [dbo].DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL = '
						CREATE SYNONYM DYN_AXSGC_AX_SYSGLOBALCONFIGURATION
						FOR [' + @SERVER_NAME + '].['
							+ @DATABASE_NAME
							+ '].dbo.SYSGLOBALCONFIGURATION'
			 END
		ELSE
		  SET @SQL = '
						CREATE SYNONYM DYN_AXSGC_AX_SYSGLOBALCONFIGURATION
						FOR [' + @DATABASE_NAME
					 + '].dbo.SYSGLOBALCONFIGURATION'

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END

		EXEC (@SQL) 

	INSERT DynamicsPerf..AX_SYSGLOBALCONFIGURATION 
	SELECT @SERVER_NAME, @DATABASE_NAME,NAME, VALUE
	FROM DYN_AXSGC_AX_SYSGLOBALCONFIGURATION
	
	
	END
	
	
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) + ', ' + CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AXSGC_AX_SQLSYSTEMVARIABLES')
		  EXEC ('DROP SYNONYM [dbo].DYN_AXSGC_AX_SQLSYSTEMVARIABLES')

		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')
		  EXEC('DROP SYNONYM [dbo].DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')






RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'


		  		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AXSGC_AX_SQLSYSTEMVARIABLES')
		  EXEC ('DROP SYNONYM [dbo].DYN_AXSGC_AX_SQLSYSTEMVARIABLES')

		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')
		  EXEC('DROP SYNONYM [dbo].DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')







    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_AX_NUMBERSEQUENCE]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_AX_NUMBERSEQUENCE (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @ROW_COUNT BIGINT
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/


--REH All versions have this table so it's here in the code
-- version specific synonyms are in the appropriate AX version below


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCETABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCETABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCETABLE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCETABLE
				FOR [' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCETABLE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 











/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


--REH Get AX version

DECLARE @AX_SERVER_NAME   NVARCHAR(128) = NULL,
        @AX_DATABASE_NAME NVARCHAR(128),
        @AX_APP_BUILD     NVARCHAR(120),
        @KERNEL_BUILD     NVARCHAR(20)
   
   CREATE TABLE #AX_VERSION_NUM
     (
        AX_APP_BUILD NVARCHAR(120),
        KERNEL_BUILD NVARCHAR(20)
     )
   
   SET NOCOUNT ON
   
   INSERT #AX_VERSION_NUM
   EXECUTE DYNPERF_AX_VERSION_INFO
     @AX_SERVER_NAME = @SERVER_NAME,
     @AX_DATABASE_NAME = @DATABASE_NAME--, @DEBUG = 'N'
   SELECT @AX_APP_BUILD = AX_APP_BUILD,
          @KERNEL_BUILD = KERNEL_BUILD
   FROM   #AX_VERSION_NUM
   
   --PRINT 'AX BUILD = ' + ISNULL(@AX_APP_BUILD, '')
   
   --PRINT 'KERNEL BUILD = '+ ISNULL(@KERNEL_BUILD, '')
   
   IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = '#AX_VERSION_NUM') 
	BEGIN
	  DROP TABLE #AX_VERSION_NUM 
	END
   
   
  
IF Substring(@AX_APP_BUILD, 1, 1) BETWEEN N'4' AND N'5'
BEGIN



--REH  Have to check if the NUMBERSEQUENCETABLE is shared or not, aka. does DATAAREAID exist in the table

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSTABLES')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSTABLES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSTABLES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.tables'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSTABLES
				FOR [' + @DATABASE_NAME + '].sys.tables'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSCOLUMNS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSCOLUMNS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.columns'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSCOLUMNS
				FOR [' + @DATABASE_NAME + '].sys.columns'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


		--REH store data by company, most common scenario
		IF EXISTS (SELECT * FROM DYN_AXNUM_SYSTABLES t INNER JOIN DYN_AXNUM_SYSCOLUMNS c
		ON t.object_id=c.object_id
		WHERE t.name = 'NUMBERSEQUENCETABLE' AND c.name = 'DATAAREAID') 
		BEGIN
			INSERT INTO AX_NUM_SEQUENCES
			SELECT @SERVER_NAME,
				   @STATS_DATE,
				   @DATABASE_NAME,
				   0,
				   NUMBERSEQUENCE,
				   TXT,
				   LOWEST,
				   HIGHEST,
				   NEXTREC,
				   0,
				   0,
				   CASE CONTINUOUS
					 WHEN 0 THEN 'No'
					 WHEN 1 THEN 'Yes'
				   END,
				   FETCHAHEAD,
				   FETCHAHEADQTY,
				   0,
				   0,
				   NULL,
				   NULL,
				   DATAAREAID,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   FORMAT
			FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE 


		END
		ELSE
		BEGIN
		
			INSERT INTO AX_NUM_SEQUENCES
			SELECT @SERVER_NAME,
				   @STATS_DATE,
				   @DATABASE_NAME,
				   0,
				   NUMBERSEQUENCE,
				   TXT,
				   LOWEST,
				   HIGHEST,
				   NEXTREC,
				   0,
				   0,
				   CASE CONTINUOUS
					 WHEN 0 THEN 'No'
					 WHEN 1 THEN 'Yes'
				   END,
				   FETCHAHEAD,
				   FETCHAHEADQTY,
				   0,
				   0,
				   NULL,
				   NULL,
				   '',			--blank out dataareid, field doesn't exist
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   FORMAT
			FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE 


		
		END

		SET @ROW_COUNT = @@ROWCOUNT
	
END

--REH Synonyms for all version of AX2012 --------------------------------------------------

IF Substring(@AX_APP_BUILD, 1, 1) = '6'
BEGIN
	

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
 EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.DATAAREA'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @DATABASE_NAME + '].dbo.DATAAREA'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)
	
END



IF Substring(@AX_APP_BUILD, 1, 1) = '7'
BEGIN
	

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.DATAAREA'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @DATABASE_NAME + '].dbo.DATAAREA'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)
	
		
	
	
PRINT ''	
END

-------------------------------------------End of AX2012 common synonyms -------------------


IF Substring(@AX_APP_BUILD, 1, 3) = '6.0'
BEGIN




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_COMPANYINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_COMPANYINFO')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_COMPANYINFO
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.COMPANYINFO'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_COMPANYINFO
				FOR [' + @DATABASE_NAME + '].dbo.COMPANYINFO'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_OMOPERATINGUNIT')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_OMOPERATINGUNIT')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_OMOPERATINGUNIT
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.OMOPERATINGUNIT'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_OMOPERATINGUNIT
				FOR [' + @DATABASE_NAME + '].dbo.OMOPERATINGUNIT'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

INSERT INTO AX_NUM_SEQUENCES
SELECT @SERVER_NAME,
       @STATS_DATE,
       @DATABASE_NAME,
       NST.RECID,
       NST.NUMBERSEQUENCE                                                                                                                                 AS [NumberSequence],
       NST.TXT                                                                                                                                            AS [Text],
       NST.LOWEST,
       NST.HIGHEST,
       NST.NEXTREC,
       CAST (( CAST(( NST.HIGHEST - NST.NEXTREC ) AS DECIMAL(20, 2)) / ( CAST(( NST.HIGHEST - NST.LOWEST ) AS DECIMAL(20, 2)) ) * 100 ) AS DECIMAL(5, 2)) AS [PercentRemaining],
       NST.HIGHEST - NST.NEXTREC                                                                                                                          AS [NumbersRemaining],
       CASE NST.CONTINUOUS
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Continuous],
       NST.FETCHAHEAD                                                                                                                                     AS FetchAhead,
       NST.FETCHAHEADQTY                                                                                                                                  AS FetchAheadQty,
       NST.CLEANINTERVAL                                                                                                                                  AS CleanInterval,
       NST.CLEANATACCESS                                                                                                                                  AS CleanAtAccess,
       'N/A'                                                                                                                                              AS [PartitionName],
       NST.NUMBERSEQUENCESCOPE,
       DA.ID                                                                                                                                              [CompanyId],
       DA.NAME                                                                                                                                            [CompanyName],
       CASE DA.ISVIRTUAL
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Shared],
       CI.DATAAREA                                                                                                                                        [LegalEntityName],
       CASE OU.OMOPERATINGUNITTYPE
         WHEN 0 THEN 'None'
         WHEN 1 THEN 'Department'
         WHEN 2 THEN 'Cost center'
         WHEN 3 THEN 'Value stream'
         WHEN 4 THEN 'Business unit'
         WHEN 5 THEN 'All operating units'
         WHEN 6 THEN 'Retail channel'
       END                                                                                                                                                [OperatingUnitType],
       OU.OMOPERATINGUNITNUMBER                                                                                                                           [OperatingUnitNumber],
       FC.CALENDARID                                                                                                                                      [FiscalCalendar],
       FCY.NAME                                                                                                                                           [FiscalCalendarYear],
       FCP.NAME                                                                                                                                           [Period],
       NST.FORMAT
FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE NST
       JOIN DYN_AXNUM_AX_NUMBERSEQUENCESCOPE NSS
         ON NSS.RECID = NST.NUMBERSEQUENCESCOPE
       LEFT JOIN DYN_AXNUM_AX_DATAAREA DA
              ON NSS.DATAAREA = DA.ID
       LEFT JOIN DYN_AXNUM_AX_COMPANYINFO CI
              ON NSS.LEGALENTITY = CI.RECID
       LEFT JOIN DYN_AXNUM_AX_OMOPERATINGUNIT OU
              ON NSS.OPERATINGUNIT = OU.RECID
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARPERIOD FCP
              ON NSS.FISCALCALENDARPERIOD = FCP.RECID
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDAR FC
              ON FC.RECID = FCP.FISCALCALENDAR
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARYEAR FCY
              ON FCY.RECID = FCP.FISCALCALENDARYEAR

	
	SET @ROW_COUNT = @@ROWCOUNT
END
	
IF Substring(@AX_APP_BUILD, 1, 3) IN ( '6.2', '6.3', '7.0')
BEGIN
	


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_PARTITIONS')
  EXEC('DROP SYNONYM [dbo].DYN_AXNUM_AX_PARTITIONS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_PARTITIONS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.PARTITIONS'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_PARTITIONS
				FOR [' + @DATABASE_NAME + '].dbo.PARTITIONS'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DIRPARTYTABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DIRPARTYTABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DIRPARTYTABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.DIRPARTYTABLE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DIRPARTYTABLE
				FOR [' + @DATABASE_NAME + '].dbo.DIRPARTYTABLE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

INSERT INTO AX_NUM_SEQUENCES
SELECT @SERVER_NAME,
       @STATS_DATE,
       @DATABASE_NAME,
       NST.RECID,
       NST.NUMBERSEQUENCE                                                                                                                                 AS [NumberSequence],
       NST.TXT                                                                                                                                            AS [Text],
       NST.LOWEST,
       NST.HIGHEST,
       NST.NEXTREC,
       CAST (( CAST(( NST.HIGHEST - NST.NEXTREC ) AS DECIMAL(20, 2)) / ( CAST(( NST.HIGHEST - NST.LOWEST ) AS DECIMAL(20, 2)) ) * 100 ) AS DECIMAL(5, 2)) AS [PercentRemaining],
       NST.HIGHEST - NST.NEXTREC                                                                                                                          AS [NumbersRemaining],
       CASE NST.CONTINUOUS
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Continuous],
       NST.FETCHAHEAD                                                                                                                                     AS FetchAhead,
       NST.FETCHAHEADQTY                                                                                                                                  AS FetchAheadQty,
       NST.CLEANINTERVAL                                                                                                                                  AS CleanInterval,
       NST.CLEANATACCESS                                                                                                                                  AS CleanAtAccess,
       P.NAME                                                                                                                                             AS [PartitionName],
       NST.NUMBERSEQUENCESCOPE,
       DA.ID                                                                                                                                              [CompanyId],
       DA.NAME                                                                                                                                            [CompanyName],
       CASE DA.ISVIRTUAL
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Shared],
       DI.DATAAREA                                                                                                                                        [LegalEntityName],
       CASE DI.OMOPERATINGUNITTYPE
         WHEN 0 THEN 'None'
         WHEN 1 THEN 'Department'
         WHEN 2 THEN 'Cost center'
         WHEN 3 THEN 'Value stream'
         WHEN 4 THEN 'Business unit'
         WHEN 5 THEN 'All operating units'
         WHEN 6 THEN 'Retail channel'
       END                                                                                                                                                [OperatingUnitType],
       DI.OMOPERATINGUNITNUMBER                                                                                                                           [OperatingUnitNumber],
       FC.CALENDARID                                                                                                                                      [FiscalCalendar],
       FCY.NAME                                                                                                                                           [FiscalCalendarYear],
       FCP.NAME                                                                                                                                           [Period],
       NST.FORMAT
FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE NST
       JOIN DYN_AXNUM_AX_PARTITIONS P
         ON NST.PARTITION = P.RECID
       JOIN DYN_AXNUM_AX_NUMBERSEQUENCESCOPE NSS
         ON NSS.RECID = NST.NUMBERSEQUENCESCOPE
       LEFT JOIN DYN_AXNUM_AX_DATAAREA DA
              ON NSS.DATAAREA = DA.ID
       LEFT JOIN DYN_AXNUM_AX_DIRPARTYTABLE DI
              ON ( NSS.LEGALENTITY = DI.RECID )
                  OR ( NSS.OPERATINGUNIT = DI.RECID )
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARPERIOD FCP
              ON NSS.FISCALCALENDARPERIOD = FCP.RECID
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDAR FC
              ON FC.RECID = FCP.FISCALCALENDAR
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARYEAR FCY
              ON FCY.RECID = FCP.FISCALCALENDARYEAR


	SET @ROW_COUNT = @@ROWCOUNT

END
    


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@ROW_COUNT as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


--REH Drop all synonyms

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCETABLE')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSTABLES')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSTABLES')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSCOLUMNS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
 EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_COMPANYINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_COMPANYINFO')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_OMOPERATINGUNIT')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_OMOPERATINGUNIT')



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_PARTITIONS')
  EXEC('DROP SYNONYM [dbo].DYN_AXNUM_AX_PARTITIONS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DIRPARTYTABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DIRPARTYTABLE')




RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/




BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

--REH Drop all synonyms

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCETABLE')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSTABLES')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSTABLES')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSCOLUMNS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
 EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_COMPANYINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_COMPANYINFO')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_OMOPERATINGUNIT')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_OMOPERATINGUNIT')



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_PARTITIONS')
  EXEC('DROP SYNONYM [dbo].DYN_AXNUM_AX_PARTITIONS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DIRPARTYTABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DIRPARTYTABLE')





    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[SP_PARSE_PLAN_COMPARE]...';


GO


 CREATE PROCEDURE [dbo].[SP_PARSE_PLAN_COMPARE] 
      @QUERY_PLAN_HASH_C VARCHAR(18)

AS BEGIN

declare @QUERY_PLAN_HASH_COMPARE varbinary(8);

select @QUERY_PLAN_HASH_COMPARE = cast('' as xml).value('xs:hexBinary( substring(sql:variable("@QUERY_PLAN_HASH_C"), sql:column("t.pos")) )', 'varbinary(8)')

from (select case substring(@QUERY_PLAN_HASH_C, 1, 2) when '0x' then 3 else 0 end) as t(pos);

WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)

  SELECT    

            REPLICATE('------', 
                    coalesce(index_node.value('(../../@NodeId)[1]', 'INT'),-1)+1) +
            index_node.value('(./@LogicalOp)[1]', 'NVARCHAR(128)') as LOGICAL_OPERATOR,
            index_node.value('(./@PhysicalOp)[1]', 'NVARCHAR(128)') as PHYSICAL_OPERATOR,
            COALESCE(REPLACE(REPLACE(index_node.value('(./*/sp:Object/@Table)[1]', 'NVARCHAR(128)'), '[',''),']',''), '') as TABLE_NAME,
            COALESCE( REPLACE(REPLACE(index_node.value('(./*/sp:Object/@Index)[1]', 'NVARCHAR(128)'), '[',''),']',''), '') as INDEX_NAME,


            index_node.value('(./@EstimateRows)[1]', 'FLOAT') as ESTIMATED_ROWS,
            index_node.value('(./@EstimateIO)[1]', 'FLOAT') as ESTIMATED_IO,
            index_node.value('(./@EstimateCPU)[1]', 'FLOAT') as ESTIMATED_CPU
  FROM QUERY_PLANS
  OUTER APPLY QUERY_PLAN.nodes('//sp:RelOp') as Operators(index_node)
  
  WHERE QUERY_PLAN_HASH =  @QUERY_PLAN_HASH_COMPARE

  
 END
GO
PRINT N'Creating [dbo].[SP_PARSE_PLAN_BASE]...';


GO


CREATE PROCEDURE [dbo].[SP_PARSE_PLAN_BASE] 
      @QUERY_PLAN_HASH_B VARCHAR(18)

AS BEGIN

declare @QUERY_PLAN_HASH_BASE varbinary(8);

select @QUERY_PLAN_HASH_BASE = cast('' as xml).value('xs:hexBinary( substring(sql:variable("@QUERY_PLAN_HASH_B"), sql:column("t.pos")) )', 'varbinary(8)')

from (select case substring(@QUERY_PLAN_HASH_B, 1, 2) when '0x' then 3 else 0 end) as t(pos);

WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)

  SELECT    

            REPLICATE('------', 
                    coalesce(index_node.value('(../../@NodeId)[1]', 'INT'),-1)+1) +
            index_node.value('(./@LogicalOp)[1]', 'NVARCHAR(128)') as LOGICAL_OPERATOR,
            index_node.value('(./@PhysicalOp)[1]', 'NVARCHAR(128)') as PHYSICAL_OPERATOR,
            COALESCE(REPLACE(REPLACE(index_node.value('(./*/sp:Object/@Table)[1]', 'NVARCHAR(128)'), '[',''),']',''), '') as TABLE_NAME,
            COALESCE( REPLACE(REPLACE(index_node.value('(./*/sp:Object/@Index)[1]', 'NVARCHAR(128)'), '[',''),']',''), '') as INDEX_NAME,


            index_node.value('(./@EstimateRows)[1]', 'FLOAT') as ESTIMATED_ROWS,
            index_node.value('(./@EstimateIO)[1]', 'FLOAT') as ESTIMATED_IO,
            index_node.value('(./@EstimateCPU)[1]', 'FLOAT') as ESTIMATED_CPU
  FROM QUERY_PLANS
  OUTER APPLY QUERY_PLAN.nodes('//sp:RelOp') as Operators(index_node)
  
  WHERE QUERY_PLAN_HASH =  @QUERY_PLAN_HASH_BASE

  
 END
GO
PRINT N'Creating [dbo].[SP_PARSE_PLAN]...';


GO

create PROCEDURE [dbo].[SP_PARSE_PLAN] 
      @QUERY_PLAN_HASH_V VARCHAR(18),
      @STATS_TIME DATETIME,
      @DATABASE_NAME    NVARCHAR(128)
AS BEGIN

declare @QUERY_PLAN_HASH varbinary(8);

select @QUERY_PLAN_HASH = cast('' as xml).value('xs:hexBinary( substring(sql:variable("@QUERY_PLAN_HASH_V"), sql:column("t.pos")) )', 'varbinary(8)')

from (select case substring(@QUERY_PLAN_HASH_V, 1, 2) when '0x' then 3 else 0 end) as t(pos);

WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)

  SELECT    

            REPLICATE('------', 
                    coalesce(index_node.value('(../../@NodeId)[1]', 'INT'),-1)+1) +
            index_node.value('(./@LogicalOp)[1]', 'NVARCHAR(128)') as LOGICAL_OPERATOR,
            index_node.value('(./@PhysicalOp)[1]', 'NVARCHAR(128)') as PHYSICAL_OPERATOR,
            COALESCE(REPLACE(REPLACE(index_node.value('(./*/sp:Object/@Table)[1]', 'NVARCHAR(128)'), '[',''),']',''), '') as TABLE_NAME,
            COALESCE( REPLACE(REPLACE(index_node.value('(./*/sp:Object/@Index)[1]', 'NVARCHAR(128)'), '[',''),']',''), '') as INDEX_NAME,


            index_node.value('(./@EstimateRows)[1]', 'FLOAT') as ESTIMATED_ROWS,
            index_node.value('(./@EstimateIO)[1]', 'FLOAT') as ESTIMATED_IO,
            index_node.value('(./@EstimateCPU)[1]', 'FLOAT') as ESTIMATED_CPU
  FROM QUERY_PLANS
  OUTER APPLY QUERY_PLAN.nodes('//sp:RelOp') as Operators(index_node)
  
  WHERE QUERY_PLAN_HASH =  @QUERY_PLAN_HASH

  
 END
GO
PRINT N'Creating [dbo].[SP_CAPTURESTATS]...';


GO



CREATE	PROCEDURE [dbo].[SP_CAPTURESTATS]
		@SERVER_NAME	NVARCHAR(128) = NULL,
		@DATABASE_NAME	NVARCHAR(128) = NULL ,
		@DYNAMICS_PRODUCT NVARCHAR(3)  = NULL,
		@TASK_TYPE		VARCHAR(50) = 'COLLECT',
		@AZURE_DB		BIT = 0,
		@TOP_ROWS		INT = 0,
		@TOP_COLUMN		NVARCHAR(128) = 'total_elapsed_time',
		@RUN_NAME		NVARCHAR(128) = NULL,
		@INDEX_PHYSICAL_STATS 	NCHAR(1)= 'N',
		@DEBUG			NVARCHAR(1)= 'N'

AS


SET NOCOUNT ON
SET DATEFORMAT MDY

SET ANSI_NULLS ON
SET ANSI_WARNINGS ON
SET ANSI_NULL_DFLT_ON ON
SET ANSI_PADDING ON


DECLARE @STATS_DATE		DATETIME, 
		@SQL_VERSION	NVARCHAR(1000), 
		@DYNAMICS_VERSION NVARCHAR(MAX),
		@DATABASE_ID	INT,
		@RETURN_CODE	INT,
		@SQL			NVARCHAR(MAX),
		@RUN_DESCRIPTION NVARCHAR(1000),
		@SQL_TOP_CLAUSE	NVARCHAR(128),
		@SQL_ORDERBY_CLAUSE	NVARCHAR(128),
		@PARM			NVARCHAR(500),
		@SQL_SERVER_STARTTIME DATETIME,
		@RC INT,
		@TASK_PROCEDURE NVARCHAR(128),
		@TASK_PARAMETERS NVARCHAR(1024),
		@TASK_DESCRIPTION NVARCHAR(256),
		@LAST_SERVER_NAME NVARCHAR(128) = 'ZZZ',  --REH This is used to trigger inserting a new STATS_COLLECTION_SUMMARY record
		@LAST_DATABASE_NAME NVARCHAR(128) = 'ZZZ',
		@LAST_STATS_DATE DATETIME,
		@REMOTE_SERVER NVARCHAR(1) = 'N',
		@TASK_STARTTIME DATETIME,
		@TASK_ENDTIME DATETIME,
		@TASK_TIME BIGINT,
		@SQL_STARTTIME DATETIME,
		@SQL_BUILD NVARCHAR(20),
		@SQL2 NVARCHAR(MAX),
		@MANUAL_CAPTURE NVARCHAR(1) = 'N',
		@SQL_TZ_OFFSET INT,
		@DPA_TZ_OFFSET INT 

		
		
DECLARE
	@C_SERVER_NAME NVARCHAR(128),
	@C_DATABASE_NAME NVARCHAR(128),
	@C_TASK_ID INT,
	@C_TASK_PROCEDURE NVARCHAR(128),
	@C_TASK_PARAMS NVARCHAR(1024),
	@C_TASK_DESC NVARCHAR(256),
	@C_SERVER_LEVEL_TASK BIT,
	@C_AZURE_DB  BIT,
	@C_LAST_RUN DATETIME
	
		
--REH Time zone off set for the DynamicsPerf database at time of collection
		SET @DPA_TZ_OFFSET = DATEDIFF(MI,GETUTCDATE(),GETDATE())

	IF @DATABASE_NAME IS NOT NULL SET @MANUAL_CAPTURE = 'Y'

	SET @STATS_DATE = GETDATE()
--REH  Verify database exists if being manually passed, skip check if Azure DB, no access to sys.databases catalogue

IF ( @AZURE_DB = 0 and ( @SERVER_NAME IS NOT NULL
      OR @DATABASE_NAME IS NOT NULL ))
     BEGIN

	 
	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_CS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_CS_QUERY_SYSDATABASES')

         IF @REMOTE_SERVER = 'Y'
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_CS_QUERY_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_CS_QUERY_SYSDATABASES
				FOR master.sys.databases'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END

         EXEC (@SQL) -- SELECT * FROM DYN_CS_QUERY_SYSDATABASES

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_CS_QUERY_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

         --REH Make sure there is a record in DATABASES_2_COLLECT or insert if new combination
         IF (SELECT COUNT(*)
             FROM   DATABASES_2_COLLECT
             WHERE  LINKED_SERVER = ISNULL(@SERVER_NAME, @@SERVERNAME)
                    AND DATABASE_NAME = @DATABASE_NAME) < 1
              BEGIN
                  INSERT DATABASES_2_COLLECT
                  VALUES(ISNULL(@SERVER_NAME,@@SERVERNAME),
                         @DATABASE_NAME,
                         ISNULL(@DYNAMICS_PRODUCT, 'ALL'),
                         1,
                         2,
                         24,
						 60,
						 2,
						 90,
						 7)
              END
     END 


	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END



---------------------------------------------------------------------------------------------
--
--  Insert Capture_log entry with paramater values used for the run
--
----------------------------------------------------------------------------------------------

INSERT CAPTURE_LOG  SELECT @TASK_TYPE, @STATS_DATE, 'SP_CAPTURESTATS PARMS PASSED @SERVER_NAME = ' + ISNULL(@SERVER_NAME,'NOT PASSED') + ' @DATABASE_NAME = ' + ISNULL(@DATABASE_NAME,'NOT PASSED') +  ' @DEBUG = ' + @DEBUG + '  ' + CHAR(10) + CHAR(13)



SET @RETURN_CODE = 0

DELETE FROM  COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH Default is 'COLLECT' for this sproc.  CAN'T TRUNCATE MULTIPLE SPROCS USING THIS TABLE



IF @DATABASE_NAME IS NULL  --REH AKA, not a manual capture
  BEGIN
      INSERT COLLECTIONDATABASES
      SELECT ISNULL(LINKED_SERVER, @@SERVERNAME),
             [DATABASE_NAME],
             [DYNAMICS_PRODUCT],
             [AZURE_DB],
             [ENABLED],
			 @TASK_TYPE
      FROM   DATABASES_2_COLLECT
      WHERE  ENABLED = 1 -- db must be enabled for autostats collection to work with it
  END
ELSE
  BEGIN   --REH  Insert DBname of the manual capture
      INSERT COLLECTIONDATABASES
      VALUES(ISNULL(@SERVER_NAME, @@SERVERNAME),
             @DATABASE_NAME,
             @DYNAMICS_PRODUCT,
             @AZURE_DB,
             1,
			 @TASK_TYPE)
  END 


--REH Insert any missing task history records in case it's a new database being collected, so we don't fail to capture against the db because of no records
-- yes, this is a cartesian join between these 2 tables

INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE	--REH default is 'COLLECT' in parm definition of this sproc
       AND NOT EXISTS (SELECT 'X'
                       FROM   DYNPERF_TASK_HISTORY DTH
                       WHERE  DTS.TASK_ID = DTH.TASK_ID
                              AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                              AND CD.DATABASE_NAME = DTH.DATABASE_NAME)
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 0 --REH Ok, to put 1 record per database in for DB type tasks


	   
--REH Need to insert 1 bogus record for each server level task, or the join on the cursor will fail

INSERT COLLECTIONDATABASES 
 SELECT	DISTINCT [LINKED_SERVER],
             'N/A',
            'ALL',
             [AZURE_DB],
             [ENABLED],
			 [TASK_TYPE]
FROM COLLECTIONDATABASES CD
WHERE DATABASE_NAME <> 'N/A'
AND TASK_TYPE = @TASK_TYPE
AND NOT EXISTS (SELECT 'X' FROM COLLECTIONDATABASES CD2 WHERE CD2.LINKED_SERVER = CD.LINKED_SERVER AND CD2.DATABASE_NAME = 'N/A')



--REH now lets insert server level tasks with a blank DB name so we only do them once per server
INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       'N/A',
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE  --REH default is 'COLLECT' in parm definition of this sproc
		AND CD.DATABASE_NAME <> 'N/A'
       AND NOT EXISTS (SELECT 'X'
                   FROM   DYNPERF_TASK_HISTORY DTH
                   WHERE  DTS.TASK_ID = DTH.TASK_ID
                          AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                          AND DTH.DATABASE_NAME = 'N/A') --REH making the db name = 'N/A' for server level tasks
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 1 






	IF @DEBUG = 'Y'
	BEGIN
		PRINT 'MANUAL_CAPTURE = ' + @MANUAL_CAPTURE
	END

	--REH Create here and truncate table in each loop

	 --  CREATE TABLE #SQL_INFO
  --   (
  --      SQL_STARTTIME DATETIME,
  --      SQL_BUILD NVARCHAR(20),
		--TZ_OFFSET INT
  --   )


/********************************************************************************
Rod Hansen

Added a trigger to DATABASES_2_COLLECT so that we always have a 
DYNPERF_TASK_HISTORY record for this code 

********************************************************************************/

DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT DISTINCT DTS.TASK_ID,
       CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_PROCEDURE,
       DTS.TASK_PARAMETERS,
       DTS.TASK_DESCRIPTION,
       DTS.SERVER_LEVEL_TASK,
       CD.AZURE_DB,
       ISNULL(DTH.LAST_RUN, '1/1/1900')
FROM   DynamicsPerf..[DYNPERF_TASK_SCHEDULER] DTS
       LEFT OUTER JOIN DynamicsPerf..[DYNPERF_TASK_HISTORY] DTH
                    ON DTH.TASK_ID = DTS.TASK_ID
       INNER JOIN DynamicsPerf..COLLECTIONDATABASES CD
               ON CD.DATABASE_NAME = DTH.DATABASE_NAME
                  AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
WHERE
  --REH Task is enabled
  DTS.ENABLED = 1
  AND
  --REH It's the correct task type C = COLLECTOR, P = PROCESS, M = MONITOR, ETC
  DTS.TASK_TYPE = @TASK_TYPE
  AND
  --REH database is enabled
  CD.ENABLED = 1
  AND
  --REH Azure_db, if Azure db, then task must support it
  ( CD.AZURE_DB = DTS.AZURE_DB_SUPPORTED
     OR CD.AZURE_DB = 0 )
  --REH Either its an Azure Task, all Azure tasks will run locally, so if task supports AZ and we pass 0, run it anyways
  AND ( DTS.AZURE_DB_SUPPORTED = @AZURE_DB
         OR ( DTS.AZURE_DB_SUPPORTED = 1
              AND @AZURE_DB = 0 ) )
  AND
  --REH it's either All products or matches the Dynamics Product
  ( DTS.DYNAMICS_PRODUCT = 'ALL'
     OR DTS.DYNAMICS_PRODUCT = CD.DYNAMICS_PRODUCT )
  AND
  --REH Scheduling options now
(
  --REH In the case of minutes or hous, we ignore schedule time and just figure out if it's time to run again
  ( @MANUAL_CAPTURE = 'Y'
     OR ( @MANUAL_CAPTURE = 'N'
          AND ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                  WHEN 'MI' THEN DATEADD(MINUTE, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                END ) <= GETDATE()
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'HH' THEN DATEADD(HOUR, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                --REH and it is on the hour
                AND ( ABS(DATEDIFF(MI, DATEADD(Hour, DATEDIFF(Hour, 0, GETDATE()), 0), GETDATE())) <= 1 ) )
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'DD' THEN DATEADD(DAY, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'WK' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'MM' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'QQ' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'YY' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                AND ( --REH TIME IS NULL SO IGNORE IT
                    COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) IS NULL
                     OR --REH Current time = Scheduled time 
                    ( SUBSTRING((SELECT REPLACE(CONVERT(VARCHAR(10), GETDATE(), 108), ':', '')), 1, 4) = (SELECT REPLICATE('0', 4 - LEN( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME)))
                                                                                                                 + CAST( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) AS VARCHAR(4))) ) ) )
         --REH and last_run < current time
         )--AND CONVERT(VARCHAR(10), LAST_RUN, 108) <= CONVERT(VARCHAR(10), Getdate(), 108) ) 
   )
)
ORDER  BY CD.LINKED_SERVER,
          CD.DATABASE_NAME,
          DTS.TASK_ID 



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */


	          SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


--Insert new STATS_COLLECTION_SUMMARY RECORD, we want 1 RUN_NAME per server not per database
IF @C_SERVER_NAME <> @LAST_SERVER_NAME OR @C_DATABASE_NAME <> @LAST_DATABASE_NAME
BEGIN
    SET @RUN_NAME = ISNULL(@C_SERVER_NAME, @@SERVERNAME)+ ' '
                    + CAST(@STATS_DATE AS VARCHAR(30))

TRUNCATE TABLE WRK_CS_SQL_INFO   --REH clear out table to repopulate

 DELETE FROM COLLECTIONDATABASES WHERE LINKED_SERVER = @LAST_SERVER_NAME AND DATABASE_NAME = @LAST_DATABASE_NAME AND TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE


 
SELECT @SQL = 'SELECT create_date AS SQL_STARTTIME,
       CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))    AS SQL_BUILD,
	   DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
		FROM sys.databases WHERE name = ''TempDB'''

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


   
   SET NOCOUNT ON
 
IF @REMOTE_SERVER = 'N'
BEGIN
		   INSERT WRK_CS_SQL_INFO
		EXEC( @SQL)
END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
			IF @C_AZURE_DB = 0
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT create_date AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROM sys.databases WHERE name = ''TempDB''"	)'
			END
			IF @C_AZURE_DB = 1
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT DATEADD(ms,AVG(-wait_time_ms), GETDATE()) AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROMsys.dm_os_wait_stats w WHEREwait_type
IN(''DIRTY_PAGE_POLL'',''HADR_FILESTREAM_IOMGR_IOCOMPLETION'',''LAZYWRITER_SLEEP'',''LOGMGR_QUEUE'',''REQUEST_FOR_DEADLOCK_SEARCH'',''XE_DISPATCHER_WAIT'',''XE_TIMER_EVENT'') "	)'
			END


				IF @DEBUG = 'Y'
                  BEGIN
                      PRINT '@SQL= ' + @SQL2
                  END 
                
			INSERT WRK_CS_SQL_INFO
				EXEC (@SQL2) 
 
 END
 
 SELECT @SQL_STARTTIME = SQL_STARTTIME, @SQL_BUILD = SQL_BUILD, @SQL_TZ_OFFSET = TZ_OFFSET FROM WRK_CS_SQL_INFO
 TRUNCATE TABLE WRK_CS_SQL_INFO --REH Cleanout the table for next loop





		INSERT INTO [DynamicsPerf].[dbo].[STATS_COLLECTION_SUMMARY]
					([SERVER_NAME],
					 [STATS_TIME],
					 [RUN_NAME],
					 [DATABASE_NAME],
					 [SQL_VERSION],
					 [DYNAMICS_VERSION],
					 [RUN_DESCRIPTION],
					 [SQL_SERVER_STARTTIME],
					 [SQL_SERVER_TZ_OFFSET] ,
					 [DPA_TZ_OFFSET])
		VALUES      (@C_SERVER_NAME,
					 @STATS_DATE,
					 @RUN_NAME,
					 @C_DATABASE_NAME,
					 @SQL_BUILD,--<SQL_VERSION>
					 '',--<DYNAMICS_VERSION>
					 '',--<RUN_DESCRIPTION>
					 @SQL_STARTTIME, -- <SQL_SERVER_STARTTIME>
					 @SQL_TZ_OFFSET,  -- Time Zone offset in minutes of database collected
					 @DPA_TZ_OFFSET  -- Time Zone of the DynamicsPerf database
					) 
				
END 

SET @LAST_SERVER_NAME = @C_SERVER_NAME
SET @LAST_DATABASE_NAME = @C_DATABASE_NAME


SET @REMOTE_SERVER = CASE @C_SERVER_NAME
                       WHEN @@SERVERNAME THEN 'N'
                       ELSE 'Y'
                     END 



--Create synonyms for the sproc

--IF  EXISTS (SELECT * FROM sys.synonyms WHERE name = 'DYN_CS_CAPTURE_SPROC')
--DROP SYNONYM [dbo].[DYN_CS_CAPTURE_SPROC]
--SET @SQL = '
--CREATE SYNONYM DYN_CS_CAPTURE_SPROC
--FOR [DynamicsPerf].dbo.[' + @C_TASK_PROCEDURE + ']'

--IF @DEBUG = 'Y' 
--BEGIN
--PRINT '@SQL= ' + @SQL
--END

--EXEC(@SQL) 

IF @DEBUG = 'Y' 
BEGIN
PRINT 'TASK ID = ' + CAST(@C_TASK_ID AS VARCHAR(10))
PRINT 'SERVER NAME = ' + @C_SERVER_NAME 
PRINT 'DATABASE NAME = ' + @C_DATABASE_NAME
PRINT 'TASK PARMS = ' + ISNULL(@C_TASK_PARAMS, '')
PRINT 'TASK DESC = ' + ISNULL(@C_TASK_DESC,'')
PRINT 'LAST RUN = ' + ISNULL(CAST(@C_LAST_RUN AS VARCHAR(30)),'')
PRINT 'RUN NAME = ' + ISNULL(@RUN_NAME,'')
PRINT 'STATS DATE = ' + CAST(@STATS_DATE AS VARCHAR(30))
PRINT 'REMNOTE SERVER FLAG = ' + ISNULL(@REMOTE_SERVER,'')
PRINT 'AZURE DB = ' + CAST(@C_AZURE_DB AS CHAR(1))


END
			
	

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@C_TASK_DESC, '') + CONVERT(VARCHAR, GETDATE(), 109)
PRINT ''


SET @TASK_STARTTIME = GETDATE()
SET @C_TASK_PARAMS = ISNULL(@C_TASK_PARAMS,'')


IF @DEBUG = 'Y'
BEGIN

	PRINT 'SERVER TIME ZONE OFFSET = ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
	PRINT 'AT LAST RUN  = ' + CAST(@C_LAST_RUN AS VARCHAR(30))

END

--REH Adjust the last_run time to UTC Time, the called sproc's will adjust it to local time unless we've never collected
IF @C_LAST_RUN > '1/1/1901'
BEGIN
SET @C_LAST_RUN = DATEADD(MI,@DPA_TZ_OFFSET *-1 ,@C_LAST_RUN)
END



IF @DEBUG = 'Y'
BEGIN
	PRINT 'AT LAST RUN TIME BEING PASSED TO SPROC ' + CAST(@C_LAST_RUN AS VARCHAR(30))
END

SELECT @SQL = 'EXEC ' + @C_TASK_PROCEDURE + '  @TASK_ID=' + CAST(@C_TASK_ID AS NVARCHAR(10)) + 
' ,@SERVER_NAME = ' + '''' +  @C_SERVER_NAME + '''' +
' ,@DATABASE_NAME = ' + '''' +  @C_DATABASE_NAME + '''' +
' ,@TASK_PARAMS = ' +  '''' +  @C_TASK_PARAMS + '''' +
' ,@TASK_DESC = ' + '''' +  @C_TASK_DESC + '''' +
' ,@LAST_RUN = ' + '''' + CONVERT(VARCHAR, @C_LAST_RUN, 109) + '''' +
' ,@RUN_NAME = ' + '''' +  @RUN_NAME + '''' +
' ,@STATS_DATE = ' + '''' + CONVERT(VARCHAR, @STATS_DATE, 109) + '''' +
' ,@REMOTE_SERVER = ' + '''' +  @REMOTE_SERVER + '''' +
' ,@AZURE_DB = ' + CAST(@C_AZURE_DB AS NVARCHAR(10)) + 
' ,@SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET AS NVARCHAR(10)) + 
' ,@DPA_TZ_OFFSET = ' + CAST(@DPA_TZ_OFFSET AS NVARCHAR(10)) + 


' ,@DEBUG = '  + '''' +  @DEBUG + ''''



UPDATE CAPTURE_LOG
SET    TEXT = TEXT  + CHAR(13) + CHAR(10) + '***** ' + @C_TASK_PROCEDURE
			+ CHAR(13) + CHAR(10)
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE



EXECUTE @RC = sp_executesql @SQL

   					  
SET @TASK_ENDTIME = GETDATE()

SET @TASK_TIME = DATEDIFF(ss,@TASK_STARTTIME, @TASK_ENDTIME)

  
--REH update last  [DYNPERF_TASK_HISTORY] IF THE TASK WAS SUCCESSFUL


  
 IF @RC = 0
      BEGIN
          PRINT ''
 
          PRINT 'SUCCESSFULLY CAPTURED '
                + ISNULL(@C_TASK_DESC, '') +  ' for SERVER '
              + ISNULL(@C_SERVER_NAME, '') + ' on database '
              + ISNULL(@C_DATABASE_NAME, '') + ' in ' + cast(@TASK_TIME AS VARCHAR(20)) + ' SECONDS '
 
       --REH if a manual capture don't update last run so we don't mess up the scheduling engine
				 IF @MANUAL_CAPTURE = 'N'
				 BEGIN
						  MERGE DynamicsPerf..[DYNPERF_TASK_HISTORY] AS target
						  USING (SELECT @C_SERVER_NAME   AS SERVER_NAME,
										@C_DATABASE_NAME AS DATABASE_NAME,
										@C_TASK_ID       AS TASK_ID,
										@STATS_DATE      AS LAST_RUN,
										@TASK_TIME	AS LAST_EXECUTION_TIME_SECS 
												) AS source
						  ON ( source.SERVER_NAME = target.LINKEDSERVER_NAME
							   AND source.DATABASE_NAME = target.DATABASE_NAME
							   AND source.TASK_ID = target.TASK_ID )
						  WHEN MATCHED THEN
							UPDATE SET LAST_RUN = source.LAST_RUN, [LAST_EXECUTION_TIME_SECS] = source.[LAST_EXECUTION_TIME_SECS]
						  WHEN NOT MATCHED THEN
							INSERT ( [LINKEDSERVER_NAME],
									 [DATABASE_NAME],
									 [TASK_ID],
									 [LAST_RUN],
									 [LAST_EXECUTION_TIME_SECS])
							VALUES (source.SERVER_NAME,
									source.DATABASE_NAME,
									source.TASK_ID,
									source.LAST_RUN,
									source.LAST_EXECUTION_TIME_SECS );
				END
      END
 ELSE
	IF @RC = 1  --REH SPROC HANDLED THE ERROR
      BEGIN
          PRINT ''
 
          PRINT 'FAILED !!!!!! ' + ISNULL(@C_TASK_DESC, '')
 
          PRINT ''
      END 
 
  


           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_CS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_CS_QUERY_SYSDATABASES')



END TRY 

BEGIN CATCH


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PROCEDURE FAILED !!! '
              + ISNULL(@C_TASK_DESC, 'TASK') + ' for SERVER
	'
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) + ', '
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE

PRINT 'ERROR WHILE COLLECTING ' + ISNULL(@C_TASK_DESC, '') +' !!!!!!!!!!!!!!'




         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_CS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_CS_QUERY_SYSDATABASES')

END CATCH



FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
	  DELETE FROM COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
		

ENDPROC:
PRINT 'RUN NAME = '+ @RUN_NAME
GO
PRINT N'Creating [dbo].[SP_SQLTRACE]...';


GO



-- ***********************************************************************
-- ***********************************************************************
CREATE           PROCEDURE [dbo].[SP_SQLTRACE]
-- ***********************************************************************
-- ***********************************************************************
-- ***********************************************************************
-- This stored procedure is provided AS IS with no warranties and confers no rights.
-- ***********************************************************************
	
	@FILE_PATH 			NVARCHAR(200)	= 'C:\SQLTRACE',-- Location to write trace files.  Note: directory must exist before start of trace
	@TRACE_NAME  		NVARCHAR(40)	= 'DYNAMICS_DEFAULT', -- Trace name - becomes base of trace file name
	@DATABASE_NAME		NVARCHAR(128)	= NULL,			-- Name of database to trace; default (NULL) will trace all databases
	@TRACE_FILE_SIZE	BIGINT			= 10,			-- maximum trace file size - will rollover when reached
	@TRACE_FILE_COUNT	INT				= 100,			-- maximum numer of trace files  - will delete oldest when reached
	@TRACE_STOP  		NVARCHAR(1)		= 'N',			-- When set to 'Y' will stop the trace and exit
	@TRACE_RUN_HOURS  	SMALLINT		= 48, 			-- Number of hours to run trace
	@HOSTNAME			NVARCHAR(128)	= NULL,			--Hostname filter for trace		
	@DURATION_SECS			BIGINT			= 0				-- enables statment, rpc, batch trace by specified duration			


AS

SET NOCOUNT ON
SET DATEFORMAT MDY
--
-- Schedulable server-side trace script
--
--
-- This script can be used to start, run and manage several traces.
-- The trace name is used as unique identifier to represent trace, so make it meaningful.
-- When this script runs, it deletes the existing trace with the same filename,
-- and creates a new trace, adding a date/time extension to the trace file name
-- Change the following as appropriate:
--
--	DATA COLUMNS
--	EVENT CLASSES
--	FILTERS
--


-- -----------------------------------------------------------------------
-- Declare variables
-- -----------------------------------------------------------------------
DECLARE	@CMD			NVARCHAR(1000),	-- Used for command or sql strings
		@RC				INT,			-- Return status for stored procedures
		@ON				BIT,			-- Used as on bit for set event
		@TRACEID 		INT, 			-- Queue handle running trace queue
		@DATABASE_ID 	INT, 			-- DB ID to filter trace
		@EVENT_ID 		INT, 			-- Trace Event
		@COLUMN_ID 		INT, 			-- Trace Event Column
		@TRACE_STOPTIME	DATETIME, 		-- Trace will be set to stop 25 hours after starting
		@FILE_NAME 		NVARCHAR(245)	-- Trace file name
DECLARE	@EVENTS_VAR		TABLE(EVENT_ID INT PRIMARY KEY(EVENT_ID))

SET @ON				= 1
SET @TRACE_STOPTIME = DATEADD(HH, @TRACE_RUN_HOURS, GETDATE())

-- -----------------------------------------------------------------------
-- Edit parameters
-- -----------------------------------------------------------------------

IF @FILE_PATH LIKE '%\'
    BEGIN
		PRINT 'OMIT TRAILING \ FROM PATH NAME'
		SET @RC = 1
		GOTO ERROR
    END


IF @DATABASE_NAME IS NOT NULL
    BEGIN
		SELECT	@DATABASE_ID = database_id 
		FROM	sys.databases
		WHERE	name =  @DATABASE_NAME
		IF @@ROWCOUNT = 0
			BEGIN
				PRINT @DATABASE_NAME + ' DOES NOT EXIST'
				SET @RC = 1
				GOTO ERROR
			END
    END


-- -----------------------------------------------------------------------
-- Stop the trace queue if running
-- -----------------------------------------------------------------------
IF EXISTS	
	(
	SELECT	*
	FROM 	fn_trace_getinfo(DEFAULT)
	WHERE 	property = 2	-- TRACE FILE NAME
	AND		CONVERT(NVARCHAR(245),value)  LIKE '%\'+@TRACE_NAME+'%'
	)
    BEGIN
		SELECT	@TRACEID = traceid
		FROM 	fn_trace_getinfo(DEFAULT)
		WHERE 	property = 2	-- TRACE FILE NAME
		AND		CONVERT(VARCHAR(240),value)  LIKE '%\'+@TRACE_NAME+'%'
		EXEC @RC = sp_trace_setstatus @TRACEID, 0	-- STOPS SPECIFIED TRACE
		IF @RC = 0  PRINT 'SP_TRACE_SETSTATUS: STOPPED TRACE ID ' + STR(@TRACEID )
		IF @RC = 1  PRINT 'SP_TRACE_SETSTATUS: - UNKNOWN ERROR'
		IF @RC = 8  PRINT 'SP_TRACE_SETSTATUS: THE SPECIFIED STATUS IS NOT VALID'
		IF @RC = 9  PRINT 'SP_TRACE_SETSTATUS: THE SPECIFIED TRACE HANDLE IS NOT VALID'
		IF @RC = 13 PRINT 'SP_TRACE_SETSTATUS: OUT OF MEMORY'
		IF @RC <> 0 GOTO ERROR

		EXEC sp_trace_setstatus @TRACEID, 2 -- DELETE SPECIFIED TRACE

		IF @RC = 0  PRINT 'SP_TRACE_SETSTATUS: DELETED TRACE ID ' + STR(@TRACEID)
		IF @RC = 1  PRINT 'SP_TRACE_SETSTATUS: - UNKNOWN ERROR'
		IF @RC = 8  PRINT 'SP_TRACE_SETSTATUS: THE SPECIFIED STATUS IS NOT VALID'
		IF @RC = 9  PRINT 'SP_TRACE_SETSTATUS: THE SPECIFIED TRACE HANDLE IS NOT VALID'
		IF @RC = 13 PRINT 'SP_TRACE_SETSTATUS: OUT OF MEMORY'
		IF @RC <> 0 GOTO ERROR
    END


-- -----------------------------------------------------------------------
-- Stop trace and leave if requested via   @TRACE_STOP
-- -----------------------------------------------------------------------
IF @TRACE_STOP = 'Y' GOTO ENDPROC


-- -----------------------------------------------------------------------
-- Build the trace file name 
-- -----------------------------------------------------------------------

SELECT 	@FILE_NAME = 	@FILE_PATH 	+ '\' + @TRACE_NAME 				
PRINT 'FILE NAME = ' + @FILE_NAME+'.trc'

-- Convert @DURATION_SECS to appropriate time for sp_trace
IF @DURATION_SECS > 0
BEGIN
SET @DURATION_SECS = @DURATION_SECS * 1000000   -- convert to microseconds
END
-- -----------------------------------------------------------------------
-- Create trace
-- -----------------------------------------------------------------------


EXEC @RC = sp_trace_create
	@TRACEID OUTPUT, 	--	TRACE HANDLE - NEEDED FOR SUBSEQUENT TRACE OPERATIONS
	2, 					--	2 INDICATES FILE ROLLOVER
	@FILE_NAME,			--	FULL TRACE FILE NAME
	@TRACE_FILE_SIZE, 	--	MAXIMUM TRACE FILE SIZE BEFORE ROLLOVER
	@TRACE_STOPTIME,	--	TRACE STOP TIME
	@TRACE_FILE_COUNT	--	MAXIMUM TRACE FILE COUNT BEFORE OLDEST DELETED

IF @RC = 0  PRINT 'SP_TRACE_CREATE: CREATED TRACE ID ' + STR(@TRACEID )
IF @RC = 1  PRINT 'SP_TRACE_CREATE: - UNKNOWN ERROR'
IF @RC = 10 PRINT 'SP_TRACE_CREATE: INVALID OPTIONS'
IF @RC = 12 PRINT 'SP_TRACE_CREATE: FILE NAME ALREADY EXISTS; NEW TRACE NOT CREATED'
IF @RC = 13 PRINT 'SP_TRACE_CREATE: OUT OF MEMORY'
IF @RC = 14 PRINT 'SP_TRACE_CREATE: INVALID STOP TIME'
IF @RC = 15 PRINT 'SP_TRACE_CREATE: INVALID PARAMETERS'
IF @RC <> 0 
	BEGIN
		PRINT 'SP_TRACE_CREATE: Confirm that directory '+@FILE_PATH+ ' exists'
		GOTO ERROR
	END


-- -----------------------------------------------------------------------
-- Set trace events to capture
-- -----------------------------------------------------------------------
IF @DURATION_SECS > 0
	BEGIN
		INSERT INTO @EVENTS_VAR VALUES(10) --  Stored Procedures: RPC:Completed
		INSERT INTO @EVENTS_VAR VALUES(45) --  Stored Procedures: SP:StmtCompleted
		INSERT INTO @EVENTS_VAR VALUES(12) --  TSQL: SQL:BatchCompleted
		INSERT INTO @EVENTS_VAR VALUES(41) --  TSQL: SQL:StmtCompleted
		INSERT INTO @EVENTS_VAR VALUES(43) --  Stored Procedures: SP:Completed  
	END
ELSE
	BEGIN
		--INSERT INTO @EVENTS_VAR VALUES(55)	-- Hash Warning
		-- INSERT INTO @EVENTS_VAR VALUES(58)	-- Auto Stats
		INSERT INTO @EVENTS_VAR VALUES(60)	-- Lock Escalation
		INSERT INTO @EVENTS_VAR VALUES(67)	-- Execution Warnings
		--INSERT INTO @EVENTS_VAR VALUES(80)	-- Missing Join Predicate
		INSERT INTO @EVENTS_VAR VALUES(92)	-- Data File Grow
		INSERT INTO @EVENTS_VAR VALUES(93)	-- Log File Grow
		INSERT INTO @EVENTS_VAR VALUES(137)	-- Blocked Process Report
		INSERT INTO @EVENTS_VAR VALUES(148)	-- Deadlock Graph
		--REH added these in 1.10
		INSERT INTO @EVENTS_VAR VALUES(94) --  Database: Data File Auto Shrink
		INSERT INTO @EVENTS_VAR VALUES(95) --  Database: Log File Auto Shrink
		INSERT INTO @EVENTS_VAR VALUES(155) --  Full text: FT:Crawl Started
		INSERT INTO @EVENTS_VAR VALUES(156) --  Full text: FT:Crawl Stopped
		INSERT INTO @EVENTS_VAR VALUES(157) --  Full text: FT:Crawl Aborted
		INSERT INTO @EVENTS_VAR VALUES(115) --  Security Audit: Audit Backup/Restore Event
	END

-- -----------------------------------------------------------------------
-- INSERT INTO @EVENTS_VAR VALUES(165)	-- Performance Statistics
-- -----------------------------------------------------------------------

-- -----------------------------------------------------------------------
-- Remaining events are provided here and can be enabled by uncommenting
-- Use EXTREME CAUTION as continous tracing of these events can introduce
-- significant overhead.
-- -----------------------------------------------------------------------


 --INSERT INTO @EVENTS_VAR VALUES(10) --  Stored Procedures: RPC:Completed
-- INSERT INTO @EVENTS_VAR VALUES(11) --  Stored Procedures: RPC:Starting
--INSERT INTO @EVENTS_VAR VALUES(12) --  TSQL: SQL:BatchCompleted
-- INSERT INTO @EVENTS_VAR VALUES(13) --  TSQL: SQL:BatchStarting
-- INSERT INTO @EVENTS_VAR VALUES(14) --  Security Audit: Audit Login
-- INSERT INTO @EVENTS_VAR VALUES(15) --  Security Audit: Audit Logout
 --INSERT INTO @EVENTS_VAR VALUES(16) --  Errors and Warnings: Attention  ---reh
-- INSERT INTO @EVENTS_VAR VALUES(17) --  Sessions: ExistingConnection
-- INSERT INTO @EVENTS_VAR VALUES(18) --  Security Audit: Audit Server Starts And Stops
-- INSERT INTO @EVENTS_VAR VALUES(19) --  Transactions: DTCTransaction
-- INSERT INTO @EVENTS_VAR VALUES(20) --  Security Audit: Audit Login Failed
-- INSERT INTO @EVENTS_VAR VALUES(21) --  Errors and Warnings: EventLog
-- INSERT INTO @EVENTS_VAR VALUES(22) --  Errors and Warnings: ErrorLog
-- INSERT INTO @EVENTS_VAR VALUES(23) --  Locks: Lock:Released
-- INSERT INTO @EVENTS_VAR VALUES(24) --  Locks: Lock:Acquired
-- INSERT INTO @EVENTS_VAR VALUES(25) --  Locks: Lock:Deadlock
-- INSERT INTO @EVENTS_VAR VALUES(26) --  Locks: Lock:Cancel
-- INSERT INTO @EVENTS_VAR VALUES(27) --  Locks: Lock:Timeout
-- INSERT INTO @EVENTS_VAR VALUES(28) --  Performance: Degree of Parallelism (7.0 Insert)
 --INSERT INTO @EVENTS_VAR VALUES(33) --  Errors and Warnings: Exception   ---reh
-- INSERT INTO @EVENTS_VAR VALUES(34) --  Stored Procedures: SP:CacheMiss
-- INSERT INTO @EVENTS_VAR VALUES(35) --  Stored Procedures: SP:CacheInsert
-- INSERT INTO @EVENTS_VAR VALUES(36) --  Stored Procedures: SP:CacheRemove
-- INSERT INTO @EVENTS_VAR VALUES(37) --  Stored Procedures: SP:Recompile
-- INSERT INTO @EVENTS_VAR VALUES(38) --  Stored Procedures: SP:CacheHit
-- INSERT INTO @EVENTS_VAR VALUES(39) --  Stored Procedures: Deprecated
-- INSERT INTO @EVENTS_VAR VALUES(40) --  TSQL: SQL:StmtStarting
 --INSERT INTO @EVENTS_VAR VALUES(41) --  TSQL: SQL:StmtCompleted
-- INSERT INTO @EVENTS_VAR VALUES(42) --  Stored Procedures: SP:Starting
 --INSERT INTO @EVENTS_VAR VALUES(43) --  Stored Procedures: SP:Completed   
-- INSERT INTO @EVENTS_VAR VALUES(44) --  Stored Procedures: SP:StmtStarting
 --INSERT INTO @EVENTS_VAR VALUES(45) --  Stored Procedures: SP:StmtCompleted  
-- INSERT INTO @EVENTS_VAR VALUES(46) --  Objects: Object:Created
-- INSERT INTO @EVENTS_VAR VALUES(47) --  Objects: Object:Deleted
-- INSERT INTO @EVENTS_VAR VALUES(50) --  Transactions: SQLTransaction
-- INSERT INTO @EVENTS_VAR VALUES(51) --  Scans: Scan:Started
-- INSERT INTO @EVENTS_VAR VALUES(52) --  Scans: Scan:Stopped
-- INSERT INTO @EVENTS_VAR VALUES(53) --  Cursors: CursorOpen
-- INSERT INTO @EVENTS_VAR VALUES(54) --  Transactions: TransactionLog
-- INSERT INTO @EVENTS_VAR VALUES(59) --  Locks: Lock:Deadlock Chain
-- INSERT INTO @EVENTS_VAR VALUES(60)   --  Locks: Lock:escalation
-- INSERT INTO @EVENTS_VAR VALUES(61) --  OLEDB: OLEDB Errors
 --INSERT INTO @EVENTS_VAR VALUES(68) --  Performance: Showplan Text (Unencoded)  
-- INSERT INTO @EVENTS_VAR VALUES(69) --  Errors and Warnings: Sort Warnings
-- INSERT INTO @EVENTS_VAR VALUES(70) --  Cursors: CursorPrepare
-- INSERT INTO @EVENTS_VAR VALUES(71) --  TSQL: Prepare SQL
-- INSERT INTO @EVENTS_VAR VALUES(72) --  TSQL: Exec Prepared SQL
-- INSERT INTO @EVENTS_VAR VALUES(73) --  TSQL: Unprepare SQL
-- INSERT INTO @EVENTS_VAR VALUES(74) --  Cursors: CursorExecute
-- INSERT INTO @EVENTS_VAR VALUES(75) --  Cursors: CursorRecompile
-- INSERT INTO @EVENTS_VAR VALUES(76)	-- Cursor Conversion
-- INSERT INTO @EVENTS_VAR VALUES(77) --  Cursors: CursorUnprepare
-- INSERT INTO @EVENTS_VAR VALUES(78) --  Cursors: CursorClose
--INSERT INTO @EVENTS_VAR VALUES(79)	-- Missing Column Statistics
-- INSERT INTO @EVENTS_VAR VALUES(81) --  Server: Server Memory Change
-- INSERT INTO @EVENTS_VAR VALUES(82) --  User configurable: UserConfigurable:0
-- INSERT INTO @EVENTS_VAR VALUES(83) --  User configurable: UserConfigurable:1
-- INSERT INTO @EVENTS_VAR VALUES(84) --  User configurable: UserConfigurable:2
-- INSERT INTO @EVENTS_VAR VALUES(85) --  User configurable: UserConfigurable:3
-- INSERT INTO @EVENTS_VAR VALUES(86) --  User configurable: UserConfigurable:4
-- INSERT INTO @EVENTS_VAR VALUES(87) --  User configurable: UserConfigurable:5
-- INSERT INTO @EVENTS_VAR VALUES(88) --  User configurable: UserConfigurable:6
-- INSERT INTO @EVENTS_VAR VALUES(89) --  User configurable: UserConfigurable:7
-- INSERT INTO @EVENTS_VAR VALUES(90) --  User configurable: UserConfigurable:8
-- INSERT INTO @EVENTS_VAR VALUES(91) --  User configurable: UserConfigurable:9
-- INSERT INTO @EVENTS_VAR VALUES(94) --  Database: Data File Auto Shrink
-- INSERT INTO @EVENTS_VAR VALUES(95) --  Database: Log File Auto Shrink
-- INSERT INTO @EVENTS_VAR VALUES(96) --  Performance: Showplan Text
-- INSERT INTO @EVENTS_VAR VALUES(97) --  Performance: Showplan All
-- INSERT INTO @EVENTS_VAR VALUES(98) --  Performance: Showplan Statistics Profile
-- INSERT INTO @EVENTS_VAR VALUES(100) --  Stored Procedures: RPC Output Parameter
-- INSERT INTO @EVENTS_VAR VALUES(102) --  Security Audit: Audit Database Scope GDR Event
-- INSERT INTO @EVENTS_VAR VALUES(103) --  Security Audit: Audit Schema Object GDR Event
-- INSERT INTO @EVENTS_VAR VALUES(104) --  Security Audit: Audit Addlogin Event
-- INSERT INTO @EVENTS_VAR VALUES(105) --  Security Audit: Audit Login GDR Event
-- INSERT INTO @EVENTS_VAR VALUES(106) --  Security Audit: Audit Login Change Property Event
-- INSERT INTO @EVENTS_VAR VALUES(107) --  Security Audit: Audit Login Change Password Event
-- INSERT INTO @EVENTS_VAR VALUES(108) --  Security Audit: Audit Add Login to Server Role Event
-- INSERT INTO @EVENTS_VAR VALUES(109) --  Security Audit: Audit Add DB User Event
-- INSERT INTO @EVENTS_VAR VALUES(110) --  Security Audit: Audit Add Member to DB Role Event
-- INSERT INTO @EVENTS_VAR VALUES(111) --  Security Audit: Audit Add Role Event
-- INSERT INTO @EVENTS_VAR VALUES(112) --  Security Audit: Audit App Role Change Password Event
-- INSERT INTO @EVENTS_VAR VALUES(113) --  Security Audit: Audit Statement Permission Event
-- INSERT INTO @EVENTS_VAR VALUES(114) --  Security Audit: Audit Schema Object Access Event
-- INSERT INTO @EVENTS_VAR VALUES(115) --  Security Audit: Audit Backup/Restore Event
-- INSERT INTO @EVENTS_VAR VALUES(116) --  Security Audit: Audit DBCC Event
-- INSERT INTO @EVENTS_VAR VALUES(117) --  Security Audit: Audit Change Audit Event
-- INSERT INTO @EVENTS_VAR VALUES(118) --  Security Audit: Audit Object Derived Permission Event
-- INSERT INTO @EVENTS_VAR VALUES(119) --  OLEDB: OLEDB Call Event
-- INSERT INTO @EVENTS_VAR VALUES(120) --  OLEDB: OLEDB QueryInterface Event
-- INSERT INTO @EVENTS_VAR VALUES(121) --  OLEDB: OLEDB DataRead Event
-- INSERT INTO @EVENTS_VAR VALUES(122) --  Performance: Showplan XML
-- INSERT INTO @EVENTS_VAR VALUES(123) --  Performance: SQL:FullTextQuery
-- INSERT INTO @EVENTS_VAR VALUES(124) --  Broker: Broker:Conversation
-- INSERT INTO @EVENTS_VAR VALUES(125) --  Deprecation: Deprecation Announcement
-- INSERT INTO @EVENTS_VAR VALUES(126) --  Deprecation: Deprecation Final Support
-- INSERT INTO @EVENTS_VAR VALUES(127) --  Errors and Warnings: Exchange Spill Event
-- INSERT INTO @EVENTS_VAR VALUES(128) --  Security Audit: Audit Database Management Event
-- INSERT INTO @EVENTS_VAR VALUES(129) --  Security Audit: Audit Database Object Management Event
-- INSERT INTO @EVENTS_VAR VALUES(130) --  Security Audit: Audit Database Principal Management Event
-- INSERT INTO @EVENTS_VAR VALUES(131) --  Security Audit: Audit Schema Object Management Event
-- INSERT INTO @EVENTS_VAR VALUES(132) --  Security Audit: Audit Server Principal Impersonation Event
-- INSERT INTO @EVENTS_VAR VALUES(133) --  Security Audit: Audit Database Principal Impersonation Event
-- INSERT INTO @EVENTS_VAR VALUES(134) --  Security Audit: Audit Server Object Take Ownership Event
-- INSERT INTO @EVENTS_VAR VALUES(135) --  Security Audit: Audit Database Object Take Ownership Event
-- INSERT INTO @EVENTS_VAR VALUES(136) --  Broker: Broker:Conversation Group
-- INSERT INTO @EVENTS_VAR VALUES(138) --  Broker: Broker:Connection
-- INSERT INTO @EVENTS_VAR VALUES(139) --  Broker: Broker:Forwarded Message Sent
-- INSERT INTO @EVENTS_VAR VALUES(140) --  Broker: Broker:Forwarded Message Dropped
-- INSERT INTO @EVENTS_VAR VALUES(141) --  Broker: Broker:Message Classify
-- INSERT INTO @EVENTS_VAR VALUES(142) --  Broker: Broker:Transmission
-- INSERT INTO @EVENTS_VAR VALUES(143) --  Broker: Broker:Queue Disabled
-- INSERT INTO @EVENTS_VAR VALUES(144) --  Broker: Broker:Mirrored Route State Changed
-- INSERT INTO @EVENTS_VAR VALUES(146) --  Performance: Showplan XML Statistics Profile
-- INSERT INTO @EVENTS_VAR VALUES(149) --  Broker: Broker:Remote Message Acknowledgement
-- INSERT INTO @EVENTS_VAR VALUES(150) --  Server: Trace File Close
-- INSERT INTO @EVENTS_VAR VALUES(152) --  Security Audit: Audit Change Database Owner
-- INSERT INTO @EVENTS_VAR VALUES(153) --  Security Audit: Audit Schema Object Take Ownership Event
-- INSERT INTO @EVENTS_VAR VALUES(155) --  Full text: FT:Crawl Started
-- INSERT INTO @EVENTS_VAR VALUES(156) --  Full text: FT:Crawl Stopped
-- INSERT INTO @EVENTS_VAR VALUES(157) --  Full text: FT:Crawl Aborted
-- INSERT INTO @EVENTS_VAR VALUES(158) --  Security Audit: Audit Broker Conversation
-- INSERT INTO @EVENTS_VAR VALUES(159) --  Security Audit: Audit Broker Login
-- INSERT INTO @EVENTS_VAR VALUES(160) --  Broker: Broker:Message Undeliverable
-- INSERT INTO @EVENTS_VAR VALUES(161) --  Broker: Broker:Corrupted Message
-- INSERT INTO @EVENTS_VAR VALUES(162) --  Errors and Warnings: User Error Message
-- INSERT INTO @EVENTS_VAR VALUES(163) --  Broker: Broker:Activation
-- INSERT INTO @EVENTS_VAR VALUES(164) --  Objects: Object:Altered
-- INSERT INTO @EVENTS_VAR VALUES(166) --  TSQL: SQL:StmtRecompile
-- INSERT INTO @EVENTS_VAR VALUES(167) --  Database: Database Mirroring State Change
-- INSERT INTO @EVENTS_VAR VALUES(168) --  Performance: Showplan XML For Query Compile
-- INSERT INTO @EVENTS_VAR VALUES(169) --  Performance: Showplan All For Query Compile
-- INSERT INTO @EVENTS_VAR VALUES(170) --  Security Audit: Audit Server Scope GDR Event
-- INSERT INTO @EVENTS_VAR VALUES(171) --  Security Audit: Audit Server Object GDR Event
-- INSERT INTO @EVENTS_VAR VALUES(172) --  Security Audit: Audit Database Object GDR Event
-- INSERT INTO @EVENTS_VAR VALUES(173) --  Security Audit: Audit Server Operation Event
-- INSERT INTO @EVENTS_VAR VALUES(175) --  Security Audit: Audit Server Alter Trace Event
-- INSERT INTO @EVENTS_VAR VALUES(176) --  Security Audit: Audit Server Object Management Event
-- INSERT INTO @EVENTS_VAR VALUES(177) --  Security Audit: Audit Server Principal Management Event
-- INSERT INTO @EVENTS_VAR VALUES(178) --  Security Audit: Audit Database Operation Event
-- INSERT INTO @EVENTS_VAR VALUES(180) --  Security Audit: Audit Database Object Access Event
-- INSERT INTO @EVENTS_VAR VALUES(181) --  Transactions: TM: Begin Tran starting
-- INSERT INTO @EVENTS_VAR VALUES(182) --  Transactions: TM: Begin Tran completed
-- INSERT INTO @EVENTS_VAR VALUES(183) --  Transactions: TM: Promote Tran starting
-- INSERT INTO @EVENTS_VAR VALUES(184) --  Transactions: TM: Promote Tran completed
-- INSERT INTO @EVENTS_VAR VALUES(185) --  Transactions: TM: Commit Tran starting
-- INSERT INTO @EVENTS_VAR VALUES(186) --  Transactions: TM: Commit Tran completed
-- INSERT INTO @EVENTS_VAR VALUES(187) --  Transactions: TM: Rollback Tran starting
-- INSERT INTO @EVENTS_VAR VALUES(188) --  Transactions: TM: Rollback Tran completed
-- INSERT INTO @EVENTS_VAR VALUES(189) --  Locks: Lock:Timeout (timeout > 0)
-- INSERT INTO @EVENTS_VAR VALUES(190) --  Progress Report: Progress Report: Online Index Operation
-- INSERT INTO @EVENTS_VAR VALUES(191) --  Transactions: TM: Save Tran starting
-- INSERT INTO @EVENTS_VAR VALUES(192) --  Transactions: TM: Save Tran completed
-- INSERT INTO @EVENTS_VAR VALUES(193) --  Errors and Warnings: Background Job Error
-- INSERT INTO @EVENTS_VAR VALUES(194) --  OLEDB: OLEDB Provider Information
-- INSERT INTO @EVENTS_VAR VALUES(195) --  Server: Mount Tape
-- INSERT INTO @EVENTS_VAR VALUES(196) --  CLR: Assembly Load
-- INSERT INTO @EVENTS_VAR VALUES(198) --  TSQL: XQuery Static Type
-- INSERT INTO @EVENTS_VAR VALUES(199) --  Query Notifications: QN: Subscription
-- INSERT INTO @EVENTS_VAR VALUES(200) --  Query Notifications: QN: Parameter table
-- INSERT INTO @EVENTS_VAR VALUES(201) --  Query Notifications: QN: Template
-- INSERT INTO @EVENTS_VAR VALUES(202) --  Query Notifications: QN: Dynamics


-- -----------------------------------------------------------------------
-- Set the events and columns to capture.  
-- Join the list of events (@EVENTS_VAR) 
-- to their valid columns (from sys.trace_event_bindings) 
-- and execute sp_trace_setevent for each event/column combination
-- -----------------------------------------------------------------------
DECLARE SETEVENTS CURSOR FOR
	SELECT	trace_event_id, trace_column_id
	FROM	@EVENTS_VAR, sys.trace_event_bindings
	WHERE	EVENT_ID = trace_event_id
	ORDER BY 1,2

OPEN	SETEVENTS
FETCH	SETEVENTS INTO @EVENT_ID, @COLUMN_ID
WHILE	@@FETCH_STATUS = 0
	BEGIN
		exec sp_trace_setevent @TRACEID, @EVENT_ID, @COLUMN_ID, @ON
		FETCH	SETEVENTS INTO @EVENT_ID, @COLUMN_ID
	END
DEALLOCATE SETEVENTS


-- -----------------------------------------------------------------------
-- Set filters
-- -----------------------------------------------------------------------
IF @HOSTNAME IS NOT NULL
	EXEC sp_trace_setfilter @TRACEID, 7,0,6, @HOSTNAME
-- -----------------------------------------------------------------------
--  Filter on Database ID if Database Name is supplied
-- -----------------------------------------------------------------------

IF @DATABASE_NAME IS NOT NULL
	EXEC sp_trace_setfilter @TRACEID,  3, 0, 0, @DATABASE_ID

-- -----------------------------------------------------------------------
--   Applicationname not like 'sql profiler'
-- -----------------------------------------------------------------------
EXEC sp_trace_setfilter @TRACEID, 10, 0, 7, N'SQL PROFILER'


-- -----------------------------------------------------------------------
--   Database name not like 'DynamicsPerf'
-- -----------------------------------------------------------------------
EXEC sp_trace_setfilter @TRACEID, 35, 0, 7, N'DynamicsPerf%'

--  If@DURATION_SECS is specified, add events and set duration filter

IF @DURATION_SECS > 0
	BEGIN
		EXEC sp_trace_setfilter @TRACEID, 13, 0, 4, @DURATION_SECS
	END

-- -----------------------------------------------------------------------
--   Objectid >= 100 (excludes system objects)
-- -----------------------------------------------------------------------
--EXEC sp_trace_setfilter @TRACEID, 22, 0, 4, 100

-- -----------------------------------------------------------------------
-- Start the trace
-- -----------------------------------------------------------------------

EXEC @RC = sp_trace_setstatus @TRACEID, 1

IF @RC = 0  PRINT 'SP_TRACE_SETSTATUS: STARTED TRACE ID  ' + STR(@TRACEID )
IF @RC = 1  PRINT 'SP_TRACE_SETSTATUS: - UNKNOWN ERROR'
IF @RC = 8  PRINT 'SP_TRACE_SETSTATUS: THE SPECIFIED STATUS IS NOT VALID'
IF @RC = 9  PRINT 'SP_TRACE_SETSTATUS: THE SPECIFIED TRACE HANDLE IS NOT VALID'
IF @RC = 13 PRINT 'SP_TRACE_SETSTATUS: OUT OF MEMORY'

IF @DURATION_SECS > 0
	BEGIN
	PRINT ''
	--Don't update the trace file path as this is not our default trace we are creating
	END
ELSE
	BEGIN
		UPDATE DynamicsPerf..DYNAMICSPERF_SETUP SET TRACE_FULL_PATH_NAME = @FILE_PATH 	+ '\' + @TRACE_NAME +'.trc'
	END

ENDPROC:




ERROR:
RETURN @RC
GO
PRINT N'Creating [dbo].[SP_PURGESTATS]...';


GO




CREATE	PROCEDURE [dbo].[SP_PURGESTATS] 
		@SERVER_NAME NVARCHAR(128) = NULL,
		@DATABASE_NAME NVARCHAR(128) = NULL, 
		@PURGE_DAYS INT = 0,
		@RUN_NAME NVARCHAR(128) = NULL,
		@TRUNCATE_ALL NVARCHAR(1) = NULL,
		@DEBUG NVARCHAR(1) = 'Y'

AS

/******************************************************************************************************************
*
*  SERVER_NAME = NULL DEFAULT TO THIS SERVER, @DATABASE_NAME NOT NULL THEN PURGE THIS DB
*
*  IF @PURGE_DAYS NOT NULL THEN PURGE DATA FOR SERVER/DB IF SERVER/DB both NULL then do it for all DBs in DynamicsPerf
*
*  IF @RUN_NAME NOT NULL THEN ONLY DELETE DATA FOR THAT RUN REGARDLESS OF OTHER SETINGS
*
*  IF @TRUNCATE_ALL NOT NULL, THEN TRUNCATE ALL TABLES AND CLEAR DYNAMICSPERF
*
*
*
*******************************************************************************************************************/






SET NOCOUNT ON
SET DATEFORMAT MDY
DECLARE @PURGE_DATE smalldatetime,  @SQL NVARCHAR(MAX)


DECLARE  @C_TABLE_NAME NVARCHAR(128), @C_TIME_COLUMN NVARCHAR(128), @C_SERVER_FLAG BIT, @C_DATABASE_FLAG BIT




DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT TABLE_NAME, TIME_COLUMN, SERVER_NAME_FLAG, DATABASE_NAME_FLAG
FROM   DynamicsPerf..[DYNPERF_PURGETABLES]




/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TABLE_NAME, @C_TIME_COLUMN, @C_SERVER_FLAG, @C_DATABASE_FLAG


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

		SET @PURGE_DAYS = @PURGE_DAYS * -1  --set to negative so we go back in time not forward in time


		SET @PURGE_DATE = DATEADD(DD,@PURGE_DAYS,GETDATE())


		--REH DELETE ALL RECORDS FOR THE DATABASE FROM THE TABLE IF @DATABASE_NAME IS PASSED
		--  THIS IS USED FOR DEV/TEST TO DROP ALL PREVIOUS DATA FROM DYNAMICSPERF




		--REH Database passed and the table has DBname in it and we didn't pass a purge date, delete all records for that database
		IF @DATABASE_NAME IS NOT NULL
		   AND @C_DATABASE_FLAG = 1
		   AND @PURGE_DAYS = 0
		  BEGIN
			  IF @SERVER_NAME IS NULL
				SET @SERVER_NAME = @@SERVERNAME -- REH default to current server if name isn't passed

			  SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + ' AND SERVER_NAME = ' + '''' + @SERVER_NAME + ''''
		  END 



		--REH Server name passed but no database name passed and no purge days passed, delete all records for that server
		IF @SERVER_NAME IS NOT NULL
		   AND @DATABASE_NAME IS NULL
		   AND @PURGE_DAYS = 0
		  BEGIN
			  SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE SERVER_NAME = ' + '''' + @SERVER_NAME + ''''
		  END 
  

		--REH Database passed and the table has DBname in it and we did pass a purge date, delete all records for that database based upon purge days
		IF @DATABASE_NAME IS NOT NULL
		   AND @C_DATABASE_FLAG = 1
		   AND @PURGE_DAYS <> 0
		  BEGIN
			  IF @SERVER_NAME IS NULL
				SET @SERVER_NAME = @@SERVERNAME -- REH default to current server if name isn't passed

			  SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE ' + 
			  CASE @C_TIME_COLUMN WHEN '' THEN ' ' ELSE @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109)+ '''' + ' AND' END 
			  
			   + ' DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + ' AND SERVER_NAME = ' + '''' + @SERVER_NAME + ''''
		  END 


		--REH Server name passed but no database name passed and no purge days passed, delete all records for that server based upon purge days
		IF @SERVER_NAME IS NOT NULL
		   AND @DATABASE_NAME IS NULL
		   AND @PURGE_DAYS <> 0
		  BEGIN
			  SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE ' + 
			 CASE @C_TIME_COLUMN WHEN '' THEN ' ' ELSE @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109)+ '''' + ' AND' END 
			  + ' DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + ' AND SERVER_NAME = ' + '''' + @SERVER_NAME + ''''
		  END 


		  --REH No server or database name passed but PURGE DAYS was passed, delete all records based upon purge days
		IF @SERVER_NAME IS NULL
		   AND @DATABASE_NAME IS NULL
		   AND @PURGE_DAYS <> 0
		  BEGIN
			  SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + 
			  CASE @C_TIME_COLUMN WHEN '' THEN ' ' ELSE  ' WHERE ' + @C_TIME_COLUMN + ' <= ' + '''' +  CONVERT(VARCHAR, @PURGE_DATE, 109) + '''' END 
			 
		  END 


		--REH Truncate all tables in DynamicsPerf
		IF @TRUNCATE_ALL = 'Y'
		  BEGIN
			  SET @SQL = 'TRUNCATE TABLE ' + @C_TABLE_NAME
		  END 


		IF @DEBUG = 'Y'
		BEGIN
		PRINT @SQL
		END


		IF @SQL IS NOT NULL 
		BEGIN
			EXEC (@SQL)
		END





		FETCH NEXT FROM TASK_CURSOR INTO @C_TABLE_NAME, @C_TIME_COLUMN, @C_SERVER_FLAG, @C_DATABASE_FLAG


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 



 --REH Delete out tables not in the purgetables such as those controlled by AOSANALYSIS

IF @DATABASE_NAME IS NOT NULL AND @PURGE_DAYS = 0
		   		   
		  BEGIN
			  IF @SERVER_NAME IS NULL
				SET @SERVER_NAME = @@SERVERNAME -- REH default to current server if name isn't passed

			  SET @SQL = 'DELETE FROM AOS_EVENTLOG WHERE  SERVER_NAME = ' + '''' + @SERVER_NAME + ''''


		  IF @TRUNCATE_ALL = 'Y'
		  BEGIN
			  SET @SQL = 'TRUNCATE TABLE AOS_EVENTLOG' 
		  END 

			  IF @DEBUG = 'Y'
				BEGIN
				PRINT @SQL
				END


			  IF @SQL IS NOT NULL 
				BEGIN
					EXEC (@SQL)
				END

		  END 

IF @DATABASE_NAME IS NOT NULL AND @PURGE_DAYS = 0
		   		   
		  BEGIN
			  IF @SERVER_NAME IS NULL
				SET @SERVER_NAME = @@SERVERNAME -- REH default to current server if name isn't passed

			  SET @SQL = 'DELETE FROM AOS_REGISTRY WHERE  SERVER_NAME = ' + '''' + @SERVER_NAME + ''''

		  IF @TRUNCATE_ALL = 'Y'
		  BEGIN
			  SET @SQL = 'TRUNCATE TABLE AOS_REGISTRY' 
		  END 
			  IF @DEBUG = 'Y'
				BEGIN
				PRINT @SQL
				END


			  IF @SQL IS NOT NULL 
				BEGIN
					EXEC (@SQL)
				END

		  END 

IF @DATABASE_NAME IS NOT NULL AND @PURGE_DAYS = 0
		   		   
		  BEGIN
			  IF @SERVER_NAME IS NULL
				SET @SERVER_NAME = @@SERVERNAME -- REH default to current server if name isn't passed

			  SET @SQL = 'DELETE FROM DYNSYSCOLUMNS WHERE  RUN_NAME LIKE ' + '''' + @SERVER_NAME + '''' + '%'
			   + ' AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + ''''

		 IF @TRUNCATE_ALL = 'Y'
		  BEGIN
			  SET @SQL = 'TRUNCATE TABLE DYNSYSCOLUMNS' 
		  END 

			  IF @DEBUG = 'Y'
				BEGIN
				PRINT @SQL
				END


			  IF @SQL IS NOT NULL 
				BEGIN
					EXEC (@SQL)
				END

		  END 

IF @DATABASE_NAME IS NOT NULL AND @PURGE_DAYS = 0
		   		   
		  BEGIN
			  IF @SERVER_NAME IS NULL
				SET @SERVER_NAME = @@SERVERNAME -- REH default to current server if name isn't passed

			  SET @SQL = 'DELETE FROM DYNSYSINDEXES WHERE  RUN_NAME LIKE ' + '''' + @SERVER_NAME + '''' + '%'
			   + ' AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + ''''


			   IF @TRUNCATE_ALL = 'Y'
				  BEGIN
					  SET @SQL = 'TRUNCATE TABLE DYNSYSINDEXES' 
				  END 

			  IF @DEBUG = 'Y'
				BEGIN
				PRINT @SQL
				END


			  IF @SQL IS NOT NULL 
				BEGIN
					EXEC (@SQL)
				END

		  END 

IF @DATABASE_NAME IS NOT NULL AND @PURGE_DAYS = 0
		   		   
		  BEGIN
			  IF @SERVER_NAME IS NULL
				SET @SERVER_NAME = @@SERVERNAME -- REH default to current server if name isn't passed

			  SET @SQL = 'DELETE FROM DYNSYSOBJECTS WHERE  RUN_NAME LIKE ' + '''' + @SERVER_NAME + '''' + '%'
			   + ' AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + ''''


			  IF @TRUNCATE_ALL = 'Y'
				  BEGIN
					  SET @SQL = 'TRUNCATE TABLE DYNSYSOBJECTS' 
				  END 


			  IF @DEBUG = 'Y'
				BEGIN
				PRINT @SQL
				END


			  IF @SQL IS NOT NULL 
				BEGIN
					EXEC (@SQL)
				END


		  END 


IF @DATABASE_NAME IS NOT NULL AND @PURGE_DAYS = 0
		   		   
		  BEGIN
			  IF @SERVER_NAME IS NULL
				SET @SERVER_NAME = @@SERVERNAME -- REH default to current server if name isn't passed

			  SET @SQL = 'DELETE FROM DYNSYSPARTITIONS WHERE  RUN_NAME LIKE ' + '''' + @SERVER_NAME + '''' + '%'
			   + ' AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + ''''

			   			  IF @TRUNCATE_ALL = 'Y'
				  BEGIN
					  SET @SQL = 'TRUNCATE TABLE DYNSYSPARTITIONS' 
				  END 


			  IF @DEBUG = 'Y'
				BEGIN
				PRINT @SQL
				END


			  IF @SQL IS NOT NULL 
				BEGIN
					EXEC (@SQL)
				END


		  END 


IF @DATABASE_NAME IS NOT NULL AND @PURGE_DAYS = 0
		   		   
		  BEGIN
			  IF @SERVER_NAME IS NULL
				SET @SERVER_NAME = @@SERVERNAME -- REH default to current server if name isn't passed

			  SET @SQL = 'DELETE FROM DATABASES_2_COLLECT WHERE  LINKED_SERVER = ' + '''' + @SERVER_NAME + '''' 
			   + ' AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + ''''

			   			  IF @TRUNCATE_ALL = 'Y'
				  BEGIN
					  SET @SQL = 'TRUNCATE TABLE DATABASES_2_COLLECT' 
				  END 


			  IF @DEBUG = 'Y'
				BEGIN
				PRINT @SQL
				END


			  IF @SQL IS NOT NULL 
				BEGIN
					EXEC (@SQL)
				END


		  END 


IF @DATABASE_NAME IS NOT NULL AND @PURGE_DAYS = 0
		   		   
		  BEGIN
			  IF @SERVER_NAME IS NULL
				SET @SERVER_NAME = @@SERVERNAME -- REH default to current server if name isn't passed

			  SET @SQL = 'DELETE FROM DYNPERF_TASK_HISTORY WHERE  LINKEDSERVER_NAME = ' + '''' + @SERVER_NAME + '''' 
			   + ' AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + ''''

			   			  IF @TRUNCATE_ALL = 'Y'
				  BEGIN
					  SET @SQL = 'TRUNCATE TABLE DYNPERF_TASK_HISTORY' 
				  END 


			  IF @DEBUG = 'Y'
				BEGIN
				PRINT @SQL
				END


			  IF @SQL IS NOT NULL 
				BEGIN
					EXEC (@SQL)
				END


		  END
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_AX_SQLSTORAGE]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_AX_SQLSTORAGE (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXSTOR_AX_SQLSTORAGE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXSTOR_AX_SQLSTORAGE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXSTOR_AX_SQLSTORAGE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SQLSTORAGE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXSTOR_AX_SQLSTORAGE
				FOR [' + @DATABASE_NAME + '].dbo.SQLSTORAGE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



		DELETE FROM AX_SQLSTORAGE
		WHERE  SERVER_NAME = @SERVER_NAME
			   AND DATABASE_NAME = @DATABASE_NAME 


		INSERT AX_SQLSTORAGE
		SELECT @SERVER_NAME,
			   @DATABASE_NAME,
			   *
		FROM   DYN_AXSTOR_AX_SQLSTORAGE 

	
	 



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXSTOR_AX_SQLSTORAGE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXSTOR_AX_SQLSTORAGE')


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'


		  IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXSTOR_AX_SQLSTORAGE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXSTOR_AX_SQLSTORAGE')




    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[SP_PURGEBLOCKS]...';


GO


CREATE PROCEDURE [dbo].[SP_PURGEBLOCKS] @days INT
AS
  SELECT @days = @days * -1

DELETE DynamicsPerf..BLOCKS
WHERE  BLOCKED_DTTM <= Dateadd(dd, @days, Getdate())

DELETE FROM [DynamicsPerf].[dbo].[BLOCKED_PROCESS_INFO]

WHERE  END_TIME <= Dateadd(dd, @days, Getdate())
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_DATABASE_STATISTICS]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_DATABASE_STATISTICS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @ROW_COUNT BIGINT = 0
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_SYSOBJECTS')
  EXEC ('DROP SYNONYM [dbo].DYN_DS_SYSOBJECTS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSOBJECTS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.sysobjects'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSOBJECTS
				FOR [' + @DATABASE_NAME + '].sys.sysobjects'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)
 

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_DS_SYSCOLUMNS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSCOLUMNS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.columns'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSCOLUMNS
				FOR [' + @DATABASE_NAME + '].sys.columns'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_SYSINDEXES')
 EXEC ('DROP SYNONYM [dbo].DYN_DS_SYSINDEXES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSINDEXES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.indexes'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSINDEXES
				FOR [' + @DATABASE_NAME + '].sys.indexes'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_SYSSCHEMAS')
  EXEC ('DROP SYNONYM [dbo].DYN_DS_SYSSCHEMAS')
  
  
IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSSCHEMAS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.schemas'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSSCHEMAS
				FOR [' + @DATABASE_NAME + '].sys.schemas'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_INDEX_COLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_DS_INDEX_COLUMNS')
  
IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_INDEX_COLUMNS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.index_columns'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_INDEX_COLUMNS
				FOR [' + @DATABASE_NAME + '].sys.index_columns'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_STATS_COLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_DS_STATS_COLUMNS')
  
IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_STATS_COLUMNS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.stats_columns'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_STATS_COLUMNS
				FOR [' + @DATABASE_NAME + '].sys.stats_columns'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_SYS_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_DS_SYS_STATS')
  
IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYS_STATS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYS_STATS
				FOR [' + @DATABASE_NAME + '].sys.stats'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[#table_stat_header]'))
BEGIN 
DROP TABLE #table_stat_header
END

create table #table_stat_header (
    [Name] sysname
,   [Updated] datetime2
,   [Rows] int
,   [Rows Sampled] int
,   [Steps] int
,   [Density] numeric(10,5)
,   [Average key length] numeric(10,5)
,   [String index] varchar(10)
,   [Filter_Expression] nvarchar(max),
	[Unfiltered_Rows] int
)

--insert into #table_stat_header exec ('dbcc show_statistics ( "tab", "i1") with  STAT_HEADER')



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[#TableStats]'))
BEGIN 
DROP TABLE #TableStats
END


CREATE TABLE #TableStats
  (
     Density FLOAT,
     Length  INT NULL,
     columns NVARCHAR(2078)
  ) 
  


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[#TableHistogram]'))
 BEGIN
DROP TABLE #TableHistogram
END

CREATE TABLE #TableHistogram
  (
     Range_HI_Key        SQL_VARIANT,
     Range_Rows          BIGINT NULL,
     EQ_Rows             BIGINT,
     Distinct_Range_Rows BIGINT,
     Avg_Range_Rows      BIGINT
  ) 



DELETE FROM INDEX_STAT_HEADER WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME
DELETE FROM INDEX_DENSITY_VECTOR WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME
DELETE FROM INDEX_HISTOGRAM WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME


TRUNCATE TABLE #TableStats
TRUNCATE TABLE #TableHistogram
TRUNCATE TABLE #table_stat_header


DECLARE @tablename sysname
DECLARE @indexname sysname
DECLARE @colname sysname
DECLARE @schemaname sysname


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

DECLARE table_cursor CURSOR
   FOR SELECT O.name,
              ST.name,
              C.name,
              SCH.name
       FROM   DYN_DS_SYSOBJECTS O
              INNER JOIN DYN_DS_SYS_STATS ST
                      ON O.id = ST.object_id
              INNER JOIN DYN_DS_STATS_COLUMNS AS SC
                      ON ST.object_id = SC.object_id
                         AND ST.stats_id = SC.stats_id
              INNER JOIN DYN_DS_SYSCOLUMNS AS C
                      ON SC.object_id = C.object_id
                         AND C.column_id = SC.column_id
              INNER JOIN DYN_DS_SYSSCHEMAS AS SCH
                      ON O.uid = SCH.schema_id
       WHERE  O.xtype = 'u'
              AND SC.stats_column_id = 1
              AND C.system_type_id <> 189
              AND SCH.name <> 'sys' --remove timestamps, incompatiable with sql_variant datatype we used
              AND ( ST.auto_created = 1
               OR ST.user_created = 1)
       UNION ALL
       SELECT O.name,
              ST.name,
              C.name,
              SCH.name
       FROM   DYN_DS_SYSOBJECTS O
              INNER JOIN DYN_DS_SYS_STATS ST
                      ON O.id = ST.object_id
              INNER JOIN DYN_DS_STATS_COLUMNS AS SC
                      ON ST.object_id = SC.object_id
                         AND ST.stats_id = SC.stats_id
              INNER JOIN DYN_DS_SYSCOLUMNS AS C
                      ON SC.object_id = C.object_id
                         AND C.column_id = SC.column_id
              INNER JOIN DYN_DS_SYSSCHEMAS AS SCH
                      ON O.uid = SCH.schema_id
       WHERE  O.xtype = 'u'
              AND SC.stats_column_id = 1
              AND C.system_type_id <> 189
              AND SCH.name <> 'sys' --remove timestamps, incompatiable with sql_variant datatype we used
              AND (ST.auto_created = 0
              AND ST.user_created = 0 )
       

/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN table_cursor 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM table_cursor INTO @tablename, @indexname, @colname, @schemaname

/* Verify that we got a record*/
/* status 0 means we got a good record*/



WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */
--	print @tablename + '    ' + @indexname




--------------------------------------STATS HEADER --------------------------------------------------------------		


	SELECT @SQL = 'DBCC SHOW_STATISTICS('+'''' +@DATABASE_NAME +'.'+@schemaname+'.' +@tablename + '''' +',' +QUOTENAME(@indexname,'''')+') WITH  STAT_HEADER, NO_INFOMSGS'
		
		IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL
		END
		
	--REH Truncate the table before we insert data into it
	TRUNCATE TABLE #table_stat_header
		
		IF @REMOTE_SERVER = 'N'
			 BEGIN
				 BEGIN TRY
					 INSERT #table_stat_header
					 EXEC (@SQL ) --DBCC SHOW_STATISTICS STAT_HEADER
				 END TRY

				 BEGIN CATCH
				 --ignore the error
				 END CATCH
			 END

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
							 + @SERVER_NAME + ']'

				 IF @DEBUG = 'Y'
					  BEGIN
						  PRINT '@SQL= ' + @SQL2
					  END

				 BEGIN TRY
					 INSERT #table_stat_header
					 EXEC (@SQL2 ) --DBCC SHOW_STATISTICS STAT_HEADER
				 END TRY

				 BEGIN CATCH
				 --ignore the error
				 END CATCH
				 
				 
			 END 


	--REH Now insert the records from the temp table into our table
			INSERT INDEX_STAT_HEADER
			SELECT @SERVER_NAME,
				   @DATABASE_NAME,
				   @tablename,
				   @indexname,
				   *
			FROM   #table_stat_header 





--------------------------------------DENSITY VECTOR --------------------------------------------------------------		


	SELECT @SQL = 'DBCC SHOW_STATISTICS('+'''' +@DATABASE_NAME +'.'+@schemaname+'.' +@tablename + '''' +',' +QUOTENAME(@indexname,'''')+') WITH DENSITY_VECTOR, NO_INFOMSGS'
		
		IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL
		END
		
	--REH Truncate the table before we insert data into it
	TRUNCATE TABLE #TableStats
		
		IF @REMOTE_SERVER = 'N'
			 BEGIN
				 BEGIN TRY
					 INSERT #TableStats
					 EXEC (@SQL ) --DBCC SHOW_STATISTICS DENSITY VECTOR
				 END TRY

				 BEGIN CATCH
				 --ignore the error
				 END CATCH
			 END

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
							 + @SERVER_NAME + ']'

				 IF @DEBUG = 'Y'
					  BEGIN
						  PRINT '@SQL= ' + @SQL2
					  END

				 BEGIN TRY
					 INSERT #TableStats
					 EXEC (@SQL2 ) --DBCC SHOW_STATISTICS DENSITY VECTOR
				 END TRY

				 BEGIN CATCH
				 --ignore the error
				 END CATCH
				 
				 
			 END 


	--REH Now insert the records from the temp table into our table
			INSERT INDEX_DENSITY_VECTOR
			SELECT @SERVER_NAME,
				   @DATABASE_NAME,
				   @tablename,
				   @indexname,
				   *
			FROM   #TableStats 

--------------------------------------HISTOGRAM --------------------------------------------------------------		


	SELECT @SQL = 'DBCC SHOW_STATISTICS('+'''' +@DATABASE_NAME +'.'+@schemaname+'.' +@tablename + '''' +',' +QUOTENAME(@indexname,'''')+') WITH HISTOGRAM, NO_INFOMSGS'
		
		IF @DEBUG = 'Y' 
		BEGIN
			PRINT '@SQL= ' + @SQL
		END
		
		
--REH Truncate the table before we insert data into it
	TRUNCATE TABLE #TableHistogram
		
			IF @REMOTE_SERVER = 'N'
				 BEGIN
					 BEGIN TRY
						 INSERT #TableHistogram
						 EXEC (@SQL ) --DBCC SHOW_STATISTICS DENSITY VECTOR
					 END TRY

					 BEGIN CATCH
					 --ignore the error
					 END CATCH
				 END 

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
							 + @SERVER_NAME + ']'

				 IF @DEBUG = 'Y'
					  BEGIN
						  PRINT '@SQL= ' + @SQL2
					  END

				 BEGIN TRY
					 INSERT #TableHistogram
					 EXEC (@SQL2 ) --DBCC SHOW_STATISTICS DENSITY VECTOR
				 END TRY

				 BEGIN CATCH
				 --ignore the error
				 END CATCH
				 
				 
			 END 	
			 
	--REH Now insert the records from the temp table into our table
				INSERT INDEX_HISTOGRAM
				SELECT @SERVER_NAME,
					   @DATABASE_NAME,
					   @tablename,
					   @indexname,
					   @colname,
					   *
				FROM   #TableHistogram 

				SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

---------------------------------------BOTTOM OF LOOP----------------------------------------------

	FETCH NEXT FROM table_cursor INTO @tablename,@indexname,@colname,@schemaname
END  /*End of the loop */
CLOSE table_cursor  /*close the cursor to free memory in SQL*/
DEALLOCATE table_cursor /*Must deallocate the cursor to destroy it and free SQL resources*/
 
 
 
 
 
 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_AX_BATCHSERVER]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_AX_BATCHSERVER (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS





return(0) --REH no longer used, AOTEXPORT CLASS goes direct to DynamicsPerf now










/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXBATCH_AX_SYSCLUSTERCONFIG')
  DROP SYNONYM [dbo].DYN_AXBATCH_AX_SYSCLUSTERCONFIG


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXBATCH_AX_SYSCLUSTERCONFIG
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSCLUSTERCONFIG'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXBATCH_AX_SYSCLUSTERCONFIG
				FOR [' + @DATABASE_NAME + '].dbo.SYSCLUSTERCONFIG'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXBATCH_AX_SYSSERVERCONFIG')
  DROP SYNONYM [dbo].DYN_AXBATCH_AX_SYSSERVERCONFIG


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXBATCH_AX_SYSSERVERCONFIG
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSSERVERCONFIG'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXBATCH_AX_SYSSERVERCONFIG
				FOR [' + @DATABASE_NAME + '].dbo.SYSSERVERCONFIG'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXBATCH_AX_BATCHSERVERCONFIG')
  DROP SYNONYM [dbo].DYN_AXBATCH_AX_BATCHSERVERCONFIG


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXBATCH_AX_BATCHSERVERCONFIG
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.BATCHSERVERCONFIG'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXBATCH_AX_BATCHSERVERCONFIG
				FOR [' + @DATABASE_NAME + '].dbo.BATCHSERVERCONFIG'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXBATCH_AX_BATCHSERVERGROUP')
  DROP SYNONYM [dbo].DYN_AXBATCH_AX_BATCHSERVERGROUP


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXBATCH_AX_BATCHSERVERGROUP
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.BATCHSERVERGROUP'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXBATCH_AX_BATCHSERVERGROUP
				FOR [' + @DATABASE_NAME + '].dbo.BATCHSERVERGROUP'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXBATCH_AX_BATCH')
  DROP SYNONYM [dbo].DYN_AXBATCH_AX_BATCH


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXBATCH_AX_BATCH
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.BATCH'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXBATCH_AX_BATCH
				FOR [' + @DATABASE_NAME + '].dbo.BATCH'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXBATCH_AX_BATCHJOB')
  DROP SYNONYM [dbo].DYN_AXBATCH_AX_BATCHJOB


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXBATCH_AX_BATCHJOB
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.BATCHJOB'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXBATCH_AX_BATCHJOB
				FOR [' + @DATABASE_NAME + '].dbo.BATCHJOB'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


--REH Get AX version

--DECLARE @AX_SERVER_NAME   NVARCHAR(128) = NULL,
--        @AX_DATABASE_NAME NVARCHAR(128),
--        @AX_APP_BUILD     NVARCHAR(120),
--        @KERNEL_BUILD     NVARCHAR(20)
   
--   CREATE TABLE #AX_VERSION
--     (
--        AX_APP_BUILD NVARCHAR(120),
--        KERNEL_BUILD NVARCHAR(20)
--     )
   
--   SET NOCOUNT ON
   
--   INSERT #AX_VERSION
--   EXECUTE DYNPERF_AX_VERSION_INFO
--     @AX_SERVER_NAME = @SERVER_NAME,
--     @AX_DATABASE_NAME = @DATABASE_NAME--, @DEBUG = 'N'
--   SELECT @AX_APP_BUILD = AX_APP_BUILD,
--          @KERNEL_BUILD = KERNEL_BUILD
--   FROM   #AX_VERSION
   
--   --PRINT 'AX BUILD = ' + ISNULL(@AX_APP_BUILD, '')
   
--   --PRINT 'KERNEL BUILD = '+ ISNULL(@KERNEL_BUILD, '')
   
--   DROP TABLE #AX_VERSION 
   
   
  

--IF Substring(@AX_APP_BUILD, 1, 2) = N'5.'  OR Substring(@AX_APP_BUILD, 1, 2) = N'6.'
--    BEGIN	
--			DELETE AC  FROM AX_BATCHSERVER_CONFIGURATION    AC WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME
            
--					INSERT AX_BATCHSERVER_CONFIGURATION
--						   SELECT DISTINCT @SERVER_NAME, @DATABASE_NAME,
--								SYSCLUSTERCONFIG.CLUSTERNAME,
--							   SYSCLUSTERCONFIG.CLUSTERDESCRIPTION,
--							   SYSSERVERCONFIG.SERVERID,
--							   SYSSERVERCONFIG.MAXSESSIONS,
--							   SYSSERVERCONFIG.ENABLEBATCH,
--							   Dateadd(SECOND, BATCHSERVERCONFIG.STARTTIME, Dateadd(DAY, Datediff(DAY, 0, Getdate()), 0)),
--							   Dateadd(SECOND, BATCHSERVERCONFIG.ENDTIME, Dateadd(DAY, Datediff(DAY, 0, Getdate()), 0))   ,
--							   BATCHSERVERCONFIG.MAXBATCHSESSIONS,
--							   BATCHSERVERGROUP.GROUPID,
--							   BATCHJOB.COMPANY,
--							   BATCHJOB.CAPTION,
--							   BATCH.CAPTION,
	
--						   CASE BATCH.RUNTYPE
--								 WHEN 1 THEN 'Server'
--								 ELSE 'Client'
--							   END                                                                  
--						FROM   DYN_AXBATCH_AX_SYSCLUSTERCONFIG SYSCLUSTERCONFIG
--							   INNER JOIN DYN_AXBATCH_AX_SYSSERVERCONFIG SYSSERVERCONFIG
--								 ON SYSSERVERCONFIG.CLUSTERREFRECID = SYSCLUSTERCONFIG.RECID
--							   LEFT OUTER JOIN DYN_AXBATCH_AX_BATCHSERVERCONFIG BATCHSERVERCONFIG
--								 ON SYSSERVERCONFIG.SERVERID = BATCHSERVERCONFIG.SERVERID
--							   LEFT OUTER JOIN DYN_AXBATCH_AX_BATCHSERVERGROUP BATCHSERVERGROUP
--								 ON BATCHSERVERGROUP.SERVERID = SYSSERVERCONFIG.SERVERID
--							   LEFT OUTER JOIN DYN_AXBATCH_AX_BATCH BATCH
--								 ON BATCH.GROUPID = BATCHSERVERGROUP.GROUPID
--							   LEFT OUTER JOIN DYN_AXBATCH_AX_BATCHJOB BATCHJOB
--								 ON BATCHJOB.RECID = BATCH.BATCHJOBID 
								 
								 
--	END
	
	
 
    
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_DATABASE_VLFS]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_DATABASE_VLFS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION VARCHAR(30), @C_DATABASE_NAME NVARCHAR(128), @ROW_COUNT BIGINT = 0
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_VLF_SYSDATABASES')
  EXEC ('DROP SYNONYM [dbo].DYN_VLF_SYSDATABASES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_VLF_SYSDATABASES
				FOR [' + @SERVER_NAME + '].master.sys.databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_VLF_SYSDATABASES
				FOR master.sys.databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_VLF_SQLVERSION')
  EXEC ('DROP SYNONYM [dbo].DYN_VLF_SQLVERSION')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_VLF_SQLVERSION
				FOR [' + @SERVER_NAME + '].master.sys.xp_msver'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_VLF_SQLVERSION
				FOR master.sys.xp_msver'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


CREATE  table #SQLVERSION(
[INDEX] INT,
NAME NVARCHAR(128),
INTERNAL_VALUE NVARCHAR(128),
VALUE NVARCHAR(128)
);

INSERT #SQLVERSION
exec DYN_VLF_SQLVERSION 'ProductVersion' --[master].sys.[xp_msver]

SELECT @SQLVERSION = VALUE FROM #SQLVERSION WHERE NAME = 'ProductVersion'

DROP TABLE #SQLVERSION


--REH  can't use temp table because they only last for the the exec(@sql) after it comes back they are gone

IF OBJECT_ID('VLFS') > 0
DROP TABLE VLFS


IF SUBSTRING(@SQLVERSION, 1, 3) = '10.'
     BEGIN
         SET @SQL = '
			CREATE TABLE VLFS (
			 FileId int, FileSize bigint, StartOffset bigint, FSeqNo int, Status tinyint, Parity tinyint, CreateLSN numeric(25,0) )
			'

         EXEC (@SQL)
     END
ELSE
     BEGIN
         SET @SQL = '
				CREATE TABLE VLFS (
				Q char, FileId int, FileSize bigint, StartOffset bigint, FSeqNo int, Status tinyint, Parity tinyint, CreateLSN numeric(25,0) )
				'

         EXEC(@SQL)
     END 


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''




DECLARE DB_CURSOR CURSOR  LOCAL
FOR
SELECT name from DYN_VLF_SYSDATABASES


OPEN DB_CURSOR

FETCH NEXT FROM DB_CURSOR INTO @C_DATABASE_NAME

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

--REH Zero it out for each pass

TRUNCATE TABLE VLFS

SET @SQL = 'DBCC LOGINFO ([' + @C_DATABASE_NAME + ']) WITH NO_INFOMSGS'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

IF @REMOTE_SERVER = 'N'
BEGIN

		INSERT VLFS EXEC (@SQL) 

END
ELSE
BEGIN

		          
		SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT ['
					+ @SERVER_NAME + ']' 

		  
		  IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL2
		END

		INSERT VLFS  EXEC (@SQL2)


END


INSERT INTO LOGINFO



SELECT @SERVER_NAME,
		@STATS_DATE,
       @C_DATABASE_NAME,
       RH.*
FROM   (SELECT FileId,
               COUNT(*) AS VLF_COUNT,
               SUM(CASE
                     WHEN Status = 0 THEN 1
                     ELSE 0
                   END) AS FREE,
               SUM(CASE
                     WHEN Status != 0 THEN 1
                     ELSE 0
                   END) AS INUSE
        FROM   VLFS
        GROUP  BY FileId
        ) AS RH 
    
	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT    
        
FETCH NEXT FROM DB_CURSOR INTO @C_DATABASE_NAME

END  /*End of the loop */
CLOSE DB_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE DB_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 

 

--REH CLEANUP THE TABLES

IF OBJECT_ID('VLFS') > 0 DROP TABLE VLFS

    
 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH


--REH CLEANUP THE TABLES

IF OBJECT_ID('VLFS') > 0 DROP TABLE VLFS



    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_INDEX_OPERATIONAL_STATS]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_INDEX_OPERATIONAL_STATS
											 (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS



/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @PREV_STATS_TIME DATETIME,
		@DATABASE_ID INT
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

--IF EXISTS (SELECT *
--           FROM   sys.synonyms
--           WHERE  name = 'DYN_SYSDBS')
--  DROP SYNONYM [dbo].DYN_SYSDBS


--IF @REMOTE_SERVER = 'Y'
--     BEGIN
--         SET @SQL = '
--				CREATE SYNONYM DYN_SYSDBS
--				FOR [' + @SERVER_NAME + '].[master].sys.sysdatabases'
--     END
--ELSE

--         SET @SQL = '
--				CREATE SYNONYM DYN_SYSDBS
--				FOR master.sys.sysdatabases'



---- SELECT * FROM DYN_SYSDBS

--IF @DEBUG = 'Y'
--     BEGIN
--         PRINT '@SQL= ' + @SQL
--     END

--EXEC(@SQL) 




/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


--SELECT @DATABASE_ID = dbid FROM DYN_SYSDBS WITH (NOLOCK) WHERE name = @DATABASE_NAME


IF @REMOTE_SERVER = 'N'
     BEGIN
         INSERT INTO DynamicsPerf.dbo.INDEX_OPERATIONAL_STATS
         SELECT @SERVER_NAME, 
				@STATS_DATE AS current_datetime,
                @DATABASE_NAME,
                object_id,
                index_id,
                leaf_insert_count,
                leaf_delete_count,
                leaf_update_count,
                leaf_ghost_count,
                nonleaf_insert_count,
                nonleaf_delete_count,
                nonleaf_update_count,
                leaf_allocation_count,
                nonleaf_allocation_count,
                leaf_page_merge_count,
                nonleaf_page_merge_count,
                range_scan_count,
                singleton_lookup_count,
                forwarded_fetch_count,
                lob_fetch_in_pages,
                lob_fetch_in_bytes,
                lob_orphan_create_count,
                lob_orphan_insert_count,
                row_overflow_fetch_in_pages,
                row_overflow_fetch_in_bytes,
                column_value_push_off_row_count,
                column_value_pull_in_row_count,
                row_lock_count,
                row_lock_wait_count,
                row_lock_wait_in_ms,
                page_lock_count,
                page_lock_wait_count,
                page_lock_wait_in_ms,
                index_lock_promotion_attempt_count,
                index_lock_promotion_count,
                page_latch_wait_count,
                page_latch_wait_in_ms,
                page_io_latch_wait_count,
                page_io_latch_wait_in_ms
         FROM    sys.dm_db_index_operational_stats(DB_ID(@DATABASE_NAME), NULL, NULL, NULL)
         WHERE  object_id > 99
     END 
IF @REMOTE_SERVER = 'Y'
BEGIN

		SET @SQL = '
		SELECT 
	               object_id,
                index_id,
                leaf_insert_count,
                leaf_delete_count,
                leaf_update_count,
                leaf_ghost_count,
                nonleaf_insert_count,
                nonleaf_delete_count,
                nonleaf_update_count,
                leaf_allocation_count,
                nonleaf_allocation_count,
                leaf_page_merge_count,
                nonleaf_page_merge_count,
                range_scan_count,
                singleton_lookup_count,
                forwarded_fetch_count,
                lob_fetch_in_pages,
                lob_fetch_in_bytes,
                lob_orphan_create_count,
                lob_orphan_insert_count,
                row_overflow_fetch_in_pages,
                row_overflow_fetch_in_bytes,
                column_value_push_off_row_count,
                column_value_pull_in_row_count,
                row_lock_count,
                row_lock_wait_count,
                row_lock_wait_in_ms,
                page_lock_count,
                page_lock_wait_count,
                page_lock_wait_in_ms,
                index_lock_promotion_attempt_count,
                index_lock_promotion_count,
                page_latch_wait_count,
                page_latch_wait_in_ms,
                page_io_latch_wait_count,
                page_io_latch_wait_in_ms
				
				 FROM  sys.dm_db_index_operational_stats( DB_ID(' + '''' + @DATABASE_NAME + '''' + '), NULL, NULL, NULL)
						
				 WHERE  object_id > 99';

		--INSERT 
		--EXECUTE (@SQL) AT [RODSP3\SQL2014];
		
		                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  INSERT INTO DynamicsPerf.dbo.INDEX_OPERATIONAL_STATS
				 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + ','
				  + '''' + @DATABASE_NAME + '''' + ',
                    
                    
	               object_id,
                index_id,
                leaf_insert_count,
                leaf_delete_count,
                leaf_update_count,
                leaf_ghost_count,
                nonleaf_insert_count,
                nonleaf_delete_count,
                nonleaf_update_count,
                leaf_allocation_count,
                nonleaf_allocation_count,
                leaf_page_merge_count,
                nonleaf_page_merge_count,
                range_scan_count,
                singleton_lookup_count,
                forwarded_fetch_count,
                lob_fetch_in_pages,
                lob_fetch_in_bytes,
                lob_orphan_create_count,
                lob_orphan_insert_count,
                row_overflow_fetch_in_pages,
                row_overflow_fetch_in_bytes,
                column_value_push_off_row_count,
                column_value_pull_in_row_count,
                row_lock_count,
                row_lock_wait_count,
                row_lock_wait_in_ms,
                page_lock_count,
                page_lock_wait_count,
                page_lock_wait_in_ms,
                index_lock_promotion_attempt_count,
                index_lock_promotion_count,
                page_latch_wait_count,
                page_latch_wait_in_ms,
                page_io_latch_wait_count,
                page_io_latch_wait_in_ms
					
					FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '
                    

					IF @DEBUG = 'Y'
					  BEGIN
						  PRINT @SQL2
					  END 
  
                    EXEC (@SQL2)
           
                
		

END

 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_INDEX_USAGE_STATS]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_INDEX_USAGE_STATS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @DATABASE_ID INT, @PREV_STATS_TIME DATETIME
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_INDEX_USAGE')
  EXEC ('DROP SYNONYM [dbo].DYN_INDEX_USAGE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_INDEX_USAGE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.dm_db_index_usage_stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_INDEX_USAGE
				FOR [' + @DATABASE_NAME + '].sys.dm_db_index_usage_stats'

IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


--IF EXISTS (SELECT *
--           FROM   sys.synonyms
--           WHERE  name = 'DYN_SYSDBS')
--  DROP SYNONYM [dbo].DYN_SYSDBS


--IF @REMOTE_SERVER = 'Y'
--     BEGIN
--         SET @SQL = '
--				CREATE SYNONYM DYN_SYSDBS
--				FOR [' + @SERVER_NAME + '].[master].sys.sysdatabases'
--     END
--ELSE

--         SET @SQL = '
--				CREATE SYNONYM DYN_SYSDBS
--				FOR master.sys.sysdatabases'


--IF @DEBUG = 'Y'
--     BEGIN
--         PRINT '@SQL= ' + @SQL
--     END

--EXEC(@SQL) 

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


--SELECT @DATABASE_ID = dbid FROM DYN_SYSDBS WITH (NOLOCK) WHERE name = @DATABASE_NAME
INSERT INTO [DynamicsPerf].dbo.INDEX_USAGE_STATS
SELECT DISTINCT @SERVER_NAME,
                @STATS_DATE,
                @DATABASE_NAME,
                object_id,
                index_id,
                user_seeks,
                user_scans,
                user_lookups,
                user_updates,
                last_user_seek,
                last_user_scan,
                last_user_lookup,
                last_user_update,
                system_seeks,
                system_scans,
                system_lookups,
                system_updates,
                last_system_seek,
                last_system_scan,
                last_system_lookup,
                last_system_update
FROM   DYN_INDEX_USAGE AS DIU
       INNER JOIN (SELECT TOP 1 DATABASE_ID,
                                SERVER_NAME,
                                DATABASE_NAME
                   FROM   [DynamicsPerf].dbo.SQL_DATABASES
                   WHERE  SERVER_NAME = @SERVER_NAME
                          AND DATABASE_NAME = @DATABASE_NAME
                   ORDER  BY STATS_TIME DESC) SD
               ON DIU.database_id = SD.DATABASE_ID
                  AND SD.SERVER_NAME = @SERVER_NAME
                  AND SD.DATABASE_NAME = @DATABASE_NAME
WHERE  object_id > 99 


 
 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_INDEXSTATS]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_INDEXSTATS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @PREV_STATS_TIME DATETIME
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_INDEX_COLS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_INDEX_COLS')


IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_INDEX_COLS
				FOR [' + @DATABASE_NAME + '].sys.index_columns'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_SYS_COLS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_SYS_COLS')


IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_SYS_COLS
				FOR [' + @DATABASE_NAME + '].sys.columns'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_INDEXES')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_INDEXES')


IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_INDEXES
				FOR [' + @DATABASE_NAME + '].sys.indexes'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_SYS_INDEXES')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_SYS_INDEXES')


IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_SYS_INDEXES
				FOR [' + @DATABASE_NAME + '].sys.sysindexes'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_OBJECTS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_OBJECTS')


IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_OBJECTS
				FOR [' + @DATABASE_NAME + '].sys.objects'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_SCHEMAS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_SCHEMAS')

IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_SCHEMAS
				FOR [' + @DATABASE_NAME + '].sys.schemas'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_PARTITIONS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_PARTITIONS')

IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_PARTITIONS
				FOR [' + @DATABASE_NAME + '].sys.partitions'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_PARTITION_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_PARTITION_STATS')

IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_PARTITION_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_db_partition_stats'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


IF @REMOTE_SERVER = 'N'
BEGIN
	INSERT INTO INDEX_DETAIL
	SELECT	@SERVER_NAME, CONVERT(NVARCHAR(50), @STATS_DATE, 121), @DATABASE_NAME ,
 			si.object_id,
			si.index_id,
			CASE 
			WHEN ss.name in ('sys', 'dbo') THEN so.name
			ELSE 
				ss.name + '.' + so.name
			END, 
			si.name,  
			si.type_desc+
			CASE
				WHEN is_unique = 1 THEN ', UNIQUE'
				ELSE ''
			END
			+	
			CASE
				WHEN is_primary_key = 1 THEN ', PRIMARY KEY'
				ELSE ''
			END
			+
			CASE
				WHEN has_filter = 1 THEN ', FILTERED'
				ELSE ''
			END			
			
			,
    	stuff
    		(
    				
    			(
    			SELECT	', ' + sc.name FROM DYN_CI_INDEX_COLS sic
    			JOIN	DYN_CI_SYS_COLS sc ON sc.column_id = sic.column_id
    			WHERE	so.object_id = sic.object_id
    			AND		sic.index_id = si.index_id
    			AND		sc.object_id = so.object_id
    			AND		sic.is_included_column=0
    			ORDER	BY sic.key_ordinal
    			FOR		xml path('')
    			)
    		,1,1,''
    		)  AS key_columns,
    	stuff
    		(
    			(
    			SELECT	', ' + sc.name FROM DYN_CI_INDEX_COLS sic
    			JOIN	DYN_CI_SYS_COLS sc ON sc.column_id = sic.column_id
    			WHERE	so.object_id = sic.object_id
    			AND		sic.index_id = si.index_id
    			AND		sc.object_id = so.object_id
    			AND		sic.is_included_column=1
    			ORDER BY sic.key_ordinal
    			FOR XML path('')
    			)
    		,1,1,''
    		)  AS included_columns,
    	PS.DATA_SIZE AS PAGE_COUNT,
    	PS.ROW_COUNT AS ROW_COUNT,
    	sp.data_compression
  	FROM	DYN_CI_INDEXES si
    	JOIN	DYN_CI_SYS_INDEXES ii ON si.object_id = ii.id AND si.index_id = ii.indid
    	JOIN	DYN_CI_OBJECTS so ON so.object_id = si.object_id
    	JOIN	DYN_CI_SCHEMAS ss ON ss.schema_id = so.schema_id
    	JOIN	DYN_CI_PARTITIONS sp ON so.object_id = sp.object_id AND sp.index_id = ii.indid
    	INNER JOIN  (SELECT object_id, index_id,SUM(row_count) AS ROW_COUNT,SUM(in_row_data_page_count + lob_used_page_count + row_overflow_used_page_count) AS DATA_SIZE
    	FROM DYN_CI_PARTITION_STATS GROUP BY  object_id, index_id) AS PS ON PS.index_id = si.index_id AND PS.object_id = si.object_id
    	   	
     WHERE	so.type = 'U'
    	AND		si.type > 0  --other than heap tables
    	AND     sp.partition_number = 1  -- fix issue with partiioned tables multiplying the number or records we return
    
	
	UNION ALL
    
    
SELECT	@SERVER_NAME, CONVERT(NVARCHAR(50), @STATS_DATE, 121), @DATABASE_NAME ,
    
			si.object_id,
			si.index_id,
			so.name, 
			so.name, 
			'HEAP',
			'N/A', 
			'N/A',
	PS.DATA_SIZE AS PAGE_COUNT,
	PS.ROW_COUNT AS ROW_COUNT,
	sp.data_compression 
    	FROM	DYN_CI_INDEXES si
	JOIN	DYN_CI_SYS_INDEXES ii ON si.object_id = ii.id AND si.index_id = ii.indid
	JOIN	DYN_CI_OBJECTS so ON so.object_id = si.object_id
	JOIN	DYN_CI_SCHEMAS ss ON ss.schema_id = so.schema_id
	JOIN	DYN_CI_PARTITIONS sp ON so.object_id = sp.object_id AND sp.index_id = ii.indid
	
    INNER JOIN  (SELECT object_id, index_id,SUM(row_count) AS ROW_COUNT,SUM(in_row_data_page_count + lob_used_page_count + row_overflow_used_page_count) AS DATA_SIZE
	FROM DYN_CI_PARTITION_STATS GROUP BY  object_id, index_id) AS PS ON PS.index_id = si.index_id AND PS.object_id = si.object_id
		
 WHERE	so.type = 'U'
	AND		si.type = 0  --only heap tables
	AND     sp.partition_number = 1  -- fix issue with partiioned tables multiplying the number or records we return

 END
 
 IF @REMOTE_SERVER = 'Y'
 BEGIN
 
 
    		SET @SQL = '	
			
			
			SELECT	
 			si.object_id,
			si.index_id,
			CASE 
			WHEN ss.name in (''sys'', ''dbo'') THEN so.name
			ELSE 
				ss.name + ''.'' + so.name
			END, 
			si.name,  
			si.type_desc+
			CASE
				WHEN is_unique = 1 THEN '', UNIQUE''
				ELSE ''''
			END
			+	
			CASE
				WHEN is_primary_key = 1 THEN '', PRIMARY KEY''
				ELSE ''''
			END
			+
			CASE
				WHEN has_filter = 1 THEN '', FILTERED''
				ELSE ''''
			END,
			

    	stuff
    		(
    				
    			(
    			SELECT '', '' + sc.name FROM	['+ @DATABASE_NAME+ '].sys.index_columns sic
    			JOIN	['+ @DATABASE_NAME+ '].sys.columns sc ON sc.column_id = sic.column_id
    			WHERE	so.object_id = sic.object_id
    			AND		sic.index_id = si.index_id
    			AND		sc.object_id = so.object_id
    			AND		sic.is_included_column=0
    			ORDER	BY sic.key_ordinal
    			FOR		xml path('''')
    			)
    		,1,1,''''
    		)  AS key_columns,
    	stuff
    		(
    			(
    			SELECT	'', '' + sc.name FROM ['+ @DATABASE_NAME+ '].sys.index_columns sic
    			JOIN	['+ @DATABASE_NAME+ '].sys.columns sc ON sc.column_id = sic.column_id
    			WHERE	so.object_id = sic.object_id
    			AND		sic.index_id = si.index_id
    			AND		sc.object_id = so.object_id
    			AND		sic.is_included_column=1
    			ORDER BY sic.key_ordinal
    			FOR XML path('''')
    			)
    		,1,1,''''
    		)  AS included_columns,
    	PS.DATA_SIZE AS PAGE_COUNT,
    	PS.ROW_COUNT AS ROW_COUNT,
    	sp.data_compression
    	FROM	['+ @DATABASE_NAME+ '].sys.indexes si
    	JOIN	['+ @DATABASE_NAME+ '].sys.sysindexes ii ON si.object_id = ii.id AND si.index_id = ii.indid
    	JOIN	['+ @DATABASE_NAME+ '].sys.objects so ON so.object_id = si.object_id
    	JOIN	['+ @DATABASE_NAME+ '].sys.schemas ss ON ss.schema_id = so.schema_id
    	JOIN	['+ @DATABASE_NAME+ '].sys.partitions sp ON so.object_id = sp.object_id AND sp.index_id = ii.indid
    	INNER JOIN  (SELECT object_id, index_id,SUM(row_count) AS ROW_COUNT,SUM(in_row_data_page_count + lob_used_page_count + row_overflow_used_page_count) AS DATA_SIZE
    	FROM ['+ @DATABASE_NAME+ '].sys.dm_db_partition_stats GROUP BY  object_id, index_id) AS PS ON PS.index_id = si.index_id AND PS.object_id = si.object_id
    	
     WHERE	so.type = ''U''
    	AND		si.type > 0 
    	AND     sp.partition_number = 1 
    
	
	UNION ALL
    
    
SELECT	
    
			si.object_id,
			si.index_id,
			so.name, 
			so.name, 
			''HEAP'',

			''N/A'', 
			''N/A'',
	PS.DATA_SIZE AS PAGE_COUNT,
	PS.ROW_COUNT AS ROW_COUNT,
	sp.data_compression 
    	FROM	['+ @DATABASE_NAME+ '].sys.indexes si
	JOIN	['+ @DATABASE_NAME+ '].sys.sysindexes ii ON si.object_id = ii.id AND si.index_id = ii.indid
	JOIN	['+ @DATABASE_NAME+ '].sys.objects so ON so.object_id = si.object_id
	JOIN	['+ @DATABASE_NAME+ '].sys.schemas ss ON ss.schema_id = so.schema_id
	JOIN	['+ @DATABASE_NAME+ '].sys.partitions sp ON so.object_id = sp.object_id AND sp.index_id = ii.indid
	
    INNER JOIN  (SELECT object_id, index_id,SUM(row_count) AS ROW_COUNT,SUM(in_row_data_page_count + lob_used_page_count + row_overflow_used_page_count) AS DATA_SIZE
	FROM ['+ @DATABASE_NAME+ '].sys.dm_db_partition_stats GROUP BY  object_id, index_id) AS PS ON PS.index_id = si.index_id AND PS.object_id = si.object_id
	
 WHERE	so.type = ''U''
	AND		si.type = 0  --only heap tables
	AND     sp.partition_number = 1 ' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  INSERT INTO DynamicsPerf.dbo.INDEX_DETAIL
						 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + ','
				  + '''' + @DATABASE_NAME + '''' + ',*
		                   FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ')'


		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)

 END
 
    
    
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_QUERY_PLANS]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_QUERY_PLANS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_QP_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_QP_STATS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_QP_STATS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.dm_exec_query_stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_QP_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_query_stats'

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @REMOTE_SERVER = 'N'
BEGIN
;WITH Query_Stats_CTE ( QUERY_PLAN_HASH, PLAN_HANDLE )
     AS
     -- Define the CTE query.
     (SELECT DISTINCT QUERY_PLAN_HASH,
                      PLAN_HANDLE
      FROM   QUERY_STATS AS QS
      WHERE  STATS_TIME >= @LAST_RUN
             AND DATABASE_NAME = @DATABASE_NAME
             AND SERVER_NAME = @SERVER_NAME 
             AND QUERY_PLAN_HASH > 0x00000000
             AND NOT EXISTS (SELECT 'X'
                             FROM   QUERY_PLANS QP
                             WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
                                    AND QS.DATABASE_NAME = QP.DATABASE_NAME
                                    AND QS.SERVER_NAME = QP.SERVER_NAME ))
INSERT INTO QUERY_PLANS
SELECT @SERVER_NAME,
       @DATABASE_NAME,
       QUERY_PLAN_HASH,
       QUERY_PLAN,
       '',
       0,
       0,
       GETDATE()
FROM   (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_PLAN_HASH
                        ORDER BY CTE.QUERY_PLAN_HASH DESC),
               CTE.QUERY_PLAN_HASH,
               query_plan AS QUERY_PLAN
        FROM   Query_Stats_CTE CTE
               OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH
WHERE  RN = 1 




END

IF @REMOTE_SERVER = 'Y'
     BEGIN
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)


         SET @SQL = '
				CREATE TABLE [tempdb].dbo.DYNPERF_QUERY_HASH
				(
				QUERY_PLAN_HASH VARBINARY(64), 
				PLAN_HANDLE VARBINARY(64)
				)'


         SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT [' + @SERVER_NAME
									 + ']'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

         SET @SQL = '

					;WITH Query_Stats_CTE ( QUERY_PLAN_HASH, PLAN_HANDLE)
						 AS (SELECT DISTINCT QUERY_PLAN_HASH,
										  PLAN_HANDLE
							 FROM   QUERY_STATS QS
							 WHERE  QS.STATS_TIME >= ' + ''''
										+ CONVERT(NVARCHAR(24), @LAST_RUN, 121)
										+ ''''
										+ '
									AND DATABASE_NAME = '
										+ '''' + @DATABASE_NAME + ''''
										+ '
									AND SERVER_NAME = ' + '''' +
										+ @SERVER_NAME + ''''
										+ ' 
									AND NOT EXISTS (SELECT ''X''
													FROM   QUERY_PLANS QP
												 WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
														AND QS.DATABASE_NAME = QP.DATABASE_NAME
														AND QS.SERVER_NAME = QP.SERVER_NAME 
													))
						INSERT INTO OPENQUERY([' + @SERVER_NAME
										+ '], ''SELECT QUERY_PLAN_HASH, PLAN_HANDLE FROM '
										+ '[tempdb].dbo.DYNPERF_QUERY_HASH'')
					                            
					  
					SELECT QUERY_PLAN_HASH, PLAN_HANDLE 
					FROM   (SELECT RN = ROW_NUMBER()
										  OVER (
											PARTITION BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE
											ORDER BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE DESC),
								   CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE 
					            
								FROM   Query_Stats_CTE CTE
							   ) AS RH
					WHERE  RN = 1 '

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END 


         EXEC(@SQL)

			SET @SQL = 'SELECT 
				   QUERY_PLAN_HASH,
				   cast(query_plan as nvarchar(max)) as QUERY_PLAN

			FROM   (SELECT RN = ROW_NUMBER()
								  OVER (
									PARTITION BY QUERY_PLAN_HASH
									ORDER BY QUERY_PLAN_HASH DESC),
						   QUERY_PLAN_HASH,
						   query_plan 
					FROM   [tempdb].dbo.DYNPERF_QUERY_HASH CTE
						   OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH
			WHERE  RN = 1 ' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  INSERT INTO DynamicsPerf.dbo.QUERY_PLANS
						 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + ''''
					+ @DATABASE_NAME + ''''
					+ ',
		                    QUERY_PLAN_HASH, CAST(QUERY_PLAN AS XML), ' + QUOTENAME('','''') + ',0,0,GETDATE() FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ')' --RH '
					--		RH.QUERY_PLAN_HASH, RH.QUERY_PLAN, '''', 0, 0, GETDATE() FROM OPENQUERY(['
					--+ @SERVER_NAME + '], ' + ''' + @SQL + ''' + ') RH ' 

		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)
         

		 --REH Drop the table at the end of the process

         SET @SQL = '

				IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
				 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)
     
     END 





UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_QUERY_STATS]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_QUERY_STATS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQL_BUILD NVARCHAR(128)

	--REH Get the build so we can add the new columns to the query_stats table from SQL2016 and above
    SELECT @SQL_BUILD = SQL_VERSION  FROM STATS_COLLECTION_SUMMARY SCS WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME=@DATABASE_NAME AND STATS_TIME = @STATS_DATE
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_QS_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_QS_STATS') 
  
IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_PLAN_ATTRIBUTES')
  EXEC ('DROP SYNONYM [dbo].DYN_PLAN_ATTRIBUTES')



         SET @SQL = '
				CREATE SYNONYM DYN_QS_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_query_stats'

EXEC (@SQL)


         SET @SQL = '
				CREATE SYNONYM DYN_PLAN_ATTRIBUTES
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_plan_attributes'

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 





PRINT 'TIME ZONE OFFSET AT TASK ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
PRINT 'LAST RUN AT TASK ' + CAST(@LAST_RUN AS VARCHAR(20))


PRINT 'LAST RUN WITH OFFSET ' + CAST(@LAST_RUN AS VARCHAR(20))
 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, ' TASK')
PRINT ''




IF @DEBUG = 'Y'
  BEGIN
      PRINT '@LAST_RUN = '

      PRINT @LAST_RUN
  END 
  
  
  IF @REMOTE_SERVER = 'N'
       BEGIN
			--IF @SQL_BUILD >= '13.' --REH  SQL2016 or above
		          
 SET @SQL =  ' INSERT INTO DynamicsPerf.dbo.QUERY_STATS

          SELECT MIN(' + '''' + @SERVER_NAME + '''' + '), MAX(' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + '),MIN('
				  + '''' + @DATABASE_NAME + '''' + '), 
                  MIN(plan_handle),
                  MAX(plan_generation_num),
                  creation_time,
                  MAX(last_execution_time),
                  SUM(execution_count),
                  SUM(total_worker_time),
                  AVG(last_worker_time),
                  MIN(min_worker_time),
                  MAX(max_worker_time),
                  SUM(total_physical_reads),
                  AVG(last_physical_reads),
                  MIN(min_physical_reads),
                  MAX(max_physical_reads),
                  SUM(total_logical_writes),
                  AVG(last_logical_writes),
                  MIN(min_logical_writes),
                  MAX(max_logical_writes),
                  SUM(total_logical_reads),
                  AVG(last_logical_reads),
                  MIN(min_logical_reads),
                  MAX(max_logical_reads),
                  SUM(total_clr_time),
                  AVG(last_clr_time),
                  MIN(min_clr_time),
                  MAX(max_clr_time),
                  SUM(total_elapsed_time),
                  AVG(last_elapsed_time),
                  MIN(min_elapsed_time),
                  MAX(max_elapsed_time),
                  query_hash,
                  query_plan_hash,
                  SUM ( total_rows),
                  SUM ( last_rows),
                  MAX ( max_rows),
                  MIN ( min_rows),'

				  IF @SQL_BUILD >= '13.' or (@SQL_BUILD >= '11.0.6020' and @SQL_BUILD < '12.') --REH correct build per version
				  BEGIN
					  SELECT @SQL = @SQL + 'SUM(total_dop), SUM(last_dop), SUM(min_dop), SUM(max_dop) '

				  END
				  ELSE
				  BEGIN
					SELECT @SQL = @SQL + 'SUM(-1), SUM(-1), SUM(-1), SUM(-1) '


				  END
SELECT @SQL = @SQL + '

           FROM   sys.dm_exec_query_stats
                  OUTER APPLY sys.dm_exec_plan_attributes (plan_handle)
           WHERE  attribute = N''dbid''
                  AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
                  AND dateadd(ms,last_elapsed_time/1000,last_execution_time) >= ''' +CONVERT(NVARCHAR(24), @LAST_RUN, 121) + '''
           GROUP  BY query_hash,
                     query_plan_hash,
					 creation_time'


					 
			IF @DEBUG = 'Y'
			  BEGIN
				  PRINT @SQL
			  END 
  
			  EXEC (@SQL)

		END

  IF @REMOTE_SERVER = 'Y'
       BEGIN
       
    

           --INSERT INTO QUERY_STATS
           
 SET @SQL = '
           SELECT 
                  MIN(plan_handle),
                  MAX(plan_generation_num),
                  creation_time,
                  MAX(last_execution_time),
                  SUM(execution_count),
                  SUM(total_worker_time),
                  AVG(last_worker_time),
                  MIN(min_worker_time),
                  MAX(max_worker_time),
                  SUM(total_physical_reads),
                  AVG(last_physical_reads),
                  MIN(min_physical_reads),
                  MAX(max_physical_reads),
                  SUM(total_logical_writes),
                  AVG(last_logical_writes),
                  MIN(min_logical_writes),
                  MAX(max_logical_writes),
                  SUM(total_logical_reads),
                  AVG(last_logical_reads),
                  MIN(min_logical_reads),
                  MAX(max_logical_reads),
                  SUM(total_clr_time),
                  AVG(last_clr_time),
                  MIN(min_clr_time),
                  MAX(max_clr_time),
                  SUM(total_elapsed_time),
                  AVG(last_elapsed_time),
                  MIN(min_elapsed_time),
                  MAX(max_elapsed_time),
                  query_hash,
                  query_plan_hash,
                  SUM ( total_rows),
                  SUM ( last_rows),
                  MAX ( max_rows),
                  MIN ( min_rows),'

				   IF @SQL_BUILD >= '13.' or (@SQL_BUILD >= '11.0.6020' and @SQL_BUILD < '12.') --REH correct build per version
				  BEGIN
					  SELECT @SQL = @SQL + 'SUM(total_dop), SUM(last_dop), SUM(min_dop), SUM(max_dop) '

				  END
				  ELSE
				  BEGIN
					SELECT @SQL = @SQL + 'SUM(-1), SUM(-1), SUM(-1), SUM(-1) '


				  END
SELECT @SQL = @SQL + '

           FROM   sys.dm_exec_query_stats
                  OUTER APPLY sys.dm_exec_plan_attributes (plan_handle)
           WHERE  attribute = N''dbid''
                  AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
                  AND dateadd(ms,last_elapsed_time/1000,last_execution_time) >= ''' +CONVERT(NVARCHAR(24), @LAST_RUN, 121) + '''
           GROUP  BY query_hash,
                     query_plan_hash,
					 creation_time'
                    



                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  INSERT INTO DynamicsPerf.dbo.QUERY_STATS
				 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + ','
				  + '''' + @DATABASE_NAME + '''' + ',
                    
                    RH.* FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '

				 
				 EXECUTE (@SQL2)
				 
       END 
  




UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_SERVER_DISKVOLUMES]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_SERVER_DISKVOLUMES (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30)
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDV_SQLVERSION')
  EXEC ('DROP SYNONYM [dbo].DYN_SDV_SQLVERSION')
  

IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SDV_SQLVERSION
				FOR [' + @SERVER_NAME + '].master.sys.xp_msver'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDV_SQLVERSION
				FOR master.sys.xp_msver'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


CREATE  table #SQLVERSION(
[INDEX] INT,
NAME NVARCHAR(128),
INTERNAL_VALUE NVARCHAR(128),
VALUE NVARCHAR(128)
);

INSERT #SQLVERSION
exec DYN_SDV_SQLVERSION  --[master].sys.[xp_msver]

SELECT @SQLVERSION = VALUE FROM #SQLVERSION WHERE NAME = 'ProductVersion'

DROP TABLE #SQLVERSION


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @SQLVERSION >= '10.50.2500'
BEGIN

DELETE FROM SERVER_DISKVOLUMES WHERE SERVER_NAME = @SERVER_NAME


SET @SQL = '
SELECT DISTINCT ' + ''''+ @SERVER_NAME +'''' + ',vs.volume_mount_point,  
                vs.volume_id,
                vs.logical_volume_name,
                vs.file_system_type,
                vs.total_bytes / 1024 / 1024,
                vs.available_bytes / 1024 / 1024,
                CONVERT(DECIMAL(5, 2), vs.available_bytes * 100.0 / vs.total_bytes),
                vs.supports_compression,
                vs.supports_alternate_streams,
                vs.supports_sparse_files,
                vs.is_read_only,
                vs.is_compressed
FROM   sys.sysaltfiles AS f
       CROSS APPLY sys.dm_os_volume_stats(f.dbid, f.fileid) AS vs
WHERE  f.dbid < 32767
ORDER  BY 7 DESC '


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


IF @REMOTE_SERVER = 'N'
BEGIN

		INSERT SERVER_DISKVOLUMES EXEC (@SQL) 

END
ELSE
BEGIN

		          
		SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT ['
					+ @SERVER_NAME + ']' 

		  
		  IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL2
		END

		INSERT SERVER_DISKVOLUMES EXEC (@SQL2) 


END



END

ELSE
BEGIN
    PRINT 'SQL older than 2008 R2 SP1, Please update'
END 

 
 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_SERVER_OS_INFO]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_SERVER_OS_INFO (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30)
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOI_SERVER_OS_INFO')
  EXEC ('DROP SYNONYM [dbo].DYN_SOI_SERVER_OS_INFO')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SOI_SERVER_OS_INFO
				FOR [' + @SERVER_NAME + '].master.sys.dm_os_windows_info'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOI_SERVER_OS_INFO
				FOR master.sys.dm_os_windows_info'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOI_SQLVERSION')
  EXEC ('DROP SYNONYM [dbo].DYN_SOI_SQLVERSION')
  

IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SOI_SQLVERSION
				FOR [' + @SERVER_NAME + '].master.sys.xp_msver'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOI_SQLVERSION
				FOR master.sys.xp_msver'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


CREATE  table #SQLVERSION(
[INDEX] INT,
NAME NVARCHAR(128),
INTERNAL_VALUE NVARCHAR(128),
VALUE NVARCHAR(128)
);

INSERT #SQLVERSION
exec DYN_SOI_SQLVERSION  --[master].sys.[xp_msver]

SELECT @SQLVERSION = VALUE FROM #SQLVERSION WHERE NAME = 'ProductVersion'

DROP TABLE #SQLVERSION


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @SQLVERSION >= '10.50.2500'
BEGIN

DELETE FROM SERVER_OS_VERSION WHERE SERVER_NAME = @SERVER_NAME

INSERT SERVER_OS_VERSION
SELECT @SERVER_NAME,
       windows_release,
       windows_service_pack_level,
       windows_sku,
       os_language_version
FROM   DYN_SOI_SERVER_OS_INFO 


END

ELSE
BEGIN
    PRINT 'SQL older than 2008 R2 SP1, Please update'
END 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_SERVER_REGISTRY]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_SERVER_REGISTRY (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30)
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SR_SERVER_REGISTRY')
  EXEC ('DROP SYNONYM [dbo].DYN_SR_SERVER_REGISTRY')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SR_SERVER_REGISTRY
				FOR [' + @SERVER_NAME + '].master.sys.dm_server_registry'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SR_SERVER_REGISTRY
				FOR master.sys.dm_server_registry'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SR_SQLVERSION')
  EXEC ('DROP SYNONYM [dbo].DYN_SR_SQLVERSION')
  

IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SR_SQLVERSION
				FOR [' + @SERVER_NAME + '].master.sys.xp_msver'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SR_SQLVERSION
				FOR master.sys.xp_msver'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


CREATE  table #SQLVERSION(
[INDEX] INT,
NAME NVARCHAR(128),
INTERNAL_VALUE NVARCHAR(128),
VALUE NVARCHAR(128)
);

INSERT #SQLVERSION
exec DYN_SR_SQLVERSION  --[master].sys.[xp_msver]

SELECT @SQLVERSION = VALUE FROM #SQLVERSION WHERE NAME = 'ProductVersion'

DROP TABLE #SQLVERSION


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @SQLVERSION >= '10.50.2500'
BEGIN

DELETE FROM SERVER_REGISTRY WHERE SERVER_NAME = @SERVER_NAME

INSERT SERVER_REGISTRY
SELECT @SERVER_NAME,
       registry_key,
       value_name,
       value_data
FROM   DYN_SR_SERVER_REGISTRY 



END

ELSE
BEGIN
    PRINT 'SQL older than 2008 R2 SP1, Please update'
END 

 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_SERVERINFO]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_SERVERINFO (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF @AZURE_DB = 0
BEGIN

		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_SI_SQLVERSION')
		 EXEC ('DROP SYNONYM [dbo].DYN_SI_SQLVERSION')


		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL = '
						CREATE SYNONYM DYN_SI_SQLVERSION
						FOR [' + @SERVER_NAME + '].master.sys.xp_msver'
			 END
		ELSE

				 SET @SQL = '
						CREATE SYNONYM DYN_SI_SQLVERSION
						FOR master.sys.xp_msver'

		IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL
		END

		EXEC (@SQL) 


		CREATE  table #SQLVERSION(
		[INDEX] INT,
		NAME NVARCHAR(128),
		INTERNAL_VALUE NVARCHAR(128),
		VALUE NVARCHAR(128)
		);

		INSERT #SQLVERSION
		exec DYN_SI_SQLVERSION  --[master].sys.[xp_msver]

		SELECT @SQLVERSION = VALUE FROM #SQLVERSION WHERE NAME = 'ProductVersion'

END
ELSE
BEGIN 
	SET @SQLVERSION = '12.0' 
END



SELECT @SQL = 'SELECT '+QUOTENAME(@SERVER_NAME,'''')+ ',
       '+ QUOTENAME(CONVERT(NVARCHAR(50), @STATS_DATE, 121),'''') +',sqlserver_start_time,
       Serverproperty(''ComputerNamePhysicalNetBIOS'') AS PhysicalComputerName,
       Serverproperty(''IsClustered'')                 AS IsClustered,
       Serverproperty(''MachineName'')                 AS MachineName,
       Serverproperty(''InstanceName'')                AS InstanceName,
       Serverproperty(''ProductVersion'')              AS ProductVersion,
       Serverproperty(''ProductLevel'')                AS ProductLevel,
       Serverproperty(''Edition'')                     AS Edition,
       Serverproperty(''EngineEdition'')               AS EngineEdition,
       Serverproperty(''SqlCharSet'')                  AS SqlCharSet,
       Serverproperty(''SqlCharSetName'')              AS SqlCharSetName,
       Serverproperty(''SqlSortOrder'')                AS SqlSortOrder,
       Serverproperty(''SqlSortOrderName'')            AS SqlSortOrderName,
       cpu_count,
       hyperthread_ratio,'

	   IF @SQLVERSION >= '11.0'
	   BEGIN
	   SELECT @SQL = @SQL +'
       committed_kb / 1024                     AS Bpool_Committed_MB,
       committed_target_kb / 1024                 AS Bpool_Commit_Target_MB,
       visible_target_kb / 1024                       AS Bpool_Visible_MB,
       (select count(*) from sys.dm_os_schedulers where status like ''VISIBLE ONLINE'' )  AS SQL_SCHEDULER_COUNT
	   '
		END
		ELSE
		BEGIN
		SELECT  @SQL = @SQL + 'bpool_committed / 1024 * 8                    AS Bpool_Committed_MB,
       bpool_commit_target / 1024 * 8                AS Bpool_Commit_Target_MB,
       bpool_visible / 1024 * 8                      AS Bpool_Visible_MB,
       (select count(*) from sys.dm_os_schedulers where status like ''VISIBLE ONLINE'' )  AS SQL_SCHEDULER_COUNT
	   '
		END

SELECT @SQL = @SQL + '
FROM   sys.dm_os_sys_info
       '



IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END




/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @REMOTE_SERVER = 'N'
BEGIN


INSERT INTO SERVERINFO 
EXEC( @SQL)

END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
 
		SET @SQL2 = ' 
						  SET QUOTED_IDENTIFIER OFF
						  	INSERT DynamicsPerf.dbo.SERVERINFO

								SELECT ' + '''' + @SERVER_NAME + '''' + ',' + ''''
					+ CONVERT(NVARCHAR(50), @STATS_DATE, 121) + ''''
					+ ', * FROM OPENQUERY(['+@SERVER_NAME+ '],"
	
	SELECT sqlserver_start_time ,
       Serverproperty(''ComputerNamePhysicalNetBIOS'') AS PhysicalComputerName,
       Serverproperty(''IsClustered'')                 AS IsClustered,
       Serverproperty(''MachineName'')                 AS MachineName,
       Serverproperty(''InstanceName'')                AS InstanceName,
       Serverproperty(''ProductVersion'')              AS ProductVersion,
       Serverproperty(''ProductLevel'')                AS ProductLevel,
       Serverproperty(''Edition'')                     AS Edition,
       Serverproperty(''EngineEdition'')               AS EngineEdition,
       Serverproperty(''SqlCharSet'')                  AS SqlCharSet,
       Serverproperty(''SqlCharSetName'')              AS SqlCharSetName,
       Serverproperty(''SqlSortOrder'')                AS SqlSortOrder,
       Serverproperty(''SqlSortOrderName'')            AS SqlSortOrderName,
       cpu_count,
       hyperthread_ratio,
       committed_kb / 1024                     AS Bpool_Committed_MB,
       committed_target_kb / 1024                 AS Bpool_Commit_Target_MB,
       visible_target_kb / 1024                       AS Bpool_Visible_MB,
       (select count(*) from sys.dm_os_schedulers where status like ''VISIBLE ONLINE'' )  AS SQL_SCHEDULER_COUNT
FROM   sys.dm_os_sys_info
	"
	)'

	
		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL2
			 END

		EXEC (@SQL2) 

 
 
 END
 
    

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_SQL_CONFIGURATION]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_SQL_CONFIGURATION (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SC_SYSCONFIGS')
  EXEC ('DROP SYNONYM [dbo].DYN_SC_SYSCONFIGS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SC_SYSCONFIGS
				FOR [' + @SERVER_NAME + '].master.sys.configurations'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SC_SYSCONFIGS
				FOR master.sys.configurations'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 





BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

INSERT INTO [DynamicsPerf]..SQL_CONFIGURATION 
SELECT @SERVER_NAME, @STATS_DATE, 
	name,
      convert(int, minimum) as minimum,
      convert(int, maximum) as maximum,
      convert(int, isnull(value, value_in_use)) as config_value,
      convert(int, value_in_use) as run_value
from  DYN_SC_SYSCONFIGS
order by lower(name)

 
    
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_SQL_DATA_BUFFER_CACHE]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_SQL_DATA_BUFFER_CACHE (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF @AZURE_DB = 0
BEGIN

		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_SDBC_OS_BUFFERS')
		  EXEC ('DROP SYNONYM [dbo].DYN_SDBC_OS_BUFFERS')


		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL = '
						CREATE SYNONYM DYN_SDBC_OS_BUFFERS
						FOR [' + @SERVER_NAME + '].master.sys.dm_os_buffer_descriptors'
			 END
		ELSE

				 SET @SQL = '
						CREATE SYNONYM DYN_SDBC_OS_BUFFERS
						FOR master.sys.dm_os_buffer_descriptors'

		IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL
		END

		EXEC (@SQL) 

END



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @REMOTE_SERVER = 'N'
BEGIN

		INSERT INTO [DynamicsPerf]..BUFFER_DETAIL
		SELECT @SERVER_NAME,
			   CONVERT(NVARCHAR(50), @STATS_DATE, 121),
			   CASE
				 WHEN database_id = 32767 THEN 'resourceDb'
				 ELSE CAST(DB_NAME(database_id) AS NVARCHAR(128))
			   END,
			   COUNT(*) * 8 / 1024
		FROM   DYN_SDBC_OS_BUFFERS WITH(nolock)
		GROUP  BY database_id 
END

IF @REMOTE_SERVER = 'Y'
BEGIN

		SET @SQL2 = ' 
						  SET QUOTED_IDENTIFIER OFF
						  	INSERT DynamicsPerf.dbo.BUFFER_DETAIL
			
					SELECT ' + '''' + @SERVER_NAME + '''' + ',' + ''''
					+ CONVERT(NVARCHAR(50), @STATS_DATE, 121) + ''''
					+ ', * FROM OPENQUERY(['+@SERVER_NAME+ '],"


		SELECT 
			   CASE
				 WHEN database_id = 32767 THEN ''resourceDb''
				 ELSE CAST(DB_NAME(database_id) AS NVARCHAR(128))
			   END,
			   COUNT(*) * 8 / 1024
		FROM   sys.dm_os_buffer_descriptors
		GROUP  BY database_id ")'

			
		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL2
			 END

		EXEC (@SQL2) 

END

 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/




BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_SQL_DATABASE_FILES]...';


GO

CREATE  PROCEDURE DYNPERF_COLLECT_SQL_DATABASE_FILES (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @C_DATABASE_NAME NVARCHAR(128), @ROW_COUNT BIGINT = 0
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDF_SYSDATABASES')
  EXEC ('DROP SYNONYM [dbo].DYN_SDF_SYSDATABASES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES
				FOR [' + @SERVER_NAME + '].master.sys.databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES
				FOR master.sys.databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


-- sys.master_files



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDF_SYSMASTERFILES')
  EXEC ('DROP SYNONYM [dbo].DYN_SDF_SYSMASTERFILES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSMASTERFILES
				FOR [' + @SERVER_NAME + '].master.sys.master_files'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSMASTERFILES 
				FOR master.sys.master_files'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


Create Table #DBFILES
(
    DatabaseName sysname,
    Name sysname,
    physical_name nvarchar(500),
    size decimal (18,2),
    FreeSpace decimal (18,2),
	Initial_size decimal (18,2)
)   


IF @REMOTE_SERVER = 'N'
BEGIN


Exec sp_MSforeachdb '
Use [?];
Insert Into #DBFILES (DatabaseName, Name, physical_name, Size, FreeSpace,Initial_size)
    Select DB_NAME() AS [DatabaseName], Name,  physical_name,
    Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) as nvarchar) Size,
    Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) -
        Cast(FILEPROPERTY(name, ''SpaceUsed'') * 8.0/1024.0 as decimal(18,2)) as nvarchar) As FreeSpace,
		0 as Initial_size
    From sys.database_files
'

--drop table #DBFILES

END


IF @REMOTE_SERVER = 'Y'
		BEGIN


		SET @SQL = 'Exec sp_MSforeachdb ' + ''''+ '
Use [?];

    Select DB_NAME() AS [DatabaseName], Name,  physical_name,
    Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) as nvarchar) Size,
    Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) -
        Cast(FILEPROPERTY(name,' + '''' + ''''+ 'SpaceUsed' +'''' + ''''+ ') * 8.0/1024.0 as decimal(18,2)) as nvarchar) As FreeSpace,
		0 as Initial_size
    From sys.database_files' + ''''


				PRINT @SQL

			SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
						EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']'

			IF @DEBUG = 'Y'
				BEGIN
					PRINT '@SQL= ' + @SQL2
				END

			BEGIN TRY
				INSERT #DBFILES
				EXEC (@SQL2 ) 
			END TRY

			BEGIN CATCH
			--ignore the error
			END CATCH
				 
				 
		END 


		 
--REH  Add initial size of TempDB

UPDATE SDF SET [Initial_size] = MF.size * 8 /1024
FROM #DBFILES SDF  JOIN
(
  SELECT size, physical_name FROM DYN_SDF_SYSMASTERFILES ) AS MF 
  ON MF.physical_name COLLATE DATABASE_DEFAULT = SDF.physical_name COLLATE DATABASE_DEFAULT




DECLARE DB_CURSOR CURSOR  LOCAL
FOR
SELECT name from DYN_SDF_SYSDATABASES


OPEN DB_CURSOR

FETCH NEXT FROM DB_CURSOR INTO @C_DATABASE_NAME

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

--REH  Build the Synonym as we loop through each database

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDF_SYSDATABASES_FILES')
  EXEC ('DROP SYNONYM [dbo].DYN_SDF_SYSDATABASES_FILES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES_FILES
				FOR [' + @SERVER_NAME + '].[' + @C_DATABASE_NAME + '].sys.database_files'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES_FILES
				FOR [' + @C_DATABASE_NAME + '].sys.database_files'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 

INSERT INTO [DynamicsPerf]..SQL_DATABASEFILES
SELECT @SERVER_NAME                                                                           AS [RUN_NAME],
       CONVERT(NVARCHAR(50), @STATS_DATE, 121)                                             AS [STATS_TIME],
       @C_DATABASE_NAME,
       [file_id],
       [File Name] COLLATE DATABASE_DEFAULT,
       [Physical Name] COLLATE DATABASE_DEFAULT,
       [File Type],
       [Total Size in Mb],
       [Available Space in Mb],
       CEILING(CAST([Available Space in Mb] AS DECIMAL(10, 1)) / [Total Size in Mb] * 100) AS [Free Space %],
       [Growth Units],
       [max File Size in Mb],
       [DB_INITAL_SIZE(MB)]
FROM   (SELECT [file_id],
               [name]   COLLATE DATABASE_DEFAULT     AS [File Name],
               physical_name COLLATE DATABASE_DEFAULT AS [Physical Name],
               [File Type] = CASE type
                               WHEN 0 THEN 'Data'
                               WHEN 1 THEN 'Log'
                             END,
               [Total Size in Mb] = CASE CEILING([size] / 128)
                                      WHEN 0 THEN 1
                                      ELSE CEILING([size] / 128)
                                    END,
               [Available Space in Mb] = (SELECT FreeSpace FROM #DBFILES TDB WHERE DYN_SDF.physical_name COLLATE DATABASE_DEFAULT = TDB.physical_name COLLATE DATABASE_DEFAULT),
			   
									--CASE CEILING([size] / 128)
         --                                  WHEN 0 THEN ( 1 - CAST(FILEPROPERTY([name], 'SpaceUsed') AS INT) / 128 )
         --                                  ELSE ( ( [size] / 128 ) - CAST(FILEPROPERTY([name], 'SpaceUsed') AS INT) / 128 )
         --                                END,
               [Growth Units] = CASE [is_percent_growth]
                                  WHEN 1 THEN CAST(growth AS VARCHAR(20)) + '%'
                                  ELSE CAST(growth/128 AS VARCHAR(20)) + 'Mb'
                                END,
               [max File Size in Mb] = CASE [max_size]
                                         WHEN -1 THEN NULL
                                         WHEN 268435456 THEN NULL
                                         ELSE [max_size]
                                       END,
				[DB_INITAL_SIZE(MB)] = (SELECT Initial_size FROM #DBFILES TDB WHERE DYN_SDF.physical_name COLLATE DATABASE_DEFAULT = TDB.physical_name COLLATE DATABASE_DEFAULT)
        FROM   DYN_SDF_SYSDATABASES_FILES DYN_SDF) AS RH
ORDER  BY [File Type],
          [file_id] 


SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

FETCH NEXT FROM DB_CURSOR INTO @C_DATABASE_NAME

END  /*End of the loop */
CLOSE DB_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE DB_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 



IF OBJECT_ID('tempdb..#DBFILES') IS NOT NULL
/*Then it exists*/
   DROP TABLE #DBFILES
 


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_SQL_DATABASES]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_SQL_DATABASES (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDB_SYSDATABASES')
  EXEC ('DROP SYNONYM [dbo].DYN_SDB_SYSDATABASES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SDB_SYSDATABASES
				FOR [' + @SERVER_NAME + '].master.sys.databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDB_SYSDATABASES
				FOR master.sys.databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

INSERT INTO [DynamicsPerf]..SQL_DATABASES
SELECT @SERVER_NAME, CONVERT(NVARCHAR(50), @STATS_DATE, 121),
[name]
      ,[database_id]
      ,[source_database_id]
      ,[owner_sid]
      ,[create_date]
      ,[compatibility_level]
      ,[collation_name]
      ,[user_access]
      ,[user_access_desc]
      ,[is_read_only]
      ,[is_auto_close_on]
      ,[is_auto_shrink_on]
      ,[state]
      ,[state_desc]
      ,[is_in_standby]
      ,[is_cleanly_shutdown]
      ,[is_supplemental_logging_enabled]
      ,[snapshot_isolation_state]
      ,[snapshot_isolation_state_desc]
      ,[is_read_committed_snapshot_on]
      ,[recovery_model]
      ,[recovery_model_desc]
      ,[page_verify_option]
      ,[page_verify_option_desc]
      ,[is_auto_create_stats_on]
      ,[is_auto_update_stats_on]
      ,[is_auto_update_stats_async_on]
      ,[is_ansi_null_default_on]
      ,[is_ansi_nulls_on]
      ,[is_ansi_padding_on]
      ,[is_ansi_warnings_on]
      ,[is_arithabort_on]
      ,[is_concat_null_yields_null_on]
      ,[is_numeric_roundabort_on]
      ,[is_quoted_identifier_on]
      ,[is_recursive_triggers_on]
      ,[is_cursor_close_on_commit_on]
      ,[is_local_cursor_default]
      ,[is_fulltext_enabled]
      ,[is_trustworthy_on]
      ,[is_db_chaining_on]
      ,[is_parameterization_forced]
      ,[is_master_key_encrypted_by_server]
      ,[is_published]
      ,[is_subscribed]
      ,[is_merge_published]
      ,[is_distributor]
      ,[is_sync_with_backup]
      ,[service_broker_guid]
      ,[is_broker_enabled]
      ,[log_reuse_wait]
      ,[log_reuse_wait_desc]
      ,[is_date_correlation_on]
      ,[is_cdc_enabled]
	FROM DYN_SDB_SYSDATABASES

    



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_SQL_ERRORLOG]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_SQL_ERRORLOG (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/
IF @AZURE_DB = 0
BEGIN
IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SEL_XP_READERRORLOG')
  EXEC ('DROP SYNONYM [dbo].DYN_SEL_XP_READERRORLOG')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SEL_XP_READERRORLOG
				FOR [' + @SERVER_NAME + '].master.sys.xp_readerrorlog'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SEL_XP_READERRORLOG
				FOR master.sys.xp_readerrorlog'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 
END


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH limit us to last 2 weeks if this is first run on this server

IF @LAST_RUN < (DATEADD(DD, -14, GETDATE()))  
BEGIN
 SET @LAST_RUN = (DATEADD(DD, -14, GETDATE()))
END

IF @AZURE_DB = 0
BEGIN


		CREATE TABLE #ERRORLOG
		  (
			 LogDate     DATETIME,
			 ProcessInfo NVARCHAR(255),
			 LogText     NVARCHAR(MAX)
		  ); 


		INSERT INTO #ERRORLOG (
		   [LogDate],
		   [ProcessInfo],
		   [LogText]
		)

		EXEC DYN_SEL_XP_READERRORLOG 0,1,NULL,NULL,@LAST_RUN, @STATS_DATE, 'ASC'
 

 
		INSERT INTO SQLERRORLOG 
		SELECT @SERVER_NAME,* FROM #ERRORLOG 
		DROP TABLE #ERRORLOG;  
END

 IF @AZURE_DB = 1
BEGIN

SET @LAST_RUN = DATEADD(hh, DATEDIFF(hh, GETDATE(), GETUTCDATE()), @LAST_RUN)


		SET @SQL2 = ' 
						  SET QUOTED_IDENTIFIER OFF
						  	INSERT DynamicsPerf.dbo.SQL_AZURE_EVENTS
			
					SELECT ' + '''' + @SERVER_NAME + '''' 
					+ ', * FROM OPENQUERY(['+@SERVER_NAME+ '],"


	 select database_name, start_time, end_time, event_category, event_type, event_subtype,
	event_subtype_desc, severity, event_count, description, cast(additional_data as nvarchar(max)) from sys.event_log
		WHERE end_time >= ' + '''' + CONVERT(VARCHAR(30),@LAST_RUN, 109) + '''' + ' 
		AND database_name = ' + '''' + @DATABASE_NAME + ''''
	 +'")'

			
		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL2
			 END

		EXEC (@SQL2) 


END
    
   


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_SQL_JOBS]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_SQL_JOBS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SJ_SYSSCHEDULES')
  EXEC ('DROP SYNONYM [dbo].DYN_SJ_SYSSCHEDULES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSSCHEDULES
				FOR [' + @SERVER_NAME + '].msdb.dbo.sysschedules'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSSCHEDULES
				FOR msdb.dbo.sysschedules'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SJ_SYSJOBSCHEDULES')
  EXEC ('DROP SYNONYM [dbo].DYN_SJ_SYSJOBSCHEDULES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSJOBSCHEDULES
				FOR [' + @SERVER_NAME + '].msdb.dbo.sysjobschedules'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSJOBSCHEDULES
				FOR msdb.dbo.sysjobschedules'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SJ_SYSJOBS')
  EXEC ('DROP SYNONYM [dbo].DYN_SJ_SYSJOBS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSJOBS
				FOR [' + @SERVER_NAME + '].msdb.dbo.sysjobs'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSJOBS
				FOR msdb.dbo.sysjobs'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SJ_SYSJOBSTEPS')
  EXEC ('DROP SYNONYM [dbo].DYN_SJ_SYSJOBSTEPS')

IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSJOBSTEPS
				FOR [' + @SERVER_NAME + '].msdb.dbo.sysjobsteps'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSJOBSTEPS
				FOR msdb.dbo.sysjobsteps'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


DECLARE @weekDay TABLE (
  mask      INT,
  maskValue VARCHAR(32)); 

INSERT INTO @weekDay
SELECT 1, 'Sunday'  UNION All
SELECT 2, 'Monday'  UNION All
SELECT 4, 'Tuesday'  UNION All
SELECT 8, 'Wednesday'  UNION All
SELECT 16, 'Thursday'  UNION All
SELECT 32, 'Friday'  UNION All
SELECT 64, 'Saturday';
 
WITH myCTE
AS(
 SELECT sched.name                                                                                     AS 'scheduleName',
        sched.schedule_id,
        jobsched.job_id,
        CASE
          WHEN sched.freq_type = 1 THEN 'Once'
          WHEN sched.freq_type = 4
               AND sched.freq_interval = 1 THEN 'Daily'
          WHEN sched.freq_type = 4 THEN 'Every ' + CAST(sched.freq_interval AS VARCHAR(5)) + ' days'
          WHEN sched.freq_type = 8 THEN REPLACE(REPLACE(REPLACE((SELECT maskValue
                                                                 FROM   @weekDay AS x
                                                                 WHERE  sched.freq_interval & x.mask <> 0
                                                                 ORDER  BY mask
                                                                 FOR XML RAW), '"/><row maskValue="', ', '), '<row maskValue="', ''), '"/>', '') + CASE
                                                                                                                                                     WHEN sched.freq_recurrence_factor <> 0
                                                                                                                                                          AND sched.freq_recurrence_factor = 1 THEN '; weekly'
                                                                                                                                                     WHEN sched.freq_recurrence_factor <> 0 THEN '; every ' + CAST(sched.freq_recurrence_factor AS VARCHAR(10)) + ' weeks'
                                                                                                                                                   END
          WHEN sched.freq_type = 16 THEN 'On day ' + CAST(sched.freq_interval AS VARCHAR(10)) + ' of every ' + CAST(sched.freq_recurrence_factor AS VARCHAR(10)) + ' months'
          WHEN sched.freq_type = 32 THEN CASE
                                           WHEN sched.freq_relative_interval = 1 THEN 'First'
                                           WHEN sched.freq_relative_interval = 2 THEN 'Second'
                                           WHEN sched.freq_relative_interval = 4 THEN 'Third'
                                           WHEN sched.freq_relative_interval = 8 THEN 'Fourth'
                                           WHEN sched.freq_relative_interval = 16 THEN 'Last'
                                         END + CASE
                                                 WHEN sched.freq_interval = 1 THEN ' Sunday'
                                                 WHEN sched.freq_interval = 2 THEN ' Monday'
                                                 WHEN sched.freq_interval = 3 THEN ' Tuesday'
                                                 WHEN sched.freq_interval = 4 THEN ' Wednesday'
                                                 WHEN sched.freq_interval = 5 THEN ' Thursday'
                                                 WHEN sched.freq_interval = 6 THEN ' Friday'
                                                 WHEN sched.freq_interval = 7 THEN ' Saturday'
                                                 WHEN sched.freq_interval = 8 THEN ' Day'
                                                 WHEN sched.freq_interval = 9 THEN ' Weekday'
                                                 WHEN sched.freq_interval = 10 THEN ' Weekend'
                                               END + CASE
                                                       WHEN sched.freq_recurrence_factor <> 0
                                                            AND sched.freq_recurrence_factor = 1 THEN '; monthly'
                                                       WHEN sched.freq_recurrence_factor <> 0 THEN '; every ' + CAST(sched.freq_recurrence_factor AS VARCHAR(10)) + ' months'
                                                     END
          WHEN sched.freq_type = 64 THEN 'StartUp'
          WHEN sched.freq_type = 128 THEN 'Idle'
        END                                                                                            AS 'frequency',
        Isnull('Every ' + CAST(sched.freq_subday_interval AS VARCHAR(10)) + CASE
                                                                              WHEN sched.freq_subday_type = 2 THEN ' seconds'
                                                                              WHEN sched.freq_subday_type = 4 THEN ' minutes'
                                                                              WHEN sched.freq_subday_type = 8 THEN ' hours'
                                                                            END, 'Once')               AS 'subFrequency',
        Replicate('0', 6 - Len(sched.active_start_time)) + CAST(sched.active_start_time AS VARCHAR(6)) AS 'startTime',
        Replicate('0', 6 - Len(sched.active_end_time)) + CAST(sched.active_end_time AS VARCHAR(6))     AS 'endTime',
        Replicate('0', 6 - Len(jobsched.next_run_time)) + CAST(jobsched.next_run_time AS VARCHAR(6))   AS 'nextRunTime',
        CAST(jobsched.next_run_date AS CHAR(8))                                                        AS 'nextRunDate'
 FROM   DYN_SJ_SYSSCHEDULES AS sched
        JOIN DYN_SJ_SYSJOBSCHEDULES AS jobsched
          ON sched.schedule_id = jobsched.schedule_id
 WHERE  sched.enabled = 1 
 
)
INSERT INTO SQL_JOBS
SELECT @SERVER_NAME                                                                                                                                                                                                   AS [SERVER_NAME],
       CONVERT(NVARCHAR(50), @STATS_DATE, 121)                                                                                                                                                                        AS [STATS_TIME],
       job.name                                                                                                                                                                                                       AS 'jobName',
       sched.scheduleName,
       sched.frequency,
       sched.subFrequency,
       substring(sched.startTime, 1, 2) + ':' + substring(sched.startTime, 3, 2) + ' - ' + substring(sched.endTime, 1, 2) + ':' + substring(sched.endTime, 3, 2)                                                      AS 'scheduleTime' -- HH:MM
       ,
       substring(sched.nextRunDate, 1, 4) + '/' + substring(sched.nextRunDate, 5, 2) + '/' + substring(sched.nextRunDate, 7, 2) + ' ' + substring(sched.nextRunTime, 1, 2) + ':' + substring(sched.nextRunTime, 3, 2) AS 'nextRunDate'
       /* Note: the sysjobschedules table refreshes every 20 min, 
         so nextRunDate may be out of date */
       ,
       steps.step_id,
       steps.step_name,
       steps.subsystem,
       steps.command
FROM   DYN_SJ_SYSJOBS AS job
       JOIN myCTE AS sched
         ON job.job_id = sched.job_id
       INNER JOIN DYN_SJ_SYSJOBSTEPS steps
               ON steps.job_id = job.job_id
WHERE  job.enabled = 1 -- do not display disabled jobs
ORDER  BY nextRunDate 



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_SQL_TEXT]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_SQL_TEXT (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



IF @REMOTE_SERVER = 'N'
     BEGIN ;
         WITH Query_Stats_CTE ( QUERY_HASH, PLAN_HANDLE)
              AS (SELECT DISTINCT QUERY_HASH, PLAN_HANDLE
                  FROM   QUERY_STATS QS
                  WHERE  QS.STATS_TIME >= @LAST_RUN
                         AND DATABASE_NAME = @DATABASE_NAME
                         AND SERVER_NAME = @SERVER_NAME 
                         AND NOT EXISTS (SELECT 'X'
                                         FROM   QUERY_TEXT QT
                                         WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                                AND QS.SERVER_NAME = QT.SERVER_NAME ))
         INSERT QUERY_TEXT
         SELECT @SERVER_NAME,
                @DATABASE_NAME,
                QUERY_HASH,
                SQL_TEXT,
				@STATS_DATE
         FROM   (SELECT RN = ROW_NUMBER()
                               OVER (
                                 PARTITION BY CTE.QUERY_HASH
                                 ORDER BY CTE.QUERY_HASH DESC),
                        qs.query_hash                                                                                              AS QUERY_HASH,
                        SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                        WHEN -1 THEN DATALENGTH(st.text)
                                                                                        ELSE qs.statement_end_offset
                                                                                      END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
                 FROM   Query_Stats_CTE CTE
                        INNER JOIN sys.dm_exec_query_stats AS qs
                                ON CTE.QUERY_HASH = qs.query_hash and CTE.PLAN_HANDLE = qs.plan_handle
                        OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                        CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
                 WHERE  attribute = N'dbid'
                        AND DB_NAME(CONVERT(INT, value)) = @DATABASE_NAME
                        AND last_execution_time >= @LAST_RUN
						) AS RH
         WHERE  RN = 1
     END 


 IF @REMOTE_SERVER = 'Y'
 BEGIN
 


				 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)



 SET @SQL = '
CREATE TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH
(
QUERY_HASH VARBINARY(64),
PLAN_HANDLE VARBINARY(64)
)' 



 SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  EXEC ('+'"' + @SQL +'"' + ') AT [' + @SERVER_NAME + ']'
  
 IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END

EXEC (@SQL2)


SET @SQL = '

;WITH Query_Stats_CTE ( QUERY_HASH, PLAN_HANDLE)
     AS (SELECT DISTINCT QUERY_HASH,PLAN_HANDLE
         FROM   QUERY_STATS QS
         WHERE  QS.STATS_TIME >= '  +'''' + CONVERT(NVARCHAR(24), @LAST_RUN, 121) +'''' +  '
                AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + '
                AND SERVER_NAME = ' + '''' + +@SERVER_NAME + '''' + ' 
                AND NOT EXISTS (SELECT ''X''
                                FROM   QUERY_TEXT QT
                                WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                AND QS.SERVER_NAME = QT.SERVER_NAME 
                                ))
INSERT INTO OPENQUERY([' + @SERVER_NAME + '], ''SELECT QUERY_HASH, PLAN_HANDLE FROM  [tempdb].dbo.DYNPERF_QUERY_HASH'')

SELECT QUERY_HASH, PLAN_HANDLE
FROM   (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_HASH, CTE.PLAN_HANDLE
                        ORDER BY CTE.QUERY_HASH ,  CTE.PLAN_HANDLE DESC),
               QUERY_HASH,
			   PLAN_HANDLE
            
            FROM   Query_Stats_CTE CTE
           ) AS RH
WHERE  RN = 1 '

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


EXEC (@SQL)


        
 SET @SQL = '
         SELECT QUERY_HASH, SQL_TEXT
         FROM (
         SELECT RN = ROW_NUMBER() OVER (PARTITION BY CTE.QUERY_HASH ORDER BY CTE.QUERY_HASH DESC),
          qs.query_hash AS QUERY_HASH,
                         SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                         WHEN -1 THEN DATALENGTH(st.text)
                                                                                         ELSE qs.statement_end_offset
                                                                                       END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
         FROM    [tempdb].dbo.DYNPERF_QUERY_HASH CTE
                INNER JOIN sys.dm_exec_query_stats AS qs
                        ON CTE.QUERY_HASH = qs.query_hash AND CTE.PLAN_HANDLE = qs.plan_handle
                OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
         WHERE  attribute = N''dbid''
                AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
				AND last_execution_time >= ' +'''' + CONVERT(NVARCHAR(24), @LAST_RUN, 121) +'''' + '
                ) AS RH  
                WHERE RN = 1 '
PRINT ''
PRINT ''
                  
IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  INSERT INTO DynamicsPerf.dbo.QUERY_TEXT
				 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + '''' + @DATABASE_NAME + '''' + ',
                    
                    RH.*, ' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + ' FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END
				 
				 EXECUTE (@SQL2)
				 
 --REH  Delete the table back out
 
 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

 
 END
 
    

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_SQL_TRACEFLAGS_RUNNING]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_SQL_TRACEFLAGS_RUNNING (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


  IF EXISTS (SELECT * FROM   sys.synonyms  WHERE  name = 'DYN_QUERY_TRACE_FLAGS')
  EXEC ('DROP SYNONYM [dbo].DYN_QUERY_TRACE_FLAGS')



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 

  

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


CREATE TABLE #TRACEFLAGS
  (
     TRACEFLAG    INT,
     STATUS       BIT,
     GLOBAL       BIT,
     SESSIONS     BIT
  ) 

SET @SQL = 'DBCC TRACESTATUS(-1) WITH NO_INFOMSGS '

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END



IF @REMOTE_SERVER = 'N'
BEGIN

INSERT  #TRACEFLAGS
EXEC (@SQL)

INSERT TRACEFLAGS 
SELECT @SERVER_NAME, @STATS_DATE,@DATABASE_NAME,*  FROM #TRACEFLAGS

END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
 
 /****************************************************************************
 
 REH Too avoid some nasty challenges of calling DBCC remotely in this case
	we will create a table in the remote TempDb and populate it with 
	DBCC on that side, then use normal Linked Server to insert that data
	back into DynamicsPerf
	
	Remote DBCC commands present all sort of challenges, particularly
		error 7411
 
 
 *****************************************************************************/
 
 
 --REH Drop the table on the remote server if it exists
         SET @SQL = '
				  use [tempdb]  
				  
				IF OBJECT_ID(' + ''''
									+ 'DYNPERF_TRACE_FLAGS' + ''''
									+ ' , ''U'' 
				) IS NOT NULL
				 DROP TABLE DYNPERF_TRACE_FLAGS'
				 
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)
         
         
--REH  Now create the table and populate it on the remote server


         SET @SQL = '
				CREATE TABLE [tempdb].dbo.DYNPERF_TRACE_FLAGS
					  (
						 TRACEFLAG    INT,
						 STATUS       BIT,
						 GLOBAL       BIT,
						 SESSIONS     BIT
					  ) 
					  
					  INSERT INTO [tempdb].dbo.DYNPERF_TRACE_FLAGS
					 EXEC (' +''''+ 'DBCC TRACESTATUS(-1) WITH NO_INFOMSGS' +'''' + ')
					  
					  '

         PRINT @SQL

         SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT [' + @SERVER_NAME
									 + ']'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)







--REH  Create Synonym for the table with just created and populated on the remote server.

  IF EXISTS (SELECT * FROM   sys.synonyms  WHERE  name = 'DYN_QUERY_TRACE_FLAGS')
  EXEC ('DROP SYNONYM [dbo].DYN_QUERY_TRACE_FLAGS')



         SET @SQL = '
				CREATE SYNONYM DYN_QUERY_TRACE_FLAGS
				FOR [' + @SERVER_NAME + '].[tempdb].dbo.DYNPERF_TRACE_FLAGS'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 
		


INSERT TRACEFLAGS 
SELECT @SERVER_NAME, @STATS_DATE,@DATABASE_NAME, *  FROM DYN_QUERY_TRACE_FLAGS

  --REH Now Drop the table to cleanup the process
  
         SET @SQL = '
				  use [tempdb]  
				  
				IF OBJECT_ID(' + ''''
									+ 'DYNPERF_TRACE_FLAGS' + ''''
									+ ' , ''U'' 
				) IS NOT NULL
				 DROP TABLE DYNPERF_TRACE_FLAGS'
				 
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)
 
 END
 
    

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



  IF EXISTS (SELECT * FROM   sys.synonyms  WHERE  name = 'DYN_QUERY_TRACE_FLAGS')
  EXEC ('DROP SYNONYM [dbo].DYN_QUERY_TRACE_FLAGS')




PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/

BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)

  IF EXISTS (SELECT * FROM   sys.synonyms  WHERE  name = 'DYN_QUERY_TRACE_FLAGS')
  EXEC ('DROP SYNONYM [dbo].DYN_QUERY_TRACE_FLAGS')


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_SSRS_EXECUTIONLOG]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_SSRS_EXECUTIONLOG (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @C_SERVER_NAME NVARCHAR(128), @C_LAST_COLLECTED DATETIME, @UTC_TIME DATETIME, @ROW_COUNT BIGINT = 0
	DECLARE @C_DATABASE_NAME NVARCHAR(128)

    
    
    
/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




SET @UTC_TIME = DATEADD(MI,@DPA_TZ_OFFSET,@STATS_DATE)




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT SERVER_NAME,
       Isnull(LAST_COLLECTED, '1/1/1900'), 
	   DATABASE_NAME
FROM   DynamicsPerf..SSRS_CONFIG SSRS



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_SERVER_NAME, @C_LAST_COLLECTED, @C_DATABASE_NAME



/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

	          SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END



--REH LAST_COLLECTED IS STORE IN UTC TIME, NEED TO CONVERT BACK TO LOCAL TIME AS TIMEEND IN EXECUTIONLOG2 IS LOCAL SQL TIME

IF @C_LAST_COLLECTED > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @C_LAST_COLLECTED = DATEADD(MI, @DPA_TZ_OFFSET*-1, @C_LAST_COLLECTED) --REH STORED AS UTC TIME, NEED TO CONVERT TO LOCAL TIME
        END
      ELSE
        BEGIN
            SET @C_LAST_COLLECTED = DATEADD(MI, @SQL_TZ_OFFSET*-1, @C_LAST_COLLECTED)  --REH STORED AS UTC TIME, NEED TO CONVERT TO LOCAL TIME
        END
  END 

  --PRINT '@C_LAST_COLLECTED ' + CAST(@C_LAST_COLLECTED AS VARCHAR(50))



IF @REMOTE_SERVER = 'N'
BEGIN

--  INSERT INTO DynamicsPerf.dbo.SSRS_EXECUTIONLOG
--SELECT 
--	InstanceName, 
--	REPLACE(COALESCE(C.Path, 'Unknown'),C.NAME,'') AS ReportPath,
--	C.Name, 
--	'removed for security reasons', --UserName,
--	ExecutionId, 
--	CASE(RequestType)
--		WHEN 0 THEN 'Interactive'
--		WHEN 1 THEN 'Subscription'
--		ELSE 'Unknown'
--		END AS RequestType, 
--	-- SubscriptionId, 
--	Format, 
--	Parameters, 
--	CASE(ReportAction)		
--		WHEN 1 THEN 'Render'
--		WHEN 2 THEN 'BookmarkNavigation'
--		WHEN 3 THEN 'DocumentMapNavigation'
--		WHEN 4 THEN 'DrillThrough'
--		WHEN 5 THEN 'FindString'
--		WHEN 6 THEN 'GetDocumentMap'
--		WHEN 7 THEN 'Toggle'
--		WHEN 8 THEN 'Sort'
--		ELSE 'Unknown'
--		END AS ReportAction,
--	TimeStart, 
--	TimeEnd, 
--	TimeDataRetrieval, 
--	TimeProcessing, 
--	TimeRendering,
--	CASE(Source)
--		WHEN 1 THEN 'Live'
--		WHEN 2 THEN 'Cache'
--		WHEN 3 THEN 'Snapshot' 
--		WHEN 4 THEN 'History'
--		WHEN 5 THEN 'AdHoc'
--		WHEN 6 THEN 'Session'
--		WHEN 7 THEN 'Rdce'
--		ELSE 'Unknown'
--		END AS Source,
--	Status,
--	ByteCount,
--	[RowCount]
--	FROM ReportServer.dbo.ExecutionLogStorage EL WITH(NOLOCK)
--LEFT OUTER JOIN ReportServer.dbo.Catalog C WITH(NOLOCK) ON (EL.ReportID = C.ItemID)
--	WHERE TimeEnd > @C_LAST_COLLECTED
	
	
		SET @SQL = '
		INSERT INTO DynamicsPerf.dbo.SSRS_EXECUTIONLOG

	SELECT 
	InstanceName, 
	REPLACE(COALESCE(C.Path, ''Unknown''),C.Name,'+'''' + ''''+') AS ReportPath, 
	C.Name,
	''Removed for security reason'', --UserName,
	ExecutionId, 
	CASE(RequestType)
		WHEN 0 THEN ''Interactive''
		WHEN 1 THEN ''Subscription''
		ELSE ''Unknown''
		END AS RequestType, 
	-- SubscriptionId, 
	Format, 
	Parameters, 
	CASE(ReportAction)		
		WHEN 1 THEN ''Render''
		WHEN 2 THEN ''BookmarkNavigation''
		WHEN 3 THEN ''DocumentMapNavigation''
		WHEN 4 THEN ''DrillThrough''
		WHEN 5 THEN ''FindString''
		WHEN 6 THEN ''GetDocumentMap''
		WHEN 7 THEN ''Toggle''
		WHEN 8 THEN ''Sort''
		ELSE ''Unknown''
		END AS ReportAction,
	TimeStart, 
	TimeEnd, 
	TimeDataRetrieval, 
	TimeProcessing, 
	TimeRendering,
	CASE(Source)
		WHEN 1 THEN ''Live''
		WHEN 2 THEN ''Cache''
		WHEN 3 THEN ''Snapshot'' 
		WHEN 4 THEN ''History''
		WHEN 5 THEN ''AdHoc''
		WHEN 6 THEN ''Session''
		WHEN 7 THEN ''Rdce''
		ELSE ''Unknown''
		END AS Source,
	Status,
	ByteCount,
	[RowCount]
FROM ['+@C_DATABASE_NAME + '].dbo.ExecutionLogStorage EL WITH(NOLOCK)
LEFT OUTER JOIN ['+@C_DATABASE_NAME + '].dbo.Catalog C WITH(NOLOCK) ON (EL.ReportID = C.ItemID)
WHERE TimeEnd > ' +'''' + CONVERT(NVARCHAR(24), @C_LAST_COLLECTED, 121) +''''

	
	
	
END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
 
 
		SET @SQL = '
	SELECT 
	InstanceName, 
	REPLACE(COALESCE(C.Path, ''Unknown''),C.Name,'+'''' + ''''+') AS ReportPath, 
	C.Name,
	''Removed for security reason'', --UserName,
	ExecutionId, 
	CASE(RequestType)
		WHEN 0 THEN ''Interactive''
		WHEN 1 THEN ''Subscription''
		ELSE ''Unknown''
		END AS RequestType, 
	-- SubscriptionId, 
	Format, 
	Parameters, 
	CASE(ReportAction)		
		WHEN 1 THEN ''Render''
		WHEN 2 THEN ''BookmarkNavigation''
		WHEN 3 THEN ''DocumentMapNavigation''
		WHEN 4 THEN ''DrillThrough''
		WHEN 5 THEN ''FindString''
		WHEN 6 THEN ''GetDocumentMap''
		WHEN 7 THEN ''Toggle''
		WHEN 8 THEN ''Sort''
		ELSE ''Unknown''
		END AS ReportAction,
	TimeStart, 
	TimeEnd, 
	TimeDataRetrieval, 
	TimeProcessing, 
	TimeRendering,
	CASE(Source)
		WHEN 1 THEN ''Live''
		WHEN 2 THEN ''Cache''
		WHEN 3 THEN ''Snapshot'' 
		WHEN 4 THEN ''History''
		WHEN 5 THEN ''AdHoc''
		WHEN 6 THEN ''Session''
		WHEN 7 THEN ''Rdce''
		ELSE ''Unknown''
		END AS Source,
	Status,
	ByteCount,
	[RowCount]
FROM ['+@C_DATABASE_NAME + '].dbo.ExecutionLogStorage EL WITH(NOLOCK)
LEFT OUTER JOIN ['+@C_DATABASE_NAME + '].dbo.Catalog C WITH(NOLOCK) ON (EL.ReportID = C.ItemID)
WHERE TimeEnd > ' +'''' + CONVERT(NVARCHAR(24), @C_LAST_COLLECTED, 121) +''''



		                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  INSERT INTO DynamicsPerf.dbo.SSRS_EXECUTIONLOG
				 SELECT * FROM OPENQUERY([' + @C_SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '
                    
                    EXEC (@SQL2)
           
               
 
 
 END
 
 SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT


 UPDATE SSRS_CONFIG SET LAST_COLLECTED = @UTC_TIME WHERE SERVER_NAME = @C_SERVER_NAME

 --PRINT '@DPA_TZ_OFFSET ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(50))
 --PRINT '@STATS_DATE ' + CAST(@STATS_DATE AS VARCHAR(50))
 --PRINT '@UTC_TIME ' + CAST(@UTC_TIME AS VARCHAR(50))



FETCH NEXT FROM TASK_CURSOR INTO @C_SERVER_NAME, @C_LAST_COLLECTED, @C_DATABASE_NAME



END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
				  + ' TRYING TO PROCESS REPORT SERVER ' + ISNULL(@C_SERVER_NAME,'') + '  '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_SYSOBJECTS]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_SYSOBJECTS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOBJ_SYSOBJECTS')
  EXEC ('DROP SYNONYM [dbo].DYN_SOBJ_SYSOBJECTS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSOBJECTS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.objects'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSOBJECTS
				FOR [' + @DATABASE_NAME + '].sys.objects'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOBJ_SYSINDEXES')
  EXEC ('DROP SYNONYM [dbo].DYN_SOBJ_SYSINDEXES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSINDEXES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.indexes'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSINDEXES
				FOR [' + @DATABASE_NAME + '].sys.indexes'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOBJ_SYS_SYSINDEXES')
  EXEC ('DROP SYNONYM [dbo].DYN_SOBJ_SYS_SYSINDEXES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYS_SYSINDEXES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.sysindexes'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYS_SYSINDEXES
				FOR [' + @DATABASE_NAME + '].sys.sysindexes'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)





IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOBJ_SYSPARTITIONS')
  EXEC ('DROP SYNONYM [dbo].DYN_SOBJ_SYSPARTITIONS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSPARTITIONS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.partitions'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSPARTITIONS
				FOR [' + @DATABASE_NAME + '].sys.partitions'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOBJ_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_SOBJ_SYSCOLUMNS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSCOLUMNS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.columns'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSCOLUMNS
				FOR [' + @DATABASE_NAME + '].sys.columns'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOBJ_SYSTYPES')
  EXEC ('DROP SYNONYM [dbo].DYN_SOBJ_SYSTYPES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSTYPES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.types'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSTYPES
				FOR [' + @DATABASE_NAME + '].sys.types'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

DELETE FROM DYNSYSINDEXES WHERE DATABASE_NAME = @DATABASE_NAME AND RUN_NAME LIKE @SERVER_NAME + '%'
DELETE FROM DYNSYSOBJECTS WHERE DATABASE_NAME = @DATABASE_NAME AND RUN_NAME LIKE @SERVER_NAME + '%'
DELETE FROM DYNSYSPARTITIONS WHERE DATABASE_NAME = @DATABASE_NAME AND RUN_NAME LIKE @SERVER_NAME + '%'
DELETE FROM DYNSYSCOLUMNS WHERE DATABASE_NAME = @DATABASE_NAME AND RUN_NAME LIKE @SERVER_NAME + '%'






INSERT INTO DYNSYSOBJECTS
SELECT @RUN_NAME,
       @DATABASE_NAME,   
       [name],
       [object_id],
       [principal_id],
       [schema_id],
       [parent_object_id],
       [type],
       [type_desc],
       [create_date],
       [modify_date],
       [is_ms_shipped],
       [is_published],
       [is_schema_published]
FROM   DYN_SOBJ_SYSOBJECTS WHERE type = 'U'

      
  
INSERT INTO DYNSYSPARTITIONS
SELECT @RUN_NAME,
       @DATABASE_NAME, 
       [partition_id],
       [object_id],
       [index_id],
       [partition_number],
       [hobt_id],
       [rows],
       [filestream_filegroup_id],
       [data_compression],
       [data_compression_desc]
FROM   DYN_SOBJ_SYSPARTITIONS 



IF @REMOTE_SERVER = 'N'
BEGIN

	  --REH performance is not impacted on same server by multi-table synonym joins, this code works great with multiple databases on same server 
		INSERT INTO DYNSYSINDEXES
		SELECT @RUN_NAME,
			   @DATABASE_NAME,
			   si.[object_id],
			   si.[name],
			   si.[index_id],
			   si.[type],
			   si.[type_desc],
			   si.[is_unique],
			   si.[data_space_id],
			   si.[ignore_dup_key],
			   si.[is_primary_key],
			   si.[is_unique_constraint],
			   si.[fill_factor],
			   si.[is_padded],
			   si.[is_disabled],
			   si.[is_hypothetical],
			   si.[allow_row_locks],
			   si.[allow_page_locks],
			   si.[has_filter],
			   si.[filter_definition],
			   ssi.[xmaxlen],
			   ssi.[maxirow]
		FROM   DYN_SOBJ_SYSINDEXES si
			   INNER JOIN DYN_SOBJ_SYS_SYSINDEXES ssi
					   ON si.object_id = ssi.id
						  AND si.index_id = ssi.indid
			   INNER JOIN DYN_SOBJ_SYSOBJECTS so
					   ON si.object_id = so.object_id
						  AND so.type = 'U' 


		INSERT INTO DYNSYSCOLUMNS
		SELECT @RUN_NAME,
			   @DATABASE_NAME,   
			   c.object_id,
			   c.name,
			   c.column_id,
			   t.name AS datatype,
			   c.max_length
		FROM   DYN_SOBJ_SYSCOLUMNS c
			   INNER JOIN DYN_SOBJ_SYSTYPES t
					   ON t.system_type_id = c.system_type_id
			   INNER JOIN DYN_SOBJ_SYSOBJECTS so
					   ON so.object_id = c.object_id
						  AND so.type = 'U' 



	  END

	  IF @REMOTE_SERVER = 'Y'
	  BEGIN
    		SET @SQL = '	
			
			SELECT	
 			 si.[object_id],
			   si.[name],
			   si.[index_id],
			   si.[type],
			   si.[type_desc],
			   si.[is_unique],
			   si.[data_space_id],
			   si.[ignore_dup_key],
			   si.[is_primary_key],
			   si.[is_unique_constraint],
			   si.[fill_factor],
			   si.[is_padded],
			   si.[is_disabled],
			   si.[is_hypothetical],
			   si.[allow_row_locks],
			   si.[allow_page_locks],
			   si.[has_filter],
			   si.[filter_definition],
			   ssi.[xmaxlen],
			   ssi.[maxirow]
    	FROM	['+ @DATABASE_NAME+ '].sys.indexes si
    	JOIN	['+ @DATABASE_NAME+ '].sys.sysindexes ssi ON si.object_id = ssi.id AND si.index_id = ssi.indid
    	JOIN	['+ @DATABASE_NAME+ '].sys.objects so ON si.object_id = so.object_id
    
     WHERE	so.type = ''U''
    	 '
             IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  INSERT INTO DynamicsPerf.dbo.DYNSYSINDEXES
						 SELECT ' + '''' + @RUN_NAME + '''' + ',' + '''' + @DATABASE_NAME + '''' + ',*
		                   FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ')'


		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)



		 		SET @SQL = '	
			
			SELECT	
 			  c.object_id,
			   c.name,
			   c.column_id,
			   t.name AS datatype,
			   c.max_length
    	FROM	['+ @DATABASE_NAME+ '].sys.columns c
    	JOIN	['+ @DATABASE_NAME+ '].sys.types t ON t.system_type_id = c.system_type_id
    	JOIN	['+ @DATABASE_NAME+ '].sys.objects so ON so.object_id = c.object_id
						  WHERE	so.type = ''U''
    	 '
             IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  INSERT INTO DynamicsPerf.dbo.DYNSYSCOLUMNS
						 SELECT ' + '''' + @RUN_NAME + '''' + ',' + '''' + @DATABASE_NAME + '''' + ',*
		                   FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ')'


		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)



END

   
   
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_UPDATE_QUERY_HISTORY]...';


GO
CREATE PROCEDURE [dbo].DYNPERF_UPDATE_QUERY_HISTORY
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @ROW_COUNT BIGINT = 0
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



  --REH need to figure out if it's midnight DB time for DB being rolled up
  --	Take stats_time which is time at DPA server and convert it to local time of the DB

  DECLARE @SERVER_TIME SMALLDATETIME, @SERVER_TIME_MIDNIGHT SMALLDATETIME, @TIME_DIFF INT, @SERVER_TIME_START SMALLDATETIME, @PREV_DAY SMALLDATETIME


   SET @SERVER_TIME = DATEADD(MI,@SQL_TZ_OFFSET,DATEADD(MI,@DPA_TZ_OFFSET*-1,@STATS_DATE))
  SET @SERVER_TIME_MIDNIGHT = (SELECT dateadd(DAY,datediff(DAY,-1,@SERVER_TIME),0))  --REH MIDNIGHT, NEXT DAY, SO HAVE TO BE LESS THAN THIS VALUE FOR TODAY
  SET @SERVER_TIME_START = (SELECT dateadd(DAY,datediff(DAY,0,@SERVER_TIME),0))  --REH MIDNIGHT, NEXT DAY, SO HAVE TO BE LESS THAN THIS VALUE FOR TODAY
  SET @PREV_DAY = DATEADD(DD,-1, @SERVER_TIME_START)
  SET @TIME_DIFF = DATEDIFF(MI, @SERVER_TIME, @SERVER_TIME_MIDNIGHT)


  UPDATE CAPTURE_LOG
SET    TEXT = TEXT + '  CURRENT SERVER TIME ' + CAST( @SERVER_TIME AS VARCHAR(50))
              + '  MIDNIGHT SERVER TIME ' + CAST(@SERVER_TIME_MIDNIGHT AS VARCHAR(50))
              + '  START OF TODAY ' + CAST(@SERVER_TIME_START AS VARCHAR(50))
              +'  FLOORED PREVIOUS DAY ' + CAST(@PREV_DAY AS VARCHAR(50))
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



  --REH Giving a 5 minute leaway after midnight to run this code, job will be scheduled to run hourly
  -- IF ABS(@TIME_DIFF)> 5  RETURN(0) ; -- If it's not midnight Server time ont he DB being rolled up, then do nothing

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



/******************************************************************************
NEED TO SUBTRACT OUT PREVIOUS DAYS AMOUNTS IF COMPILE_TIME WAS BEFORE TODAY

SUBTRACT THE LAST QUERY_STATS RECORD FROM PREVIOUS DAY WITH SAME COMPILE_TIME


*******************************************************************************/
--REH This sums up to the totals of the day


			MERGE QUERY_HISTORY AS target
			USING (SELECT T1.SERVER_NAME,
						  T1.DATABASE_NAME,
						  T1.DATE,
						  T1.QUERY_HASH,
						  T1.QUERY_PLAN_HASH,
						  SUM(T1.EXECUTION_COUNT - COALESCE(T2.EXECUTION_COUNT, 0))         AS EXECUTION_COUNT_TODAY,
	--					  SUM(T1.EXECUTION_COUNT)                                           AS EXECUTION_COUNT,
						  SUM(T1.ELAPSED_TIME - COALESCE(T2.ELAPSED_TIME, 0))               AS ELAPSED_TIME_TODAY,
		--				  SUM(T1.ELAPSED_TIME)                                              AS ELAPSED_TIME,
						  MAX(T1.MAX_ELAPSED_TIME)                                          AS MAX_ELAPSED_TIME,
						  MAX(T1.LAST_EXECUTION_TIME)                                       AS LAST_EXECUTION_TIME,
						  SUM(T1.TOTAL_LOGICAL_READS - COALESCE(T2.TOTAL_LOGICAL_READS, 0)) AS TOTAL_LOGICAL_READS_TODAY,
		--				  SUM(T1.TOTAL_LOGICAL_READS)                                       AS TOTAL_LOGICAL_READS,
						  SUM(T1.TOTAL_ROWS - COALESCE(T2.TOTAL_ROWS, 0))                   AS TOTAL_ROWS_TODAY,
						  SUM(T1.TOTAL_WORKER_TIME - COALESCE(T2.TOTAL_WORKER_TIME,0))	    AS TOTAL_WORKER_TIME_TODAY,
		--				  SUM(T1.TOTAL_ROWS)                                                AS TOTAL_ROWS,
						  MAX('D')                                                          AS FLAG
				   FROM   (
						  --REH This sums per compiled time in a day in case we get multiple recompiles in the day
						  SELECT SERVER_NAME,
								 DATABASE_NAME,
								 MAX(@SERVER_TIME_START)  AS DATE,
								 CREATION_TIME,
								 QUERY_HASH,
								 QUERY_PLAN_HASH,
								 MAX(EXECUTION_COUNT)     AS EXECUTION_COUNT,
								 MAX(TOTAL_ELAPSED_TIME)  AS ELAPSED_TIME,
								 MAX(MAX_ELAPSED_TIME)    AS MAX_ELAPSED_TIME,
								 MAX(LAST_EXECUTION_TIME) AS LAST_EXECUTION_TIME,
								 MAX(TOTAL_LOGICAL_READS) AS TOTAL_LOGICAL_READS,
								 MAX(TOTAL_ROWS)          AS TOTAL_ROWS, 
								 MAX(TOTAL_WORKER_TIME)   AS TOTAL_WORKER_TIME
						   FROM   QUERY_STATS
						   WHERE  QUERY_HASH <> 0x0000000000000000 -- REH ignore fetch_api or other misc stuff
								  AND DATEADD(MI, @SQL_TZ_OFFSET, DATEADD(MI, @DPA_TZ_OFFSET * -1, STATS_TIME)) >= @SERVER_TIME_START --REH 12AM THIS MORNING
								  AND DATEADD(MI, @SQL_TZ_OFFSET, DATEADD(MI, @DPA_TZ_OFFSET * -1, STATS_TIME)) < @SERVER_TIME_MIDNIGHT --REH LESS THEN 12M NEXT DAY
								  -- AND LAST_EXECUTION_TIME > @LAST_RUN
								  AND SERVER_NAME = @SERVER_NAME
						   GROUP  BY SERVER_NAME,
									 DATABASE_NAME,
									 QUERY_HASH,
									 QUERY_PLAN_HASH,
									 CREATION_TIME) AS T1
						  LEFT JOIN (
									--REH This sums per compiled time in a day in case we get multiple recompiles in the day
									SELECT SERVER_NAME,
										   DATABASE_NAME,
										   DATEADD(day, DATEDIFF(day, 0, STATS_TIME), 0) AS DATE,
										   CREATION_TIME,
										   QUERY_HASH,
										   QUERY_PLAN_HASH,
										   MAX(EXECUTION_COUNT)                          AS EXECUTION_COUNT,
										   MAX(TOTAL_ELAPSED_TIME)                       AS ELAPSED_TIME,
										   MAX(MAX_ELAPSED_TIME)                         AS MAX_ELAPSED_TIME,
										   MAX(LAST_EXECUTION_TIME)                      AS LAST_EXECUTION_TIME,
										   MAX(TOTAL_LOGICAL_READS)                      AS TOTAL_LOGICAL_READS,
										   MAX(TOTAL_ROWS)                               AS TOTAL_ROWS,
										   MAX(TOTAL_WORKER_TIME)						 AS TOTAL_WORKER_TIME
									 FROM   QUERY_STATS
									 WHERE  QUERY_HASH <> 0x0000000000000000 -- REH ignore fetch_api or other misc stuff
											AND DATEADD(DAY, DATEDIFF(DAY, 0, DATEADD(MI, @SQL_TZ_OFFSET, DATEADD(MI, @DPA_TZ_OFFSET * -1, STATS_TIME))), 0) = @PREV_DAY --REH SUBTRACT TOTAL FROM PREV DAY , 
											--AND LAST_EXECUTION_TIME < @LAST_RUN
											--AND LAST_EXECUTION_TIME > DATEADD(D, -1, @LAST_RUN) -- REH The MAX will get us the highest value from previous day/days
											AND SERVER_NAME = @SERVER_NAME
									 GROUP  BY SERVER_NAME,
											   DATABASE_NAME,
											   DATEADD(day, DATEDIFF(day, 0, STATS_TIME), 0),
											   QUERY_HASH,
											   QUERY_PLAN_HASH,
											   CREATION_TIME) AS T2
								 ON T1.SERVER_NAME = T2.SERVER_NAME
									AND T1.DATABASE_NAME = T2.DATABASE_NAME
									AND T1.DATABASE_NAME = T2.DATABASE_NAME
									AND T1.QUERY_HASH = T2.QUERY_HASH
									AND T1.QUERY_PLAN_HASH = T2.QUERY_PLAN_HASH
									AND T1.CREATION_TIME = T2.CREATION_TIME --REH creation_time is how we are linking to the stats for the same compiled query
				   GROUP  BY T1.SERVER_NAME,
							 T1.DATABASE_NAME,
							 T1.DATE,
							 T1.QUERY_HASH,
							 T1.QUERY_PLAN_HASH) AS source
			ON ( source.SERVER_NAME = target.SERVER_NAME
				 AND source.DATABASE_NAME = target.DATABASE_NAME
				 AND source.DATE = target.DATE
				 AND source.QUERY_HASH = target.QUERY_HASH
				 AND source.QUERY_PLAN_HASH = target.QUERY_PLAN_HASH
				 AND source.FLAG = target.FLAG )
			WHEN MATCHED THEN
			  UPDATE SET --EXECUTION_COUNT = source.EXECUTION_COUNT,
						 EXECUTION_COUNT_TODAY = source.EXECUTION_COUNT_TODAY,
						-- ELAPSED_TIME = source.ELAPSED_TIME,
						 ELAPSED_TIME_TODAY = source.ELAPSED_TIME_TODAY,
						 MAX_ELAPSED_TIME = source.MAX_ELAPSED_TIME,
						 LAST_EXECUTION_TIME = source.LAST_EXECUTION_TIME,
						-- TOTAL_LOGICAL_READS = source.TOTAL_LOGICAL_READS,
						 TOTAL_LOGICAL_READS_TODAY = source.TOTAL_LOGICAL_READS_TODAY,
						-- TOTAL_ROWS = source.TOTAL_ROWS,
						 TOTAL_ROWS_TODAY = source.TOTAL_ROWS_TODAY
			WHEN NOT MATCHED THEN
			  INSERT ( [SERVER_NAME],
					   [DATABASE_NAME],
					   [DATE], 
					   [QUERY_HASH],
					   [QUERY_PLAN_HASH],
					 --  [EXECUTION_COUNT],
					   [EXECUTION_COUNT_TODAY],
					 --  [ELAPSED_TIME],
					   [ELAPSED_TIME_TODAY],
					   [MAX_ELAPSED_TIME],
					   [LAST_EXECUTION_TIME],
					--   [TOTAL_LOGICAL_READS],
					   [TOTAL_LOGICAL_READS_TODAY],
					--   [TOTAL_ROWS],
					   [TOTAL_ROWS_TODAY],
					   [TOTAL_WORKER_TIME_TODAY],
					   [FLAG] )
			  VALUES (source.[SERVER_NAME],
					  source.[DATABASE_NAME],
					  source.[DATE],
					  source.[QUERY_HASH],
					  source.[QUERY_PLAN_HASH],
					--  source.[EXECUTION_COUNT],
					  source.[EXECUTION_COUNT_TODAY],
					--  source.[ELAPSED_TIME],
					  source.[ELAPSED_TIME_TODAY],
					  source.[MAX_ELAPSED_TIME],
					  source.[LAST_EXECUTION_TIME],
					--  source.[TOTAL_LOGICAL_READS],
					  source.[TOTAL_LOGICAL_READS_TODAY],
					  
					--  source.[TOTAL_ROWS],
					  source.[TOTAL_ROWS_TODAY],
					  source.[TOTAL_WORKER_TIME_TODAY],
					  'D'); 
 



				  SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT


 --REH Rollup the daily total into the Monthly total
			 MERGE QUERY_HISTORY AS target
			USING (SELECT [SERVER_NAME],
						  [DATABASE_NAME],
						  DATEADD(MONTH, DATEDIFF(MONTH, 0, [DATE]), 0) AS MDATE,
						  [QUERY_HASH],
						  [QUERY_PLAN_HASH],
				--		  MAX([EXECUTION_COUNT])                        AS EXECUTION_COUNT,
						  SUM([EXECUTION_COUNT_TODAY])                  AS EXECUTION_COUNT_TODAY,
				--		  MAX([ELAPSED_TIME])                           AS ELAPSED_TIME,
						  SUM([ELAPSED_TIME_TODAY])                     AS ELAPSED_TIME_TODAY,
						  MAX([MAX_ELAPSED_TIME])                       AS MAX_ELAPSED_TIME,
						  MAX([LAST_EXECUTION_TIME])                    AS LAST_EXECUTION_TIME,
					--	  MAX([TOTAL_LOGICAL_READS])                    AS TOTAL_LOGICAL_READS,
						  SUM([TOTAL_LOGICAL_READS_TODAY])              AS TOTAL_LOGICAL_READS_TODAY,
					--	  MAX([TOTAL_ROWS])                             AS TOTAL_ROWS,
						  SUM([TOTAL_ROWS_TODAY])                       AS TOTAL_ROWS_TODAY,
						  SUM([TOTAL_WORKER_TIME_TODAY])			    AS TOTAL_WORKER_TIME_TODAY,
						  'M'                                           AS FLAG
				   FROM   [dbo].[QUERY_HISTORY]
				   WHERE  FLAG = 'D'
						AND DATEADD(MONTH, DATEDIFF(MONTH, 0, [DATE]), 0) >= DATEADD(MONTH, DATEDIFF(MONTH, 0, @SERVER_TIME_START), 0) --REH Prevent us from rolling up old months, possibly changing totals
						  AND SERVER_NAME = @SERVER_NAME
				   GROUP  BY SERVER_NAME,
							 DATABASE_NAME,
							 DATEADD(MONTH, DATEDIFF(MONTH, 0, [DATE]), 0),
							 QUERY_HASH,
							 QUERY_PLAN_HASH) AS source
			ON ( source.SERVER_NAME = target.SERVER_NAME
				 AND source.DATABASE_NAME = target.DATABASE_NAME
				 AND source.MDATE = target.DATE
				 AND source.QUERY_HASH = target.QUERY_HASH
				 AND source.QUERY_PLAN_HASH = target.QUERY_PLAN_HASH
				 AND source.FLAG = target.FLAG )
			WHEN MATCHED THEN
			  UPDATE SET EXECUTION_COUNT_TODAY = source.EXECUTION_COUNT_TODAY,
						 ELAPSED_TIME_TODAY = source.ELAPSED_TIME_TODAY,
						 MAX_ELAPSED_TIME = source.MAX_ELAPSED_TIME,
						 LAST_EXECUTION_TIME = source.LAST_EXECUTION_TIME,
						 TOTAL_LOGICAL_READS_TODAY = source.TOTAL_LOGICAL_READS_TODAY,
						 TOTAL_ROWS_TODAY = source.TOTAL_ROWS_TODAY,
						 TOTAL_WORKER_TIME_TODAY = source.TOTAL_WORKER_TIME_TODAY
			WHEN NOT MATCHED THEN
			  INSERT ( [SERVER_NAME],
					   [DATABASE_NAME],
					   [DATE],
					   [QUERY_HASH],
					   [QUERY_PLAN_HASH],
					--   [EXECUTION_COUNT],
					   [EXECUTION_COUNT_TODAY],
				--	   [ELAPSED_TIME],
					   [ELAPSED_TIME_TODAY],
					   [MAX_ELAPSED_TIME],
					   [LAST_EXECUTION_TIME],
					--   [TOTAL_LOGICAL_READS],
					   [TOTAL_LOGICAL_READS_TODAY],
					--   [TOTAL_ROWS],
					   [TOTAL_ROWS_TODAY],
					   [TOTAL_WORKER_TIME_TODAY],
					   [FLAG] )
			  VALUES (source.[SERVER_NAME],
					  source.[DATABASE_NAME],
					  source.[MDATE],
					  source.[QUERY_HASH],
					  source.[QUERY_PLAN_HASH],
					--  source.[EXECUTION_COUNT],
					  source.[EXECUTION_COUNT_TODAY],
					--  source.[ELAPSED_TIME],
					  source.[ELAPSED_TIME_TODAY],
					  source.[MAX_ELAPSED_TIME],
					  source.[LAST_EXECUTION_TIME],
					--  source.[TOTAL_LOGICAL_READS],
					  source.[TOTAL_LOGICAL_READS_TODAY],
					--  source.[TOTAL_ROWS],
					  source.[TOTAL_ROWS_TODAY],
					  source.[TOTAL_WORKER_TIME_TODAY],
					  'M'); 


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_REFRESH_QUERY_PLANS]...';


GO
CREATE PROCEDURE [dbo].DYNPERF_REFRESH_QUERY_PLANS
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @REFRESH_PLAN_DAYS INT
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_RQP_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_RQP_STATS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_RQP_STATS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.dm_exec_query_stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_RQP_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_query_stats'

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


  SELECT @REFRESH_PLAN_DAYS = REFRESH_PLAN_DAYS FROM DATABASES_2_COLLECT WHERE LINKED_SERVER = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @REMOTE_SERVER = 'N'
BEGIN
;WITH Query_Stats_CTE (SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH, PLAN_HANDLE )
     AS
     -- Define the CTE query.
     (SELECT  * FROM 
     (SELECT DISTINCT SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH,
                      PLAN_HANDLE
      FROM   QUERY_STATS AS QS WITH (NOLOCK)
      WHERE  STATS_TIME > DATEADD(D,-1,GETDATE())  --REH ANY QUERIES COLLECTED IN THE LAST DAY
             AND DATABASE_NAME = @DATABASE_NAME
             AND SERVER_NAME = @SERVER_NAME 
             AND QUERY_PLAN_HASH > 0x00000000
             AND  EXISTS (SELECT 'X'
                             FROM   QUERY_PLANS QP WITH (NOLOCK)
                             WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
                                    AND QS.DATABASE_NAME = QP.DATABASE_NAME
                                    AND QS.SERVER_NAME = QP.SERVER_NAME 
									AND QP.DATE_UPDATED <= DATEADD(D,-@REFRESH_PLAN_DAYS,GETDATE() ) --REH ANY PLANS THAT HAVEN'T BEEN UPDATED IN THE LAST 7 DAYS
									)) AS A)
									 
UPDATE QP 
SET QUERY_PLAN = COALESCE(RH.QUERY_PLAN,QP.QUERY_PLAN), DATE_UPDATED = GETDATE(), PARSED_FLAG = 0
FROM   QUERY_PLANS QP
INNER JOIN (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_PLAN_HASH
                        ORDER BY CTE.QUERY_PLAN_HASH DESC),
                        SERVER_NAME, 
                        DATABASE_NAME,
               CTE.QUERY_PLAN_HASH,
               query_plan AS QUERY_PLAN
        FROM   Query_Stats_CTE CTE
               OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH ON RH.SERVER_NAME = QP.SERVER_NAME AND RH.DATABASE_NAME = QP.DATABASE_NAME
               AND RH.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
WHERE  RN = 1 AND QP.SERVER_NAME = @SERVER_NAME AND QP.DATABASE_NAME = @DATABASE_NAME


END

IF @REMOTE_SERVER = 'Y'
     BEGIN
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)


         SET @SQL = '
				CREATE TABLE [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH
				(
				QUERY_PLAN_HASH VARBINARY(64), 
				PLAN_HANDLE VARBINARY(64)
				)'

		IF @DEBUG = 'Y'
		BEGIN
         PRINT @SQL
		 END


         SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT [' + @SERVER_NAME
									 + ']'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

         SET @SQL = '

					;WITH Query_Stats_CTE ( QUERY_PLAN_HASH, PLAN_HANDLE)
						 AS (SELECT DISTINCT QUERY_PLAN_HASH,
										  PLAN_HANDLE
							 FROM   QUERY_STATS QS WITH (NOLOCK)
							 WHERE  QS.STATS_TIME >=  DATEADD(D,-1,GETDATE()) 
							  AND QUERY_PLAN_HASH > 0x00000000
									AND DATABASE_NAME = '
										+ '''' + @DATABASE_NAME + ''''
										+ '
									AND SERVER_NAME = ' + '''' +
										+ @SERVER_NAME + ''''
										+ ' 
									AND EXISTS (SELECT ''X''
													FROM   QUERY_PLANS QP WITH (NOLOCK)
												 WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
														AND QS.DATABASE_NAME = QP.DATABASE_NAME
														AND QS.SERVER_NAME = QP.SERVER_NAME 
															AND QP.DATE_UPDATED <= DATEADD(D,-' + CAST(@REFRESH_PLAN_DAYS AS VARCHAR(4)) +',GETDATE() ) 
													))
						INSERT INTO OPENQUERY([' + @SERVER_NAME
										+ '], ''SELECT QUERY_PLAN_HASH, PLAN_HANDLE FROM [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH'')
					                            
					  
					SELECT QUERY_PLAN_HASH, PLAN_HANDLE 
					FROM   (SELECT RN = ROW_NUMBER()
										  OVER (
											PARTITION BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE
											ORDER BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE DESC),
								   CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE 
					            
								FROM   Query_Stats_CTE CTE
							   ) AS RH
					WHERE  RN = 1 '

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END 


         EXEC(@SQL)



			SET @SQL = 'SELECT 
				   QUERY_PLAN_HASH,
				   cast(query_plan as nvarchar(max)) as QUERY_PLAN

			FROM   (SELECT RN = ROW_NUMBER()
								  OVER (
									PARTITION BY QUERY_PLAN_HASH
									ORDER BY QUERY_PLAN_HASH DESC),
						   QUERY_PLAN_HASH,
						   query_plan 
					FROM   [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH CTE
						   OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH
			WHERE  RN = 1 ' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  UPDATE DynamicsPerf.dbo.QUERY_PLANS
						 SET QUERY_PLAN =  COALESCE( RH.QUERY_PLAN, QUERY_PLANS.QUERY_PLAN), PARSED_FLAG = 0, DATE_UPDATED = ' + '''' + CAST(GETDATE() AS VARCHAR(20)) + '''' 
						 + 'FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') AS RH
						 WHERE SERVER_NAME = ' + '''' + @SERVER_NAME + '''' +
						  '   AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + 
						  '  AND RH.QUERY_PLAN_HASH = QUERY_PLANS.QUERY_PLAN_HASH' 

		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)
         

		 --REH Drop the table at the end of the process

         SET @SQL = '

				IF EXISTS (SELECT * FROM  [' + @DATABASE_NAME + '].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
				 DROP TABLE  [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)
     
     END 




UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)

	
         SET @SQL = '

				IF EXISTS (SELECT * FROM  [' + @DATABASE_NAME + '].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
				 DROP TABLE  [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 

				EXEC(@SQL2)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_CRM_POA_TOTALS]...';


GO


CREATE PROCEDURE DYNPERF_COLLECT_CRM_POA_TOTALS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPOA_CRM_POA')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPOA_CRM_POA')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPOA_CRM_POA
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..PrincipalObjectAccess'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPOA_CRM_POA
				FOR [' + @DATABASE_NAME + ']..PrincipalObjectAccess'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPOA_CRM_EV')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPOA_CRM_EV')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPOA_CRM_EV
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..EntityAsIfPublishedLogicalView'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPOA_CRM_EV
				FOR [' + @DATABASE_NAME + ']..EntityAsIfPublishedLogicalView'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


INSERT INTO [DynamicsPerf]..CRM_POA_TOTALS
SELECT @SERVER_NAME,
       CONVERT(NVARCHAR(50), @STATS_DATE, 121),
       @DATABASE_NAME,
       e.NAME   AS [EntityName],
       Sum(CASE
             WHEN p.AccessRightsMask > 0 THEN 1
             ELSE 0
           END) AS [DirectShares],
       Sum(CASE
             WHEN p.InheritedAccessRightsMask > 0 THEN 1
             ELSE 0
           END) AS [InheritedShares],
       Sum(CASE
             WHEN p.AccessRightsMask = 0
                  AND p.InheritedAccessRightsMask = 0 THEN 1
             ELSE 0
           END) AS[QueuedForDeletion],
       Sum(CASE
             WHEN p.AccessRightsMask > 0
                  AND p.InheritedAccessRightsMask > 0 THEN 1
             ELSE 0
           END) AS[InheritedAndDirect],
       Count(*) AS TotalShares
FROM   DYN_CRMPOA_CRM_POA p
       JOIN DYN_CRMPOA_CRM_EV e
         ON p.ObjectTypeCode = e.ObjectTypeCode
GROUP  BY e.Name
ORDER  BY TotalShares DESC 

    


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_CRM_PLUGINS]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_CRM_PLUGINS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_PLUGINTYPE')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_PLUGINTYPE')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINTYPE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..PluginType'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINTYPE
				FOR [' + @DATABASE_NAME + ']..PluginType'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_PLUGINASSEMBLY')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_PLUGINASSEMBLY')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINASSEMBLY
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..PluginAssembly'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINASSEMBLY
				FOR [' + @DATABASE_NAME + ']..PluginAssembly'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_PLUGINTYPESTATISTIC')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_PLUGINTYPESTATISTIC')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINTYPESTATISTIC
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..PluginTypeStatistic'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINTYPESTATISTIC
				FOR [' + @DATABASE_NAME + ']..PluginTypeStatistic'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_SDKMESSAGEPROCESSINGSTEP')
 EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_SDKMESSAGEPROCESSINGSTEP')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGEPROCESSINGSTEP
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..SdkMessageProcessingStep'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGEPROCESSINGSTEP
				FOR [' + @DATABASE_NAME + ']..SdkMessageProcessingStep'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_SDKMESSAGEFILTER')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_SDKMESSAGEFILTER')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGEFILTER
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..SdkMessageFilter'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGEFILTER
				FOR [' + @DATABASE_NAME + ']..SdkMessageFilter'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_SDKMESSAGE')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_SDKMESSAGE')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..SdkMessage'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGE
				FOR [' + @DATABASE_NAME + ']..SdkMessage'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_ENTITYLOGICALVIEW')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_ENTITYLOGICALVIEW')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_ENTITYLOGICALVIEW
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..EntityLogicalView'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_ENTITYLOGICALVIEW
				FOR [' + @DATABASE_NAME + ']..EntityLogicalView'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

INSERT INTO [DynamicsPerf]..CRM_PLUGINS
SELECT @SERVER_NAME,
       CONVERT(NVARCHAR(50), @STATS_DATE, 121),
       @DATABASE_NAME,
       CASE sdkmessageprocessingstep0.StateCode
         WHEN 0 THEN 'Enabled'
         WHEN 1 THEN 'Disabled'
         ELSE 'n/a'
       END                                                        AS 'StatusName',
       ISNULL(e.NAME, 'None')                                     AS 'EntityName',
       CASE sdkmessageprocessingstep0.Stage
         WHEN 10 THEN 'Pre-Out Of Trx'
         WHEN 20 THEN 'Pre in Trx'
         WHEN 40 THEN 'Post in Trx'
         WHEN 50 THEN 'Post-Out of Trx'
         ELSE 'Workflow Activity'
       END                                                        AS 'StageName',
       CASE PluginAssembly.IsolationMode
         WHEN 1 THEN 'Full'
         WHEN 2 THEN 'Isolated-SandBox'
         ELSE 'Unknown'
       END                                                        AS 'IsolationModeName',
       PluginAssembly.IsolationMode,
       PluginAssembly.Version,
       PluginAssembly.IsManaged,
       ISNULL(sm.Name, 'None')                                    AS 'MessageName',
       PluginType0.componentstate                                 AS 'Assembly',
       PluginType0.typename                                       AS 'Plugin',
       CASE sdkmessageprocessingstep0.Mode
         WHEN 1 THEN 'Asynchronous'
         WHEN 0 THEN 'Synchronous'
         ELSE 'None'
       END                                                        AS 'ModeName',
       CASE ( ( COALESCE(sdkmessageprocessingstep0.AsyncAutoDelete, 0) * sdkmessageprocessingstep0.Mode ) + sdkmessageprocessingstep0.Mode )
         WHEN 1 THEN 'No'
         WHEN 2 THEN 'Yes'
         ELSE '-'
       END                                                        AS 'AsyncAutoDeleteName',
       ISNULL(sdkmessageprocessingstep0.Rank, '')                 AS 'Rank',
       --CASE sdkmessageprocessingstep0.InvocationSource WHEN 0 Then 'Parent' WHEN 1 Then 'Child' END as 'PipelineName',
       ISNULL(sdkmessageprocessingstep0.FilteringAttributes, '-') AS 'FilteringAttributes',
       ISNULL(sdkmessageprocessingstep0.Description, '-')         AS 'StepName',
       ISNULL(sdkmessageprocessingstep0.AsyncAutoDelete, '')      AS 'AsyncAutoDelete',
       ISNULL(sdkmessageprocessingstep0.Mode, '')                 'Mode',
       ISNULL(sdkmessageprocessingstep0.Stage, '')                'Stage',
       COALESCE(pts.AverageExecuteTimeInMilliseconds, -1)         'AvgExecTimeMs',
       COALESCE(pts.ExecuteCount, -1)                             'Executes',
       COALESCE(pts.FailureCount, -1)                             'Failures'
FROM   DYN_CRMPLUG_CRM_PLUGINTYPE PluginType0
       INNER JOIN DYN_CRMPLUG_CRM_PLUGINASSEMBLY PluginAssembly
               ON PluginType0.PluginAssemblyId = PluginAssembly.PluginAssemblyId
       INNER JOIN DYN_CRMPLUG_CRM_PLUGINTYPESTATISTIC pts
               ON pts.PluginTypeId = PluginType0.PluginTypeId
       LEFT JOIN DYN_CRMPLUG_CRM_SDKMESSAGEPROCESSINGSTEP AS sdkmessageprocessingstep0
              ON PluginType0.PluginTypeId = sdkmessageprocessingstep0.PluginTypeId
       LEFT JOIN DYN_CRMPLUG_CRM_SDKMESSAGEFILTER filter
              ON filter.SdkMessageFilterId = sdkmessageprocessingstep0.SdkMessageFilterId
       LEFT JOIN DYN_CRMPLUG_CRM_SDKMESSAGE sm
              ON sm.SdkMessageId = filter.SdkMessageId
       LEFT JOIN DYN_CRMPLUG_CRM_ENTITYLOGICALVIEW e
              ON filter.PrimaryObjectTypeCode = e.ObjectTypeCode
WHERE  ( ( sdkmessageprocessingstep0.CustomizationLevel != 2
            OR sdkmessageprocessingstep0.CustomizationLevel IS NULL )
         AND ( sdkmessageprocessingstep0.Stage IS NULL
                OR ( sdkmessageprocessingstep0.Stage IN ( 10, 20, 40, 50 ) ) ) )
       AND FriendlyName NOT IN ( 'InternalOperation' )
       AND IsolationMode = 2 


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_CRM_ORGANIZATION]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_CRM_ORGANIZATION (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMO_CRMORGANIZATION')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMO_CRMORGANIZATION')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMO_CRMORGANIZATION
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..Organization'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMO_CRMORGANIZATION
				FOR [' + @DATABASE_NAME + ']..Organization'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


INSERT INTO [DynamicsPerf]..CRM_ORGANIZATION
SELECT @SERVER_NAME,
       CONVERT(NVARCHAR(50), @STATS_DATE, 121),
       @DATABASE_NAME,
       sharetopreviousowneronassign,
       minoutlooksyncinterval,
       tagpollingperiod,
       MinAddressBookSyncInterval,
       AllowAddressBookSyncs,
       emailsendpollingperiod,
       ispresenceenabled,
       GetStartedPaneContentEnabled,
       orgdborgsettings
FROM   DYN_CRMO_CRMORGANIZATION 


    


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_SQL_PLAN_GUIDES]...';


GO


CREATE PROCEDURE DYNPERF_COLLECT_SQL_PLAN_GUIDES (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SPG_PLANGUIDES')
  EXEC ('DROP SYNONYM [dbo].DYN_SPG_PLANGUIDES')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SPG_PLANGUIDES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.plan_guides'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SPG_PLANGUIDES
				FOR [' + @DATABASE_NAME + '].sys.plan_guides'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


--REH Needs to be lower case for case sensitive databases

INSERT INTO [DynamicsPerf]..SQL_PLAN_GUIDES
SELECT @SERVER_NAME, CONVERT(NVARCHAR(50), @STATS_DATE, 121),
@DATABASE_NAME

      ,[plan_guide_id]
      ,[name]
      ,[create_date]
      ,[modify_date]
      ,[is_disabled]
      ,[query_text]
      ,[scope_type]
      ,[scope_type_desc]
      ,[scope_object_id]
      ,[scope_batch]
      ,[parameters]
      ,[hints]
	FROM DYN_SPG_PLANGUIDES

    



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_VIRTIALIO_DISKSTATS]...';


GO
CREATE PROCEDURE [dbo].[DYNPERF_COLLECT_VIRTIALIO_DISKSTATS] (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @PREV_STATS_TIME DATETIME
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



IF @REMOTE_SERVER = 'N'
BEGIN

		INSERT DISKSTATS
		SELECT DISTINCT @SERVER_NAME,
						@STATS_DATE,
						db_name(database_id) AS DATABASENAME,
						database_id,
						file_id,
						sample_ms,
						num_of_reads,
						num_of_bytes_read,
						io_stall_read_ms,
						num_of_writes,
						num_of_bytes_written,
						io_stall_write_ms,
						io_stall,
						size_on_disk_bytes,
						file_handle
		FROM   sys.dm_io_virtual_file_stats
                (NULL, NULL) 


END



IF @REMOTE_SERVER = 'Y'
	BEGIN

			SET @SQL = '
			SELECT DISTINCT DB_NAME(database_id) AS DATABASENAME, 
			database_id,file_id, sample_ms, num_of_reads,num_of_bytes_read, io_stall_read_ms, num_of_writes, num_of_bytes_written,io_stall_write_ms, io_stall, size_on_disk_bytes, file_handle
				FROM sys.dm_io_virtual_file_stats (NULL, NULL) '


			IF @DEBUG = 'Y' 
			BEGIN
			PRINT '@SQL= ' + @SQL
			END


			SET @SQL2 = ' 
			  SET QUOTED_IDENTIFIER OFF
			  INSERT INTO DynamicsPerf.dbo.DISKSTATS
							 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + '''' + CONVERT(NVARCHAR(50), @STATS_DATE, 121) + '''' +  ',
                    
								RH.*  FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '




			IF @DEBUG = 'Y' 
			BEGIN
			PRINT '@SQL= ' + @SQL2
			END

			EXEC (@SQL2)


	END
 
 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_AX_AOTEXPORT_DATA]...';


GO
CREATE PROCEDURE [dbo].[DYNPERF_COLLECT_AX_AOTEXPORT_DATA](@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS








return(0) --REH no longer used, AOTEXPORT CLASS goes direct to DynamicsPerf now























/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/


		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AOT_SYSTABLES')
		  DROP SYNONYM [dbo].DYN_AOT_SYSTABLES

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL = '
						CREATE SYNONYM DYN_AOT_SYSTABLES
						FOR [' + @SERVER_NAME + '].['
							+ @DATABASE_NAME
							+ '].sys.tables'
			 END
		ELSE
		  SET @SQL = '
						CREATE SYNONYM DYN_AOT_SYSTABLES
						FOR [' + @DATABASE_NAME
					 + '].sys.tables'

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END

		EXEC (@SQL) 

IF NOT EXISTS (SELECT * FROM DYN_AOT_SYSTABLES  WHERE name = 'AOTTABLEPROPERTIES')
BEGIN

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'NO AOTEXPORT DATA  for SERVER	' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109)
			  + ', ' 
			  + CHAR(10)
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT 'NO AOTEXPORT DATA IN THE DATABASE'
			 END
		RETURN(0)
			 
			 
END



		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AOT_AX_AOTTABLEPROPERTIES')
		  DROP SYNONYM [dbo].DYN_AOT_AX_AOTTABLEPROPERTIES

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL = '
						CREATE SYNONYM DYN_AOT_AX_AOTTABLEPROPERTIES
						FOR [' + @SERVER_NAME + '].['
							+ @DATABASE_NAME
							+ '].dbo.AOTTABLEPROPERTIES'
			 END
		ELSE
		  SET @SQL = '
						CREATE SYNONYM DYN_AOT_AX_AOTTABLEPROPERTIES
						FOR [' + @DATABASE_NAME
					 + '].dbo.AOTTABLEPROPERTIES'

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END

		EXEC (@SQL) 
		
				IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AX_AOTINDEXFIELDS')
		  DROP SYNONYM [dbo].DYN_AX_AOTINDEXFIELDS

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL = '
						CREATE SYNONYM DYN_AX_AOTINDEXFIELDS
						FOR [' + @SERVER_NAME + '].['
							+ @DATABASE_NAME
							+ '].dbo.AOTINDEXFIELDS'
			 END
		ELSE
		  SET @SQL = '
						CREATE SYNONYM DYN_AX_AOTINDEXFIELDS
						FOR [' + @DATABASE_NAME
					 + '].dbo.AOTINDEXFIELDS'

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END

		EXEC (@SQL) 
		
			IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AX_AOTINDEXPROPERTIES')
		  DROP SYNONYM [dbo].DYN_AX_AOTINDEXPROPERTIES

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL = '
						CREATE SYNONYM DYN_AX_AOTINDEXPROPERTIES
						FOR [' + @SERVER_NAME + '].['
							+ @DATABASE_NAME
							+ '].dbo.AOTINDEXPROPERTIES'
			 END
		ELSE
		  SET @SQL = '
						CREATE SYNONYM DYN_AX_AOTINDEXPROPERTIES
						FOR [' + @DATABASE_NAME
					 + '].dbo.AOTINDEXPROPERTIES'

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END

		EXEC (@SQL) 	








/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



DELETE FROM  AX_TABLE_DETAIL WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME

		INSERT INTO AX_TABLE_DETAIL
		SELECT @SERVER_NAME,
			   @STATS_DATE,
			   @DATABASE_NAME,
			   TABLENAME,
			   TABID,
			   OCCENABLED,
			   CACHELOOKUP,
			   INSERTMETHODOVERRIDDEN,
			   UPDATEMETHODOVERRIDDEN,
			   DELETEMETHODOVERRIDDEN,
			   AOSVALIDATEINSERT,
			   AOSVALIDATEUPDATE,
			   AOSVALIDATEDELETE,
			   DATABASELOGINSERT,
			   DATABASELOGDELETE,
			   DATABASELOGUPDATE,
			   DATABASELOGRENAMEKEY,
			   EVENTINSERT,
			   EVENTDELETE,
			   EVENTUPDATE,
			   EVENTRENAMEKEY,
			   TABLEGROUP,
			   APPLAYER
		FROM   DYN_AOT_AX_AOTTABLEPROPERTIES 


		INSERT INTO AX_INDEX_DETAIL
		SELECT @SERVER_NAME,
			   @STATS_DATE,
			   @DATABASE_NAME,
			   T.TABLENAME,
			   INDEXNAME,
			   INDEX_ID = INDEXID,
			   INDEX_DESCRIPTION = (CASE
									 WHEN I.INDEXNAME = T.CLUSTEREDINDEX THEN 'CLUSTERED'
									 ELSE 'NONCLUSTERED'
								   END) +
								   (CASE
									 WHEN I.ALLOWDUPLICATES = 0 THEN ', UNIQUE'
									 ELSE ''
								   END) +
								   (CASE
									 WHEN I.INDEXNAME = T.PRIMARYKEY THEN ', PRIMARY KEY'
									 ELSE ''
								   END),
			   INDEX_KEYS = CASE
							  WHEN T.DATAPERCOMPANY = 1
								   AND 0 < (SELECT COUNT(*)
											FROM   DYN_AX_AOTINDEXFIELDS F WITH (NOLOCK)
											WHERE  F.TABLENAME = I.TABLENAME
												   AND F.INDEXNAME = I.INDEXNAME
												   AND F.FIELDNAME = 'DATAAREAID') THEN ''
							  WHEN T.DATAPERCOMPANY = 1 THEN ' DATAAREAID,'
							  ELSE ''
							END +
			   STUFF ((SELECT ', ' + FIELDNAME
					   FROM   DYN_AX_AOTINDEXFIELDS F WITH (NOLOCK)
					   WHERE  F.TABLENAME = I.TABLENAME
							  AND FIELDNAME <> ''
							  AND F.INDEXNAME = I.INDEXNAME
					   ORDER  BY FIELDPOSITION
					   FOR xml path('')), 1, 1, ''),
			   I.APPLAYER
		FROM   DYN_AOT_AX_AOTTABLEPROPERTIES T WITH (NOLOCK),
			   DYN_AX_AOTINDEXPROPERTIES I WITH (NOLOCK)
		WHERE  T.TABLENAME = I.TABLENAME 

		    

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_CHANGE_DATA_CONTROL]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_CHANGE_DATA_CONTROL (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @RC INT, @CDC_ENABLED CHAR(1) = 'N'
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SYN_CDC')
  EXEC ('DROP SYNONYM [dbo].DYN_SYN_CDC')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SYN_CDC
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.sp_cdc_help_change_data_capture'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SYN_CDC
				FOR [' + @DATABASE_NAME + '].sys.sp_cdc_help_change_data_capture'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SYN_SYSDATABASES')
 EXEC ('DROP SYNONYM [dbo].DYN_SYN_SYSDATABASES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SYN_SYSDATABASES
				FOR [' + @SERVER_NAME + '].master.sys.databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SYN_SYSDATABASES
				FOR master.sys.databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC(@SQL) 

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

SELECT @RC = is_cdc_enabled FROM DYN_SYN_SYSDATABASES WHERE name = @DATABASE_NAME

IF @RC = 1  SET  @CDC_ENABLED = 'Y' 

IF @DEBUG = 'Y' 
BEGIN
PRINT 'CDC FLAG ' + @CDC_ENABLED
END



IF @CDC_ENABLED = 'Y' 
BEGIN 


		DELETE FROM [DynamicsPerf]..CDC WHERE DATABASE_NAME = @DATABASE_NAME AND SERVER_NAME = @SERVER_NAME 


			CREATE TABLE #CDC
			  (
				 source_schema		sysname,
				 source_table		sysname,
				 capture_instance	sysname,
				 object_id			int,
				 source_object_id	int,
				 start_lsn			binary(10),
				 end_lsn			binary(10),
				 supports_net_changes bit,
				 has_drop_pending	bit,
				 role_name			sysname,
				 index_name			sysname,
				 filegroup_name		sysname,
				 create_date		datetime,
				 index_column_list	nvarchar(max),
				 captured_column_list nvarchar(max)
				   ); 


			INSERT INTO #CDC (
				 source_schema,		
				 source_table,		
				 capture_instance,
				 object_id,
				 source_object_id,
				 start_lsn,
				 end_lsn,
				 supports_net_changes,
				 has_drop_pending,
				 role_name,
				 index_name,
				 filegroup_name,
				 create_date,
				 index_column_list,
				 captured_column_list
			)


			EXECUTE DYN_SYN_CDC;

			INSERT INTO DynamicsPerf..CDC
			SELECT @SERVER_NAME, @STATS_DATE,@DATABASE_NAME, * FROM #CDC
END
	
	



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[SP_LOGBLOCKS_MS]...';


GO


CREATE PROCEDURE [dbo].[SP_LOGBLOCKS_MS]
AS


SET nocount ON
SET DATEFORMAT MDY 


-- ***********************************************************************
-- Copyright  Microsoft Corporation. All rights reserved.
-- This script is made available to you without any express, implied or statutory warranty, 
-- not even the implied warranty of merchantability or fitness for a particular purpose, 
-- or the warranty of title or non-infringement. 
-- The entire risk of the use or the results from the use of this script remains with you.
-- ***********************************************************************

DECLARE @BLOCKED TABLE(
  BLOCKER_LOGIN          NVARCHAR(128) COLLATE database_default,
  BLOCKER_PROGRAM        NVARCHAR(128) COLLATE database_default,
  BLOCKER_HOSTNAME       NVARCHAR(128) COLLATE database_default,
  BLOCKED_LOGIN          NVARCHAR(128) COLLATE database_default,
  BLOCKED_PROGRAM        NVARCHAR(128) COLLATE database_default,
  BLOCKED_HOSTNAME       NVARCHAR(128) COLLATE database_default,
  BLOCKER_SESSION_ID     SMALLINT,
  BLOCKER_CONTEXT_INFO	 BINARY (128),
  BLOCKER_CONTEXT        NVARCHAR(MAX) COLLATE database_default,
  BLOCKER_TRAN_ISOLATION NVARCHAR(20) COLLATE database_default,
  BLOCKER_STATUS         NVARCHAR(18) COLLATE database_default,
  BLOCKED_SESSION_ID     SMALLINT,
  BLOCKED_CONTEXT_INFO	 BINARY(128),
  BLOCKED_CONTEXT        NVARCHAR(MAX) COLLATE database_default,
  BLOCKED_TRAN_ISOLATION NVARCHAR(20) COLLATE database_default,
  TRANSACTION_ID		 BIGINT,
  WAIT_TIME              BIGINT,
  LOCK_MODE              NVARCHAR(60) COLLATE database_default,
  LOCK_SIZE              NVARCHAR(6) COLLATE database_default,
  DATABASE_NAME          NVARCHAR(128) COLLATE database_default,
  OBJECT_NAME            NVARCHAR(128) COLLATE database_default,
  INDEX_ID               INT,
  BLOCKER_SQL            NVARCHAR(MAX) COLLATE database_default,
  BLOCKER_PLAN           XML,
  BLOCKED_SQL            NVARCHAR(MAX) COLLATE database_default,
  BLOCKED_PLAN           XML ) 




DECLARE @BLOCKER_SESSION_ID     SMALLINT,
        @BLOCKER_CONTEXT        NVARCHAR(MAX),
        @BLOCKER_CONTEXT_INFO	BINARY(128),
        @BLOCKER_TRAN_ISOLATION NVARCHAR(20),
        @BLOCKER_STATUS         NVARCHAR(18),
        @BLOCKED_SESSION_ID     SMALLINT,
        @BLOCKED_CONTEXT        NVARCHAR(MAX),
        @BLOCKED_CONTEXT_INFO	BINARY(128),
        @BLOCKED_TRAN_ISOLATION NVARCHAR(20),
        @WAITTIME               BIGINT,
        @LOCK_MODE              NVARCHAR(60),
        @LOCK_SIZE              CHAR(6),
        @DATABASE_NAME          NVARCHAR(128),
        @ASSOCIATEDOBJECTID     BIGINT,
        @OBJECT_NAME            NVARCHAR(128),
        @INDEX_ID               INT,
        @BLOCKER_SQL            NVARCHAR(MAX),
        @BLOCKER_PLAN           XML,
        @BLOCKED_SQL            NVARCHAR(MAX),
        @BLOCKED_PLAN           XML,
        @SQL                    NVARCHAR(4000),
        @PARM                   NVARCHAR(500),
        @BLOCKED_LOGIN          NVARCHAR(128),
        @BLOCKED_PROGRAM        NVARCHAR(128),
        @BLOCKED_HOSTNAME       NVARCHAR(128),
        @BLOCKER_LOGIN          NVARCHAR(128),
        @BLOCKER_PROGRAM        NVARCHAR(128),
        @BLOCKER_HOSTNAME       NVARCHAR(128),
        @TRANSACTION_ID			BIGINT,
        @rows                   BIGINT 



SET NOCOUNT ON
SET DATEFORMAT MDY
--	-------------------------------------------------------------------------------------
--	Populate temporary table #BLOCKED from sysindexes for blocked and blocking processes
--	-------------------------------------------------------------------------------------
DECLARE BLOCKED CURSOR FOR
SELECT WAIT.blocking_session_id,
       WAIT.session_id,
       Rtrim(CONVERT(NVARCHAR(MAX), BLOCKED.context_info)),
       CASE BLOCKED.transaction_isolation_level
         WHEN 1 THEN 'Read Uncommitted'
         WHEN 2 THEN 'Read Committed'
         WHEN 3 THEN 'Repeatable Read'
         WHEN 4 THEN 'Serializable'
         WHEN 5 THEN 'Snapshot'
         ELSE Str(BLOCKED.transaction_isolation_level)
       END,
       WAIT.wait_duration_ms,
       WAIT.wait_type,
       CASE
         WHEN resource_description LIKE 'objectlock%' THEN 'Object'
         WHEN resource_description LIKE 'pagelock%' THEN 'Page'
         WHEN resource_description LIKE 'keylock%' THEN 'Key'
         WHEN resource_description LIKE 'ridlock%' THEN 'Row'
         ELSE 'N/A'
       END,
       Db_name(BLOCKED.database_id),
       CASE
         WHEN resource_description LIKE '%associatedObjectId%' THEN CONVERT(BIGINT, Substring (resource_description, Charindex('associatedObjectId=', resource_description)
                                                                                                                     + 19, ( Len(resource_description) + 1 ) - ( Charindex('associatedObjectId=', resource_description)
                                                                                                                                                                 + 19 )))
         ELSE 0
       END,
       BLOCKEDSQL.text,
       BLOCKEDPLAN.query_plan,
       BLOCKED.transaction_id
FROM   sys.dm_os_waiting_tasks WAIT
       INNER LOOP JOIN sys.dm_exec_requests AS BLOCKED
                    ON WAIT.session_id = BLOCKED.session_id
       OUTER APPLY sys.dm_exec_sql_text(BLOCKED.sql_handle) AS BLOCKEDSQL
       OUTER APPLY sys.dm_exec_query_plan(BLOCKED.plan_handle) AS BLOCKEDPLAN
WHERE  WAIT.wait_type LIKE 'LCK%' 


--AND			database_id = db_id()


OPEN BLOCKED

FETCH BLOCKED INTO 
	@BLOCKER_SESSION_ID		,
	@BLOCKED_SESSION_ID		,
	@BLOCKED_CONTEXT		, 
	@BLOCKED_TRAN_ISOLATION		,
	@WAITTIME				,
	@LOCK_MODE				,
	@LOCK_SIZE				,
	@DATABASE_NAME			,
	@ASSOCIATEDOBJECTID		,
	@BLOCKED_SQL			,
	@BLOCKED_PLAN			,
	@TRANSACTION_ID		

WHILE @@FETCH_STATUS = 0
	BEGIN
		IF EXISTS (SELECT * FROM sys.dm_exec_requests where session_id = @BLOCKER_SESSION_ID)
			
			BEGIN
				SELECT @BLOCKER_CONTEXT = '; Waiting on ' + wait_type,
                       @BLOCKER_TRAN_ISOLATION = CASE transaction_isolation_level
                                                   WHEN 1 THEN 'Read Uncommitted'
                                                   WHEN 2 THEN 'Read Committed'
                                                   WHEN 3 THEN 'Repeatable Read'
                                                   WHEN 4 THEN 'Serializable'
                                                   WHEN 5 THEN 'Snapshot'
                                                   ELSE Str(transaction_isolation_level)
                                                 END,
                       --	-------------------------------------------------------------------------------------
                       --	If blocking process is not waiting on a lock, it is a lead blocker
                       --	-------------------------------------------------------------------------------------
                       @BLOCKER_STATUS = CASE
                                           WHEN blocking_session_id = 0 THEN 'Lead Blocker'
                                           WHEN REQUESTS.session_id = blocking_session_id THEN 'Lead Blocker'
                                           ELSE 'In Blocking Chain'
                                         END,
                       @BLOCKER_SQL = BLOCKERSQL.text,
                       @BLOCKER_PLAN = query_plan
                FROM   sys.dm_exec_requests AS REQUESTS
                       OUTER APPLY sys.dm_exec_sql_text(sql_handle) AS BLOCKERSQL
                       OUTER APPLY sys.dm_exec_query_plan(plan_handle)
                WHERE  REQUESTS.session_id = @BLOCKER_SESSION_ID 
                
		END
	ELSE IF EXISTS (SELECT * FROM  sys.dm_exec_connections WHERE session_id = @BLOCKER_SESSION_ID)
--	-------------------------------------------------------------------------------------
--	If blocker does not have an active request, retrieve most recent information from
--      sys.dm_exec_connections.  
--	SQL txt is via sys.dm_exec_connections.most_recent_sql_handle
--	and the query plan via sys.dm_exec_query_stats.plan_handle
--	-------------------------------------------------------------------------------------
		BEGIN
			SELECT @BLOCKER_CONTEXT = '',
				   @BLOCKER_TRAN_ISOLATION = 'n/a',
				   @BLOCKER_STATUS = 'Lead Blocker',
				   @BLOCKER_SQL = text,
				   @BLOCKER_PLAN = query_plan
			FROM   sys.dm_exec_connections AS CONNECTIONS
				   OUTER APPLY sys.dm_exec_sql_text(CONNECTIONS.most_recent_sql_handle)
				   LEFT JOIN sys.dm_exec_query_stats AS QUERYSTATS
						  ON most_recent_sql_handle = sql_handle
				   OUTER APPLY sys.dm_exec_query_plan(QUERYSTATS.plan_handle)
			WHERE  session_id = @BLOCKER_SESSION_ID 


--	-------------------------------------------------------------------------------------
--	Retrieve blocker's session INFORMATION
--	-------------------------------------------------------------------------------------
			SELECT
			--	@BLOCKER_CONTEXT = '',
			@BLOCKER_TRAN_ISOLATION = CASE transaction_isolation_level
										WHEN 1 THEN 'Read Uncommitted'
										WHEN 2 THEN 'Read Committed'
										WHEN 3 THEN 'Repeatable Read'
										WHEN 4 THEN 'Serializable'
										WHEN 5 THEN 'Snapshot'
										ELSE Str(transaction_isolation_level)
									  END,
			@BLOCKER_LOGIN = login_name,
			@BLOCKER_PROGRAM = program_name,
			@BLOCKER_HOSTNAME = host_name
			FROM   sys.dm_exec_sessions
			WHERE  session_id = @BLOCKER_SESSION_ID 

		END
		
--	-------------------------------------------------------------------------------------
--	Determine User INformation 
--	-------------------------------------------------------------------------------------

			SELECT @BLOCKER_LOGIN = login_name,
				   @BLOCKER_PROGRAM = program_name,
				   @BLOCKER_HOSTNAME = host_name,
				   @BLOCKER_CONTEXT_INFO = context_info 
			FROM   sys.dm_exec_sessions
			WHERE  session_id = @BLOCKER_SESSION_ID

			SELECT @BLOCKED_LOGIN = login_name,
				   @BLOCKED_PROGRAM = program_name,
				   @BLOCKED_HOSTNAME = host_name,
				   @BLOCKED_CONTEXT_INFO = context_info
			FROM   sys.dm_exec_sessions
			WHERE  session_id = @BLOCKED_SESSION_ID 
			

			

		
--	-------------------------------------------------------------------------------------
--	Determine Object ID of lock request
--	-------------------------------------------------------------------------------------


	IF @LOCK_SIZE IN('Row','Key','Page')
		 BEGIN
			SET @SQL=	'USE ['+ @DATABASE_NAME + '] SELECT @OBJECT_NAME_OUT = OBJECT_NAME(object_id),@INDEX_ID_OUT = index_id, @rows_out = 0	FROM '+
						@DATABASE_NAME+
						'.sys.partitions PAR with (NOLOCK)  JOIN ' +@DATABASE_NAME+ + '.sys.sysobjects OBJ ON OBJ.ID = PAR.OBJECT_ID	WHERE partition_id = ' + cast(@ASSOCIATEDOBJECTID as varchar(MAX))
			SET	@PARM = '@OBJECT_NAME_OUT NVARCHAR(128) OUTPUT, @INDEX_ID_OUT INT OUTPUT,@rows_out bigint OUTPUT'

			EXEC sp_executesql	@SQL, 
								@PARM,
								@OBJECT_NAME_OUT    = @OBJECT_NAME OUTPUT,
								@INDEX_ID_OUT = @INDEX_ID OUTPUT,
								@rows_out = @rows OUTPUT
								
								--print @SQL
		END
	ELSE
		BEGIN
			SET @SQL=	'USE ['+ @DATABASE_NAME + '] SELECT @OBJECT_NAME_OUT  = name,@INDEX_ID_OUT = 0, @rows_out = 0	FROM '+
						@DATABASE_NAME+
						'.sys.objects with (NOLOCK)	WHERE object_id = '+ cast(@ASSOCIATEDOBJECTID as varchar(MAX))
			SET	@PARM = '@OBJECT_NAME_OUT NVARCHAR(128) OUTPUT, @INDEX_ID_OUT INT OUTPUT, @rows_out BIGINT OUTPUT'

			EXEC sp_executesql	@SQL, 
								@PARM,
								@OBJECT_NAME_OUT    = @OBJECT_NAME OUTPUT,
								@INDEX_ID_OUT		= @INDEX_ID OUTPUT,
								@rows_out = @rows OUTPUT
		END
		
		--print @SQL
--	-------------------------------------------------------------------------------------

		INSERT INTO @BLOCKED VALUES (
			@BLOCKER_LOGIN			,
			@BLOCKER_PROGRAM		,
			@BLOCKER_HOSTNAME		,
			@BLOCKED_LOGIN			,
			@BLOCKED_PROGRAM		,
			@BLOCKED_HOSTNAME		,
			@BLOCKER_SESSION_ID		,
			@BLOCKER_CONTEXT_INFO   ,
			@BLOCKER_CONTEXT		,
			@BLOCKER_TRAN_ISOLATION	,
			@BLOCKER_STATUS			,
			@BLOCKED_SESSION_ID		,
			@BLOCKED_CONTEXT_INFO   ,
			@BLOCKED_CONTEXT		,
			@BLOCKED_TRAN_ISOLATION	,
			@TRANSACTION_ID			,
			@WAITTIME				,
			@LOCK_MODE				,
			@LOCK_SIZE				,
			@DATABASE_NAME			,
			@OBJECT_NAME			,
			@INDEX_ID				,
			@BLOCKER_SQL			,
			@BLOCKER_PLAN			,
			@BLOCKED_SQL			,
			@BLOCKED_PLAN			)

	FETCH BLOCKED INTO 
		@BLOCKER_SESSION_ID		,
		@BLOCKED_SESSION_ID		,
		@BLOCKED_CONTEXT		, 
		@BLOCKED_TRAN_ISOLATION		,
		@WAITTIME				,
		@LOCK_MODE				,
		@LOCK_SIZE				,
		@DATABASE_NAME			,
		@ASSOCIATEDOBJECTID		,
		@BLOCKED_SQL			,
		@BLOCKED_PLAN			,
		@TRANSACTION_ID	
			
	END

DEALLOCATE BLOCKED;

--print @ASSOCIATEDOBJECTID


SELECT 
	GETDATE() AS BLOCKED_DTTM,
	BLOCKER_LOGIN			,
	BLOCKER_PROGRAM		,
	BLOCKER_HOSTNAME		,
	BLOCKED_LOGIN			,
	BLOCKED_PROGRAM		,
	BLOCKED_HOSTNAME		,
	BLOCKER_SESSION_ID		,
	BLOCKER_CONTEXT_INFO	,
	BLOCKER_CONTEXT	=
		CASE
				WHEN BLOCKER_CURSORS.properties IS NULL THEN BLOCKER_CONTEXT
				ELSE BLOCKER_CURSORS.properties+'; Dormant for '+ltrim(str(BLOCKER_CURSORS.dormant_duration))+' milleseconds'+BLOCKER_CONTEXT
		END,
	BLOCKER_TRAN_ISOLATION	,
	BLOCKER_STATUS			,
	BLOCKED_SESSION_ID		,
	BLOCKED_CONTEXT_INFO	,
	BLOCKED_CONTEXT			=
		CASE
				WHEN BLOCKED_CURSORS.properties IS NULL THEN BLOCKED_CONTEXT
				ELSE BLOCKED_CURSORS.properties+'; Dormant for '+ltrim(str(BLOCKED_CURSORS.dormant_duration))+' milleseconds'+BLOCKED_CONTEXT
		END,
	BLOCKED_TRAN_ISOLATION	,
	TRANSACTION_ID			,
	WAIT_TIME				,
	LOCK_MODE				,
	LOCK_SIZE				,
	DATABASE_NAME			,
	ALLOW_SNAPSHOT_ISOLATION = snapshot_isolation_state_desc,
	READ_COMMITTED_SNAPSHOT = 
		CASE is_read_committed_snapshot_on
			WHEN 0 THEN 'OFF'
			WHEN 1 THEN 'ON'
		END,
	OBJECT_NAME				,
	INDEX_ID				,
	BLOCKER_SQL = CASE
				WHEN BLOCKER_SQL LIKE 'FETCH API_CURSOR%' THEN isnull( BLOCKER_CURSORSQL.text, BLOCKER_SQL)
				WHEN BLOCKER_SQL IS NULL THEN BLOCKER_CURSORSQL.text
				ELSE BLOCKER_SQL
			END,
	BLOCKER_PLAN = CASE
				WHEN BLOCKER_SQL LIKE 'FETCH API_CURSOR%' THEN isnull (BLOCKER_CURSORPLAN.query_plan, BLOCKER_PLAN)
				WHEN BLOCKER_SQL IS NULL THEN BLOCKER_CURSORPLAN.query_plan
				ELSE BLOCKER_PLAN	
			END	,
	BLOCKED_SQL = CASE
				WHEN BLOCKED_SQL LIKE 'FETCH API_CURSOR%' THEN isnull('Cursor: '+BLOCKED_CURSORSQL.text, BLOCKED_SQL)
				ELSE	BLOCKED_SQL
			END,
	BLOCKED_PLAN = CASE
				WHEN BLOCKED_SQL LIKE 'FETCH API_CURSOR%' THEN isnull(BLOCKED_CURSORPLAN.query_plan, BLOCKED_PLAN)
				ELSE BLOCKED_PLAN	
			END
FROM	@BLOCKED
JOIN	sys.databases ON name = DATABASE_NAME COLLATE database_default
--	-------------------------------------------------------------------------------------
--	Special Handling for Cursors
--	If the blocking process is a cursor, get SQL text via  sys.dm_exec_cursors.sql_handle
--	and the query plan via sys.dm_exec_query_stats.plan_handle
--	-------------------------------------------------------------------------------------
OUTER APPLY		sys.dm_exec_cursors(BLOCKER_SESSION_ID) AS BLOCKER_CURSORS 

OUTER APPLY		sys.dm_exec_sql_text(BLOCKER_CURSORS.sql_handle) AS BLOCKER_CURSORSQL
LEFT JOIN		sys.dm_exec_query_stats AS BLOCKER_CURSORSTATS ON BLOCKER_CURSORSTATS.sql_handle = BLOCKER_CURSORS.sql_handle
OUTER APPLY		sys.dm_exec_query_plan(BLOCKER_CURSORSTATS.plan_handle) AS BLOCKER_CURSORPLAN
--	-------------------------------------------------------------------------------------
--	Special Handling for Cursors
--	If the blocked process is a cursor, get SQL text via  sys.dm_exec_cursors.sql_handle
--	and the query plan via sys.dm_exec_query_stats.plan_handle
--	-------------------------------------------------------------------------------------
OUTER APPLY		sys.dm_exec_cursors(BLOCKED_SESSION_ID) AS BLOCKED_CURSORS

OUTER APPLY		sys.dm_exec_sql_text(BLOCKED_CURSORS.sql_handle) AS BLOCKED_CURSORSQL
LEFT JOIN		sys.dm_exec_query_stats AS BLOCKED_CURSORSTATS ON BLOCKED_CURSORSTATS.sql_handle = BLOCKED_CURSORS.sql_handle
OUTER APPLY		sys.dm_exec_query_plan(BLOCKED_CURSORSTATS.plan_handle) AS BLOCKED_CURSORPLAN
--WHERE BLOCKER_CURSORS.is_open = 1
--AND		BLOCKED_CURSORS.is_open = 1
ORDER BY WAIT_TIME DESC
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_CHANGE_TRACKING]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_CHANGE_TRACKING (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CT_SYSDATABASES')
  EXEC ('DROP SYNONYM [dbo].DYN_CT_SYSDATABASES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_CT_SYSDATABASES
				FOR [' + @SERVER_NAME + '].master.sys.databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CT_SYSDATABASES
				FOR master.sys.databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CT_CT_DB')
  EXEC ('DROP SYNONYM [dbo].DYN_CT_CT_DB')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_CT_CT_DB
				FOR [' + @SERVER_NAME + '].master.sys.change_tracking_databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CT_CT_DB
				FOR master.sys.change_tracking_databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL)  

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CT_SYSOBJECTS')
  EXEC ('DROP SYNONYM [dbo].DYN_CT_SYSOBJECTS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CT_SYSOBJECTS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.objects'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CT_SYSOBJECTS
				FOR [' + @DATABASE_NAME + '].sys.objects'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CT_TRACKING_TABLES')
  EXEC ('DROP SYNONYM [dbo].DYN_CT_TRACKING_TABLES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CT_TRACKING_TABLES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.change_tracking_tables'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CT_TRACKING_TABLES
				FOR [' + @DATABASE_NAME + '].sys.change_tracking_tables'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

DELETE FROM DynamicsPerf..SQL_CHANGETRACKING_DBS WHERE SERVER_NAME = @SERVER_NAME
DELETE FROM DynamicsPerf..SQL_CHANGETRACKING_TABLES WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME

IF @AZURE_DB = 0
BEGIN

INSERT DynamicsPerf..SQL_CHANGETRACKING_DBS
SELECT @SERVER_NAME,d.name,d.database_id,ct.is_auto_cleanup_on,ct.max_cleanup_version,ct.retention_period,ct.retention_period_units,ct.retention_period_units_desc
FROM   DYN_CT_CT_DB ct
       INNER JOIN DYN_CT_SYSDATABASES d
               ON ct.database_id = d.database_id 
               
               INSERT DynamicsPerf..SQL_CHANGETRACKING_TABLES
SELECT @SERVER_NAME, @DATABASE_NAME,o.name,o.[object_id],ct.is_track_columns_updated_on,ct.min_valid_version,ct.begin_version,ct.cleanup_version
FROM   DYN_CT_TRACKING_TABLES ct
       INNER JOIN DYN_CT_SYSOBJECTS o
               ON ct.object_id = o.object_id 
END

IF @AZURE_DB = 1
BEGIN




		SET @SQL2 = ' 
						  SET QUOTED_IDENTIFIER OFF
						  	INSERT DynamicsPerf.dbo.SQL_CHANGETRACKING_DBS
			
					SELECT ' + '''' + @SERVER_NAME + '''' + 
					', * FROM OPENQUERY(['+@SERVER_NAME+ '],"


		SELECT d.name,d.database_id,ct.is_auto_cleanup_on,ct.max_cleanup_version,ct.retention_period,ct.retention_period_units,ct.retention_period_units_desc
			   FROM   sys.change_tracking_databases ct
       INNER JOIN sys.databases d
               ON ct.database_id = d.database_id ")'

			
		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL2
			 END

		EXEC (@SQL2) 


				SET @SQL2 = ' 
						  SET QUOTED_IDENTIFIER OFF
						  	INSERT DynamicsPerf.dbo.SQL_CHANGETRACKING_DBS
			
					SELECT ' + '''' + @SERVER_NAME + '''' + ','+  '''' + @DATABASE_NAME + '''' + 
					', * FROM OPENQUERY(['+@SERVER_NAME+ '],"


		SELECT o.name,o.[object_id],ct.is_track_columns_updated_on,ct.min_valid_version,ct.begin_version,ct.cleanup_version
			   FROM   sys.change_tracking_tables ct
       INNER JOIN sys.objects o
              ON ct.object_id = o.object_id ")'

			
		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL2
			 END

		EXEC (@SQL2) 

END
             
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_DATABASE_REPLICATION_INFO]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_DATABASE_REPLICATION_INFO (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @RC INT
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DRI_SYSDATABASES')
  EXEC ('DROP SYNONYM [dbo].DYN_DRI_SYSDATABASES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSDATABASES
				FOR [' + @SERVER_NAME + '].master.sys.databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSDATABASES
				FOR master.sys.databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 



--REH validate publication is on for this database otherwise bailout
SELECT @RC = is_published FROM DYN_DRI_SYSDATABASES WHERE name = @DATABASE_NAME
IF @RC<> 1 RETURN(0)





IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DRI_SYSSERVERS')
  EXEC('DROP SYNONYM [dbo].DYN_DRI_SYSSERVERS')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSSERVERS
				FOR [' + @SERVER_NAME + '].master.dbo.sysservers'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSSERVERS
				FOR master.dbo.sysservers'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DRI_SYSPUBLICATIONS')
  EXEC ('DROP SYNONYM [dbo].DYN_DRI_SYSPUBLICATIONS')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSPUBLICATIONS
				FOR [' + @SERVER_NAME + '].['+@DATABASE_NAME + '].dbo.syspublications'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSPUBLICATIONS
				FOR ['+@DATABASE_NAME + '].dbo.syspublications'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DRI_SYSARTICLES')
  EXEC ('DROP SYNONYM [dbo].DYN_DRI_SYSARTICLES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSARTICLES
				FOR [' + @SERVER_NAME + '].['+@DATABASE_NAME + '].dbo.sysarticles'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSARTICLES
				FOR ['+@DATABASE_NAME + '].dbo.sysarticles'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DRI_SYSSUBSCRIPTIONS')
  EXEC ('DROP SYNONYM [dbo].DYN_DRI_SYSSUBSCRIPTIONS')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSSUBSCRIPTIONS
				FOR [' + @SERVER_NAME + '].['+@DATABASE_NAME + '].dbo.syssubscriptions'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSSUBSCRIPTIONS
				FOR ['+@DATABASE_NAME + '].dbo.syssubscriptions'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



SELECT @RC = is_published FROM DYN_DRI_SYSDATABASES WHERE name = @DATABASE_NAME

IF @RC = 1
BEGIN


INSERT INTO SQL_REPLICATION
SELECT  @SERVER_NAME,@STATS_DATE,@DATABASE_NAME,
db_name() PUBLISHER_DB 
, sp.name as PUBLISHER_NAME 
, sa.name as TABLE_NAME 
, UPPER(srv.srvname) as SUBSCRIBER_SERVER_NAME 
from DYN_DRI_SYSPUBLICATIONS sp  
join DYN_DRI_SYSARTICLES sa on sp.pubid = sa.pubid 
join DYN_DRI_SYSSUBSCRIPTIONS s on sa.artid = s.artid 
join DYN_DRI_SYSSERVERS srv on s.srvid = srv.srvid 


END


 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_PERF_COUNTERS_AZURE]...';


GO
CREATE PROCEDURE [dbo].[DYNPERF_COLLECT_PERF_COUNTERS_AZURE]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30), @START_POS INT, @END_POS INT
    DECLARE @INSTANCE_NAME NVARCHAR(128)
    
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF @AZURE_DB = 0 RETURN(0)  --REH THIS SPROC IS MEANT FOR AZURE ONLY


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CPC_PERF_COUNTERS')
  EXEC ('DROP SYNONYM [dbo].DYN_CPC_PERF_COUNTERS')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_CPC_PERF_COUNTERS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.dm_os_performance_counters '
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CPC_PERF_COUNTERS
				FOR master.sys.dm_os_performance_counters '

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 




/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

		--SET @END_POS = LEN(@SERVER_NAME)
		--SET @START_POS = CHARINDEX('\', @SERVER_NAME,1)+1
		--IF @START_POS > 0
		--BEGIN
		--	SET @INSTANCE_NAME = 'MSSQL$' + SUBSTRING(@SERVER_NAME, @START_POS, @END_POS) + ':'
		--END
		--ELSE
		--BEGIN
		--	SET @INSTANCE_NAME = 'SQLServer:'
		--END
		
		

INSERT PERF_COUNTER_DATA
SELECT @SERVER_NAME,
       @STATS_DATE,
       PTC.OBJECT_NAME,
       PTC.COUNTER_NAME,
       PTC.INSTANCE_NAME,
       DPC.cntr_value,
       DPC.cntr_type
FROM   PERF_COUNTER_2_COLLECT PTC 
        JOIN DYN_CPC_PERF_COUNTERS as DPC
               ON DPC.counter_name = PTC.COUNTER_NAME
                  AND PTC.INSTANCE_NAME = DPC.instance_name
                  AND  DPC.object_name   LIKE '%' + PTC.OBJECT_NAME + '%'



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_PERF_COUNTERS]...';


GO
CREATE PROCEDURE [dbo].[DYNPERF_COLLECT_PERF_COUNTERS]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30), @START_POS INT, @END_POS INT
    DECLARE @INSTANCE_NAME NVARCHAR(128)
    
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CPC_PERF_COUNTERS')
  EXEC ('DROP SYNONYM [dbo].DYN_CPC_PERF_COUNTERS')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_CPC_PERF_COUNTERS
				FOR [' + @SERVER_NAME + '].master.sys.dm_os_performance_counters '
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CPC_PERF_COUNTERS
				FOR master.sys.dm_os_performance_counters '

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 




/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

		--SET @END_POS = LEN(@SERVER_NAME)
		--SET @START_POS = CHARINDEX('\', @SERVER_NAME,1)+1
		--IF @START_POS > 0
		--BEGIN
		--	SET @INSTANCE_NAME = 'MSSQL$' + SUBSTRING(@SERVER_NAME, @START_POS, @END_POS) + ':'
		--END
		--ELSE
		--BEGIN
		--	SET @INSTANCE_NAME = 'SQLServer:'
		--END
		
		

INSERT PERF_COUNTER_DATA
SELECT @SERVER_NAME,
       @STATS_DATE,
       PTC.OBJECT_NAME,
       PTC.COUNTER_NAME,
       PTC.INSTANCE_NAME,
       DPC.cntr_value,
       DPC.cntr_type
FROM   PERF_COUNTER_2_COLLECT PTC 
        JOIN DYN_CPC_PERF_COUNTERS as DPC
               ON DPC.counter_name = PTC.COUNTER_NAME
                  AND PTC.INSTANCE_NAME = DPC.instance_name
                  AND  DPC.object_name   LIKE '%' + PTC.OBJECT_NAME + '%'



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_PROCESS_QUERY_ALERTS]...';


GO
CREATE PROCEDURE [dbo].[DYNPERF_PROCESS_QUERY_ALERTS]
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @PCT_AVG_TIME_CHANGE_DAY int, @PCT_AVG_TIME_CHANGE_MONTH INT
	DECLARE @MIN_EXECUTION_COUNTS INT, @MIN_AVG_TIME_MS INT
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




SELECT @PCT_AVG_TIME_CHANGE_DAY = PCT_AVG_TIME_CHANGE_DAY,
       @PCT_AVG_TIME_CHANGE_MONTH = PCT_AVG_TIME_CHANGE_MONTH,
       @MIN_EXECUTION_COUNTS = MIN_EXECUTION_COUNTS,
       @MIN_AVG_TIME_MS = MIN_AVG_TIME_MS
FROM   QUERY_ALERTS_CONFIG
WHERE  SERVER_NAME = @SERVER_NAME
       AND DATABASE_NAME = @DATABASE_NAME 


--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
  --REH in this case, we are going to compare to STATS_TIME which is the DynamicsPerf Time Zone so convert last_run back into that time

     SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset

  END 


  IF @PCT_AVG_TIME_CHANGE_DAY IS NULL RETURN(0)  --REH No settings for this server/db just return and do nothing

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH SAME QUERY_HASH/PLAN_HASH , true parm sniffing query issue

INSERT QUERY_ALERTS
SELECT DISTINCT QS_CTE.SERVER_NAME,
       QS_CTE.STATS_TIME,
       QS_CTE.DATABASE_NAME,
       QS_CTE.QUERY_HASH,
       QS_CTE.QUERY_PLAN_HASH
FROM    (SELECT SERVER_NAME,
					   DATABASE_NAME,
					   STATS_TIME,
					   QUERY_HASH,
					   QUERY_PLAN_HASH,
					   SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                               AS TOTAL_TIME_MS,
					   SUM(EXECUTIONS_THIS_PERIOD)                                                            AS TOTAL_EXECUTIONS,
					   CASE SUM(EXECUTIONS_THIS_PERIOD)
						 WHEN 0 THEN 0
						 ELSE ( SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3))) / SUM(EXECUTIONS_THIS_PERIOD) )
					   END                                                                                    AS AVG_TIME_MS,
					   SUM(CAST(WORKER_TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                        AS WORK_TIME,
					   SUM(CAST(( TIME_THIS_PERIOD - WORKER_TIME_THIS_PERIOD ) / 1000.000 AS DECIMAL(14, 3))) AS WAIT_TIME
			FROM   QUERY_STATS_CTE_VW CTE WITH (NOLOCK)
			WHERE  
				--QS.SERVER_NAME = CTE.SERVER_NAME AND QS.DATABASE_NAME=CTE.DATABASE_NAME AND
				--QS.STATS_TIME = CTE.STATS_TIME 
				--AND QS.QUERY_HASH = CTE.QUERY_HASH AND QS.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH AND
				 CTE.DATABASE_NAME = @DATABASE_NAME AND CTE.SERVER_NAME = @SERVER_NAME
				AND CTE.STATS_TIME > @LAST_RUN

			GROUP  BY SERVER_NAME,
						DATABASE_NAME,
				         STATS_TIME,
						QUERY_HASH,
						QUERY_PLAN_HASH) AS QS_CTE

       INNER JOIN QUERY_HISTORY QHD 
               ON QHD.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHD.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHD.QUERY_HASH = QS_CTE.QUERY_HASH
                  AND QHD.QUERY_PLAN_HASH = QS_CTE.QUERY_PLAN_HASH
                  AND QHD.FLAG = 'D'
                  AND QHD.DATE = DATEADD(DAY, DATEDIFF(DAY, 0, QS_CTE.STATS_TIME), 0)
       INNER JOIN QUERY_HISTORY QHM
               ON QHM.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHM.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHM.QUERY_HASH = QS_CTE.QUERY_HASH
                  AND QHM.QUERY_PLAN_HASH = QS_CTE.QUERY_PLAN_HASH
                  AND QHM.FLAG = 'M'
                  AND QHM.DATE = DATEADD(MONTH, DATEDIFF(MONTH, 0, QS_CTE.STATS_TIME), 0)
WHERE  QS_CTE.SERVER_NAME = @SERVER_NAME
       AND QS_CTE.DATABASE_NAME = @DATABASE_NAME
       AND QS_CTE.STATS_TIME > @LAST_RUN
       AND ( ( QS_CTE.AVG_TIME_MS  > QHD.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_DAY/100
                OR QS_CTE.AVG_TIME_MS   > QHM.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_MONTH/100 )
             AND QS_CTE.AVG_TIME_MS   > @MIN_AVG_TIME_MS
             AND QS_CTE.TOTAL_EXECUTIONS > @MIN_EXECUTION_COUNTS ) 
			 option (maxdop 1)
--REH any variation 
INSERT QUERY_ALERTS
SELECT DISTINCT QS_CTE.SERVER_NAME,
       QS_CTE.STATS_TIME,
       QS_CTE.DATABASE_NAME,
       QS_CTE.QUERY_HASH,
       QS_CTE.QUERY_PLAN_HASH
FROM    (SELECT TOP 100 SERVER_NAME,
					   DATABASE_NAME,
					   STATS_TIME,
					   QUERY_HASH,
					   QUERY_PLAN_HASH,
					   SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                               AS TOTAL_TIME_MS,
					   SUM(EXECUTIONS_THIS_PERIOD)                                                            AS TOTAL_EXECUTIONS,
					   CASE SUM(EXECUTIONS_THIS_PERIOD)
						 WHEN 0 THEN 0
						 ELSE ( SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3))) / SUM(EXECUTIONS_THIS_PERIOD) )
					   END                                                                                    AS AVG_TIME_MS,
					   SUM(CAST(WORKER_TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                        AS WORK_TIME,
					   SUM(CAST(( TIME_THIS_PERIOD - WORKER_TIME_THIS_PERIOD ) / 1000.000 AS DECIMAL(14, 3))) AS WAIT_TIME
			FROM   QUERY_STATS_CTE_VW CTE WITH (NOLOCK)
			WHERE  
				--QS.SERVER_NAME = CTE.SERVER_NAME AND QS.DATABASE_NAME=CTE.DATABASE_NAME AND
				--QS.STATS_TIME = CTE.STATS_TIME 
				--AND QS.QUERY_HASH = CTE.QUERY_HASH AND QS.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH AND
				 CTE.DATABASE_NAME = @DATABASE_NAME AND CTE.SERVER_NAME = @SERVER_NAME
				AND CTE.STATS_TIME > @LAST_RUN

			GROUP  BY SERVER_NAME,
						DATABASE_NAME,
				         STATS_TIME,
						QUERY_HASH,
						QUERY_PLAN_HASH) AS QS_CTE

       CROSS APPLY (SELECT SERVER_NAME, DATABASE_NAME, QUERY_HASH, MAX(QHD.AVG_TIME_TODAY_MS) AS AVG_TIME_TODAY_MS
				FROM  QUERY_HISTORY QHD
               WHERE QHD.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHD.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHD.QUERY_HASH = QS_CTE.QUERY_HASH
				  AND QHD.QUERY_PLAN_HASH <> QS_CTE.QUERY_PLAN_HASH
                  AND QHD.FLAG = 'D'
                  AND QHD.DATE = DATEADD(DAY, DATEDIFF(DAY, 0, QS_CTE.STATS_TIME), 0)
				  GROUP BY SERVER_NAME, DATABASE_NAME, QUERY_HASH
				  ) AS QHDAILY
       CROSS APPLY ( SELECT SERVER_NAME, DATABASE_NAME, QUERY_HASH, MAX(QHM.AVG_TIME_TODAY_MS) AS AVG_TIME_TODAY_MS
				FROM  QUERY_HISTORY QHM
               WHERE QHM.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHM.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHM.QUERY_HASH = QS_CTE.QUERY_HASH
				  AND QHM.QUERY_PLAN_HASH <> QS_CTE.QUERY_PLAN_HASH
                  AND QHM.FLAG = 'M'
                  AND QHM.DATE = DATEADD(MONTH, DATEDIFF(MONTH, 0, QS_CTE.STATS_TIME), 0)
				  GROUP BY SERVER_NAME, DATABASE_NAME, QUERY_HASH
				  ) AS QHMONTHLY
WHERE  QS_CTE.SERVER_NAME = @SERVER_NAME
       AND QS_CTE.DATABASE_NAME = @DATABASE_NAME
       AND QS_CTE.STATS_TIME > @LAST_RUN
       AND ( ( QS_CTE.AVG_TIME_MS  > QHDAILY.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_DAY/100
                OR QS_CTE.AVG_TIME_MS   > QHMONTHLY.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_MONTH/100 )
             AND QS_CTE.AVG_TIME_MS   > @MIN_AVG_TIME_MS
             AND QS_CTE.TOTAL_EXECUTIONS > @MIN_EXECUTION_COUNTS ) 
option (maxdop 1)



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_SET_AX_SQLTRACE]...';


GO
CREATE PROCEDURE [dbo].[DYNPERF_SET_AX_SQLTRACE]
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @AX_TRACE_ON BIT, @SQL_DURATION INT, @AXDB_DELETION_DAYS INT=0
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SETAXSQLTRACE')
  EXEC ('DROP SYNONYM [dbo].DYN_SETAXSQLTRACE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SETAXSQLTRACE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXSTOR_AX_SQLSTORAGE
				FOR [' + @DATABASE_NAME + '].dbo.USERINFO'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AX_SYSTRACETABLESQL')
  EXEC ('DROP SYNONYM [dbo].DYN_AX_SYSTRACETABLESQL')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLESQL
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLESQL
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AX_SYSTRACETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AX_SYSTRACETABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLE
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AX_SYSTRACETABLESQLEXECPLAN')
  EXEC ('DROP SYNONYM [dbo].DYN_AX_SYSTRACETABLESQLEXECPLAN')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLESQLEXECPLAN
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQLEXECPLAN'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLESQLEXECPLAN
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQLEXECPLAN'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AX_SYSTRACETABLESQLTABREF')
  EXEC ('DROP SYNONYM [dbo].DYN_AX_SYSTRACETABLESQLTABREF')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLESQLTABREF
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQLTABREF'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLESQLTABREF
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQLTABREF'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

SELECT @AX_TRACE_ON = TRACE_ON, @SQL_DURATION = SQL_DURATION , @AXDB_DELETION_DAYS = AXDB_DELETION_DAYS
FROM AX_SQLTRACE_CONFIG 
WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME

IF @@ROWCOUNT = 0 GOTO ENDPROC

IF @AX_TRACE_ON = 1
BEGIN
		UPDATE DS
		SET    QUERYTIMELIMIT = @SQL_DURATION,
			   DEBUGINFO = 268,
			   TRACEINFO = 2048
		FROM   DYN_SETAXSQLTRACE DS 
			
END

IF @AX_TRACE_ON = 0 
BEGIN
		UPDATE DS
		SET    QUERYTIMELIMIT = 0,
				DEBUGINFO = 12,
				TRACEINFO = 0
		FROM   DYN_SETAXSQLTRACE DS 
		WHERE QUERYTIMELIMIT = 5000
END


IF @AXDB_DELETION_DAYS > 0
  BEGIN
      DELETE FROM DYN_AX_SYSTRACETABLE
      WHERE  CREATEDDATETIME <= DATEADD(DD, -14, GETDATE())

      DELETE FROM DYN_AX_SYSTRACETABLESQL
      WHERE  CREATEDDATETIME <= DATEADD(DD, -14, GETDATE())

      DELETE SP
      FROM   DYN_AX_SYSTRACETABLESQLEXECPLAN SP
      WHERE  NOT EXISTS (SELECT RECID
                         FROM   DYN_AX_SYSTRACETABLE ST
                         WHERE  ST.RECID = SP.TRACERECID)

      DELETE SF
      FROM   DYN_AX_SYSTRACETABLESQLTABREF SF
      WHERE  NOT EXISTS (SELECT RECID
                         FROM   DYN_AX_SYSTRACETABLE ST
                         WHERE  ST.RECID = SF.TRACERECID)
  END 


ENDPROC:

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_PROCESS_AXSQLTRACE]...';


GO
CREATE PROCEDURE [dbo].[DYNPERF_PROCESS_AXSQLTRACE]
		(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



UPDATE AST
SET    QUERY_HASH = COALESCE((SELECT TOP 1 QUERY_HASH
                     FROM   QUERY_TEXT QT WITH (NOLOCK)
                     WHERE  QT.SERVER_NAME = AST.SERVER_NAME
                            AND QT.DATABASE_NAME = AST.DATABASE_NAME
                            AND QT.SQL_TEXT LIKE REPLACE(AST.SQL_TEXT, '?', '%')), 0X00) --REH There could be several. We are only getting the first
FROM   AX_SQLTRACE AST
WHERE  SERVER_NAME = @SERVER_NAME
       AND DATABASE_NAME = @DATABASE_NAME
       AND AST.QUERY_HASH IS NULL 
	   AND LEN(AST.SQL_TEXT) < 4000 --REH LIKE command is limited to 8k characters

--UPDATE AST
--SET    QUERY_HASH = (SELECT TOP 1 QUERY_HASH
--                     FROM   QUERY_TEXT QT
--                     WHERE  QT.SERVER_NAME = AST.SERVER_NAME
--                            AND QT.DATABASE_NAME = AST.DATABASE_NAME
--                            AND QT.SQL_TEXT LIKE REPLACE(AST.SQL_TEXT, '?', '%')) --REH There could be several. We are only getting the first
--FROM   AX_SQLTRACE AST WITH (READPAST)
--WHERE  SERVER_NAME = @SERVER_NAME
--       AND DATABASE_NAME = @DATABASE_NAME
--       AND AST.QUERY_HASH IS NULL 
--	   AND LEN(AST.SQL_TEXT) <= 4000 --REH LIKE command is limited to 8k characters NVARCHAR 4k = 8k characters
--	   AND AST.CREATED_DATETIME > DATEADD(DD,CAST(@TASK_PARAMS as INT) * -1,@LAST_RUN)  --REH keep trying to parse queries for X days, based on @task_params


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_REFRESH_QUERY_TEXT]...';


GO
CREATE PROCEDURE [dbo].[DYNPERF_REFRESH_QUERY_TEXT]
 (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @REFRESH_PLAN_DAYS INT
    
/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


  SELECT @REFRESH_PLAN_DAYS = REFRESH_PLAN_DAYS FROM DATABASES_2_COLLECT WHERE LINKED_SERVER = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



IF @REMOTE_SERVER = 'N'
     BEGIN ;
         WITH Query_Stats_CTE ( QUERY_HASH)
              AS (SELECT  QUERY_HASH
                  FROM   QUERY_STATS QS WITH (NOLOCK)
                  WHERE  QS.STATS_TIME >= DATEADD(D,-1,GETDATE())
                         AND DATABASE_NAME = @DATABASE_NAME
                         AND SERVER_NAME = @SERVER_NAME 
						 AND QUERY_HASH > 0x0000000000
                         AND  EXISTS (SELECT 'X'
                                         FROM   QUERY_TEXT QT WITH (NOLOCK)
                                         WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                                AND QS.SERVER_NAME = QT.SERVER_NAME
												AND QT.DATE_UPDATED <= DATEADD(D,-@REFRESH_PLAN_DAYS,GETDATE() ) --REH ANY PLANS THAT HAVEN'T BEEN UPDATED IN THE LAST 7 DAYS
												 ))
    --     INSERT QUERY_TEXT
    --     SELECT @SERVER_NAME,
    --            @DATABASE_NAME,
    --            QUERY_HASH,
    --            SQL_TEXT,
				--@STATS_DATE
				
	UPDATE QT 
	SET SQL_TEXT = COALESCE(RH.SQL_TEXT, QT.SQL_TEXT), DATE_UPDATED = @STATS_DATE
         FROM   
         QUERY_TEXT QT INNER JOIN 
         (SELECT RN = ROW_NUMBER()
                               OVER (
                                 PARTITION BY CTE.QUERY_HASH
                                 ORDER BY CTE.QUERY_HASH DESC),
                        qs.query_hash                                                                                              AS QUERY_HASH,
                        SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                        WHEN -1 THEN DATALENGTH(st.text)
                                                                                        ELSE qs.statement_end_offset
                                                                                      END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
                 FROM   Query_Stats_CTE CTE
                        INNER JOIN sys.dm_exec_query_stats AS qs
                                ON CTE.QUERY_HASH = qs.query_hash
                        OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                        CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
                 WHERE  attribute = N'dbid'
                        AND DB_NAME(CONVERT(INT, value)) = @DATABASE_NAME
                        AND last_execution_time >= @LAST_RUN
						) AS RH ON RH.QUERY_HASH = QT.QUERY_HASH AND QT.SERVER_NAME = @SERVER_NAME AND QT.DATABASE_NAME = @DATABASE_NAME
         WHERE  RN = 1
     END 


 IF @REMOTE_SERVER = 'Y'
 BEGIN
 


				 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)



 SET @SQL = '
CREATE TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH
(
QUERY_HASH VARBINARY(64)
)' 



 SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  EXEC ('+'"' + @SQL +'"' + ') AT [' + @SERVER_NAME + ']'
  
 IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END

EXEC (@SQL2)


SET @SQL = '

;WITH Query_Stats_CTE ( QUERY_HASH)
     AS (SELECT  QUERY_HASH
         FROM   QUERY_STATS QS
         WHERE  QS.STATS_TIME >= DATEADD(D,-1, GETDATE()  )
                AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + '
                AND SERVER_NAME = ' + '''' + +@SERVER_NAME + '''' + ' 
				AND QUERY_HASH > 0x0000000000
                AND  EXISTS (SELECT ''X''
                                FROM   QUERY_TEXT QT WITH (NOLOCK)
                                WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                AND QS.SERVER_NAME = QT.SERVER_NAME 
								AND QT.DATE_UPDATED <= DATEADD(D,-'+CAST(@REFRESH_PLAN_DAYS AS VARCHAR(4))+',GETDATE() )
                                ))
INSERT INTO OPENQUERY([' + @SERVER_NAME + '], ''SELECT QUERY_HASH FROM  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH'')

SELECT QUERY_HASH
FROM   (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_HASH
                        ORDER BY CTE.QUERY_HASH DESC),
               QUERY_HASH 
            
            FROM   Query_Stats_CTE CTE
           ) AS RH
WHERE  RN = 1 '

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


EXEC (@SQL)


        
 SET @SQL = '
         SELECT QUERY_HASH, SQL_TEXT
         FROM (
         SELECT RN = ROW_NUMBER() OVER (PARTITION BY CTE.QUERY_HASH ORDER BY CTE.QUERY_HASH DESC),
          qs.query_hash AS QUERY_HASH,
                         SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                         WHEN -1 THEN DATALENGTH(st.text)
                                                                                         ELSE qs.statement_end_offset
                                                                                       END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
         FROM    [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH CTE
                INNER JOIN sys.dm_exec_query_stats AS qs
                        ON CTE.QUERY_HASH = qs.query_hash
                OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
         WHERE  attribute = N''dbid''
                AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
                ) AS RH  
                WHERE RN = 1 '
PRINT ''
PRINT ''
                  
IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  	UPDATE QT 
	SET SQL_TEXT = COALESCE(A.SQL_TEXT,QT.SQL_TEXT), DATE_UPDATED =' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' +
	' FROM QUERY_TEXT QT INNER JOIN  (' +
				 '  SELECT RH.* FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH
                    ) AS A ON A.QUERY_HASH = QT.QUERY_HASH AND QT.SERVER_NAME = ' +'''' + @SERVER_NAME + '''' +
                    '   AND QT.DATABASE_NAME = ' + '''' + @DATABASE_NAME +''''
                   


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END
				 
				 EXECUTE (@SQL2)
				 
 --REH  Delete the table back out
 
 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

 
 END
 
    

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)

	
         SET @SQL = '

				IF EXISTS (SELECT * FROM  [' + @DATABASE_NAME + '].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
				 DROP TABLE  [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 

			EXEC (@SQL2)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_SERVER_ACTIVITY]...';


GO
CREATE PROCEDURE [dbo].[DYNPERF_SERVER_ACTIVITY]
	(@SERVER_NAME NVARCHAR(128) = @@SERVERNAME)

AS

SET QUOTED_IDENTIFIER OFF
DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
 


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SERVER_ACTIVITY]') AND type in (N'U'))
DROP TABLE [dbo].[SERVER_ACTIVITY]



      
 SET @SQL = '
SELECT r.session_id                                     AS SPID,
       r.blocking_session_id                            AS BLOCKED_BY_SPID,
       se.host_name                                     AS HOSTNAME,
       se.login_name                                    AS LOGIN_NAME,
       DB_NAME(r.database_id)                           AS DATABASE_NAME,
       r.status                                         AS STATUS,
       r.command                                        AS COMMAND,
       r.cpu_time                                       AS CPU_TIME,
       r.total_elapsed_time                             AS TOTAL_ELAPSED_TIME,
       r.reads                                          AS READS,
       r.logical_reads                                  AS LOGICAL_READS,
       r.writes                                         AS WRITES,
       r.context_info                                   AS AX_SESSION_ID,
       r.context_info                                   AS AX_USER_ID,
       CAST(r.context_info AS VARCHAR(128))             AS CONTEXT_INFO,
       s.text                                           AS SQL_TEXT,
       CAST(p.query_plan AS NVARCHAR(MAX))              AS QUERY_PLAN,
       SQL_CURSORSQL.text                               AS CURSOR_SQL_TEXT,
       CAST(SQL_CURSORPLAN.query_plan AS NVARCHAR(MAX)) AS CURSOR_QUERY_PLAN,
       BLOCKING_DATA.ctext                              AS BLOCKING_TEXT,
       BLOCKING_DATA.BLOCKING_CONTEXT                   AS BLOCKING_CONTEXT,
       BLOCKING_DATA.BLOCKING_QUERY_PLAN                AS BLOCKING_QUERY_PLAN,
       BLOCKING_DATA.BLOCKING_CURSOR_PLAN               AS BLOCKING_CURSOR_PLAN,
       r.wait_time                                      AS WAIT_TIME,
       r.wait_type                                      AS WAIT_TYPE,
       r.open_transaction_count                         AS OPEN_TRANS_COUNT,
       r.estimated_completion_time                      AS ESTIMATED_COMPLETION_TIME,
       TSU.TEMPDBUSEROBJECTSALLOCATED                   AS TEMPDB_USER_OBJECTS_ALLOCATED,
       TSU.TEMPDBUSEROBJECTSDEALLOCATED                 AS TEMPDB_USER_OBJECTS_DEALLOCATED,
       TSU.TEMPDBINTERNALOBJECTSALLOCATED               AS TEMPDB_INTERNAL_OBJECTS_ALLOCATED,
       TSU.TEMPDBINTERNALOBJECTSDEALLOCATED             AS TEMPDB_INTERNAL_OBJECTS_DEALLOCATED'
         
         
SELECT @SQL = @SQL + '

FROM   sys.dm_exec_requests AS r
       INNER JOIN sys.dm_exec_sessions AS se
               ON r.session_id = se.session_id
       OUTER APPLY sys.DM_EXEC_SQL_TEXT(r.sql_handle) AS s
       OUTER APPLY sys.DM_EXEC_QUERY_PLAN(r.plan_handle) AS p
       OUTER APPLY sys.DM_EXEC_CURSORS(r.session_id) AS SQL_CURSORS
       OUTER APPLY sys.DM_EXEC_SQL_TEXT(SQL_CURSORS.sql_handle) AS SQL_CURSORSQL
       LEFT JOIN sys.dm_exec_query_stats AS SQL_CURSORSTATS
              ON SQL_CURSORSTATS.sql_handle = SQL_CURSORS.sql_handle
       OUTER APPLY sys.DM_EXEC_QUERY_PLAN(SQL_CURSORSTATS.plan_handle) AS SQL_CURSORPLAN
       OUTER APPLY (SELECT r.session_id,
                           CAST(r_blk.context_info AS VARCHAR(128))         AS BLOCKING_CONTEXT,
                           s.text,
                           SQL_CURSORSQL.text                               AS CTEXT,
                           CAST(SQL_CURSORPLAN.query_plan AS NVARCHAR(MAX)) AS BLOCKING_CURSOR_PLAN,
                           CAST(p.query_plan AS NVARCHAR(MAX))              AS BLOCKING_QUERY_PLAN
                    FROM   sys.dm_exec_requests AS r_blk
                           INNER JOIN sys.dm_exec_sessions AS se
                                   ON r.session_id = se.session_id
                           OUTER APPLY sys.DM_EXEC_SQL_TEXT(r.sql_handle) AS s
                           OUTER APPLY sys.DM_EXEC_QUERY_PLAN(r.plan_handle) AS p
                           OUTER APPLY sys.DM_EXEC_CURSORS(r.session_id) AS SQL_CURSORS
                           OUTER APPLY sys.DM_EXEC_SQL_TEXT(SQL_CURSORS.sql_handle) AS SQL_CURSORSQL
                           LEFT JOIN sys.dm_exec_query_stats AS SQL_CURSORSTATS
                                  ON SQL_CURSORSTATS.sql_handle = SQL_CURSORS.sql_handle
                           OUTER APPLY sys.DM_EXEC_QUERY_PLAN(SQL_CURSORSTATS.plan_handle) AS SQL_CURSORPLAN
                    WHERE  r_blk.session_id = r.blocking_session_id) AS BLOCKING_DATA
       LEFT JOIN (SELECT SESSIONID = session_id,
                         REQUESTID = request_id,
                         TEMPDBUSEROBJECTSALLOCATED = SUM (user_objects_alloc_page_count),
                         TEMPDBUSEROBJECTSDEALLOCATED = SUM(user_objects_dealloc_page_count),
                         TEMPDBINTERNALOBJECTSALLOCATED = SUM (internal_objects_alloc_page_count),
                         TEMPDBINTERNALOBJECTSDEALLOCATED = SUM (internal_objects_dealloc_page_count)
                  FROM   sys.dm_db_task_space_usage
                  GROUP  BY session_id,
                            request_id) AS TSU
              ON TSU.SESSIONID = r.session_id
                 AND TSU.REQUESTID = r.request_id
WHERE  r.session_Id > 50 AND r.session_id <> @@SPID
       AND se.host_name IS NOT NULL 			   
				   
				   '
                    

IF @SERVER_NAME <> @@SERVERNAME
BEGIN

                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF

				 SELECT RH.*
                    INTO SERVER_ACTIVITY
                     FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '


				 
				 EXECUTE (@SQL2)
END
ELSE
BEGIN

		SET @SQL2 = '
		SELECT RH.*
			INTO SERVER_ACTIVITY
				FROM (' +@SQL + ') RH'
		
	PRINT @SQL2
				EXECUTE (@SQL2)
END
SELECT [SPID],
       [BLOCKED_BY_SPID],
       [HOSTNAME],
       [LOGIN_NAME],
       [DATABASE_NAME],
       [STATUS],
       [COMMAND],
       [CPU_TIME],
       [TOTAL_ELAPSED_TIME],
       [READS],
       [LOGICAL_READS],
       [WRITES],
       dbo.FN_RETURN_AXSESSION_FROM_CONTEXT([AX_SESSION_ID]) AS AX_SESSION_ID,
       dbo.FN_RETURN_AXID_FROM_CONTEXT([AX_USER_ID])         AS AX_USER_ID,
       [CONTEXT_INFO],
       [SQL_TEXT],
       Cast([QUERY_PLAN] AS XML)                             AS QUERY_PLAN,
       [CURSOR_SQL_TEXT],
       Cast([CURSOR_QUERY_PLAN] AS XML)                      AS CURSOR_QUERY_PLAN,
       BLOCKING_TEXT,
       BLOCKING_CONTEXT,
       BLOCKING_QUERY_PLAN,
       BLOCKING_CURSOR_PLAN,
       [WAIT_TIME],
       [WAIT_TYPE],
       [OPEN_TRANS_COUNT],
       [ESTIMATED_COMPLETION_TIME],
       [TEMPDB_USER_OBJECTS_ALLOCATED],
       [TEMPDB_USER_OBJECTS_DEALLOCATED],
       [TEMPDB_INTERNAL_OBJECTS_ALLOCATED],
       [TEMPDB_INTERNAL_OBJECTS_DEALLOCATED]
FROM   [dbo].[SERVER_ACTIVITY]
ORDER  BY [TOTAL_ELAPSED_TIME] DESC 


DROP TABLE SERVER_ACTIVITY
GO
PRINT N'Creating [dbo].[DYNPERF_UPDATE_SSRS_HISTORY]...';


GO
CREATE PROCEDURE [dbo].[DYNPERF_UPDATE_SSRS_HISTORY]
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @ROW_COUNT BIGINT = 0
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH Deal with default instance

IF CHARINDEX(@SERVER_NAME, '\',0) =0
SET @SERVER_NAME = @SERVER_NAME + '\MSSQLSERVER'


/******************************************************************************
NEED TO SUBTRACT OUT PREVIOUS DAYS AMOUNTS IF COMPILE_TIME WAS BEFORE TODAY

SUBTRACT THE LAST QUERY_STATS RECORD FROM PREVIOUS DAY WITH SAME COMPILE_TIME


*******************************************************************************/
--REH This sums up to the totals of the day

MERGE SSRS_HISTORY AS target
		USING (
		SELECT SERVER_NAME,
       REPORTPATH,
       REPORTNAME                                      AS REPORT_NAME,
       MAX(DATEADD(DAY, DATEDIFF(DAY, 0, TIMEEND), 0)) AS REPORT_DATE,
       SUM([TIME_DATARETRIEVAL])                       AS TOTAL_TIME_DATA,
       SUM([TIME_PROCESSING])                          AS TOTAL_TIME_PROCESSING,
       SUM([TIME_RENDERING])                           AS TOTAL_TIME_RENDERING,
       MAX(TIME_DATARETRIEVAL + TIME_PROCESSING
           + TIME_RENDERING)                           AS MAX_REPORT_TIME_MS,
       MIN(TIME_DATARETRIEVAL + TIME_PROCESSING
           + TIME_RENDERING)                           AS MIN_REPORT_TIME_MS,
       COUNT(REPORTPATH)                               AS EXECUTION_COUNT,
       MAX(BYTECOUNT)                                  AS MAX_SIZE_BYTES,
       MAX([ROWCOUNT])                                 AS MAX_ROW_COUNT,
       MAX('D')                                        AS FLAG
FROM   SSRS_EXECUTIONLOG
WHERE SERVER_NAME = @SERVER_NAME AND DATEADD(DAY, DATEDIFF(DAY, 0, TIMEEND), 0) = DATEADD(DAY, DATEDIFF(DAY, 0, @LAST_RUN), 0)
GROUP  BY SERVER_NAME,
DATEADD(DAY, DATEDIFF(DAY, 0, TIMEEND), 0) ,
          REPORTPATH,
          REPORTNAME ) AS source
ON ( source.SERVER_NAME = target.SERVER_NAME
			 AND source.REPORTPATH = target.REPORTPATH
			 AND source.REPORT_NAME = target.REPORT_NAME
			 AND source.REPORT_DATE = target.REPORT_DATE
			 AND source.FLAG = target.FLAG )
		WHEN MATCHED THEN
		 UPDATE SET TOTAL_TIME_DATA = source.TOTAL_TIME_DATA,
					 TOTAL_TIME_PROCESSING = source.TOTAL_TIME_PROCESSING,
					 TOTAL_TIME_RENDERING = source.TOTAL_TIME_RENDERING,
					 MAX_REPORT_TIME_MS = source.MAX_REPORT_TIME_MS,
					 MIN_REPORT_TIME_MS = source.MIN_REPORT_TIME_MS,
					 EXECUTION_COUNT = source.EXECUTION_COUNT,
					 MAX_SIZE_BYTES = source.MAX_SIZE_BYTES,
					 MAX_ROW_COUNT = source.MAX_ROW_COUNT


		WHEN NOT MATCHED THEN
		  INSERT ([SERVER_NAME]
           ,[REPORTPATH]
           ,[REPORT_NAME]
           ,[REPORT_DATE]
           ,[TOTAL_TIME_DATA]
           ,[TOTAL_TIME_PROCESSING]
           ,[TOTAL_TIME_RENDERING]
           ,[MAX_REPORT_TIME_MS]
           ,[MIN_REPORT_TIME_MS]
           ,[EXECUTION_COUNT]
           ,[MAX_SIZE_BYTES]
           ,[MAX_ROW_COUNT]
           ,[FLAG])
		  VALUES (source.[SERVER_NAME]
           ,source.[REPORTPATH]
           ,source.[REPORT_NAME]
           ,source.[REPORT_DATE]
           ,source.[TOTAL_TIME_DATA]
           ,source.[TOTAL_TIME_PROCESSING]
           ,source.[TOTAL_TIME_RENDERING]
           ,source.[MAX_REPORT_TIME_MS]
           ,source.[MIN_REPORT_TIME_MS]
           ,source.[EXECUTION_COUNT]
           ,source.[MAX_SIZE_BYTES]
           ,source.[MAX_ROW_COUNT]
           ,source.[FLAG]);


		   SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

 --REH Rollup the daily total into the Monthly total


MERGE SSRS_HISTORY AS target
		USING (
		SELECT [SERVER_NAME]
           ,[REPORTPATH]
           ,[REPORT_NAME]
           ,DATEADD(MONTH, DATEDIFF(MONTH, 0, REPORT_DATE), 0) AS REPORT_DATE --REH floor the date to the month level
           ,SUM([TOTAL_TIME_DATA]) AS TOTAL_TIME_DATA
           ,SUM([TOTAL_TIME_PROCESSING]) AS TOTAL_TIME_PROCESSING
           ,SUM([TOTAL_TIME_RENDERING]) AS TOTAL_TIME_RENDERING
           ,MAX([MAX_REPORT_TIME_MS]) AS MAX_REPORT_TIME_MS
           ,MIN([MIN_REPORT_TIME_MS]) AS MIN_REPORT_TIME_MS
           ,SUM([EXECUTION_COUNT]) AS EXECUTION_COUNT
           ,MAX([MAX_SIZE_BYTES]) AS MAX_SIZE_BYTES
           ,MAX([MAX_ROW_COUNT]) AS MAX_ROW_COUNT
           ,'M' AS FLAG
FROM   SSRS_HISTORY
WHERE SERVER_NAME = @SERVER_NAME AND FLAG = 'D' -- ONLY sum up the Daily totals into the monthly totals
	AND DATEADD(MONTH, DATEDIFF(MONTH, 0, REPORT_DATE), 0) = DATEADD(MONTH, DATEDIFF(MONTH, 0, @LAST_RUN), 0) 
GROUP  BY SERVER_NAME,
DATEADD(MONTH, DATEDIFF(MONTH, 0, REPORT_DATE), 0) ,
          REPORTPATH,
          REPORT_NAME ) AS source
ON ( source.SERVER_NAME = target.SERVER_NAME
			 AND source.REPORTPATH = target.REPORTPATH
			 AND source.REPORT_NAME = target.REPORT_NAME
			 AND source.REPORT_DATE = target.REPORT_DATE
			 AND source.FLAG = target.FLAG )
		WHEN MATCHED THEN
		 UPDATE SET TOTAL_TIME_DATA = source.TOTAL_TIME_DATA,
					 TOTAL_TIME_PROCESSING = source.TOTAL_TIME_PROCESSING,
					 TOTAL_TIME_RENDERING = source.TOTAL_TIME_RENDERING,
					 MAX_REPORT_TIME_MS = source.MAX_REPORT_TIME_MS,
					 MIN_REPORT_TIME_MS = source.MIN_REPORT_TIME_MS,
					 EXECUTION_COUNT = source.EXECUTION_COUNT,
					 MAX_SIZE_BYTES = source.MAX_SIZE_BYTES,
					 MAX_ROW_COUNT = source.MAX_ROW_COUNT


		WHEN NOT MATCHED THEN
		  INSERT ([SERVER_NAME]
           ,[REPORTPATH]
           ,[REPORT_NAME]
           ,[REPORT_DATE]
           ,[TOTAL_TIME_DATA]
           ,[TOTAL_TIME_PROCESSING]
           ,[TOTAL_TIME_RENDERING]
           ,[MAX_REPORT_TIME_MS]
           ,[MIN_REPORT_TIME_MS]
           ,[EXECUTION_COUNT]
           ,[MAX_SIZE_BYTES]
           ,[MAX_ROW_COUNT]
           ,[FLAG])
		  VALUES (source.[SERVER_NAME]
           ,source.[REPORTPATH]
           ,source.[REPORT_NAME]
           ,source.[REPORT_DATE]
           ,source.[TOTAL_TIME_DATA]
           ,source.[TOTAL_TIME_PROCESSING]
           ,source.[TOTAL_TIME_RENDERING]
           ,source.[MAX_REPORT_TIME_MS]
           ,source.[MIN_REPORT_TIME_MS]
           ,source.[EXECUTION_COUNT]
           ,source.[MAX_SIZE_BYTES]
           ,source.[MAX_ROW_COUNT]
           ,source.[FLAG]);

		   SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[SP_PROCESS_STATS]...';


GO
CREATE PROCEDURE [dbo].[SP_PROCESS_STATS]
		@SERVER_NAME	NVARCHAR(128) = NULL,
		@DATABASE_NAME	NVARCHAR(128) = NULL ,
		@DYNAMICS_PRODUCT NVARCHAR(3)  = NULL,
		@TASK_TYPE		VARCHAR(50) = 'PROCESS',
		@AZURE_DB		BIT = 0,
		@TOP_ROWS		INT = 0,
		@TOP_COLUMN		NVARCHAR(128) = 'total_elapsed_time',
		@RUN_NAME		NVARCHAR(128) = NULL,
		@INDEX_PHYSICAL_STATS 	NCHAR(1)= 'N',
		@DEBUG			NVARCHAR(1)= 'N'

AS


SET NOCOUNT ON
SET DATEFORMAT MDY

DECLARE @STATS_DATE		DATETIME, 
		@SQL_VERSION	NVARCHAR(1000), 
		@DYNAMICS_VERSION NVARCHAR(MAX),
		@DATABASE_ID	INT,
		@RETURN_CODE	INT,
		@SQL			NVARCHAR(MAX),
		@RUN_DESCRIPTION NVARCHAR(1000),
		@SQL_TOP_CLAUSE	NVARCHAR(128),
		@SQL_ORDERBY_CLAUSE	NVARCHAR(128),
		@PARM			NVARCHAR(500),
		@SQL_SERVER_STARTTIME DATETIME,
		@RC INT,
		@TASK_PROCEDURE NVARCHAR(128),
		@TASK_PARAMETERS NVARCHAR(1024),
		@TASK_DESCRIPTION NVARCHAR(256),
		@LAST_SERVER_NAME NVARCHAR(128) = 'ZZZ',  --REH This is used to trigger inserting a new STATS_COLLECTION_SUMMARY record
		@LAST_DATABASE_NAME NVARCHAR(128) = 'ZZZ',
		@LAST_STATS_DATE DATETIME,
		@REMOTE_SERVER NVARCHAR(1) = 'N',
		@TASK_STARTTIME DATETIME,
		@TASK_ENDTIME DATETIME,
		@TASK_TIME BIGINT,
		@SQL_STARTTIME DATETIME,
		@SQL_BUILD NVARCHAR(20),
		@SQL2 NVARCHAR(MAX),
		@MANUAL_CAPTURE NVARCHAR(1) = 'N',
		@SQL_TZ_OFFSET INT,
		@DPA_TZ_OFFSET INT 

		
		
DECLARE
	@C_SERVER_NAME NVARCHAR(128),
	@C_DATABASE_NAME NVARCHAR(128),
	@C_TASK_ID INT,
	@C_TASK_PROCEDURE NVARCHAR(128),
	@C_TASK_PARAMS NVARCHAR(1024),
	@C_TASK_DESC NVARCHAR(256),
	@C_SERVER_LEVEL_TASK BIT,
	@C_AZURE_DB  BIT,
	@C_LAST_RUN DATETIME
	
		
--REH Time zone off set for the DynamicsPerf database at time of collection
		SET @DPA_TZ_OFFSET = DATEDIFF(MI,GETUTCDATE(),GETDATE())

	IF @DATABASE_NAME IS NOT NULL SET @MANUAL_CAPTURE = 'Y'

	SET @STATS_DATE = GETDATE()
--REH  Verify database exists if being manually passed, skip check if Azure DB, no access to sys.databases catalogue

IF ( @AZURE_DB = 0 and ( @SERVER_NAME IS NOT NULL
      OR @DATABASE_NAME IS NOT NULL ))
     BEGIN

	 
	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_QUERY_SYSDATABASES')

         IF @REMOTE_SERVER = 'Y'
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_PS_QUERY_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_PS_QUERY_SYSDATABASES
				FOR master.sys.databases'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END

         EXEC (@SQL) -- SELECT * FROM DYN_PS_QUERY_SYSDATABASES

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_PS_QUERY_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

         --REH Make sure there is a record in DATABASES_2_COLLECT or insert if new combination
         IF (SELECT COUNT(*)
             FROM   DATABASES_2_COLLECT
             WHERE  LINKED_SERVER = ISNULL(@SERVER_NAME, @@SERVERNAME)
                    AND DATABASE_NAME = @DATABASE_NAME) < 1
              BEGIN
                  INSERT DATABASES_2_COLLECT
                  VALUES(ISNULL(@SERVER_NAME,@@SERVERNAME),
                         @DATABASE_NAME,
                         ISNULL(@DYNAMICS_PRODUCT, 'ALL'),
                         0,
                         2,
                         24,
						 60,
						 2,
						 90,
						 7)
              END
     END 


	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END



---------------------------------------------------------------------------------------------
--
--  Insert Capture_log entry with paramater values used for the run
--
----------------------------------------------------------------------------------------------

INSERT CAPTURE_LOG  SELECT @TASK_TYPE, @STATS_DATE, 'SP_PROCESS_STATS PARMS PASSED @SERVER_NAME = ' + ISNULL(@SERVER_NAME,'NOT PASSED') + ' @DATABASE_NAME = ' + ISNULL(@DATABASE_NAME,'NOT PASSED') +  ' @DEBUG = ' + @DEBUG + '  ' + CHAR(10) + CHAR(13)



SET @RETURN_CODE = 0

DELETE FROM  COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH Default is 'COLLECT' for this sproc.  CAN'T TRUNCATE MULTIPLE SPROCS USING THIS TABLE




IF @DATABASE_NAME IS NULL  --REH AKA, not a manual capture
  BEGIN
      INSERT COLLECTIONDATABASES
      SELECT ISNULL(LINKED_SERVER, @@SERVERNAME),
             [DATABASE_NAME],
             [DYNAMICS_PRODUCT],
             [AZURE_DB],
             [ENABLED],
			 @TASK_TYPE
      FROM   DATABASES_2_COLLECT
      WHERE  ENABLED = 1 -- db must be enabled for autostats collection to work with it
  END
ELSE
  BEGIN   --REH  Insert DBname of the manual capture
      INSERT COLLECTIONDATABASES
      VALUES(ISNULL(@SERVER_NAME, @@SERVERNAME),
             @DATABASE_NAME,
             @DYNAMICS_PRODUCT,
             @AZURE_DB,
             1,
			 @TASK_TYPE)
  END 


--REH Insert any missing task history records in case it's a new database being collected, so we don't fail to capture against the db because of no records
-- yes, this is a cartesian join between these 2 tables

INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE	--REH default is 'PROCESS' in parm definition of this sproc
       AND NOT EXISTS (SELECT 'X'
                       FROM   DYNPERF_TASK_HISTORY DTH
                       WHERE  DTS.TASK_ID = DTH.TASK_ID
                              AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                              AND CD.DATABASE_NAME = DTH.DATABASE_NAME)
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 0 --REH Ok, to put 1 record per database in for DB type tasks


	   
--REH Need to insert 1 bogus record for each server level task, or the join on the cursor will fail

INSERT COLLECTIONDATABASES 
 SELECT	DISTINCT [LINKED_SERVER],
             'N/A',
            'ALL',
             [AZURE_DB],
             [ENABLED],
			 [TASK_TYPE]
FROM COLLECTIONDATABASES CD
WHERE DATABASE_NAME <> 'N/A'
AND TASK_TYPE = @TASK_TYPE
AND NOT EXISTS (SELECT 'X' FROM COLLECTIONDATABASES CD2 WHERE CD2.LINKED_SERVER = CD.LINKED_SERVER AND CD2.DATABASE_NAME = 'N/A')



--REH now lets insert server level tasks with a blank DB name so we only do them once per server
INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       'N/A',
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE  --REH default is 'COLLECT' in parm definition of this sproc
		AND CD.DATABASE_NAME <> 'N/A'
       AND NOT EXISTS (SELECT 'X'
                   FROM   DYNPERF_TASK_HISTORY DTH
                   WHERE  DTS.TASK_ID = DTH.TASK_ID
                          AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                          AND DTH.DATABASE_NAME = 'N/A') --REH making the db name = 'N/A' for server level tasks
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 1 





	IF @DEBUG = 'Y'
	BEGIN
		PRINT 'MANUAL_CAPTURE = ' + @MANUAL_CAPTURE
	END

	--REH Create here and truncate table in each loop
	 --  CREATE TABLE #SQL_INFO
  --   (
  --      SQL_STARTTIME DATETIME,
  --      SQL_BUILD NVARCHAR(20),
		--TZ_OFFSET INT
  --   )
   

/********************************************************************************
Rod Hansen

Added a trigger to DATABASES_2_COLLECT so that we always have a 
DYNPERF_TASK_HISTORY record for this code 

********************************************************************************/

DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT DISTINCT DTS.TASK_ID,
       CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_PROCEDURE,
       DTS.TASK_PARAMETERS,
       DTS.TASK_DESCRIPTION,
       DTS.SERVER_LEVEL_TASK,
       CD.AZURE_DB,
       ISNULL(DTH.LAST_RUN, '1/1/1900')
FROM   DynamicsPerf..[DYNPERF_TASK_SCHEDULER] DTS
       LEFT OUTER JOIN DynamicsPerf..[DYNPERF_TASK_HISTORY] DTH
                    ON DTH.TASK_ID = DTS.TASK_ID
       INNER JOIN DynamicsPerf..COLLECTIONDATABASES CD
               ON CD.DATABASE_NAME = DTH.DATABASE_NAME
                  AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
WHERE
  --REH Task is enabled
  DTS.ENABLED = 1
  AND
  --REH It's the correct task type C = COLLECTOR, P = PROCESS, M = MONITOR, ETC
  DTS.TASK_TYPE = @TASK_TYPE
  AND
  --REH database is enabled
  CD.ENABLED = 1
  AND
  --REH Azure_db, if Azure db, then task must support it
  ( CD.AZURE_DB = DTS.AZURE_DB_SUPPORTED
     OR CD.AZURE_DB = 0 )
  --REH Either its an Azure Task, all Azure tasks will run locally, so if task supports AZ and we pass 0, run it anyways
  AND ( DTS.AZURE_DB_SUPPORTED = @AZURE_DB
         OR ( DTS.AZURE_DB_SUPPORTED = 1
              AND @AZURE_DB = 0 ) )
  AND
  --REH it's either All products or matches the Dynamics Product
  ( DTS.DYNAMICS_PRODUCT = 'ALL'
     OR DTS.DYNAMICS_PRODUCT = CD.DYNAMICS_PRODUCT )
  AND
  --REH Scheduling options now
(
  --REH In the case of minutes or hous, we ignore schedule time and just figure out if it's time to run again
  ( @MANUAL_CAPTURE = 'Y'
     OR ( @MANUAL_CAPTURE = 'N'
          AND ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                  WHEN 'MI' THEN DATEADD(MINUTE, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                END ) <= GETDATE()
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'HH' THEN DATEADD(HOUR, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                --REH and it is on the hour
                AND ( ABS(DATEDIFF(MI, DATEADD(Hour, DATEDIFF(Hour, 0, GETDATE()), 0), GETDATE())) <= 1 ) )
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'DD' THEN DATEADD(DAY, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'WK' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'MM' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'QQ' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'YY' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                AND ( --REH TIME IS NULL SO IGNORE IT
                    COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) IS NULL
                     OR --REH Current time = Scheduled time 
                    ( SUBSTRING((SELECT REPLACE(CONVERT(VARCHAR(10), GETDATE(), 108), ':', '')), 1, 4) = (SELECT REPLICATE('0', 4 - LEN( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME)))
                                                                                                                 + CAST( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) AS VARCHAR(4))) ) ) )
         --REH and last_run < current time
         )--AND CONVERT(VARCHAR(10), LAST_RUN, 108) <= CONVERT(VARCHAR(10), Getdate(), 108) ) 
   )
)
ORDER  BY CD.LINKED_SERVER,
          CD.DATABASE_NAME,
          DTS.TASK_ID 



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

	SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                    WHEN @@SERVERNAME THEN 'N'
                    ELSE 'Y'
                    END

--Insert new STATS_COLLECTION_SUMMARY RECORD, we want 1 RUN_NAME per server not per database
IF @C_SERVER_NAME <> @LAST_SERVER_NAME OR @C_DATABASE_NAME <> @LAST_DATABASE_NAME
BEGIN
    SET @RUN_NAME = ISNULL(@C_SERVER_NAME, @@SERVERNAME)+ ' '
                    + CAST(@STATS_DATE AS VARCHAR(30))


TRUNCATE TABLE WRK_PS_SQL_INFO   

 DELETE FROM COLLECTIONDATABASES WHERE LINKED_SERVER = @LAST_SERVER_NAME AND DATABASE_NAME = @LAST_DATABASE_NAME AND TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
 
SELECT @SQL = 'SELECT create_date AS SQL_STARTTIME,
       CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))    AS SQL_BUILD,
	   DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
		FROM sys.databases WHERE name = ''TempDB'''

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


   SET NOCOUNT ON
 
IF @REMOTE_SERVER = 'N'
BEGIN
		   INSERT WRK_PS_SQL_INFO
		EXEC( @SQL)
END


 IF @REMOTE_SERVER = 'Y'
 BEGIN
			IF @C_AZURE_DB = 0
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT create_date AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROM sys.databases WHERE name = ''TempDB''"	)'
			END
			IF @C_AZURE_DB = 1
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT DATEADD(ms,AVG(-wait_time_ms), GETDATE()) AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROMsys.dm_os_wait_stats w WHEREwait_type
IN(''DIRTY_PAGE_POLL'',''HADR_FILESTREAM_IOMGR_IOCOMPLETION'',''LAZYWRITER_SLEEP'',''LOGMGR_QUEUE'',''REQUEST_FOR_DEADLOCK_SEARCH'',''XE_DISPATCHER_WAIT'',''XE_TIMER_EVENT'') "	)'
			END


				IF @DEBUG = 'Y'
                  BEGIN
                      PRINT '@SQL= ' + @SQL2
                  END 
                
			INSERT WRK_PS_SQL_INFO
				EXEC (@SQL2) 
 
 END
 
 SELECT @SQL_STARTTIME = SQL_STARTTIME, @SQL_BUILD = SQL_BUILD, @SQL_TZ_OFFSET = TZ_OFFSET FROM WRK_PS_SQL_INFO
 TRUNCATE TABLE WRK_PS_SQL_INFO  -- REH cleanout for next pass


  --REH NOT Collecting so don't need this code in this sproc


		--INSERT INTO [DynamicsPerf].[dbo].[STATS_COLLECTION_SUMMARY]
		--			([SERVER_NAME],
		--			 [STATS_TIME],
		--			 [RUN_NAME],
		--			 [DATABASE_NAME],
		--			 [SQL_VERSION],
		--			 [DYNAMICS_VERSION],
		--			 [RUN_DESCRIPTION],
		--			 [SQL_SERVER_STARTTIME],
		--			 [SQL_SERVER_TZ_OFFSET] ,
		--			 [DPA_TZ_OFFSET])
		--VALUES      (@C_SERVER_NAME,
		--			 @STATS_DATE,
		--			 @RUN_NAME,
		--			 @C_DATABASE_NAME,
		--			 @SQL_BUILD,--<SQL_VERSION>
		--			 '',--<DYNAMICS_VERSION>
		--			 '',--<RUN_DESCRIPTION>
		--			 @SQL_STARTTIME, -- <SQL_SERVER_STARTTIME>
		--			 @SQL_TZ_OFFSET,  -- Time Zone offset in minutes of database collected
		--			 @DPA_TZ_OFFSET  -- Time Zone of the DynamicsPerf database
		--			) 
				
END 

SET @LAST_SERVER_NAME = @C_SERVER_NAME
SET @LAST_DATABASE_NAME = @C_DATABASE_NAME


SET @REMOTE_SERVER = CASE @C_SERVER_NAME
                       WHEN @@SERVERNAME THEN 'N'
                       ELSE 'Y'
                     END 



--Create synonyms for the sproc

--IF  EXISTS (SELECT * FROM sys.synonyms WHERE name = 'DYN_PS_CAPTURE_SPROC')
--DROP SYNONYM [dbo].[DYN_PS_CAPTURE_SPROC]
--SET @SQL = '
--CREATE SYNONYM DYN_PS_CAPTURE_SPROC
--FOR [DynamicsPerf].dbo.[' + @C_TASK_PROCEDURE + ']'

--IF @DEBUG = 'Y' 
--BEGIN
--PRINT '@SQL= ' + @SQL
--END

--EXEC(@SQL) 

IF @DEBUG = 'Y' 
BEGIN
PRINT 'TASK ID = ' + CAST(@C_TASK_ID AS VARCHAR(10))
PRINT 'SERVER NAME = ' + @C_SERVER_NAME 
PRINT 'DATABASE NAME = ' + @C_DATABASE_NAME
PRINT 'TASK PARMS = ' + ISNULL(@C_TASK_PARAMS, '')
PRINT 'TASK DESC = ' + ISNULL(@C_TASK_DESC,'')
PRINT 'LAST RUN = ' + ISNULL(CAST(@C_LAST_RUN AS VARCHAR(30)),'')
PRINT 'RUN NAME = ' + ISNULL(@RUN_NAME,'')
PRINT 'STATS DATE = ' + CAST(@STATS_DATE AS VARCHAR(30))
PRINT 'REMNOTE SERVER FLAG = ' + ISNULL(@REMOTE_SERVER,'')
PRINT 'AZURE DB = ' + CAST(@C_AZURE_DB AS CHAR(1))


END
			
	

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@C_TASK_DESC, '') + CONVERT(VARCHAR, GETDATE(), 109)
PRINT ''


SET @TASK_STARTTIME = GETDATE()
SET @C_TASK_PARAMS = ISNULL(@C_TASK_PARAMS,'')


IF @DEBUG = 'Y'
BEGIN

	PRINT 'SERVER TIME ZONE OFFSET = ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
	PRINT 'AT LAST RUN  = ' + CAST(@C_LAST_RUN AS VARCHAR(30))

END

--REH Adjust the last_run time to UTC Time, the called sproc's will adjust it to local time unless we've never collected
IF @C_LAST_RUN > '1/1/1901'
BEGIN
SET @C_LAST_RUN = DATEADD(MI,@DPA_TZ_OFFSET *-1 ,@C_LAST_RUN)
END



IF @DEBUG = 'Y'
BEGIN
	PRINT 'AT LAST RUN TIME BEING PASSED TO SPROC ' + CAST(@C_LAST_RUN AS VARCHAR(30))
END

SELECT @SQL = 'EXEC ' + @C_TASK_PROCEDURE + '  @TASK_ID=' + CAST(@C_TASK_ID AS NVARCHAR(10)) + 
' ,@SERVER_NAME = ' + '''' +  @C_SERVER_NAME + '''' +
' ,@DATABASE_NAME = ' + '''' +  @C_DATABASE_NAME + '''' +
' ,@TASK_PARAMS = ' +  '''' +  @C_TASK_PARAMS + '''' +
' ,@TASK_DESC = ' + '''' +  @C_TASK_DESC + '''' +
' ,@LAST_RUN = ' + '''' + CONVERT(VARCHAR, @C_LAST_RUN, 109) + '''' +
' ,@RUN_NAME = ' + '''' +  @RUN_NAME + '''' +
' ,@STATS_DATE = ' + '''' + CONVERT(VARCHAR, @STATS_DATE, 109) + '''' +
' ,@REMOTE_SERVER = ' + '''' +  @REMOTE_SERVER + '''' +
' ,@AZURE_DB = ' + CAST(@C_AZURE_DB AS NVARCHAR(10)) + 
' ,@SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET AS NVARCHAR(10)) + 
' ,@DPA_TZ_OFFSET = ' + CAST(@DPA_TZ_OFFSET AS NVARCHAR(10)) + 


' ,@DEBUG = '  + '''' +  @DEBUG + ''''


UPDATE CAPTURE_LOG
SET    TEXT = TEXT  + CHAR(13) + CHAR(10) + '***** ' + @C_TASK_PROCEDURE
			+ CHAR(13) + CHAR(10)
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE



EXECUTE @RC = sp_executesql @SQL

   					  
SET @TASK_ENDTIME = GETDATE()

SET @TASK_TIME = DATEDIFF(ss,@TASK_STARTTIME, @TASK_ENDTIME)

  
--REH update last  [DYNPERF_TASK_HISTORY] IF THE TASK WAS SUCCESSFUL


  
 IF @RC = 0
      BEGIN
          PRINT ''
 
          PRINT 'SUCCESSFULLY CAPTURED '
                + ISNULL(@C_TASK_DESC, '') +  ' for SERVER
	'
              + ISNULL(@C_SERVER_NAME, '') + ' on database '
              + ISNULL(@C_DATABASE_NAME, '') + ' in ' + cast(@TASK_TIME AS VARCHAR(20)) + ' SECONDS '
 
       --REH if a manual capture don't update last run so we don't mess up the scheduling engine
				 IF @MANUAL_CAPTURE = 'N'
				 BEGIN
						  MERGE DynamicsPerf..[DYNPERF_TASK_HISTORY] AS target
						  USING (SELECT @C_SERVER_NAME   AS SERVER_NAME,
										@C_DATABASE_NAME AS DATABASE_NAME,
										@C_TASK_ID       AS TASK_ID,
										@STATS_DATE      AS LAST_RUN,
										@TASK_TIME	AS LAST_EXECUTION_TIME_SECS 
												) AS source
						  ON ( source.SERVER_NAME = target.LINKEDSERVER_NAME
							   AND source.DATABASE_NAME = target.DATABASE_NAME
							   AND source.TASK_ID = target.TASK_ID )
						  WHEN MATCHED THEN
							UPDATE SET LAST_RUN = source.LAST_RUN, [LAST_EXECUTION_TIME_SECS] = source.[LAST_EXECUTION_TIME_SECS]
						  WHEN NOT MATCHED THEN
							INSERT ( [LINKEDSERVER_NAME],
									 [DATABASE_NAME],
									 [TASK_ID],
									 [LAST_RUN],
									 [LAST_EXECUTION_TIME_SECS])
							VALUES (source.SERVER_NAME,
									source.DATABASE_NAME,
									source.TASK_ID,
									source.LAST_RUN,
									source.LAST_EXECUTION_TIME_SECS );
				END
      END
 ELSE
	IF @RC = 1  --REH SPROC HANDLED THE ERROR
      BEGIN
          PRINT ''
 
          PRINT 'FAILED !!!!!! ' + ISNULL(@C_TASK_DESC, '')
 
          PRINT ''
      END 
 

 
 

           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_QUERY_SYSDATABASES')

  
END TRY 

BEGIN CATCH


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PROCEDURE FAILED !!! '
              + ISNULL(@C_TASK_DESC, 'TASK') + ' for SERVER
	'
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) + ', '
WHERE  STATS_TIME = @STATS_DATE  AND TASK_TYPE = @TASK_TYPE

PRINT 'ERROR WHILE COLLECTING ' + ISNULL(@C_TASK_DESC, '') +' !!!!!!!!!!!!!!'


           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_QUERY_SYSDATABASES')


END CATCH



FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
 DELETE FROM COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
 
			

ENDPROC:
PRINT 'RUN NAME = '+ @RUN_NAME
GO
PRINT N'Creating [dbo].[DYNPERF_PURGE_DATA]...';


GO
CREATE PROCEDURE [dbo].[DYNPERF_PURGE_DATA]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


SET NOCOUNT ON
SET DATEFORMAT MDY
DECLARE @PURGE_DATE smalldatetime, @PURGE_DAYS INT, @SQL NVARCHAR(MAX), @ROW_COUNT BIGINT = 0


DECLARE  @C_TABLE_NAME NVARCHAR(128), @C_TIME_COLUMN NVARCHAR(128), @C_SERVER_FLAG BIT, @C_DATABASE_FLAG BIT, @C_PURGE_DAYS INT
DECLARE @DC_SERVER_NAME NVARCHAR(128), @DC_DATABASE_NAME NVARCHAR(128), @DC_HISTORY_MONTHS INT, @DC_HISTORY_DAYS INT, @DC_DETAILS_DAYS INT






/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''




DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT TABLE_NAME, TIME_COLUMN, SERVER_NAME_FLAG, DATABASE_NAME_FLAG, RETENTION_DAYS
FROM   DynamicsPerf..[DYNPERF_PURGETABLES] WHERE TIME_COLUMN > ''  ---REH Ignore tables without some form of time column.  The collection sproc will handle deletion of data in those tables
ORDER BY RETENTION_DAYS, TABLE_NAME    --REH this sort is to force QUERY_STATS to delete before QUERY_PLANS/QUERY_TEXT so we don't wait a day to delete records not attached to data



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TABLE_NAME, @C_TIME_COLUMN, @C_SERVER_FLAG, @C_DATABASE_FLAG, @C_PURGE_DAYS


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */



	SET @PURGE_DAYS = @C_PURGE_DAYS * -1  --set to negative so we go back in time not forward in time
	SET @PURGE_DATE = DATEADD(DD,@PURGE_DAYS,GETDATE())



	UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PURGING TABLE ' + ISNULL(@C_TABLE_NAME, 'TABLE ')
              + ' using PURGE_DAYS ' + CAST(@PURGE_DAYS AS VARCHAR(10)) + ' on DATE '
              + CONVERT(VARCHAR, @PURGE_DATE, 109) + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




IF @C_TABLE_NAME IN ('QUERY_PLANS', 'QUERY_TEXT')  --REH Use special handling for QUERY_PLANS and QUERY_TEXT TABLE delete based on no dependent records
BEGIN
--REH All associated records in other tables must be deleted first, QUERY_STATS, QUERY_HISTORY, ETC

		IF @C_TABLE_NAME = 'QUERY_PLANS'

			DELETE QP FROM QUERY_PLANS QP WHERE QP.SERVER_NAME = @SERVER_NAME AND
			 NOT EXISTS (SELECT QS.QUERY_PLAN_HASH FROM QUERY_STATS QS WHERE QS.DATABASE_NAME = QP.DATABASE_NAME AND QS.SERVER_NAME = QP.SERVER_NAME AND QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH) 
				AND NOT EXISTS (SELECT QUERY_PLAN_HASH FROM QUERY_HISTORY QH WHERE QH.DATABASE_NAME = QP.DATABASE_NAME AND QH.SERVER_NAME = QP.SERVER_NAME AND QP.QUERY_PLAN_HASH = QH.QUERY_PLAN_HASH) 
				
				SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

	   IF @C_TABLE_NAME = 'QUERY_TEXT'
			DELETE QT FROM QUERY_TEXT QT WHERE QT.SERVER_NAME = @SERVER_NAME AND
			 NOT EXISTS (SELECT QS.QUERY_HASH FROM QUERY_STATS QS WHERE QS.DATABASE_NAME = QT.DATABASE_NAME AND QS.SERVER_NAME = QT.SERVER_NAME AND QT.QUERY_HASH = QS.QUERY_HASH) 
				AND NOT EXISTS (SELECT QUERY_HASH FROM QUERY_HISTORY QH WHERE QH.DATABASE_NAME = QT.DATABASE_NAME AND QH.SERVER_NAME = QT.SERVER_NAME AND QT.QUERY_HASH = QH.QUERY_HASH) 

				SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

END
ELSE
IF @C_TABLE_NAME IN ('QUERY_STATS', 'INDEX_DETAIL')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE

		BEGIN

				IF @C_TABLE_NAME = 'QUERY_STATS'
					DELETE QS FROM QUERY_STATS QS INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE QS.SERVER_NAME = @SERVER_NAME AND QS.STATS_TIME < DATEADD(D,DC.RETAIN_DETAILS_DAYS * -1, GETDATE())

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

				IF @C_TABLE_NAME = 'INDEX_DETAIL'
					DELETE ID FROM INDEX_DETAIL ID INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.STATS_TIME < DATEADD(D,DC.RETAIN_DETAILS_DAYS * -1, GETDATE())

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
		
				
		END

ELSE
IF @C_TABLE_NAME IN ('CAPTURE_LOG')


	BEGIN

	
	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE  ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

	END
ELSE

IF @C_TABLE_NAME IN ('INDEX_HISTORY', 'QUERY_HISTORY')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE

		BEGIN

				IF @C_TABLE_NAME = 'QUERY_HISTORY'
				BEGIN
					--REH DELETE MONTHLY QUERY TOTALS 
					DELETE QS FROM QUERY_HISTORY QS INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE  QS.SERVER_NAME = @SERVER_NAME AND QS.DATE < DATEADD(MM,DC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) AND QS.FLAG = 'M'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



					--REH DELETE DAYS TOTALS FROM QUERY_HISTORY		
					DELETE QS FROM QUERY_HISTORY QS INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE  QS.SERVER_NAME = @SERVER_NAME AND QS.DATE < DATEADD(MM,DC.RETAIN_HISTORY_DAYS * -1, GETDATE()) AND QS.FLAG = 'D'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

											--REH STALE QUERY delete

							;WITH CTE_HIST (SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, MAX_DATE)
								 AS (SELECT SERVER_NAME,
											DATABASE_NAME,
											QUERY_HASH,
											QUERY_PLAN_HASH,
											MAX(DATE)
									 FROM   QUERY_HISTORY
									 GROUP  BY SERVER_NAME,
											   DATABASE_NAME,
											   QUERY_HASH,
											   QUERY_PLAN_HASH)
							DELETE QS
							FROM   QUERY_HISTORY QS
								   INNER JOIN DATABASES_2_COLLECT DC
										   ON QS.SERVER_NAME = DC.LINKED_SERVER
											  AND QS.DATABASE_NAME = DC.DATABASE_NAME
								   INNER JOIN CTE_HIST CTE
										   ON CTE.SERVER_NAME = QS.SERVER_NAME
											  AND CTE.DATABASE_NAME = QS.DATABASE_NAME
											  AND CTE.QUERY_HASH = QS.QUERY_HASH
											  AND CTE.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
							WHERE  QS.SERVER_NAME = @SERVER_NAME
								   AND CTE.MAX_DATE < DATEADD(MM, DC.PURGE_STALE_QUERIES_DAYS * -1, GETDATE()) 


						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

				END

				IF @C_TABLE_NAME = 'INDEX_HISTORY'
				BEGIN
					DELETE ID FROM INDEX_HISTORY ID INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.DATE < DATEADD(MM,DC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) AND ID.FLAG = 'M'

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

					DELETE ID FROM INDEX_HISTORY ID INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.DATE < DATEADD(MM,DC.RETAIN_HISTORY_DAYS * -1, GETDATE()) AND ID.FLAG = 'D'

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

				END	
			
		END

ELSE

IF @C_TABLE_NAME IN ('SSRS_EXECUTIONLOG', 'SSRS_HISTORY')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE
BEGIN
	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
END


ELSE

BEGIN



	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE SERVER_NAME =  ' + ''''+ @SERVER_NAME + '''' + ' AND ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

END




FETCH NEXT FROM TASK_CURSOR INTO @C_TABLE_NAME, @C_TIME_COLUMN, @C_SERVER_FLAG, @C_DATABASE_FLAG, @C_PURGE_DAYS


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
	


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Deleted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_UPDATE_INDEX_HISTORY]...';


GO
CREATE PROCEDURE [dbo].[DYNPERF_UPDATE_INDEX_HISTORY]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @ROW_COUNT BIGINT = 0
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


  --REH need to figure out if it's midnight DB time for DB being rolled up
  --	Take stats_time which is time at DPA server and convert it to local time of the DB

  DECLARE @SERVER_TIME SMALLDATETIME, @SERVER_TIME_MIDNIGHT SMALLDATETIME, @TIME_DIFF INT, @SERVER_TIME_START SMALLDATETIME, @PREV_DAY SMALLDATETIME


   SET @SERVER_TIME = DATEADD(MI,@SQL_TZ_OFFSET,DATEADD(MI,@DPA_TZ_OFFSET*-1,@STATS_DATE))
  SET @SERVER_TIME_MIDNIGHT = (SELECT dateadd(DAY,datediff(DAY,-1,@SERVER_TIME),0))  --REH MIDNIGHT, NEXT DAY, SO HAVE TO BE LESS THAN THIS VALUE FOR TODAY
  SET @SERVER_TIME_START = (SELECT dateadd(DAY,datediff(DAY,0,@SERVER_TIME),0))  --REH MIDNIGHT, NEXT DAY, SO HAVE TO BE LESS THAN THIS VALUE FOR TODAY
  SET @PREV_DAY = DATEADD(DD,-1, @SERVER_TIME_START)
  SET @TIME_DIFF = DATEDIFF(MI, @SERVER_TIME, @SERVER_TIME_MIDNIGHT)


  UPDATE CAPTURE_LOG
SET    TEXT = TEXT + '  CURRENT SERVER TIME ' + CAST( @SERVER_TIME AS VARCHAR(50))
              + '  MIDNIGHT SERVER TIME ' + CAST(@SERVER_TIME_MIDNIGHT AS VARCHAR(50))
              + '  START OF TODAY ' + CAST(@SERVER_TIME_START AS VARCHAR(50))
              +'  FLOORED PREVIOUS DAY ' + CAST(@PREV_DAY AS VARCHAR(50))
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




  --REH Giving a 5 minute leaway after midnight to run this code, job will be scheduled to run hourly
 -- IF ABS(@TIME_DIFF)> 5  RETURN(0) ;  -- If it's not midnight Server time ont he DB being rolled up, then do nothing

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



/******************************************************************************
NEED TO SUBTRACT OUT PREVIOUS DAYS AMOUNTS IF COMPILE_TIME WAS BEFORE TODAY

SUBTRACT THE LAST QUERY_STATS RECORD FROM PREVIOUS DAY WITH SAME COMPILE_TIME


*******************************************************************************/



		--REH This sums up to the totals of the day
		MERGE INDEX_HISTORY AS target
		USING (SELECT T1.SERVER_NAME,
					  T1.DATABASE_NAME,
					  T1.DDATE                                                                AS [DATE],
					  T1.TABLE_NAME,
					  T1.INDEX_NAME,
					  MAX(T1.INDEX_DESCRIPTION)                                               AS INDEX_DESCRIPTION,
					  MAX(T1.INDEX_KEYS)                                                      AS INDEX_KEYS,
					  MAX(T1.DATA_COMPRESSION)                                                AS COMPRESSION_TYPE,
					  SUM(T1.USER_SEEKS - COALESCE(T2.USER_SEEKS, 0))                         AS USER_SEEKS_DELTA,
					  SUM(T1.USER_SCANS - COALESCE(T2.USER_SCANS, 0))                         AS USER_SCANS_DELTA,
					  SUM(T1.USER_LOOKUPS - COALESCE(T2.USER_LOOKUPS, 0))                     AS USER_LOOKUPS_DELTA,
					  SUM(T1.USER_UPDATES - COALESCE(T2.USER_UPDATES, 0))                     AS USER_UPDATES_DELTA,
					  SUM(T1.RANGE_SCAN_COUNT - COALESCE(T2.RANGE_SCAN_COUNT, 0))             AS RANGE_SCAN_COUNT_DELTA,
					  SUM(T1.PAGE_COUNT - COALESCE(T2.PAGE_COUNT, 0))                         AS PAGE_COUNT_DELTA,
					  SUM(T1.ROW_COUNT - COALESCE(T2.ROW_COUNT, 0))                           AS ROW_COUNT_DELTA,
					  MAX(T1.ROW_COUNT)                                                       AS ROW_COUNT,
					  MAX(T1.PAGE_COUNT)                                                      AS PAGE_COUNT,
					  SUM(T1.SINGLETON_LOOKUP_COUNT - COALESCE(T2.SINGLETON_LOOKUP_COUNT, 0)) AS SINGLETON_LOOKUP_COUNT,
					  MAX('D')                                                                AS FLAG --REH Mark the record as a DAILY record
			   FROM   (
					  --REH is meant to be run once per day at midnight
					  SELECT SERVER_NAME,
							 DATABASE_NAME,
							 SQL_SERVER_STARTTIME,
							 TABLE_NAME,
							 INDEX_NAME,
							 MAX(@SERVER_TIME_START)     AS DDATE,
							 MAX(INDEX_DESCRIPTION)      AS INDEX_DESCRIPTION,
							 MAX(INDEX_KEYS)             AS INDEX_KEYS,
							 MAX(DATA_COMPRESSION)       AS DATA_COMPRESSION,
							 MAX(USER_SEEKS)             AS USER_SEEKS,
							 MAX(USER_SCANS)             AS USER_SCANS,
							 MAX(USER_LOOKUPS)           AS USER_LOOKUPS,
							 MAX(USER_UPDATES)           AS USER_UPDATES,
							 MAX(RANGE_SCAN_COUNT)       AS RANGE_SCAN_COUNT,
							 MAX(PAGE_COUNT)             AS PAGE_COUNT,
							 MAX(ROW_COUNT)              AS ROW_COUNT,
							 MAX(SINGLETON_LOOKUP_COUNT) AS SINGLETON_LOOKUP_COUNT
					   FROM   INDEX_STATS_VW
					   --REH STATS_TIME IS Dynperf local time, convert it to UTC TIME then convert it to local time for the server
					   WHERE  DATEADD(MI, @SQL_TZ_OFFSET, DATEADD(MI, @DPA_TZ_OFFSET * -1, STATS_TIME)) >= @SERVER_TIME_START --REH 12AM THIS MORNING
							  AND DATEADD(MI, @SQL_TZ_OFFSET, DATEADD(MI, @DPA_TZ_OFFSET * -1, STATS_TIME)) < @SERVER_TIME_MIDNIGHT --REH LESS THEN 12M NEXT DAY
							  AND SERVER_NAME = @SERVER_NAME
					   GROUP  BY SERVER_NAME,
								 DATABASE_NAME,
								 SQL_SERVER_STARTTIME,
								 TABLE_NAME,
								 INDEX_NAME) AS T1
					  LEFT JOIN (
								--REH This gives us the previous record when we rolled up the last time
								SELECT SERVER_NAME,
									   DATABASE_NAME,
									   SQL_SERVER_STARTTIME,
									   TABLE_NAME,
									   INDEX_NAME,
									   MAX(DATEADD(DAY, DATEDIFF(DAY, 0, STATS_TIME), 0)) AS DDATE,
									   MAX(INDEX_DESCRIPTION)                             AS INDEX_DESCRIPTION,
									   MAX(INDEX_KEYS)                                    AS INDEX_KEYS,
									   MAX(DATA_COMPRESSION)                              AS DATA_COMPRESSION,
									   MAX(USER_SEEKS)                                    AS USER_SEEKS,
									   MAX(USER_SCANS)                                    AS USER_SCANS,
									   MAX(USER_LOOKUPS)                                  AS USER_LOOKUPS,
									   MAX(USER_UPDATES)                                  AS USER_UPDATES,
									   MAX(RANGE_SCAN_COUNT)                              AS RANGE_SCAN_COUNT,
									   MAX(PAGE_COUNT)                                    AS PAGE_COUNT,
									   MAX(ROW_COUNT)                                     AS ROW_COUNT,
									   MAX(SINGLETON_LOOKUP_COUNT)                        AS SINGLETON_LOOKUP_COUNT
								 FROM   INDEX_STATS_VW
								 WHERE  DATEADD(DAY, DATEDIFF(DAY, 0, DATEADD(MI, @SQL_TZ_OFFSET, DATEADD(MI, @DPA_TZ_OFFSET * -1, STATS_TIME))), 0) = @PREV_DAY --REH SUBTRACT TOTAL FROM PREV DAY , FLOORING THE STATS TIME HERE TO STRIP OUT TIME
										AND SERVER_NAME = @SERVER_NAME
								 GROUP  BY SERVER_NAME,
										   DATABASE_NAME,
										   SQL_SERVER_STARTTIME,
										   TABLE_NAME,
										   INDEX_NAME) AS T2
							 ON T1.SERVER_NAME = T2.SERVER_NAME
								AND T1.DATABASE_NAME = T2.DATABASE_NAME
								AND T1.SQL_SERVER_STARTTIME = T2.SQL_SERVER_STARTTIME
								AND T1.TABLE_NAME = T2.TABLE_NAME
								AND T1.INDEX_NAME = T2.INDEX_NAME --REH sql_server_starttime is how we are linking to the stats for the same compiled query
			   GROUP  BY T1.SERVER_NAME,
						 T1.DATABASE_NAME,
						 T1.DDATE,
						 T1.TABLE_NAME,
						 T1.INDEX_NAME) AS source
		ON ( source.SERVER_NAME = target.SERVER_NAME
			 AND source.DATABASE_NAME = target.DATABASE_NAME
			 AND source.DATE = target.DATE
			 AND source.TABLE_NAME = target.TABLE_NAME
			 AND source.INDEX_NAME = target.INDEX_NAME
			 AND source.FLAG = target.FLAG )
		WHEN MATCHED THEN
		  UPDATE SET COMPRESSION_TYPE = source.COMPRESSION_TYPE,
					 USER_SEEKS_DELTA = source.USER_SEEKS_DELTA,
					 USER_SCANS_DELTA = source.USER_SCANS_DELTA,
					 USER_LOOKUPS_DELTA = source.USER_LOOKUPS_DELTA,
					 USER_UPDATES_DELTA = source.USER_UPDATES_DELTA,
					 RANGE_SCAN_COUNT_DELTA = source.RANGE_SCAN_COUNT_DELTA,
					 PAGE_COUNT_DELTA = source.PAGE_COUNT_DELTA,
					 ROW_COUNT_DELTA = source.ROW_COUNT_DELTA,
					 ROW_COUNT = source.ROW_COUNT,
					 PAGE_COUNT = source.PAGE_COUNT,
					 SINGLETON_LOOKUP_COUNT = source.SINGLETON_LOOKUP_COUNT
		WHEN NOT MATCHED THEN
		  INSERT ( [SERVER_NAME],
				   [DATABASE_NAME],
				   [DATE],
				   [TABLE_NAME],
				   [INDEX_NAME],
				   [INDEX_DESCRIPTION],
				   [INDEX_KEYS],
				   [COMPRESSION_TYPE],
				   [USER_SEEKS_DELTA],
				   [USER_SCANS_DELTA],
				   [USER_LOOKUPS_DELTA],
				   [USER_UPDATES_DELTA],
				   [RANGE_SCAN_COUNT_DELTA],
				   [PAGE_COUNT_DELTA],
				   [ROW_COUNT_DELTA],
				   [ROW_COUNT],
				   [PAGE_COUNT],
				   [SINGLETON_LOOKUP_COUNT],
				   [FLAG] )
		  VALUES (source.[SERVER_NAME],
				  source.[DATABASE_NAME],
				  source.[DATE],
				  source.[TABLE_NAME],
				  source.[INDEX_NAME],
				  source.[INDEX_DESCRIPTION],
				  source.[INDEX_KEYS],
				  source.[COMPRESSION_TYPE],
				  source.[USER_SEEKS_DELTA],
				  source.[USER_SCANS_DELTA],
				  source.[USER_LOOKUPS_DELTA],
				  source.[USER_UPDATES_DELTA],
				  source.[RANGE_SCAN_COUNT_DELTA],
				  source.[PAGE_COUNT_DELTA],
				  source.[ROW_COUNT_DELTA],
				  source.[ROW_COUNT],
				  source.[PAGE_COUNT],
				  source.[SINGLETON_LOOKUP_COUNT],
				  'D'); 


				  SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT


 --REH Rollup the daily total into the Monthly total
			 MERGE INDEX_HISTORY AS target
			USING (SELECT [SERVER_NAME],
						  [DATABASE_NAME],
						  DATEADD(MONTH, DATEDIFF(MONTH, 0, [DATE]), 0) AS MDATE,
						  [TABLE_NAME]                                  AS TABLE_NAME,
						  [INDEX_NAME]                                  AS INDEX_NAME,
						  MAX(INDEX_DESCRIPTION)                        AS INDEX_DESCRIPTION,
						  MAX(INDEX_KEYS)                               AS INDEX_KEYS,
						  MAX(COMPRESSION_TYPE)                         AS COMPRESSION_TYPE,
						  MAX(USER_SEEKS_DELTA)                         AS USER_SEEKS_DELTA,
						  MAX(USER_SCANS_DELTA)                         AS USER_SCANS_DELTA,
						  MAX(USER_LOOKUPS_DELTA)                       AS USER_LOOKUPS_DELTA,
						  MAX(USER_UPDATES_DELTA)                       AS USER_UPDATES_DELTA,
						  MAX(RANGE_SCAN_COUNT_DELTA)                   AS RANGE_SCAN_COUNT_DELTA,
						  MAX(PAGE_COUNT_DELTA)                         AS PAGE_COUNT_DELTA,
						  MAX(ROW_COUNT_DELTA)                          AS ROW_COUNT_DELTA,
						  MAX(ROW_COUNT)                                AS ROW_COUNT,
						  MAX(PAGE_COUNT)                               AS PAGE_COUNT,
						  MAX(SINGLETON_LOOKUP_COUNT)                   AS SINGLETON_LOOKUP_COUNT,
						  'M'                                           AS FLAG
				   FROM   [dbo].[INDEX_HISTORY]
				   WHERE  FLAG = 'D'
				   AND DATEADD(MONTH, DATEDIFF(MONTH, 0, [DATE]), 0) >= DATEADD(MONTH, DATEDIFF(MONTH, 0, @SERVER_TIME_START), 0) --REH Prevent us from rolling up old months, possibly changing totals
						  AND SERVER_NAME = @SERVER_NAME
				   GROUP  BY SERVER_NAME,
							 DATABASE_NAME,
							 DATEADD(MONTH, DATEDIFF(MONTH, 0, [DATE]), 0),
							 TABLE_NAME,
							 INDEX_NAME) AS source
			ON ( source.SERVER_NAME = target.SERVER_NAME
				 AND source.DATABASE_NAME = target.DATABASE_NAME
				 AND source.MDATE = target.DATE
				 AND source.TABLE_NAME = target.TABLE_NAME
				 AND source.INDEX_NAME = target.INDEX_NAME
				 AND source.FLAG = target.FLAG )
			WHEN MATCHED THEN
			  UPDATE SET COMPRESSION_TYPE = source.COMPRESSION_TYPE,
						 USER_SEEKS_DELTA = source.USER_SEEKS_DELTA,
						 USER_SCANS_DELTA = source.USER_SCANS_DELTA,
						 USER_LOOKUPS_DELTA = source.USER_LOOKUPS_DELTA,
						 USER_UPDATES_DELTA = source.USER_UPDATES_DELTA,
						 RANGE_SCAN_COUNT_DELTA = source.RANGE_SCAN_COUNT_DELTA,
						 PAGE_COUNT_DELTA = source.PAGE_COUNT_DELTA,
						 ROW_COUNT_DELTA = source.ROW_COUNT_DELTA,
						 ROW_COUNT = source.ROW_COUNT,
						 PAGE_COUNT = source.PAGE_COUNT,
						 SINGLETON_LOOKUP_COUNT = source.SINGLETON_LOOKUP_COUNT
			WHEN NOT MATCHED THEN
			  INSERT ( [SERVER_NAME],
					   [DATABASE_NAME],
					   [DATE],
					   [TABLE_NAME],
					   [INDEX_NAME],
					   [INDEX_DESCRIPTION],
					   [INDEX_KEYS],
					   [COMPRESSION_TYPE],
					   [USER_SEEKS_DELTA],
					   [USER_SCANS_DELTA],
					   [USER_LOOKUPS_DELTA],
					   [USER_UPDATES_DELTA],
					   [RANGE_SCAN_COUNT_DELTA],
					   [PAGE_COUNT_DELTA],
					   [ROW_COUNT_DELTA],
					   [ROW_COUNT],
					   [PAGE_COUNT],
					   [SINGLETON_LOOKUP_COUNT],
					   [FLAG] )
			  VALUES (source.[SERVER_NAME],
					  source.[DATABASE_NAME],
					  source.[MDATE],
					  source.[TABLE_NAME],
					  source.[INDEX_NAME],
					  source.[INDEX_DESCRIPTION],
					  source.[INDEX_KEYS],
					  source.[COMPRESSION_TYPE],
					  source.[USER_SEEKS_DELTA],
					  source.[USER_SCANS_DELTA],
					  source.[USER_LOOKUPS_DELTA],
					  source.[USER_UPDATES_DELTA],
					  source.[RANGE_SCAN_COUNT_DELTA],
					  source.[PAGE_COUNT_DELTA],
					  source.[ROW_COUNT_DELTA],
					  source.[ROW_COUNT],
					  source.[PAGE_COUNT],
					  source.[SINGLETON_LOOKUP_COUNT],
					  'M'); 


 SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
  

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_AX_USERINFO]...';


GO
CREATE PROCEDURE [dbo].[DYNPERF_COLLECT_AX_USERINFO](@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AX_USERINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AX_USERINFO')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AX_USERINFO
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AX_USERINFO
				FOR [' + @DATABASE_NAME + '].dbo.USERINFO'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



		DELETE FROM AX_USERINFO
		WHERE  SERVER_NAME = @SERVER_NAME
			   AND DATABASE_NAME = @DATABASE_NAME 

		INSERT AX_USERINFO
		SELECT @SERVER_NAME,
		@STATS_DATE,
			   @DATABASE_NAME,
			   ID,
			   NAME
		FROM   DYN_AX_USERINFO 

	
	 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AX_USERINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AX_USERINFO')


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'


		  IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AX_USERINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AX_USERINFO')




    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_AZURE_EVENTLOG]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE PROCEDURE [dbo].[DYNPERF_COLLECT_AZURE_EVENTLOG]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30), @START_POS INT, @END_POS INT
    DECLARE @INSTANCE_NAME NVARCHAR(128)
    
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/




IF @AZURE_DB = 0 RETURN(0)  --REH THIS SPROC IS MEANT FOR AZURE ONLY





IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AZURE_EVENTS')
  EXEC ('DROP SYNONYM [dbo].DYN_AZURE_EVENTS')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_AZURE_EVENTS
				FOR [' + @SERVER_NAME + '].[master].sys.event_log'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AZURE_EVENTS
				FOR master.sys.event_log'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 




/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH The end_time column in this event is in UTC time so we do not need to convert ours since we pass to this sproc in UTC time


----REH  Time Zone code for all procedures
--IF @LAST_RUN > '1/1/1901'
--  BEGIN
--      IF @REMOTE_SERVER = 'N'
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
--        END
--      ELSE
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
--        END
--  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

		--SET @END_POS = LEN(@SERVER_NAME)
		--SET @START_POS = CHARINDEX('\', @SERVER_NAME,1)+1
		--IF @START_POS > 0
		--BEGIN
		--	SET @INSTANCE_NAME = 'MSSQL$' + SUBSTRING(@SERVER_NAME, @START_POS, @END_POS) + ':'
		--END
		--ELSE
		--BEGIN
		--	SET @INSTANCE_NAME = 'SQLServer:'
		--END
		
		

INSERT AZURE_EVENTS
SELECT @SERVER_NAME,
       @STATS_DATE,
       @DATABASE_NAME,
       AE.[database_name],
       AE.[start_time],
       AE.[end_time],
       AE.[event_category],
       AE.[event_type],
       AE.[event_subtype],
       AE.[event_subtype_desc],
       AE.[severity],
       AE.[event_count],
       AE.[description],
       AE.[additional_data]
FROM   DYN_AZURE_EVENTS AE
WHERE  AE.severity > 0 --Warnings and above
AND AE.database_name = @DATABASE_NAME
AND AE.[end_time] > @LAST_RUN  --REH LAST_RUN is UTC time in this case


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[SP_DELETE_AOTEXPORT]...';


GO
CREATE PROCEDURE [dbo].[SP_DELETE_AOTEXPORT]
	@SERVERNAME NVARCHAR(128),
	@DATABASENAME NVARCHAR(128) 
	
	AS

	BEGIN TRY
        DELETE FROM AX_TABLE_DETAIL
        WHERE  SERVER_NAME = @SERVERNAME
               AND DATABASE_NAME = @DATABASENAME
    
        DELETE FROM AX_INDEX_DETAIL
        WHERE  SERVER_NAME = @SERVERNAME
               AND DATABASE_NAME = @DATABASENAME
    
        DELETE FROM AX_CONFIGURATIONKEY_DETAIL
        WHERE  SERVER_NAME = @SERVERNAME
               AND DATABASE_NAME = @DATABASENAME
    
        DELETE FROM AX_LICENSEKEY_DETAIL
        WHERE  SERVER_NAME = @SERVERNAME
               AND DATABASE_NAME = @DATABASENAME
    
        DELETE FROM AX_BATCHJOB_DETAIL
        WHERE  SERVER_NAME = @SERVERNAME
               AND DATABASE_NAME = @DATABASENAME
    
        DELETE FROM AX_SERVER_CONFIG
        WHERE  SERVER_NAME = @SERVERNAME
               AND DATABASE_NAME = @DATABASENAME
    
        DELETE FROM AX_BATCHSERVERGROUP_CONFIG
        WHERE  SERVER_NAME = @SERVERNAME
               AND DATABASE_NAME = @DATABASENAME
    
        RETURN 0
    END TRY 
    



BEGIN CATCH
RETURN 1
END CATCH
GO
PRINT N'Creating [dbo].[DYNPERF_PROCESS_QUERY_PLANS]...';


GO
CREATE PROCEDURE [dbo].[DYNPERF_PROCESS_QUERY_PLANS]
       (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
                                                                             @AZURE_DB           BIT,
                                                                             @SQL_TZ_OFFSET INT,
                                                                             @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @CPU INT
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH Need to delete any old data in case QUERY_PLAN refresh updates the flag.  We need to delete old parsed plans

DELETE QPP
FROM   QUERY_PLANS_PARSED QPP
       INNER JOIN QUERY_PLANS QP WITH (NOLOCK)
               ON QPP.SERVER_NAME = QP.SERVER_NAME
                  AND QPP.DATABASE_NAME = QP.DATABASE_NAME
                  AND QPP.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
WHERE  QP.PARSED_FLAG = 0 and QP.SERVER_NAME = @SERVER_NAME and QP.DATABASE_NAME = @DATABASE_NAME

IF EXISTS (SELECT * FROM [tempdb].sys.objects WHERE name = '#PARSE_PLANS')
DROP TABLE #PARSE_PLANS

;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT	TOP 10000	QT.SERVER_NAME, QT.DATABASE_NAME, QT.[QUERY_PLAN_HASH],
 CONVERT (NVARCHAR(MAX), index_node.query('for $qplan in //sp:QueryPlan, $plist in $qplan/sp:ParameterList, $colref in $plist/sp:ColumnReference  return concat(string($colref/@Column),":",string($colref/@ParameterCompiledValue),",   "),"  "')) as SQL_PARAMS,
 CASE WHEN CAST(QT.QUERY_PLAN AS NVARCHAR(MAX)) LIKE '%MissingIndex%' THEN 1 ELSE 0 END as MI_FLAG
INTO #PARSE_PLANS

  FROM [QUERY_PLANS] QT WITH (NOLOCK)
  	INNER LOOP JOIN QUERY_STATS QS ON QT.SERVER_NAME = QS.SERVER_NAME AND QT.DATABASE_NAME = QS.DATABASE_NAME
		AND QT.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
      OUTER APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node)
    
WHERE PARSED_FLAG = 0 AND QT.SERVER_NAME = @SERVER_NAME AND QT.DATABASE_NAME = @DATABASE_NAME
	AND QT.QUERY_PLAN_HASH > 0X000000000000000  --REH Don't process the 0 hash values
	ORDER BY QS.TOTAL_ELAPSED_TIME DESC  --REH do the top execution times first, most likely to show up in query views


--REH Parse out the QUERY_PLANS table into it's vital statistics

SET QUOTED_IDENTIFIER OFF
SELECT @CPU = CPU_COUNT * .25 FROM sys.dm_os_sys_info

IF @CPU < 2 SET @CPU = 2

SET @SQL = '
 ;WITH XMLNAMESPACES (''http://schemas.microsoft.com/sqlserver/2004/07/showplan'' AS sp)

 INSERT QUERY_PLANS_PARSED
 SELECT DISTINCT *
FROM   (SELECT QUERY_PLANS.SERVER_NAME, QUERY_PLANS.DATABASE_NAME, QUERY_PLANS.QUERY_PLAN_HASH,
			   CAST(isnull(index_node.value(''(..//@NodeId)[1]'', ''nvarchar(128)''),''0'') AS INT) AS NodeID,
               CAST(Replace(Replace(index_node.value(''(.//@Table)[1]'', ''NVARCHAR(128)''), ''['', ''''), '']'', '''') AS NVARCHAR(128))  AS TABLE_NAME,
               CAST(Replace(Replace(index_node.value(''(.//@Index)[1]'', ''NVARCHAR(128)''), ''['', ''''), '']'', '''') AS NVARCHAR(128)) AS INDEX_NAME,
			   CAST(isnull(index_node.value(''(.//@Lookup)[1]'', ''nvarchar(128)''),''0'') AS INT) AS LOOKUP,
			   CAST(isnull(index_node.value(''(..//@Parallel)[1]'', ''nvarchar(128)''),''0'') AS INT) AS PARALLEL,
			   CAST(index_node.value(''(..//@PhysicalOp)[1]'', ''nvarchar(128)'') AS NVARCHAR(128)) AS PHYSICALOP,
			   CAST(index_node.value(''(..//@LogicalOp)[1]'', ''nvarchar(128)'') AS NVARCHAR(128)) AS LOGICALOP,
			   CAST(str(ISNULL(index_node.value(''(..//@EstimateRows)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(14,0)) AS ESTIMATEROWS,
			   CAST(str(ISNULL(index_node.value(''(..//@EstimateIO)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(20,7)) AS EstimateIO,
			   CAST(str(ISNULL(index_node.value(''(..//@EstimateCPU)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(20,7)) AS ESTIMATECPU,
			   CAST(str(ISNULL(index_node.value(''(..//@AvgRowSize)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(14,0)) AS AVGROWSIZE,
			   CAST(str(isnull(index_node.value(''(..//@EstimatedTotalSubtreeCost)[1]'', ''nvarchar(128)'') ,''0.0''),30,17) AS DECIMAL (20,7)) AS ESTIMATEDTOTALSUBTREECOST,
               CONVERT(NVARCHAR(MAX), index_node.query(''for $seekpredicate in ./sp:SeekPredicates,
                                                            $rangecolumns in $seekpredicate//sp:RangeColumns,
                                                            $columnreference in $rangecolumns/sp:ColumnReference
                                        return string($columnreference/@Column)''))        AS SEEK_COLUMNS,

              CONVERT(NVARCHAR(MAX), index_node.query(''for $predicate2 in ./sp:Predicate,
                                                           $Ident in  $predicate2//sp:Identifier,
														   $COLREF2 in  $Ident/sp:ColumnReference
                                                            
                                        return string($COLREF2/@Column)'')) AS PREDICATES,

		    REPLACE( REPLACE( CONVERT(NVARCHAR(MAX), index_node.query(''for $predicate in ./sp:Predicate,
                                                $rangecolumn in $predicate//sp:ScalarOperator
                                                            
                            return string($rangecolumn/@ScalarString)''))
							,''&lt;'', ''<'')   ,''&gt;'', ''>'')         AS PREDICATE_TEXT
        FROM   QUERY_PLANS WITH (NOLOCK)
			INNER JOIN #PARSE_PLANS ON QUERY_PLANS.SERVER_NAME = #PARSE_PLANS.SERVER_NAME
					AND QUERY_PLANS.DATABASE_NAME = #PARSE_PLANS.DATABASE_NAME
					AND QUERY_PLANS.QUERY_PLAN_HASH = #PARSE_PLANS.QUERY_PLAN_HASH
			OUTER APPLY QUERY_PLAN.nodes(''//sp:RelOp/sp:IndexScan'') AS SeekPredicates(index_node)
               --CROSS APPLY QUERY_PLAN.nodes(''//sp:Batch'') AS Batch(index_node2)
			WHERE QUERY_PLANS.SERVER_NAME = ' + '''' + @SERVER_NAME + '''' +'  AND QUERY_PLANS.DATABASE_NAME = '+ '''' +  @DATABASE_NAME +'''' + ' 
			   AND QUERY_PLANS.PARSED_FLAG = 0

			   ) A
			   OPTION(MAXDOP ' + CAST(@CPU AS VARCHAR(4)) + ')'

			   IF @DEBUG = 'Y'
			   BEGIN
				 PRINT @SQL
			   END


			   EXEC (@SQL)



UPDATE QP SET SQL_PARMS = PP.SQL_PARAMS
, MI_FLAG = PP.MI_FLAG
, PARSED_FLAG = 1

FROM QUERY_PLANS QP
INNER JOIN #PARSE_PLANS PP ON QP.SERVER_NAME = PP.SERVER_NAME
			AND QP.DATABASE_NAME = PP.DATABASE_NAME
			AND QP.QUERY_PLAN_HASH = PP.QUERY_PLAN_HASH

 WHERE QP.SERVER_NAME = @SERVER_NAME AND QP.DATABASE_NAME = @DATABASE_NAME AND QP.PARSED_FLAG = 0 
 OPTION(MAXDOP 1)
 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[SP_INDEX_CHANGES]...';


GO
CREATE PROCEDURE [dbo].[SP_INDEX_CHANGES] @START_DATE AS VARCHAR(128),
                                          @START_FLAG VARCHAR(1),
                                          @END_DATE   AS VARCHAR(128),
                                          @END_FLAG   VARCHAR(1)
AS
    SELECT *
    FROM   (SELECT LAST.DATABASE_NAME,
                   LAST.TABLE_NAME,
                   LAST.INDEX_NAME,
                   'INDEX CHANGED' AS DIFFERENCE
            FROM   INDEX_HISTORY LAST
                   INNER JOIN INDEX_HISTORY START
                           ON LAST.SERVER_NAME = START.SERVER_NAME
                              AND LAST.DATABASE_NAME = START.DATABASE_NAME
                              AND LAST.TABLE_NAME = START.TABLE_NAME
                              AND LAST.INDEX_NAME = START.INDEX_NAME
                              AND LAST.INDEX_KEYS <> START.INDEX_KEYS
            WHERE  LAST.DATE = @END_DATE
                   AND LAST.FLAG = @END_FLAG
                   AND START.DATE = @START_DATE
                   AND START.FLAG = @START_FLAG
            UNION
            SELECT START.DATABASE_NAME,
                   START.TABLE_NAME,
                   START.INDEX_NAME,
                   'INDEX DELETED' AS DIFFERENCE
            FROM   INDEX_HISTORY START
            WHERE  NOT EXISTS (SELECT INDEX_NAME
                               FROM   INDEX_HISTORY LAST
                               WHERE  LAST.SERVER_NAME = START.SERVER_NAME
                                      AND LAST.DATABASE_NAME = START.DATABASE_NAME
                                      AND LAST.TABLE_NAME = START.TABLE_NAME
                                      AND LAST.INDEX_NAME = START.INDEX_NAME
                                      AND LAST.DATE = @END_DATE
                                      AND LAST.FLAG = @END_FLAG)
                   AND START.DATE = @START_DATE
                   AND START.FLAG = @START_FLAG
            UNION
            SELECT LAST.DATABASE_NAME,
                   LAST.TABLE_NAME,
                   LAST.INDEX_NAME,
                   'INDEX ADDED' AS DIFFERENCE
            FROM   INDEX_HISTORY LAST
            WHERE  NOT EXISTS (SELECT INDEX_NAME
                               FROM   INDEX_HISTORY START
                               WHERE  LAST.SERVER_NAME = START.SERVER_NAME
                                      AND LAST.DATABASE_NAME = START.DATABASE_NAME
                                      AND LAST.TABLE_NAME = START.TABLE_NAME
                                      AND LAST.INDEX_NAME = START.INDEX_NAME
                                      AND START.DATE = @START_DATE
                                      AND START.FLAG = @START_FLAG)
                   AND LAST.DATE = @END_DATE
                   AND LAST.FLAG = @END_FLAG) AS A
    ORDER  BY A.DATABASE_NAME,
              A.TABLE_NAME
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_AX_SQLTRACE]...';


GO

CREATE PROCEDURE DYNPERF_COLLECT_AX_SQLTRACE (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/
--REH Moved the synonms to avoid SQL runtime error that columns don't exists.  

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')




/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures

--REH @LAST_RUN IS UTC TIME WHICH IS WHAT WE NEED IN THIS SPROC AND THIS SPROC ALONE


--IF @LAST_RUN > '1/1/1901'
--  BEGIN
--      IF @REMOTE_SERVER = 'N'
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
--        END
--      ELSE
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
--        END
--  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = '#AX_VERSION') 
 DROP TABLE  #AX_VERSION 

--REH Get AX version

DECLARE @AX_SERVER_NAME   NVARCHAR(128) = NULL,
        @AX_DATABASE_NAME NVARCHAR(128),
        @AX_APP_BUILD     NVARCHAR(120),
        @KERNEL_BUILD     NVARCHAR(20)
   
   CREATE TABLE #AX_VERSION
     (
        AX_APP_BUILD NVARCHAR(120),
        KERNEL_BUILD NVARCHAR(20)
     )
   
   SET NOCOUNT ON
   
   INSERT #AX_VERSION
   EXECUTE DYNPERF_AX_VERSION_INFO
     @AX_SERVER_NAME = @SERVER_NAME,
     @AX_DATABASE_NAME = @DATABASE_NAME--, @DEBUG = 'N'
   SELECT @AX_APP_BUILD = AX_APP_BUILD,
          @KERNEL_BUILD = KERNEL_BUILD
   FROM   #AX_VERSION
   
   --PRINT 'AX BUILD = ' + ISNULL(@AX_APP_BUILD, '')
   
   --PRINT 'KERNEL BUILD = '+ ISNULL(@KERNEL_BUILD, '')
   
IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = '#AX_VERSION') 
 BEGIN 
	DROP TABLE  #AX_VERSION 
 END
   

  
IF Substring(@AX_APP_BUILD, 1, 1) BETWEEN N'3' AND N'4'
BEGIN


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  EXEC('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


INSERT INTO AX_SQLTRACE 
		   (SERVER_NAME
		   ,STATS_TIME
		   ,DATABASE_NAME
		   ,SQL_DURATION
		   ,TRACE_CATEGORY
		   ,SQL_TEXT
		   ,CALL_STACK
		   ,TRACE_EVENT_CODE
		   ,TRACE_EVENT_DESC
		   ,TRACE_EVENT_DETAILS
		   ,CONNECTION_TYPE
		   ,SQL_SESSION_ID
		   ,AX_CONNECTION_ID
		   ,IS_LOBS_INCLUDED
		   ,IS_MORE_DATA_PENDING
		   ,ROWS_AFFECTED
		   ,ROW_SIZE
		   ,ROWS_PER_FETCH
		   ,IS_SELECTED_FOR_UPDATE
		   ,IS_STARTED_WITHIN_TRANSACTION
		   ,SQL_TYPE
		   ,STATEMENT_ID
		   ,STATEMENT_REUSE_COUNT
		   ,DETAIL_TYPE
		   ,CREATED_DATETIME
		   ,AX_USER_ID)
		SELECT @SERVER_NAME,
			@STATS_DATE,
			@DATABASE_NAME,
			TRACETIME
			,CATEGORY
			,STATEMENT
			,CALLSTACK
			,CODE
			,TEXT
			,TEXTDETAILS
			,CONNECTIONTYPE
			,CONNECTIONSPID
			,CONNECTIONID
			,ISLOBSINCLUDED
			,ISMOREDATAPENDING
			,ROWSAFFECTED
			,ROWSIZE
			,ROWSPERFETCH
			,ISSELECTEDFORUPDATE
			,ISSTARTEDWITHINTRANSACTION
			,STATEMENTTYPE
			,STATEMENTID
			,STATEMENTREUSECOUNT
			,DETAILTYPE
			,  DATEADD(MI, @SQL_TZ_OFFSET, DATEADD(S, CREATEDTIME, CREATEDDATE))      
			,CREATEDBY
			
			
		FROM DYN_AXTRACE_AX_SYSTRACETABLE WITH (NOLOCK)
		WHERE DATEADD(S, CREATEDTIME, CREATEDDATE) >= @LAST_RUN
	 AND DATEADD(D, 14, CREATEDDATE) >= GETDATE()


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')
	
END

IF Substring(@AX_APP_BUILD, 1, 2) IN ('5.', '6.', '7.') 
    BEGIN	
	
	
IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

INSERT INTO AX_SQLTRACE 
		   (SERVER_NAME
		   ,STATS_TIME
		   ,DATABASE_NAME
		   ,SQL_DURATION
		   ,TRACE_CATEGORY
		   ,SQL_TEXT
		   ,CALL_STACK
		   ,TRACE_EVENT_CODE
		   ,TRACE_EVENT_DESC
		   ,TRACE_EVENT_DETAILS
		   ,CONNECTION_TYPE
		   ,SQL_SESSION_ID
		   ,AX_CONNECTION_ID
		   ,IS_LOBS_INCLUDED
		   ,IS_MORE_DATA_PENDING
		   ,ROWS_AFFECTED
		   ,ROW_SIZE
		   ,ROWS_PER_FETCH
		   ,IS_SELECTED_FOR_UPDATE
		   ,IS_STARTED_WITHIN_TRANSACTION
		   ,SQL_TYPE
		   ,STATEMENT_ID
		   ,STATEMENT_REUSE_COUNT
		   ,DETAIL_TYPE
		   ,CREATED_DATETIME
		   ,AX_USER_ID)
		SELECT @SERVER_NAME,
			@STATS_DATE,
			@DATABASE_NAME,
			TRACETIME
			,CATEGORY
			,STATEMENT
			,CALLSTACK
			,CODE
			,TEXT
			,TEXTDETAILS
			,CONNECTIONTYPE
			,CONNECTIONSPID
			,CONNECTIONID
			,ISLOBSINCLUDED
			,ISMOREDATAPENDING
			,ROWSAFFECTED
			,ROWSIZE
			,ROWSPERFETCH
			,ISSELECTEDFORUPDATE
			,ISSTARTEDWITHINTRANSACTION
			,STATEMENTTYPE
			,STATEMENTID
			,STATEMENTREUSECOUNT
			,DETAILTYPE
			,DATEADD(MI, @SQL_TZ_OFFSET, CREATEDDATETIME)
			,CREATEDBY
	
		FROM DYN_AXTRACE_AX_SYSTRACETABLE WITH (NOLOCK)
		WHERE CREATEDDATETIME >= @LAST_RUN
	 AND DATEADD(D, 14, CREATEDDATETIME) >= GETDATE()
	
	END
	
IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
 EXEC('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')
  
  	
 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')



    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[SP_LOCKS_MS]...';


GO



CREATE PROCEDURE [dbo].[SP_LOCKS_MS] @delay VARCHAR(10)
 AS

SET quoted_identifier OFF
--truncate table Dynamicsperf..blocks  --delete all previous records
DECLARE  @cmd NVARCHAR(100)



/****** Object:  Table [dbo].[BLOCKS]    Script Date: 04/17/2012 14:10:13 ******/
IF  OBJECT_ID('tempdb..#BLOCKS') IS NOT NULL
          DROP TABLE [dbo].[#BLOCKS]



CREATE TABLE [dbo].[#BLOCKS](
	[BLOCKED_DTTM] [datetime] NOT NULL,
	[BLOCKER_LOGIN] [nvarchar](128) NULL,
	[BLOCKER_PROGRAM] [nvarchar](128) NULL,
	[BLOCKER_HOSTNAME] [nvarchar](128) NULL,
	[BLOCKED_LOGIN] [nvarchar](128) NULL,
	[BLOCKED_PROGRAM] [nvarchar](128) NULL,
	[BLOCKED_HOSTNAME] [nvarchar](128) NULL,
	[BLOCKER_SESSION_ID] [smallint] NULL,
	[BLOCKER_CONTEXT_INFO] [binary](128) NULL,
	[BLOCKER_CONTEXT] [nvarchar](max) NULL,
	[BLOCKER_TRAN_ISOLATION] [varchar](20) NULL,
	[BLOCKER_STATUS] [varchar](18) NULL,
	[BLOCKED_SESSION_ID] [smallint] NULL,
	[BLOCKED_CONTEXT_INFO] [binary](128) NULL,
	[BLOCKED_CONTEXT] [nvarchar](max) NULL,
	[BLOCKED_TRAN_ISOLATION] [varchar](20) NULL,
	[TRANSACTION_ID] [bigint] NULL,
	[WAIT_TIME] [bigint] NULL,
	[LOCK_MODE] [nvarchar](60) NULL,
	[LOCK_SIZE] [nvarchar](6) NULL,
	[DATABASE_NAME] [nvarchar](128) NULL,
	[ALLOW_SNAPSHOT_ISOLATION] [nvarchar](60) NULL,
	[READ_COMMITTED_SNAPSHOT] [nvarchar](3) NULL,
	[OBJECT_NAME] [nvarchar](128) NULL,
	[INDEX_ID] [int] NULL,
	[BLOCKER_SQL] [nvarchar](max) NULL,
	[BLOCKER_PLAN] [xml] NULL,
	[BLOCKED_SQL] [nvarchar](max) NULL,
	[BLOCKED_PLAN] [xml] NULL
) ON [PRIMARY]

TOP_LOOP:
BEGIN TRY

TRUNCATE TABLE #BLOCKS

INSERT #BLOCKS
EXEC [SP_LOGBLOCKS_MS]



 MERGE DynamicsPerf..BLOCKS AS target
    USING (
SELECT 
	BLOCKED_DTTM,
	BLOCKER_LOGIN			,
	BLOCKER_PROGRAM		,
	BLOCKER_HOSTNAME		,
	BLOCKED_LOGIN			,
	BLOCKED_PROGRAM		,
	BLOCKED_HOSTNAME		,
	BLOCKER_SESSION_ID		,
	BLOCKER_CONTEXT_INFO	,
	BLOCKER_CONTEXT			,
	BLOCKER_TRAN_ISOLATION	,
	BLOCKER_STATUS			,
	BLOCKED_SESSION_ID		,
	BLOCKED_CONTEXT_INFO	,
	BLOCKED_CONTEXT			,
	BLOCKED_TRAN_ISOLATION	,
	TRANSACTION_ID			,
	WAIT_TIME				,
	LOCK_MODE				,
	LOCK_SIZE				,
	DATABASE_NAME			,
	ALLOW_SNAPSHOT_ISOLATION,
	READ_COMMITTED_SNAPSHOT ,
	OBJECT_NAME				,
	INDEX_ID				,
	BLOCKER_SQL				,
			
	BLOCKER_PLAN = BLOCKER_PLAN	,
	BLOCKED_SQL = 	BLOCKED_SQL ,
	BLOCKED_PLAN =  BLOCKED_PLAN	
				
FROM	#BLOCKS
) as source

ON (source.TRANSACTION_ID = target.TRANSACTION_ID 
AND source.BLOCKED_SESSION_ID = target.BLOCKED_SESSION_ID 
AND source.BLOCKER_SESSION_ID = target.BLOCKER_SESSION_ID)

    WHEN MATCHED THEN 
        UPDATE SET WAIT_TIME = source.WAIT_TIME, BLOCKED_DTTM = source.BLOCKED_DTTM
	WHEN NOT MATCHED THEN	
	    INSERT ([BLOCKED_DTTM]
           ,[BLOCKER_LOGIN]
           ,[BLOCKER_PROGRAM]
           ,[BLOCKER_HOSTNAME]
           ,[BLOCKED_LOGIN]
           ,[BLOCKED_PROGRAM]
           ,[BLOCKED_HOSTNAME]
           ,[BLOCKER_SESSION_ID]
           ,[BLOCKER_CONTEXT_INFO]
           ,[BLOCKER_CONTEXT]
           ,[BLOCKER_TRAN_ISOLATION]
           ,[BLOCKER_STATUS]
           ,[BLOCKED_SESSION_ID]
           ,[BLOCKED_CONTEXT_INFO]
           ,[BLOCKED_CONTEXT]
           ,[BLOCKED_TRAN_ISOLATION]
           ,[TRANSACTION_ID]
           ,[WAIT_TIME]
           ,[LOCK_MODE]
           ,[LOCK_SIZE]
           ,[DATABASE_NAME]
           ,[ALLOW_SNAPSHOT_ISOLATION]
           ,[READ_COMMITTED_SNAPSHOT]
           ,[OBJECT_NAME]
           ,[INDEX_ID]
           ,[BLOCKER_SQL]
           ,[BLOCKER_PLAN]
           ,[BLOCKED_SQL]
           ,[BLOCKED_PLAN])
           
           VALUES (source.[BLOCKED_DTTM]
           ,source.[BLOCKER_LOGIN]
           ,source.[BLOCKER_PROGRAM]
           ,source.[BLOCKER_HOSTNAME]
           ,source.[BLOCKED_LOGIN]
           ,source.[BLOCKED_PROGRAM]
           ,source.[BLOCKED_HOSTNAME]
           ,source.[BLOCKER_SESSION_ID]
           ,source.[BLOCKER_CONTEXT_INFO]
           ,source.[BLOCKER_CONTEXT]
           ,source.[BLOCKER_TRAN_ISOLATION]
           ,source.[BLOCKER_STATUS]
           ,source.[BLOCKED_SESSION_ID]
           ,source.[BLOCKED_CONTEXT_INFO]
           ,source.[BLOCKED_CONTEXT]
           ,source.[BLOCKED_TRAN_ISOLATION]
           ,source.[TRANSACTION_ID]
           ,source.[WAIT_TIME]
           ,source.[LOCK_MODE]
           ,source.[LOCK_SIZE]
           ,source.[DATABASE_NAME]
           ,source.[ALLOW_SNAPSHOT_ISOLATION]
           ,source.[READ_COMMITTED_SNAPSHOT]
           ,source.[OBJECT_NAME]
           ,source.[INDEX_ID]
           ,source.[BLOCKER_SQL]
           ,source.[BLOCKER_PLAN]
           ,source.[BLOCKED_SQL]
           ,source.[BLOCKED_PLAN]);
           
   

END TRY
BEGIN CATCH
 --ignore the error
END catch
 
SELECT @cmd = 'waitfor delay ' +Quotename(@delay,'''')
EXEC sp_executesql @cmd

GOTO TOP_LOOP


ABORT:
RETURN(0)
GO
-- Refactoring step to update target server with deployed transaction logs

IF OBJECT_ID(N'dbo.__RefactorLog') IS NULL
BEGIN
    CREATE TABLE [dbo].[__RefactorLog] (OperationKey UNIQUEIDENTIFIER NOT NULL PRIMARY KEY)
    EXEC sp_addextendedproperty N'microsoft_database_tools_support', N'refactoring log', N'schema', N'dbo', N'table', N'__RefactorLog'
END
GO
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'e98125e1-c435-47d9-9a7c-b551c2e7a158')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('e98125e1-c435-47d9-9a7c-b551c2e7a158')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'ca8bb5f5-9ee9-40cd-84a3-d7835ddfbf01')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('ca8bb5f5-9ee9-40cd-84a3-d7835ddfbf01')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '315561fd-a0ea-4f11-80d6-defd99ebc871')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('315561fd-a0ea-4f11-80d6-defd99ebc871')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '42f57e58-6006-4bce-902f-7577431a9703')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('42f57e58-6006-4bce-902f-7577431a9703')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '511c420e-3e55-4c31-9e67-e7c719b88c5f')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('511c420e-3e55-4c31-9e67-e7c719b88c5f')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'f5741dda-43b8-41bb-9bc7-9abefa4927f2')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('f5741dda-43b8-41bb-9bc7-9abefa4927f2')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'f2066074-07d4-4547-8c3b-87dbd5a2c7c9')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('f2066074-07d4-4547-8c3b-87dbd5a2c7c9')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '3b4325fd-6b16-4d07-a4cc-6cdec4882cbf')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('3b4325fd-6b16-4d07-a4cc-6cdec4882cbf')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'd8728227-048a-490a-ab8b-6863c6cf7b29')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('d8728227-048a-490a-ab8b-6863c6cf7b29')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '9d6fdfd6-b8ef-488a-8a67-ba5128167064')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('9d6fdfd6-b8ef-488a-8a67-ba5128167064')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'e8fecb27-1c54-4691-b40f-f86eeca33c1c')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('e8fecb27-1c54-4691-b40f-f86eeca33c1c')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '061ac704-5917-4459-990a-a3ac80d3ce36')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('061ac704-5917-4459-990a-a3ac80d3ce36')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '353c2fae-52e3-4761-a709-e03312f22df2')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('353c2fae-52e3-4761-a709-e03312f22df2')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '4fdd3cdb-a4b9-49d7-a536-c7df759ea5a7')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('4fdd3cdb-a4b9-49d7-a536-c7df759ea5a7')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'ce55e019-2097-4af5-93aa-6dd85d25107f')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('ce55e019-2097-4af5-93aa-6dd85d25107f')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'f6119492-457a-4e4a-9ac7-9a11fc5d8db1')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('f6119492-457a-4e4a-9ac7-9a11fc5d8db1')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'ea6f7532-962d-4b0e-9a22-046fb45c51ca')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('ea6f7532-962d-4b0e-9a22-046fb45c51ca')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '81615cc2-4ac2-4f1d-aeac-88223a12c2a1')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('81615cc2-4ac2-4f1d-aeac-88223a12c2a1')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '0b91e5c4-6fb3-4e56-ba60-b038f2f3a18b')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('0b91e5c4-6fb3-4e56-ba60-b038f2f3a18b')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '2ec6241d-1716-4090-88d1-ce91bd0fffd2')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('2ec6241d-1716-4090-88d1-ce91bd0fffd2')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'd468179b-5990-4e10-b45b-1b603863c00f')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('d468179b-5990-4e10-b45b-1b603863c00f')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'c0846b99-0469-4b39-ab3d-5922ae0f23fe')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('c0846b99-0469-4b39-ab3d-5922ae0f23fe')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '3c847f8e-5d19-4649-b732-3e83f6261c9f')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('3c847f8e-5d19-4649-b732-3e83f6261c9f')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '16500d6a-9899-474c-8fee-dfa7382870fe')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('16500d6a-9899-474c-8fee-dfa7382870fe')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'bd76f4cf-3c8c-4286-9993-066a8500fe12')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('bd76f4cf-3c8c-4286-9993-066a8500fe12')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '5e688ce2-4d81-4cc3-b13c-336fa9107cd5')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('5e688ce2-4d81-4cc3-b13c-336fa9107cd5')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '38658598-2979-4518-9ca1-fbdc59b90e09')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('38658598-2979-4518-9ca1-fbdc59b90e09')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'bea8bb2d-399c-4420-9f61-15fdc6029df2')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('bea8bb2d-399c-4420-9f61-15fdc6029df2')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '76bb66bd-ad2b-4276-97b8-c20ccf248343')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('76bb66bd-ad2b-4276-97b8-c20ccf248343')

GO

GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/


INSERT [DynamicsPerf]..[DYNAMICSPERF_SETUP]
VALUES('2.00 BETA 5', GETDATE(), '')



GO
ALTER TABLE QUERY_PLANS SET (LOCK_ESCALATION = DISABLE)

GO

/****************************************************************************************************************************
INSERT PUGETABLE STUFF
*****************************************************************************************************************************/

TRUNCATE TABLE [DYNPERF_PURGETABLES]


INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_BATCHJOB_DETAIL' ,'STATS_TIME', 1, 1,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_BATCHSERVERGROUP_CONFIG' ,'STATS_TIME', 1, 1,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_INDEX_DETAIL' ,'STATS_TIME', 1, 1,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_LICENSEKEY_DETAIL' ,'STATS_TIME', 1, 1,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_NUM_SEQUENCES' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_SERVER_CONFIG' ,'STATS_TIME', 1, 1,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_SQLTRACE' ,'STATS_TIME', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_TABLE_DETAIL' ,'STATS_TIME', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AZURE_EVENTS' ,'STATS_TIME', 1, 1,90) 


-- HANDLED BY SPROC  INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_SYSGLOBALCONFIGURATION' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('BLOCKS' ,'BLOCKED_DTTM', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('BUFFER_DETAIL' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('CAPTURE_LOG' ,'STATS_TIME', 0, 0,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('CDC' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('CRM_ORGANIZATION' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('CRM_PLUGINS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('CRM_POA_TOTALS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('DISKSTATS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_DENSITY_VECTOR' ,'', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_DETAIL' ,'STATS_TIME', 1, 1,2) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_HISTOGRAM' ,'', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_HISTORY' ,'DATE', 1, 1,999) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_OPERATIONAL_STATS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_PHYSICAL_STATS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_STAT_HEADER' ,'', 1, 1,14)
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_USAGE_STATS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('LOGINFO' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('PERF_COUNTER_DATA' ,'STATS_TIME', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_ALERTS' ,'STATS_TIME', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_ALERTS_CONFIG' ,'', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_HISTORY' ,'DATE', 1, 1,999) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_PLANS' ,'DATE_UPDATED', 1, 1,999) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_PLANS_PARSED' ,'', 1, 1,999) 

INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_STATS' ,'STATS_TIME', 1, 1,2) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_TEXT' ,' ', 1, 1,999) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SERVERINFO' ,'STATS_TIME', 1, 0,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_AZURE_EVENTS' ,'END_TIME', 1, 1,14) 

INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_CONFIGURATION' ,'STATS_TIME', 1, 0,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_DATABASEFILES' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_DATABASES' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_JOBS' ,'STATS_TIME', 1, 0,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_PLAN_GUIDES' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_REPLICATION' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQLERRORLOG' ,'LOGDATE', 1, 0,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SSRS_EXECUTIONLOG' ,'TIMEEND', 1, 0,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('STATS_COLLECTION_SUMMARY' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('TRACEFLAGS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('TRIGGER_TABLE' ,'', 1, 1,14) 

INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('WAIT_STATS' ,'STATS_TIME', 1, 0,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SSRS_HISTORY' ,'REPORT_DATE', 1, 0,730) 





GO


/****************************************************************************************************************************
INSERT sys.dm_os_performance_counters STUFF
*****************************************************************************************************************************/
TRUNCATE TABLE PERF_COUNTER_2_COLLECT
									--OBJECT NAME        COUNTER_NAME         INSTANCE
INSERT PERF_COUNTER_2_COLLECT VALUES('Buffer Manager', 'Page life expectancy', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Access Methods', 'Page Splits/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Access Methods', 'Table Lock Escalations/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Availability Replica', 'Bytes Sent to Replica/sec', '_Total')
INSERT PERF_COUNTER_2_COLLECT VALUES('Buffer Manager', 'Page reads/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Buffer Manager', 'Page writes/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Cursor Manager by Type', 'Active cursors', '_Total')
INSERT PERF_COUNTER_2_COLLECT VALUES('Cursor Manager by Type', 'Cursor memory usage', '_Total')
INSERT PERF_COUNTER_2_COLLECT VALUES('Databases', 'Transactions/sec', '_Total')
INSERT PERF_COUNTER_2_COLLECT VALUES('General Statistics', 'Processes blocked', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('General Statistics', 'User Connections', '')


INSERT PERF_COUNTER_2_COLLECT VALUES('Locks', 'Average Wait Time (ms)', '_Total')
INSERT PERF_COUNTER_2_COLLECT VALUES('Locks', 'Average Wait Time Base', '_Total')

INSERT PERF_COUNTER_2_COLLECT VALUES('Locks', 'Number of Deadlocks/sec', '_Total')
INSERT PERF_COUNTER_2_COLLECT VALUES('Memory Manager', 'Free Memory (KB)', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Memory Manager', 'Lock Memory (KB)', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Memory Manager', 'Target Server Memory (KB)', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Memory Manager', 'Total Server Memory (KB)', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Plan Cache', 'Cache Pages', '_Total')
INSERT PERF_COUNTER_2_COLLECT VALUES('SQL Statistics', 'Batch Requests/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('SQL Statistics', 'Guided plan executions/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('SQL Statistics', 'SQL Compilations/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('SQL Statistics', 'SQL Re-Compilations/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Transactions', 'Free Space in tempdb (KB)', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Transactions', 'Version Store Size (KB)', '')

                                                                                                         



INSERT PERF_COUNTER_2_COLLECT VALUES('Wait Statistics', 'Network IO waits', 'Average wait time (ms)')
INSERT PERF_COUNTER_2_COLLECT VALUES('Wait Statistics', 'Page IO latch waits', 'Average wait time (ms)')
INSERT PERF_COUNTER_2_COLLECT VALUES('Wait Statistics', 'Page latch waits', 'Average wait time (ms)')
INSERT PERF_COUNTER_2_COLLECT VALUES('Wait Statistics', 'Network IO waits', 'Cumulative wait time (ms) per second')
INSERT PERF_COUNTER_2_COLLECT VALUES('Wait Statistics', 'Page IO latch waits', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Wait Statistics', 'Page latch waits', 'Cumulative wait time (ms) per second')




--INSERT PERF_COUNTER_2_COLLECT VALUES('', '', '')












/***************************************************************************
*
* 3/2/2012  REH   Turn on row compression for all DynamicsPerf indexes
*                   if compression is supported
*
*
****************************************************************************/
IF  (cast(serverproperty('Edition') as varchar(100)) like 'Enterprise%' or cast(serverproperty('Edition') as varchar(100)) like 'Developer%')
BEGIN
		DECLARE @INDEX_NAME SYSNAME
		DECLARE @TABLE_NAME SYSNAME
		DECLARE @SQL VARCHAR(MAX)


		DECLARE INDEXCURSOR CURSOR FOR
			SELECT	
					si.name, 
					so.name
			FROM	DynamicsPerf.sys.indexes si
			JOIN	DynamicsPerf.sys.sysindexes ii on si.object_id = ii.id and si.index_id = ii.indid
			JOIN	DynamicsPerf.sys.objects so on so.object_id = si.object_id
			JOIN	DynamicsPerf.sys.schemas ss on ss.schema_id = so.schema_id
			WHERE	so.type = 'U'
			AND		si.type > 0  --other than heap tables
			
			OPEN INDEXCURSOR

		FETCH INDEXCURSOR INTO 
			@INDEX_NAME		,
			@TABLE_NAME		
			
			
		WHILE @@FETCH_STATUS = 0
			BEGIN
			
			--Need page compression on this table to get maximum space savings
			IF @TABLE_NAME = 'SQLErrorLog'
			BEGIN
			SELECT @SQL = 'ALTER INDEX [' + @INDEX_NAME + '] ON ' + @TABLE_NAME + 
			' REBUILD WITH (DATA_COMPRESSION = PAGE)'
			END
			ELSE
			BEGIN
			SELECT @SQL = 'ALTER INDEX [' + @INDEX_NAME + '] ON ' + @TABLE_NAME + 
			' REBUILD WITH (DATA_COMPRESSION = ROW)'
			END
			
			EXEC (@SQL)
			
			FETCH NEXT FROM INDEXCURSOR INTO @INDEX_NAME,@TABLE_NAME
			END
			
			CLOSE INDEXCURSOR
			DEALLOCATE INDEXCURSOR
			
			
			--REH Compress the QUERY_PLANS table that we removed the clustered index on
			ALTER TABLE dbo.QUERY_PLANS  REBUILD WITH ( DATA_COMPRESSION = ROW )
END


/*************************** START OF SQL JOBS ******************************************/

USE [msdb]
GO
--REH  Delete old jobs that we renamed

/****** Object:  Job [DYNPERF_Log_Blocks_Option1_Tracing]    Script Date: 10/10/2010 14:34:59 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Log_Blocks_Option1_Tracing_Start')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Log_Blocks_Option1_Tracing_Start', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option1_Tracing_Stop]    Script Date: 10/10/2010 15:24:21 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Log_Blocks_Option1_Tracing_Stop')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Log_Blocks_Option1_Tracing_Stop', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option1_Load_Blocked_Data]    Script Date: 12/16/2010 11:22:48 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Log_Blocks_Option1_Load_Blocked_Data')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Log_Blocks_Option1_Load_Blocked_Data', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option2_Polling]    Script Date: 10/10/2010 14:36:42 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Log_Blocks_Option2_Polling')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Log_Blocks_Option2_Polling', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Option1_Tracing_Start]    Script Date: 10/19/2011 15:23:06 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Option1_Tracing_Start')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Option1_Tracing_Start', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option1_Tracing_Stop]    Script Date: 10/10/2010 15:24:21 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Option1_Tracing_Stop')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Option1_Tracing_Stop', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option1_Load_Blocked_Data]    Script Date: 12/16/2010 11:22:48 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Option1_Load_Blocked_Data')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Option1_Load_Blocked_Data', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option2_Polling]    Script Date: 10/10/2010 14:36:42 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Option2_Polling_for_Blocking')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Option2_Polling_for_Blocking', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option2_Polling]    Script Date: 10/10/2010 14:36:42 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Option2_Polling_for_Blocking')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Option2_Polling_for_Blocking', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_PerfStats_Hourly]    Script Date: 03/13/2011 13:38:20 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_PerfStats_Hourly')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_PerfStats_Hourly', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Capture_Stats_Purge]    Script Date: 02/18/2010 11:38:53 ******/
IF EXISTS (SELECT job_id FROM   msdb.dbo.sysjobs_view WHERE  name = N'DYNPERF_Capture_Stats_Purge')
EXEC msdb.dbo.sp_delete_job  @job_name=N'DYNPERF_Capture_Stats_Purge',  @delete_unused_schedule=1 
GO
IF EXISTS (SELECT job_id FROM   msdb.dbo.sysjobs_view WHERE  name = N'DYNPERF_Compression_Analyzer')
  EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Compression_Analyzer', @delete_unused_schedule=1
GO

/****** Object:  Job [DYNPERF_Purge_Stats]    Script Date: 10/10/2010 14:36:42 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Purge_Stats')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Purge_Stats', @delete_unused_schedule=1
GO

/****** Object:  Job [DYNPERF_Default_Trace_Start]    Script Date: 04/26/2012 19:26:53 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Detailed_Trace')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Detailed_Trace', @delete_unused_schedule=1
GO

IF EXISTS (SELECT job_id FROM   msdb.dbo.sysjobs_view  WHERE  name = N'DYNPERF_Purge_Blocks')
  EXEC msdb.dbo.sp_delete_job @job_name = N'DYNPERF_Purge_Blocks', @delete_unused_schedule=1
GO
IF EXISTS (SELECT job_id FROM   msdb.dbo.sysjobs_view WHERE  name = N'DYNPERF_Capture_Stats_Purge')
  EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Capture_Stats_Purge', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Capture_Stats_Baseline]    Script Date: 03/18/2014 21:27:20 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Capture_Stats_Baseline')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Capture_Stats_Baseline', @delete_unused_schedule=1
GO


--REH deleting lowercased named ones on Case Sensitive systems
/****** Object:  Job [DYNPERF_Capture_Stats]    Script Date: 02/18/2010 11:38:20 ******/ --REH converted to UPPERCASE
IF EXISTS (SELECT job_id FROM   msdb.dbo.sysjobs_view   WHERE  name = N'DYNPERF_Capture_Stats')
EXEC msdb.dbo.sp_delete_job  @job_name=N'DYNPERF_Capture_Stats',  @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Default_Trace_Start]    Script Date: 10/19/2011 15:23:06 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Default_Trace_Start')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Default_Trace_Start', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Default_Trace_Stop]    Script Date: 10/10/2010 15:24:21 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Default_Trace_Stop')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Default_Trace_Stop', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_LONG_DURATION_TRACE]    Script Date: 04/26/2012 19:26:53 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Long_Duration_Trace')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Long_Duration_Trace', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option2_Polling]    Script Date: 10/10/2010 14:36:42 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Optional_Polling_for_Blocking')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Optional_Polling_for_Blocking', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Purge_SYSTRACETABLESQL_AX]    Script Date: 10/19/2011 16:21:00 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Purge_SYSTRACETABLESQL_AX')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Purge_SYSTRACETABLESQL_AX', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Set_AX_User_Trace_on]    Script Date: 04/01/2014 08:20:00 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Set_AX_User_Trace_on')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Set_AX_User_Trace_on', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Set_AX_User_Trace_off]    Script Date: 04/01/2014 08:21:23 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Set_AX_User_Trace_off')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Set_AX_User_Trace_off', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_SET_AX_USER_TRACE_ON]    Script Date: 04/01/2014 08:20:00 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_SET_AX_USER_TRACE_ON')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_SET_AX_USER_TRACE_ON', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_SET_AX_USER_TRACE_OFF]    Script Date: 04/01/2014 08:21:23 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_SET_AX_USER_TRACE_OFF')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_SET_AX_USER_TRACE_OFF', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_PURGE_SYSTRACETABLESQL_AX]    Script Date: 10/19/2011 16:21:00 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_PURGE_SYSTRACETABLESQL_AX')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_PURGE_SYSTRACETABLESQL_AX', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_DEFAULT_TRACE_START]    Script Date: 10/19/2011 15:23:06 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_DEFAULT_TRACE_START')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_DEFAULT_TRACE_START', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_DEFAULT_TRACE_STOP]    Script Date: 10/10/2010 15:24:21 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_DEFAULT_TRACE_STOP')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_DEFAULT_TRACE_STOP', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_LONG_DURATION_TRACE]    Script Date: 04/26/2012 19:26:53 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_LONG_DURATION_TRACE')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_LONG_DURATION_TRACE', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option2_Polling]    Script Date: 10/10/2010 14:36:42 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_OPTIONAL_POLLING_FOR_BLOCKING')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_OPTIONAL_POLLING_FOR_BLOCKING', @delete_unused_schedule=1
GO




USE [msdb]
GO
/****** Object:  Job [DYNPERF_CAPTURE_STATS]    Script Date: 02/18/2010 11:38:20 ******/
IF EXISTS (SELECT job_id FROM   msdb.dbo.sysjobs_view  WHERE  name = N'DYNPERF_CAPTURE_STATS')
  EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_CAPTURE_STATS',  @delete_unused_schedule=1
GO

USE [msdb]
GO

/****** Object:  Job [DYNPERF_CAPTURE_STATS]    Script Date: 09/20/2015 19:31:09 ******/
BEGIN TRANSACTION
DECLARE @ReturnCode INT
SELECT @ReturnCode = 0
/****** Object:  JobCategory [[Uncategorized (Local)]]]    Script Date: 09/20/2015 19:31:09 ******/
IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
BEGIN
EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'[Uncategorized (Local)]'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

END

DECLARE @jobId BINARY(16)
EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'DYNPERF_CAPTURE_STATS', 
		@enabled=1, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'Capture DMV Data for performance analysis, daily', 
		@category_name=N'[Uncategorized (Local)]', 
		@owner_login_name=N'sa', @job_id = @jobId OUTPUT
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
/****** Object:  Step [sp_capturestats]    Script Date: 09/20/2015 19:31:10 ******/
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'sp_capturestats', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'EXEC  SP_CAPTURESTATS', 
		@database_name=N'DynamicsPerf', 
		@flags=0
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'5 MINUTES', 
		@enabled=1, 
		@freq_type=4, 
		@freq_interval=1, 
		@freq_subday_type=4, 
		@freq_subday_interval=5, 
		@freq_relative_interval=0, 
		@freq_recurrence_factor=0, 
		@active_start_date=20101008, 
		@active_end_date=99991231, 
		@active_start_time=0, 
		@active_end_time=235959
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
COMMIT TRANSACTION
GOTO EndSave
QuitWithRollback:
    IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
EndSave:
GO






USE [msdb]
GO
/****** Object:  Job [DYNPERF_PROCESS_TASKS]    Script Date: 02/18/2010 11:38:20 ******/
IF EXISTS (SELECT job_id
           FROM   msdb.dbo.sysjobs_view
           WHERE  name = N'DYNPERF_PROCESS_TASKS')
  EXEC msdb.dbo.sp_delete_job
    @job_name=N'DYNPERF_PROCESS_TASKS',
    @delete_unused_schedule=1

GO

USE [msdb]
GO

/****** Object:  Job [DYNPERF_PROCESS_TASKS]    Script Date: 10/10/2010 14:25:48 ******/
BEGIN TRANSACTION
DECLARE @ReturnCode INT
SELECT @ReturnCode = 0
/****** Object:  JobCategory [[Uncategorized (Local)]]]    Script Date: 10/10/2010 14:25:48 ******/
IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
BEGIN
EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'[Uncategorized (Local)]'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

END

DECLARE @jobId BINARY(16)
EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'DYNPERF_PROCESS_TASKS', 
		@enabled=1, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'Run Processing tasks in DynamicsPerf Database', 
		@category_name=N'[Uncategorized (Local)]', 
		@owner_login_name=N'sa', @job_id = @jobId OUTPUT
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
/****** Object:  Step [sp_capturestats]    Script Date: 10/10/2010 14:25:48 ******/
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'SP_PROCESS_STATS', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'EXEC SP_PROCESS_STATS	 ', 
		@database_name=N'DynamicsPerf', 
		@flags=0
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'EVERY 5 MINUTES', 
		@enabled=1, 
		@freq_type=4, 
		@freq_interval=1, 
		@freq_subday_type=4, 
		@freq_subday_interval=5, 
		@freq_relative_interval=0, 
		@freq_recurrence_factor=0, 
		@active_start_date=20101008, 
		@active_end_date=99991231, 
		@active_start_time=100, 
		@active_end_time=235959

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
COMMIT TRANSACTION
GOTO EndSave
QuitWithRollback:
    IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
EndSave:

GO






USE [msdb]
GO

/****** Object:  Job [DYNPERF_COLLECT_AOS_CONFIG]    Script Date: 09/19/2015 07:23:26 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_COLLECT_AOS_CONFIG')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_COLLECT_AOS_CONFIG', @delete_unused_schedule=1
GO

USE [msdb]
GO

/****** Object:  Job [DYNPERF_COLLECT_AOS_CONFIG]    Script Date: 09/19/2015 07:23:26 ******/
BEGIN TRANSACTION
DECLARE @ReturnCode INT
SELECT @ReturnCode = 0
/****** Object:  JobCategory [[Uncategorized (Local)]]]    Script Date: 09/19/2015 07:23:26 ******/
IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
BEGIN
EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'[Uncategorized (Local)]'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

END

DECLARE @jobId BINARY(16)
EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'DYNPERF_COLLECT_AOS_CONFIG', 
		@enabled=0, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'No description available.', 
		@category_name=N'[Uncategorized (Local)]', 
		@owner_login_name=N'sa', @job_id = @jobId OUTPUT
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
/****** Object:  Step [COLLECT AOS CONFIG]    Script Date: 09/19/2015 07:23:26 ******/
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'COLLECT AOS CONFIG', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'ActiveScripting', 
	@command=N'strSQLInstance = "PROD_SQL"
strAXDataBase = "PROD_DB"

strSQLInstanceDPA = "DP_SQL"
strDataBaseDPA = "DynamicsPerf"


Const HKLM          = &H80000002
Const adInteger     = 3
Const adVarWChar    = 202
Const adlongVarWChar= 203
Const adParamInput  = &H0001
Const adCmdText     = &H0001
const REG_SZ        = 1
const REG_EXPAND_SZ = 2
const REG_BINARY    = 3
const REG_DWORD     = 4
const REG_MULTI_SZ  = 7

Dim objConnection
Dim objRecordset
Dim objCommandEvt
Dim objCommandReg


Dim objConnectionDPA
Dim objRecordsetDPA
Dim objCommandEvtDPA
Dim objCommandRegDPA



Dim prmEvt1
Dim prmEvt2
Dim prmEvt3
Dim prmEvt4
Dim prmEvt5
Dim prmEvt6

Dim prmReg1
Dim prmReg2
Dim prmReg3
Dim prmReg4
Dim prmReg5
Dim prmReg6
Dim prmReg7
Dim prmReg8


Dim strAOS
Dim strRecordset

strRecordset = "SELECT SUBSTRING(SERVERID,(CHARINDEX(''@'',SERVERID)+1), (LEN(SERVERID)-CHARINDEX(''@'',SERVERID)))FROM SYSSERVERCONFIG"

Set objConnection=CreateObject("ADODB.Connection") 
Set objRecordset=CreateObject("ADODB.Recordset")
set objCommandEvt=CreateObject("ADODB.command")
set objCommandReg=CreateObject("ADODB.command")


Set objConnectionDPA=CreateObject("ADODB.Connection") 
Set objRecordsetDPA=CreateObject("ADODB.Recordset")
set objCommandEvtDPA=CreateObject("ADODB.command")
set objCommandRegDPA=CreateObject("ADODB.command")




objConnection.Provider="SQLOLEDB"
objConnection.Properties("Data Source").Value = strSQLInstance
objConnection.Properties("Initial Catalog").Value = strAXDatabase
objConnection.Properties("Integrated Security").Value = "SSPI"

objConnection.Open


objConnectionDPA.Provider="SQLOLEDB"
objConnectionDPA.Properties("Data Source").Value = strSQLInstanceDPA
objConnectionDPA.Properties("Initial Catalog").Value = strDatabaseDPA
objConnectionDPA.Properties("Integrated Security").Value = "SSPI"

objConnectionDPA.Open



objCommandEvtDPA.ActiveConnection=objConnectionDPA
objCommandEvtDPA.CommandType=adCmdText
objCommandEvtDPA.CommandText="INSERT INTO DynamicsPerf..AOS_EVENTLOG VALUES (?,?,?,?,?,?)"

Set prmEvt1=objCommandEvtDPA.CreateParameter ("", adVarWChar,adParamInput,23)
Set prmEvt2=objCommandEvtDPA.CreateParameter ("", adVarWChar,adParamInput,255)
Set prmEvt3=objCommandEvtDPA.CreateParameter ("", adInteger,adParamInput)
Set prmEvt4=objCommandEvtDPA.CreateParameter ("", adVarWChar,adParamInput,255)
Set prmEvt5=objCommandEvtDPA.CreateParameter ("", adlongVarWChar,adParamInput,32768)
Set prmEvt6=objCommandEvtDPA.CreateParameter ("", adVarWChar,adParamInput,255)

objCommandEvtDPA.Parameters.Append prmEvt1
objCommandEvtDPA.Parameters.Append prmEvt2
objCommandEvtDPA.Parameters.Append prmEvt3
objCommandEvtDPA.Parameters.Append prmEvt4
objCommandEvtDPA.Parameters.Append prmEvt5
objCommandEvtDPA.Parameters.Append prmEvt6

objCommandRegDPA.ActiveConnection=objConnectionDPA
objCommandRegDPA.CommandType=adCmdText
objCommandRegDPA.CommandText="INSERT INTO DynamicsPerf..AOS_REGISTRY VALUES (?,?,?,?,?,?,?,?)"

Set prmReg1=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,255)
Set prmReg2=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,5)
Set prmReg3=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,255)
Set prmReg4=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,25)
Set prmReg5=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,255)
Set prmReg6=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,1)
Set prmReg7=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,255)
Set prmReg8=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,8000)

objCommandRegDPA.Parameters.Append prmReg1
objCommandRegDPA.Parameters.Append prmReg2
objCommandRegDPA.Parameters.Append prmReg3
objCommandRegDPA.Parameters.Append prmReg4
objCommandRegDPA.Parameters.Append prmReg5
objCommandRegDPA.Parameters.Append prmReg6
objCommandRegDPA.Parameters.Append prmReg7
objCommandRegDPA.Parameters.Append prmReg8

objConnectionDPA.Execute "SET DATEFORMAT MDY"
objConnectionDPA.Execute "TRUNCATE TABLE DynamicsPerf..AOS_EVENTLOG"
objConnectionDPA.Execute "TRUNCATE TABLE DynamicsPerf..AOS_REGISTRY"

objRecordset.Open strRecordset, objConnection


Do While Not objRecordset.EOF


				strAOS =  objRecordset.Fields(0) 


				On Error Resume Next

				Set objWMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!\\" & strAOS & "\root\cimv2")
				if Err.Number <> 0 then
							set objWMIService = nothing
							err.clear
				Else
				Set objWMIService = Nothing


				AOSevt(strAOS)
				AOSreg(strAOS)

		end IF
		on error goto 0
		objRecordset.MoveNext 
Loop

Set objConnection=nothing
Set objRecordset=nothing
set objCommandEvt=nothing
set objCommandReg=nothing


Set objConnectionDPA=nothing
Set objRecordsetDPA=nothing
set objCommandEvtDPA=nothing
set objCommandRegDPA=nothing



Sub AOSevt(strAOS)
  
    Const CONVERT_TO_LOCAL_TIME = True
    Set dtmStartDate = CreateObject("WbemScripting.SWbemDateTime")
    DateToCheck = CDate(DATE - 14)
    dtmStartDate.SetVarDate DateToCheck, CONVERT_TO_LOCAL_TIME
    Set objWMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!\\" & strAOS & "\root\cimv2")
    Set colLoggedEvents = objWMIService.ExecQuery _
	    ("Select * from Win32_NTLogEvent Where Logfile = ''Application'' and (eventtype = 1 or eventtype = 2 or (eventtype = 3 and eventcode = 149)) and  TimeWritten >= ''" & dtmStartDate & "''")
    For Each objEvent in colLoggedEvents
        prmEvt1.value=cUTC2Lt(objEvent.TimeWritten)
        prmEvt2.value=objEvent.ComputerName
        prmEvt3.value=objEvent.EventCode
        prmEvt4.value=objEvent.Type
        prmEvt5.value=left(objEvent.Message, 256)
        prmEvt6.value=objEvent.SourceName
        objCommandEvtDPA.Execute
    Next	
End Sub

Sub AOSreg(strAOS)
    Const HKLM = &H80000002
    Set ObjReg=GetObject("winmgmts:{impersonationLevel=impersonate}!\\" & StrAOS & "\root\default:StdRegProv")
    StrKeyPath = "System\CurrentControlSet\Services\Dynamics Server"
    ObjReg.EnumKey HKLM, StrKeyPath, ArrVersions
    For Each StrVersion In ArrVersions
        ObjReg.EnumKey HKLM, StrKeyPath & "\" & StrVersion, ArrInstances
        If IsArray(ArrInstances) Then
            For Each StrInstance In ArrInstances 
                objReg.GetStringValue HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance, "InstanceName", strInstanceName 
                objReg.GetStringValue HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance, "Current", strCurrentConfig 
                objReg.GetStringValue HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance, "ProductVersion", strProductVersion 
                ObjReg.EnumKey HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance, ArrConfigs
                    For Each StrConfig In ArrConfigs
                        If StrConfig = StrCurrentConfig Then
                            strActive = "Y"
                        Else
                            strActive = "N"
                        End if
                        ObjReg.EnumValues HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance & "\" & StrConfig, ArrValueNames,  ArrValueTypes
                        For I=0 To UBound(arrValueNames) 
                            StrValueName = arrValueNames(I)           
                            Select Case arrValueTypes(I)
                                Case REG_SZ
                                    objReg.GetStringValue HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance & "\" & StrConfig, strValueName, strValue
                                Case REG_EXPAND_SZ
                                    objReg.GetExpandedStringValue HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance & "\" & StrConfig, strValueName, strValue
                                Case REG_BINARY
                                     objReg.GetBinaryValue  HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance & "\" & StrConfig, strValueName, strValue
                                Case REG_DWORD
                                     objReg.GetDWORDValue HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance & "\" & StrConfig, strValueName, strValue
                                Case REG_MULTI_SZ
                                     objReg.GetMultiStringValue  HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance & "\" & StrConfig, strValueName, strValue
                            End Select        
                            prmReg1.value=StrAOS
                            prmReg2.value=StrVersion
                            prmReg3.value=strInstanceName
                            prmReg4.value=StrProductVersion
                            prmReg5.value=StrConfig
                            prmReg6.value=strActive
                            prmReg7.value=StrValueName
                            prmReg8.value=StrValue
                            objCommandRegDPA.Execute
                        Next
                    Next
            Next
        End If
    Next
End Sub

Function cUTC2Lt(WMITime)
''   Convert UTC Time from Event Log to DateTime format compatible with SQL Server DateTime data type
   	Dim strDate, strTime
   	Dim yyyy : yyyy = left(WMITime,4) ''year
   	Dim mm   : mm = mid(WMITime,5,2)  ''month
   	Dim dd   : dd = mid(WMITime,7,2)  ''day
   	Dim hh   : hh = mid(WMITime,9,2)  ''hour
   	Dim mn   : mn = mid(WMITime,11,2) ''minutes
   	Dim ss   : ss = mid(WMITime,13,2) ''seconds
   	Dim ms   : ms = mid(WMITime,16,6) ''microseconds
 ''  	strDate = mm & "-" & dd & "-" & yyyy
	strDate = yyyy & "-" & mm & "-" & dd
      	strTime = hh & ":" & mn & ":" & ss
      	cUTC2Lt = strDate & " " & strTime
End Function


', 
		@database_name=N'VBScript', 
		@flags=0
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'DAILY', 
		@enabled=1, 
		@freq_type=4, 
		@freq_interval=1, 
		@freq_subday_type=1, 
		@freq_subday_interval=0, 
		@freq_relative_interval=0, 
		@freq_recurrence_factor=0, 
		@active_start_date=20150919, 
		@active_end_date=99991231, 
		@active_start_time=60000, 
		@active_end_time=235959

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
COMMIT TRANSACTION
GOTO EndSave
QuitWithRollback:
    IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
EndSave:

GO





/********************** END OF SQL JOBS ***********************************/






--Insert  blank record for Dynamics AX cursors, so we only have 1 plan for fetch api_cursor calls  otherwise we'll insert a plan for every fetch api_cursor sitting in procedure cache
--     this record will be deleted after a week by the purge_stats job if it's not needed.
--INSERT INTO [DynamicsPerf]..QUERY_PLANS VALUES(0x0000000000000000,'<ShowPlanXML xmlns="http://schemas.microsoft.com/sqlserver/2004/07/showplan" Version="1.1" Build="10.50.1765.0"><BatchSequence><Batch><Statements><StmtCursor StatementText="FETCH API_CURSOR Look for another QUERY_STATS record with a creation time close to this record" StatementId="1" StatementCompId="9" StatementType="FETCH CURSOR"><CursorPlan CursorName="API_CURSOR00000000000000B3" /></StmtCursor></Statements></Batch></BatchSequence></ShowPlanXML>','',0)



PRINT '-----------------------------------------------------------------------------------------'
PRINT '-- Be sure to complete Steps 2-10 as appropriate in the Simple Installation.txt							'
PRINT '-----------------------------------------------------------------------------------------'
PRINT ''
PRINT '-----------------------------------------------------------------------------------------'
PRINT '-- 												'
PRINT '-- PLEASE VISIT HTTP://BLOGS.MSDN.COM/AXINTHEFIELD  for details on this tool			'
PRINT '-- 												'
PRINT '-----------------------------------------------------------------------------------------'

GO

GO
PRINT N'Update complete.';


GO
