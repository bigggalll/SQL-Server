/*
Deployment script for DynamicsPerf

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;



GO
USE [DynamicsPerf];


ALTER DATABASE [DynamicsPerf] SET ANSI_NULL_DEFAULT OFF 

ALTER DATABASE [DynamicsPerf] SET ANSI_NULLS OFF 

ALTER DATABASE [DynamicsPerf] SET ANSI_PADDING OFF 

ALTER DATABASE [DynamicsPerf] SET ANSI_WARNINGS OFF 

ALTER DATABASE [DynamicsPerf] SET ARITHABORT OFF 

ALTER DATABASE [DynamicsPerf] SET AUTO_CLOSE OFF 

ALTER DATABASE [DynamicsPerf] SET AUTO_CREATE_STATISTICS ON 

ALTER DATABASE [DynamicsPerf] SET AUTO_SHRINK OFF 

ALTER DATABASE [DynamicsPerf] SET AUTO_UPDATE_STATISTICS ON 

ALTER DATABASE [DynamicsPerf] SET CURSOR_CLOSE_ON_COMMIT OFF 

ALTER DATABASE [DynamicsPerf] SET CURSOR_DEFAULT  GLOBAL 

ALTER DATABASE [DynamicsPerf] SET CONCAT_NULL_YIELDS_NULL OFF 

ALTER DATABASE [DynamicsPerf] SET NUMERIC_ROUNDABORT OFF 

ALTER DATABASE [DynamicsPerf] SET QUOTED_IDENTIFIER OFF 

ALTER DATABASE [DynamicsPerf] SET RECURSIVE_TRIGGERS OFF 

ALTER DATABASE [DynamicsPerf] SET  ENABLE_BROKER 

ALTER DATABASE [DynamicsPerf] SET AUTO_UPDATE_STATISTICS_ASYNC OFF 

ALTER DATABASE [DynamicsPerf] SET DATE_CORRELATION_OPTIMIZATION OFF 

ALTER DATABASE [DynamicsPerf] SET TRUSTWORTHY OFF 

ALTER DATABASE [DynamicsPerf] SET READ_COMMITTED_SNAPSHOT ON

ALTER DATABASE [DynamicsPerf] SET ALLOW_SNAPSHOT_ISOLATION ON

ALTER DATABASE [DynamicsPerf] SET PARAMETERIZATION SIMPLE 

ALTER DATABASE [DynamicsPerf] SET  READ_WRITE 

ALTER DATABASE [DynamicsPerf] SET RECOVERY SIMPLE 

ALTER DATABASE [DynamicsPerf] SET  MULTI_USER 

ALTER DATABASE [DynamicsPerf] SET PAGE_VERIFY NONE  

ALTER DATABASE [DynamicsPerf] SET DB_CHAINING OFF 

GO
/*
The column [dbo].[AX_SQLTRACE_CONFIG].[Id] is being dropped, data loss could occur.
*/

declare @n char(1)
set @n = char(10)

declare @stmt nvarchar(max)

select @stmt = isnull( @stmt + @n, '' ) +
'drop synonym [' + SCHEMA_NAME(schema_id) + '].[' + name + ']'
from sys.synonyms

exec sp_executesql @stmt


go

TRUNCATE TABLE AX_SQLTRACE_CONFIG

TRUNCATE TABLE QUERY_PLANS_PARSED
UPDATE QUERY_PLANS SET PARSED_FLAG = 0


IF EXISTS (select top 1 1 from [dbo].[AX_SQLTRACE_CONFIG])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO

GO
PRINT N'Altering [dbo].[AX_SQLTRACE_CONFIG]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
IF EXISTS(SELECT * FROM sys.columns 
            WHERE Name = N'Id' AND Object_ID = Object_ID(N'AX_SQLTRACE_CONIFG'))
BEGIN
ALTER TABLE [dbo].[AX_SQLTRACE_CONFIG] DROP COLUMN [Id];
END


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[QUERY_STATS]...';


GO
ALTER TABLE [dbo].[QUERY_STATS] DROP COLUMN [AVG_TIME_MS], COLUMN [WAIT_TIME_MS];


GO
ALTER TABLE [dbo].[QUERY_STATS]
    ADD [WAIT_TIME_MS] AS (CONVERT (DECIMAL (29, 3), ([TOTAL_ELAPSED_TIME] - [TOTAL_WORKER_TIME]) / (1000), (0))),
        [AVG_TIME_MS]  AS (CASE WHEN [EXECUTION_COUNT] > (0) THEN CONVERT (DECIMAL (29, 3), ([TOTAL_ELAPSED_TIME] / [EXECUTION_COUNT]) / (1000.000), (0)) ELSE (0) END);


GO
PRINT N'Creating [dbo].[QUERY_STATS].[IX_QUERY_STATS_SERVER]...';


GO

/****** Object:  Index [IX_QUERY_STATS_SERVER]    Script Date: 02/16/2016 09:17:59 ******/
IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[QUERY_STATS]') AND name = N'IX_QUERY_STATS_SERVER')
DROP INDEX [IX_QUERY_STATS_SERVER] ON [dbo].[QUERY_STATS] WITH ( ONLINE = OFF )
GO


/****** Object:  Index [IX_QUERY_STATS_SERVER]    Script Date: 02/16/2016 09:17:59 ******/
CREATE NONCLUSTERED INDEX [IX_QUERY_STATS_SERVER] ON [dbo].[QUERY_STATS] 
(
	[SERVER_NAME] ASC,
	[DATABASE_NAME] ASC,
	[STATS_TIME] ASC,
	[QUERY_HASH] ASC
)
GO




GO
PRINT N'Creating [dbo].[QUERY_PLANS].[IX_QUERY_PLANS_PARSED_HASH]...';


GO


/****** Object:  Index [IX_QUERY_PLANS_PARSED_HASH]    Script Date: 02/16/2016 09:19:30 ******/
IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[QUERY_PLANS]') AND name = N'IX_QUERY_PLANS_PARSED_HASH')
DROP INDEX [IX_QUERY_PLANS_PARSED_HASH] ON [dbo].[QUERY_PLANS] WITH ( ONLINE = OFF )
GO


/****** Object:  Index [IX_QUERY_PLANS_PARSED_HASH]    Script Date: 02/16/2016 09:19:30 ******/
CREATE CLUSTERED INDEX [IX_QUERY_PLANS_PARSED_HASH] ON [dbo].[QUERY_PLANS] 
(
	[SERVER_NAME] ASC,
	[DATABASE_NAME] ASC,
	[QUERY_PLAN_HASH] ASC
)



GO
PRINT N'Refreshing [dbo].[MISSING_INDEXES_CURR_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[MISSING_INDEXES_CURR_VW]';


GO
PRINT N'Refreshing [dbo].[MISSING_INDEXES_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[MISSING_INDEXES_VW]';


GO
PRINT N'Refreshing [dbo].[QUERY_STATS_CTE_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[QUERY_STATS_CTE_VW]';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Refreshing [dbo].[QUERY_STATS_CURR_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[QUERY_STATS_CURR_VW]';


GO
PRINT N'Refreshing [dbo].[QUERY_STATS_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[QUERY_STATS_VW]';


GO
PRINT N'Refreshing [dbo].[HIDDEN_SCANS_CURR_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[HIDDEN_SCANS_CURR_VW]';


GO
PRINT N'Refreshing [dbo].[USER_SCANS_CURR_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[USER_SCANS_CURR_VW]';


GO
PRINT N'Creating [dbo].[QUERY_ALERTS_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;

/****** Object:  View [dbo].[QUERY_ALERTS_VW]    Script Date: 02/16/2016 09:15:19 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[QUERY_ALERTS_VW]'))
DROP VIEW [dbo].[QUERY_ALERTS_VW]
GO

GO
CREATE VIEW [dbo].[QUERY_ALERTS_VW]
	AS 

	SELECT QA.SERVER_NAME,
       QA.DATABASE_NAME,
       QA.STATS_TIME                                                                                                                                                                           AS ALERT_TIME,
       QA.QUERY_HASH,
       QA.QUERY_PLAN_HASH,
       QHD.EXECUTION_COUNT_TODAY                                                                                                                                                               AS EXECUTIONS_TODAY,
       CAST(QHD.ELAPSED_TIME_TODAY / 1000.000 AS DECIMAL(20, 3))                                                                                                                               AS TOTAL_TIME_TODAY,
       QHD.AVG_TIME_TODAY_MS                                                                                                                                                                   AS AVG_TIME_TODAY,
       CAST(QHD.MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(20, 3))                                                                                                                                 AS MAX_ELAPSED_TIME,
       REPLACE(REPLACE(QT.SQL_TEXT, 'SELECT ', CHAR(10)+'SELECT '), ' FROM', CHAR(10)+' FROM')
       + CHAR(10) + CHAR(10) + REPLICATE('-', 50)
       + 'QUERY PARAMETERS' + REPLICATE('-', 61)
       + CHAR(10) + QP.SQL_PARMS + CHAR(10) + CHAR(10)
       + REPLICATE('-', 50)
       + 'TABLE NODES FROM QUERY PLAN'
       + REPLICATE('-', 50) + CHAR(10)
       + ISNULL((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE QA.SERVER_NAME = QPV.SERVER_NAME AND QA.DATABASE_NAME = QPV.DATABASE_NAME AND QA.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '') AS QUERY_PLAN_PARSED,
       ISNULL((SELECT MISSING_INDEX_INFO
               FROM   QUERY_PLANS_MISSING_INDEX_VW QPV
               WHERE  QA.SERVER_NAME = QPV.SERVER_NAME
                      AND QA.DATABASE_NAME = QPV.DATABASE_NAME
                      AND QA.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '')                                                                                                                       AS MISSING_INDEXES,
       QP.SQL_PARMS                                                                                                                                                                            AS QUERY_PARAMETER_VALUES,
       QP.QUERY_PLAN,
       QT.SQL_TEXT
FROM   QUERY_ALERTS QA WITH (NOLOCK)
       INNER JOIN QUERY_HISTORY QHD
               ON QA.SERVER_NAME = QHD.SERVER_NAME
                  AND QA.DATABASE_NAME = QHD.DATABASE_NAME
                  AND QA.QUERY_HASH = QHD.QUERY_HASH
                  AND QA.QUERY_PLAN_HASH = QHD.QUERY_PLAN_HASH
				  AND QHD.FLAG = 'D'
                  AND QHD.DATE = DATEADD(day, DATEDIFF(day, 0, QA.STATS_TIME), 0)
       INNER LOOP JOIN QUERY_PLANS QP WITH (NOLOCK)
                    ON QP.QUERY_PLAN_HASH = QA.QUERY_PLAN_HASH
                       AND QP.SERVER_NAME = QA.SERVER_NAME
                       AND QP.DATABASE_NAME = QA.DATABASE_NAME
       LEFT OUTER LOOP JOIN QUERY_TEXT AS QT
                         ON QA.QUERY_HASH = QT.QUERY_HASH
                            AND QA.SERVER_NAME = QT.SERVER_NAME
                            AND QA.DATABASE_NAME = QT.DATABASE_NAME
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[DYNPERF_SET_AX_SQLTRACE]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_SET_AX_SQLTRACE]
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @AX_TRACE_ON BIT, @SQL_DURATION INT, @AXDB_DELETION_DAYS INT=0
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SETAXSQLTRACE')
  EXEC ('DROP SYNONYM [dbo].DYN_SETAXSQLTRACE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SETAXSQLTRACE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXSTOR_AX_SQLSTORAGE
				FOR [' + @DATABASE_NAME + '].dbo.USERINFO'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AX_SYSTRACETABLESQL')
  EXEC ('DROP SYNONYM [dbo].DYN_AX_SYSTRACETABLESQL')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLESQL
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLESQL
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AX_SYSTRACETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AX_SYSTRACETABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLE
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AX_SYSTRACETABLESQLEXECPLAN')
  EXEC ('DROP SYNONYM [dbo].DYN_AX_SYSTRACETABLESQLEXECPLAN')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLESQLEXECPLAN
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQLEXECPLAN'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLESQLEXECPLAN
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQLEXECPLAN'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AX_SYSTRACETABLESQLTABREF')
  EXEC ('DROP SYNONYM [dbo].DYN_AX_SYSTRACETABLESQLTABREF')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLESQLTABREF
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQLTABREF'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AX_SYSTRACETABLESQLTABREF
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQLTABREF'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

SELECT @AX_TRACE_ON = TRACE_ON, @SQL_DURATION = SQL_DURATION , @AXDB_DELETION_DAYS = AXDB_DELETION_DAYS
FROM AX_SQLTRACE_CONFIG 
WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME

IF @@ROWCOUNT = 0 GOTO ENDPROC

IF @AX_TRACE_ON = 1
BEGIN
		UPDATE DS
		SET    QUERYTIMELIMIT = @SQL_DURATION,
			   DEBUGINFO = 268,
			   TRACEINFO = 2048
		FROM   DYN_SETAXSQLTRACE DS 
			
END

IF @AX_TRACE_ON = 0 
BEGIN
		UPDATE DS
		SET    QUERYTIMELIMIT = 0,
				DEBUGINFO = 12,
				TRACEINFO = 0
		FROM   DYN_SETAXSQLTRACE DS 
		WHERE QUERYTIMELIMIT = 5000
END


IF @AXDB_DELETION_DAYS > 0
  BEGIN
      DELETE FROM DYN_AX_SYSTRACETABLE
      WHERE  CREATEDDATETIME <= DATEADD(DD, -14, GETDATE())

      DELETE FROM DYN_AX_SYSTRACETABLESQL
      WHERE  CREATEDDATETIME <= DATEADD(DD, -14, GETDATE())

      DELETE SP
      FROM   DYN_AX_SYSTRACETABLESQLEXECPLAN SP
      WHERE  NOT EXISTS (SELECT RECID
                         FROM   DYN_AX_SYSTRACETABLE ST
                         WHERE  ST.RECID = SP.TRACERECID)

      DELETE SF
      FROM   DYN_AX_SYSTRACETABLESQLTABREF SF
      WHERE  NOT EXISTS (SELECT RECID
                         FROM   DYN_AX_SYSTRACETABLE ST
                         WHERE  ST.RECID = SF.TRACERECID)
  END 


ENDPROC:

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[SET_AX_SQLTRACE]...';


GO


ALTER PROCEDURE [dbo].[SET_AX_SQLTRACE] @SERVER_NAME NVARCHAR(128) = @@SERVERNAME,
								@DATABASE_NAME    NVARCHAR(128),
                                 @QUERY_TIME_LIMIT INT = 5000,
                                 @AX_ID            NVARCHAR(10) = NULL,
                                 @TRACE_STATUS     NVARCHAR(3) = 'ON', 
                               --  @CLIENTACESSLOG   INT = 0,
								 @OVERRIDE		INT = 0
AS

  DECLARE @SQL NVARCHAR(1000),
          @RC  INT

  SET @RC = 0

  IF NOT EXISTS (SELECT *
                 FROM   sys.databases
                 WHERE  name = @DATABASE_NAME)
    BEGIN
        PRINT @DATABASE_NAME + ' DOES NOT EXIST'
        SET @RC = 1
        GOTO ERROR
    END

IF @OVERRIDE = 0 AND @QUERY_TIME_LIMIT < 5000 SET @QUERY_TIME_LIMIT = 5000

  IF @TRACE_STATUS = 'ON'
    BEGIN
        
          SET @SQL = 'UPDATE [' +@SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO
				SET QUERYTIMELIMIT = ' + Str(@QUERY_TIME_LIMIT) + ',
					DEBUGINFO =  268,
					TRACEINFO =  2048'
			IF @AX_ID IS NOT NULL	
			SET @SQL = @SQL + 	' WHERE ID = ''' + @AX_ID + ''''	
			

				MERGE AX_SQLTRACE_CONFIG AS target
				USING (SELECT @SERVER_NAME AS SERVER_NAME,
							  @DATABASE_NAME AS DATABASE_NAME,
							  @QUERY_TIME_LIMIT AS SQL_DURATION,
							  1                 AS TRACE_ON,		--REH Turns it ON
							  14 AS AXDB_DELETION_DAYS
) AS source
				ON ( source.SERVER_NAME = target.SERVER_NAME
					 AND source.DATABASE_NAME = target.DATABASE_NAME )
				WHEN MATCHED THEN
				  UPDATE SET SQL_DURATION = source.SQL_DURATION,
							 TRACE_ON = source.TRACE_ON
				WHEN NOT MATCHED THEN
				  INSERT ( [SERVER_NAME],
						   [DATABASE_NAME],
						   [SQL_DURATION],
						   [TRACE_ON],
						   [AXDB_DELETION_DAYS])
				  VALUES (source.[SERVER_NAME],
						  source.[DATABASE_NAME],
						  source.[SQL_DURATION],
						  source.[TRACE_ON],
						  14);		--REH default 14 days, DYNPERF_SET_AX_SQLTRACE sproc will delete from systracetable in the AX database using this value
									-- setting it to 0 disables this feature
			
			END
  ELSE
    IF @TRACE_STATUS = 'OFF'
      BEGIN
          IF @AX_ID IS NULL
            SET @SQL = 'UPDATE [' +@SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO
				SET QUERYTIMELIMIT = 0,
					DEBUGINFO =  12,
					TRACEINFO =  0'
					
			IF @AX_ID IS NOT NULL	
			SET @SQL = @SQL + 	' WHERE ID = ''' + @AX_ID + ''''	

        	--REH Insert a record so that our scheduled job auto updates it
MERGE AX_SQLTRACE_CONFIG AS target
				USING (SELECT @SERVER_NAME AS SERVER_NAME,
							  @DATABASE_NAME AS DATABASE_NAME,
							  @QUERY_TIME_LIMIT AS SQL_DURATION,
							  0                 AS TRACE_ON,		--REH Turns it OFF
							  14 AS AXDB_DELETION_DAYS
					  ) AS source
				ON ( source.SERVER_NAME = target.SERVER_NAME
					 AND source.DATABASE_NAME = target.DATABASE_NAME )
				WHEN MATCHED THEN
				  UPDATE SET SQL_DURATION = source.SQL_DURATION,
							 TRACE_ON = source.TRACE_ON
				WHEN NOT MATCHED THEN
				  INSERT ( [SERVER_NAME],
						   [DATABASE_NAME],
						   [SQL_DURATION],
						   [TRACE_ON],
						   [AXDB_DELETION_DAYS])
				  VALUES (source.[SERVER_NAME],
						  source.[DATABASE_NAME],
						  source.[SQL_DURATION],
						  source.[TRACE_ON],
						  14); --REH default 14 days, DYNPERF_SET_AX_SQLTRACE sproc will delete from systracetable in the AX database using this value
								-- setting it to 0 disables this feature
      END
    ELSE
      PRINT 'Invalid @TRACE_STATUS option; must be ON or OFF'

  PRINT @SQL
  EXEC (@SQL)
 

 
  ENDPROC:

  ERROR:

  RETURN @RC
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_QUERY_PLANS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_QUERY_PLANS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_QP_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_QP_STATS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_QP_STATS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.dm_exec_query_stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_QP_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_query_stats'

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @REMOTE_SERVER = 'N'
BEGIN
;WITH Query_Stats_CTE ( QUERY_PLAN_HASH, PLAN_HANDLE )
     AS
     -- Define the CTE query.
     (SELECT DISTINCT QUERY_PLAN_HASH,
                      PLAN_HANDLE
      FROM   QUERY_STATS AS QS
      WHERE  STATS_TIME >= @LAST_RUN
             AND DATABASE_NAME = @DATABASE_NAME
             AND SERVER_NAME = @SERVER_NAME 
             AND QUERY_PLAN_HASH > 0x00000000
             AND NOT EXISTS (SELECT 'X'
                             FROM   QUERY_PLANS QP
                             WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
                                    AND QS.DATABASE_NAME = QP.DATABASE_NAME
                                    AND QS.SERVER_NAME = QP.SERVER_NAME ))
INSERT INTO QUERY_PLANS
SELECT @SERVER_NAME,
       @DATABASE_NAME,
       QUERY_PLAN_HASH,
       QUERY_PLAN,
       '',
       0,
       0,
       GETDATE()
FROM   (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_PLAN_HASH
                        ORDER BY CTE.QUERY_PLAN_HASH DESC),
               CTE.QUERY_PLAN_HASH,
               query_plan AS QUERY_PLAN
        FROM   Query_Stats_CTE CTE
               OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH
WHERE  RN = 1 




END

IF @REMOTE_SERVER = 'Y'
     BEGIN
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)


         SET @SQL = '
				CREATE TABLE [tempdb].dbo.DYNPERF_QUERY_HASH
				(
				QUERY_PLAN_HASH VARBINARY(64), 
				PLAN_HANDLE VARBINARY(64)
				)'


         SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT [' + @SERVER_NAME
									 + ']'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

         SET @SQL = '

					;WITH Query_Stats_CTE ( QUERY_PLAN_HASH, PLAN_HANDLE)
						 AS (SELECT DISTINCT QUERY_PLAN_HASH,
										  PLAN_HANDLE
							 FROM   QUERY_STATS QS
							 WHERE  QS.STATS_TIME >= ' + ''''
										+ CONVERT(NVARCHAR(24), @LAST_RUN, 121)
										+ ''''
										+ '
									AND DATABASE_NAME = '
										+ '''' + @DATABASE_NAME + ''''
										+ '
									AND SERVER_NAME = ' + '''' +
										+ @SERVER_NAME + ''''
										+ ' 
									AND NOT EXISTS (SELECT ''X''
													FROM   QUERY_PLANS QP
												 WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
														AND QS.DATABASE_NAME = QP.DATABASE_NAME
														AND QS.SERVER_NAME = QP.SERVER_NAME 
													))
						INSERT INTO OPENQUERY([' + @SERVER_NAME
										+ '], ''SELECT QUERY_PLAN_HASH, PLAN_HANDLE FROM '
										+ '[tempdb].dbo.DYNPERF_QUERY_HASH'')
					                            
					  
					SELECT QUERY_PLAN_HASH, PLAN_HANDLE 
					FROM   (SELECT RN = ROW_NUMBER()
										  OVER (
											PARTITION BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE
											ORDER BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE DESC),
								   CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE 
					            
								FROM   Query_Stats_CTE CTE
							   ) AS RH
					WHERE  RN = 1 '

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END 


         EXEC(@SQL)

			SET @SQL = 'SELECT 
				   QUERY_PLAN_HASH,
				   cast(query_plan as nvarchar(max)) as QUERY_PLAN

			FROM   (SELECT RN = ROW_NUMBER()
								  OVER (
									PARTITION BY QUERY_PLAN_HASH
									ORDER BY QUERY_PLAN_HASH DESC),
						   QUERY_PLAN_HASH,
						   query_plan 
					FROM   [tempdb].dbo.DYNPERF_QUERY_HASH CTE
						   OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH
			WHERE  RN = 1 ' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  INSERT INTO DynamicsPerf.dbo.QUERY_PLANS
						 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + ''''
					+ @DATABASE_NAME + ''''
					+ ',
		                    QUERY_PLAN_HASH, CAST(QUERY_PLAN AS XML), ' + QUOTENAME('','''') + ',0,0,GETDATE() FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ')' --RH '
					--		RH.QUERY_PLAN_HASH, RH.QUERY_PLAN, '''', 0, 0, GETDATE() FROM OPENQUERY(['
					--+ @SERVER_NAME + '], ' + ''' + @SQL + ''' + ') RH ' 

		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)
         

		 --REH Drop the table at the end of the process

         SET @SQL = '

				IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
				 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)
     
     END 





UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SQL_TEXT]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SQL_TEXT (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



IF @REMOTE_SERVER = 'N'
     BEGIN ;
         WITH Query_Stats_CTE ( QUERY_HASH)
              AS (SELECT QUERY_HASH
                  FROM   QUERY_STATS QS
                  WHERE  QS.STATS_TIME >= @LAST_RUN
                         AND DATABASE_NAME = @DATABASE_NAME
                         AND SERVER_NAME = @SERVER_NAME 
                         AND NOT EXISTS (SELECT 'X'
                                         FROM   QUERY_TEXT QT
                                         WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                                AND QS.SERVER_NAME = QT.SERVER_NAME ))
         INSERT QUERY_TEXT
         SELECT @SERVER_NAME,
                @DATABASE_NAME,
                QUERY_HASH,
                SQL_TEXT,
				@STATS_DATE
         FROM   (SELECT RN = ROW_NUMBER()
                               OVER (
                                 PARTITION BY CTE.QUERY_HASH
                                 ORDER BY CTE.QUERY_HASH DESC),
                        qs.query_hash                                                                                              AS QUERY_HASH,
                        SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                        WHEN -1 THEN DATALENGTH(st.text)
                                                                                        ELSE qs.statement_end_offset
                                                                                      END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
                 FROM   Query_Stats_CTE CTE
                        INNER JOIN sys.dm_exec_query_stats AS qs
                                ON CTE.QUERY_HASH = qs.query_hash
                        OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                        CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
                 WHERE  attribute = N'dbid'
                        AND DB_NAME(CONVERT(INT, value)) = @DATABASE_NAME
                        AND last_execution_time >= @LAST_RUN
						) AS RH
         WHERE  RN = 1
     END 


 IF @REMOTE_SERVER = 'Y'
 BEGIN
 


				 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)



 SET @SQL = '
CREATE TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH
(
QUERY_HASH VARBINARY(64)
)' 



 SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  EXEC ('+'"' + @SQL +'"' + ') AT [' + @SERVER_NAME + ']'
  
 IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END

EXEC (@SQL2)


SET @SQL = '

;WITH Query_Stats_CTE ( QUERY_HASH)
     AS (SELECT QUERY_HASH
         FROM   QUERY_STATS QS
         WHERE  QS.STATS_TIME >= '  +'''' + CONVERT(NVARCHAR(24), @LAST_RUN, 121) +'''' +  '
                AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + '
                AND SERVER_NAME = ' + '''' + +@SERVER_NAME + '''' + ' 
                AND NOT EXISTS (SELECT ''X''
                                FROM   QUERY_TEXT QT
                                WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                AND QS.SERVER_NAME = QT.SERVER_NAME 
                                ))
INSERT INTO OPENQUERY([' + @SERVER_NAME + '], ''SELECT QUERY_HASH FROM  [tempdb].dbo.DYNPERF_QUERY_HASH'')

SELECT QUERY_HASH
FROM   (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_HASH
                        ORDER BY CTE.QUERY_HASH DESC),
               QUERY_HASH 
            
            FROM   Query_Stats_CTE CTE
           ) AS RH
WHERE  RN = 1 '

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


EXEC (@SQL)


        
 SET @SQL = '
         SELECT QUERY_HASH, SQL_TEXT
         FROM (
         SELECT RN = ROW_NUMBER() OVER (PARTITION BY CTE.QUERY_HASH ORDER BY CTE.QUERY_HASH DESC),
          qs.query_hash AS QUERY_HASH,
                         SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                         WHEN -1 THEN DATALENGTH(st.text)
                                                                                         ELSE qs.statement_end_offset
                                                                                       END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
         FROM    [tempdb].dbo.DYNPERF_QUERY_HASH CTE
                INNER JOIN sys.dm_exec_query_stats AS qs
                        ON CTE.QUERY_HASH = qs.query_hash
                OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
         WHERE  attribute = N''dbid''
                AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
                ) AS RH  
                WHERE RN = 1 '
PRINT ''
PRINT ''
                  
IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  INSERT INTO DynamicsPerf.dbo.QUERY_TEXT
				 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + '''' + @DATABASE_NAME + '''' + ',
                    
                    RH.*, ' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + ' FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END
				 
				 EXECUTE (@SQL2)
				 
 --REH  Delete the table back out
 
 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

 
 END
 
    

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_PROCESS_QUERY_ALERTS]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PROCESS_QUERY_ALERTS]
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @PCT_AVG_TIME_CHANGE_DAY int, @PCT_AVG_TIME_CHANGE_MONTH INT
	DECLARE @MIN_EXECUTION_COUNTS INT, @MIN_AVG_TIME_MS INT
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




SELECT @PCT_AVG_TIME_CHANGE_DAY = PCT_AVG_TIME_CHANGE_DAY,
       @PCT_AVG_TIME_CHANGE_MONTH = PCT_AVG_TIME_CHANGE_MONTH,
       @MIN_EXECUTION_COUNTS = MIN_EXECUTION_COUNTS,
       @MIN_AVG_TIME_MS = MIN_AVG_TIME_MS
FROM   QUERY_ALERTS_CONFIG
WHERE  SERVER_NAME = @SERVER_NAME
       AND DATABASE_NAME = @DATABASE_NAME 


--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
  --REH in this case, we are going to compare to STATS_TIME which is the DynamicsPerf Time Zone so convert last_run back into that time

     SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset

  END 


  IF @PCT_AVG_TIME_CHANGE_DAY IS NULL RETURN(0)  --REH No settings for this server/db just return and do nothing

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH SAME QUERY_HASH/PLAN_HASH , true parm sniffing query issue

INSERT QUERY_ALERTS
SELECT DISTINCT QS_CTE.SERVER_NAME,
       QS_CTE.STATS_TIME,
       QS_CTE.DATABASE_NAME,
       QS_CTE.QUERY_HASH,
       QS_CTE.QUERY_PLAN_HASH
FROM    (SELECT SERVER_NAME,
					   DATABASE_NAME,
					   STATS_TIME,
					   QUERY_HASH,
					   QUERY_PLAN_HASH,
					   SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                               AS TOTAL_TIME_MS,
					   SUM(EXECUTIONS_THIS_PERIOD)                                                            AS TOTAL_EXECUTIONS,
					   CASE SUM(EXECUTIONS_THIS_PERIOD)
						 WHEN 0 THEN 0
						 ELSE ( SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3))) / SUM(EXECUTIONS_THIS_PERIOD) )
					   END                                                                                    AS AVG_TIME_MS,
					   SUM(CAST(WORKER_TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                        AS WORK_TIME,
					   SUM(CAST(( TIME_THIS_PERIOD - WORKER_TIME_THIS_PERIOD ) / 1000.000 AS DECIMAL(14, 3))) AS WAIT_TIME
			FROM   QUERY_STATS_CTE_VW CTE
			WHERE  
				--QS.SERVER_NAME = CTE.SERVER_NAME AND QS.DATABASE_NAME=CTE.DATABASE_NAME AND
				--QS.STATS_TIME = CTE.STATS_TIME 
				--AND QS.QUERY_HASH = CTE.QUERY_HASH AND QS.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH AND
				 CTE.DATABASE_NAME = @DATABASE_NAME AND CTE.SERVER_NAME = @SERVER_NAME
				AND CTE.STATS_TIME > @LAST_RUN

			GROUP  BY SERVER_NAME,
						DATABASE_NAME,
				         STATS_TIME,
						QUERY_HASH,
						QUERY_PLAN_HASH) AS QS_CTE

       INNER JOIN QUERY_HISTORY QHD
               ON QHD.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHD.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHD.QUERY_HASH = QS_CTE.QUERY_HASH
                  AND QHD.QUERY_PLAN_HASH = QS_CTE.QUERY_PLAN_HASH
                  AND QHD.FLAG = 'D'
                  AND QHD.DATE = DATEADD(DAY, DATEDIFF(DAY, 0, QS_CTE.STATS_TIME), 0)
       INNER JOIN QUERY_HISTORY QHM
               ON QHM.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHM.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHM.QUERY_HASH = QS_CTE.QUERY_HASH
                  AND QHM.QUERY_PLAN_HASH = QS_CTE.QUERY_PLAN_HASH
                  AND QHM.FLAG = 'M'
                  AND QHM.DATE = DATEADD(MONTH, DATEDIFF(MONTH, 0, QS_CTE.STATS_TIME), 0)
WHERE  QS_CTE.SERVER_NAME = @SERVER_NAME
       AND QS_CTE.DATABASE_NAME = @DATABASE_NAME
       AND QS_CTE.STATS_TIME > @LAST_RUN
       AND ( ( QS_CTE.AVG_TIME_MS  > QHD.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_DAY/100
                OR QS_CTE.AVG_TIME_MS   > QHM.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_MONTH/100 )
             AND QS_CTE.AVG_TIME_MS   > @MIN_AVG_TIME_MS
             AND QS_CTE.TOTAL_EXECUTIONS > @MIN_EXECUTION_COUNTS ) 
			 option (maxdop 1)
--REH any variation 
INSERT QUERY_ALERTS
SELECT DISTINCT QS_CTE.SERVER_NAME,
       QS_CTE.STATS_TIME,
       QS_CTE.DATABASE_NAME,
       QS_CTE.QUERY_HASH,
       QS_CTE.QUERY_PLAN_HASH
FROM    (SELECT TOP 100 SERVER_NAME,
					   DATABASE_NAME,
					   STATS_TIME,
					   QUERY_HASH,
					   QUERY_PLAN_HASH,
					   SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                               AS TOTAL_TIME_MS,
					   SUM(EXECUTIONS_THIS_PERIOD)                                                            AS TOTAL_EXECUTIONS,
					   CASE SUM(EXECUTIONS_THIS_PERIOD)
						 WHEN 0 THEN 0
						 ELSE ( SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3))) / SUM(EXECUTIONS_THIS_PERIOD) )
					   END                                                                                    AS AVG_TIME_MS,
					   SUM(CAST(WORKER_TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                        AS WORK_TIME,
					   SUM(CAST(( TIME_THIS_PERIOD - WORKER_TIME_THIS_PERIOD ) / 1000.000 AS DECIMAL(14, 3))) AS WAIT_TIME
			FROM   QUERY_STATS_CTE_VW CTE
			WHERE  
				--QS.SERVER_NAME = CTE.SERVER_NAME AND QS.DATABASE_NAME=CTE.DATABASE_NAME AND
				--QS.STATS_TIME = CTE.STATS_TIME 
				--AND QS.QUERY_HASH = CTE.QUERY_HASH AND QS.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH AND
				 CTE.DATABASE_NAME = @DATABASE_NAME AND CTE.SERVER_NAME = @SERVER_NAME
				AND CTE.STATS_TIME > @LAST_RUN

			GROUP  BY SERVER_NAME,
						DATABASE_NAME,
				         STATS_TIME,
						QUERY_HASH,
						QUERY_PLAN_HASH) AS QS_CTE

       CROSS APPLY (SELECT SERVER_NAME, DATABASE_NAME, QUERY_HASH, MAX(QHD.AVG_TIME_TODAY_MS) AS AVG_TIME_TODAY_MS
				FROM  QUERY_HISTORY QHD
               WHERE QHD.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHD.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHD.QUERY_HASH = QS_CTE.QUERY_HASH
				  AND QHD.QUERY_PLAN_HASH <> QS_CTE.QUERY_PLAN_HASH
                  AND QHD.FLAG = 'D'
                  AND QHD.DATE = DATEADD(DAY, DATEDIFF(DAY, 0, QS_CTE.STATS_TIME), 0)
				  GROUP BY SERVER_NAME, DATABASE_NAME, QUERY_HASH
				  ) AS QHDAILY
       CROSS APPLY ( SELECT SERVER_NAME, DATABASE_NAME, QUERY_HASH, MAX(QHM.AVG_TIME_TODAY_MS) AS AVG_TIME_TODAY_MS
				FROM  QUERY_HISTORY QHM
               WHERE QHM.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHM.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHM.QUERY_HASH = QS_CTE.QUERY_HASH
				  AND QHM.QUERY_PLAN_HASH <> QS_CTE.QUERY_PLAN_HASH
                  AND QHM.FLAG = 'M'
                  AND QHM.DATE = DATEADD(MONTH, DATEDIFF(MONTH, 0, QS_CTE.STATS_TIME), 0)
				  GROUP BY SERVER_NAME, DATABASE_NAME, QUERY_HASH
				  ) AS QHMONTHLY
WHERE  QS_CTE.SERVER_NAME = @SERVER_NAME
       AND QS_CTE.DATABASE_NAME = @DATABASE_NAME
       AND QS_CTE.STATS_TIME > @LAST_RUN
       AND ( ( QS_CTE.AVG_TIME_MS  > QHDAILY.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_DAY/100
                OR QS_CTE.AVG_TIME_MS   > QHMONTHLY.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_MONTH/100 )
             AND QS_CTE.AVG_TIME_MS   > @MIN_AVG_TIME_MS
             AND QS_CTE.TOTAL_EXECUTIONS > @MIN_EXECUTION_COUNTS ) 
option (maxdop 1)



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_REFRESH_QUERY_PLANS]...';


GO
ALTER PROCEDURE [dbo].DYNPERF_REFRESH_QUERY_PLANS
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @REFRESH_PLAN_DAYS INT
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_RQP_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_RQP_STATS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_RQP_STATS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.dm_exec_query_stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_RQP_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_query_stats'

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


  SELECT @REFRESH_PLAN_DAYS = REFRESH_PLAN_DAYS FROM DATABASES_2_COLLECT WHERE LINKED_SERVER = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @REMOTE_SERVER = 'N'
BEGIN
;WITH Query_Stats_CTE ( QUERY_PLAN_HASH, PLAN_HANDLE )
     AS
     -- Define the CTE query.
     (SELECT DISTINCT QUERY_PLAN_HASH,
                      PLAN_HANDLE
      FROM   QUERY_STATS AS QS
      WHERE  STATS_TIME > DATEADD(D,-1,GETDATE())  --REH ANY QUERIES COLLECTED IN THE LAST DAY
             AND DATABASE_NAME = @DATABASE_NAME
             AND SERVER_NAME = @SERVER_NAME 
             AND QUERY_PLAN_HASH > 0x00000000
             AND  EXISTS (SELECT 'X'
                             FROM   QUERY_PLANS QP
                             WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
                                    AND QS.DATABASE_NAME = QP.DATABASE_NAME
                                    AND QS.SERVER_NAME = QP.SERVER_NAME 
									AND QP.DATE_UPDATED <= DATEADD(D,-@REFRESH_PLAN_DAYS,GETDATE() ) --REH ANY PLANS THAT HAVEN'T BEEN UPDATED IN THE LAST 7 DAYS
									))
UPDATE QUERY_PLANS
SET QUERY_PLAN = RH.QUERY_PLAN, DATE_UPDATED = GETDATE()
FROM   (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_PLAN_HASH
                        ORDER BY CTE.QUERY_PLAN_HASH DESC),
               CTE.QUERY_PLAN_HASH,
               query_plan AS QUERY_PLAN
        FROM   Query_Stats_CTE CTE
               OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH
WHERE  RN = 1 


END

IF @REMOTE_SERVER = 'Y'
     BEGIN
SET @SQL = '

IF EXISTS (SELECT * FROM  [' + @DATABASE_NAME + '].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
 DROP TABLE  [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)


         SET @SQL = '
				CREATE TABLE [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH
				(
				QUERY_PLAN_HASH VARBINARY(64), 
				PLAN_HANDLE VARBINARY(64)
				)'

		IF @DEBUG = 'Y'
		BEGIN
         PRINT @SQL
		 END


         SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT [' + @SERVER_NAME
									 + ']'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

         SET @SQL = '

					;WITH Query_Stats_CTE ( QUERY_PLAN_HASH, PLAN_HANDLE)
						 AS (SELECT DISTINCT QUERY_PLAN_HASH,
										  PLAN_HANDLE
							 FROM   QUERY_STATS QS
							 WHERE  QS.STATS_TIME >=  DATEADD(D,-1,GETDATE()) 
									AND DATABASE_NAME = '
										+ '''' + @DATABASE_NAME + ''''
										+ '
									AND SERVER_NAME = ' + '''' +
										+ @SERVER_NAME + ''''
										+ ' 
									AND EXISTS (SELECT ''X''
													FROM   QUERY_PLANS QP
												 WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
														AND QS.DATABASE_NAME = QP.DATABASE_NAME
														AND QS.SERVER_NAME = QP.SERVER_NAME 
														AND QP.DATE_UPDATED <= DATEADD(D,-7,GETDATE() ) 
													))
						INSERT INTO OPENQUERY([' + @SERVER_NAME
										+ '], ''SELECT QUERY_PLAN_HASH, PLAN_HANDLE FROM ['
										+ @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH'')
					                            
					  
					SELECT QUERY_PLAN_HASH, PLAN_HANDLE 
					FROM   (SELECT RN = ROW_NUMBER()
										  OVER (
											PARTITION BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE
											ORDER BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE DESC),
								   CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE 
					            
								FROM   Query_Stats_CTE CTE
							   ) AS RH
					WHERE  RN = 1 '

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END 


         EXEC(@SQL)

			SET @SQL = 'SELECT 
				   QUERY_PLAN_HASH,
				   cast(query_plan as nvarchar(max)) as QUERY_PLAN

			FROM   (SELECT RN = ROW_NUMBER()
								  OVER (
									PARTITION BY QUERY_PLAN_HASH
									ORDER BY QUERY_PLAN_HASH DESC),
						   QUERY_PLAN_HASH,
						   query_plan 
					FROM   [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH CTE
						   OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH
			WHERE  RN = 1 ' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  UPDATE DynamicsPerf.dbo.QUERY_PLANS
						 SET QUERY_PLAN =  RH.QUERY_PLAN, DATE_UPDATED = ' + '''' + CAST(GETDATE() AS VARCHAR(20)) + '''' 
						 + 'FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') AS RH' --RH '
					--		RH.QUERY_PLAN_HASH, RH.QUERY_PLAN, '''', 0, 0, GETDATE() FROM OPENQUERY(['
					--+ @SERVER_NAME + '], ' + ''' + @SQL + ''' + ') RH ' 

		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)
         

		 --REH Drop the table at the end of the process

         SET @SQL = '

				IF EXISTS (SELECT * FROM  [' + @DATABASE_NAME + '].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
				 DROP TABLE  [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)
     
     END 




UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_AX_VERSION_INFO]...';


GO

ALTER PROCEDURE DYNPERF_AX_VERSION_INFO (@AX_SERVER_NAME      NVARCHAR(128) = NULL,
                                          @AX_DATABASE_NAME    NVARCHAR(128),
                                          @DEBUG            NVARCHAR(1) = 'N')
                                      
AS
    /************************************************************************************************************
    *  SETUP
    *		DECLARE VARIABLES, CREATE SYNONYMS, ETC
    *
    *************************************************************************************************************/
    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL           NVARCHAR(MAX),
            @SQL2          NVARCHAR(MAX),
            @REMOTE_SERVER NVARCHAR(1),
			@AX_APP_BUILD_OUT NVARCHAR(120) ,
            @KERNEL_BUILD_OUT NVARCHAR(20),
			@AX_VERSION NVARCHAR(20)

    /*************************************************
    
    --REH Template for creating a synonym, 
    --Will help avoid having to use EXEC (@SQL) code
    -- and make the code more dynamic to the inputs
    
    
    ***************************************************/
    SET @REMOTE_SERVER = CASE @AX_SERVER_NAME
                           WHEN @@SERVERNAME THEN 'N'
                           ELSE 'Y'
                         END

    IF EXISTS (SELECT *
               FROM   sys.synonyms
               WHERE  name = 'DYN_AVI_AX_SYSSETUPLOG')
      DROP SYNONYM [dbo].DYN_AVI_AX_SYSSETUPLOG

    IF @REMOTE_SERVER = 'Y'
         BEGIN
             SET @SQL = '
				CREATE SYNONYM DYN_AVI_AX_SYSSETUPLOG
				FOR [' + @AX_SERVER_NAME + '].['
                        + @AX_DATABASE_NAME + '].dbo.SYSSETUPLOG'
         END
    ELSE
      SET @SQL = '
				CREATE SYNONYM DYN_AVI_AX_SYSSETUPLOG
				FOR [' + @AX_DATABASE_NAME
                 + '].dbo.SYSSETUPLOG'

    IF @DEBUG = 'Y'
         BEGIN
             PRINT '@SQL= ' + @SQL
         END

    EXEC (@SQL)

    IF EXISTS (SELECT *
               FROM   sys.synonyms
               WHERE  name = 'DYN_AVI_AX_SYSCONFIG')
      DROP SYNONYM [dbo].DYN_AVI_AX_SYSCONFIG

    IF @REMOTE_SERVER = 'Y'
         BEGIN
             SET @SQL = '
				CREATE SYNONYM DYN_AVI_AX_SYSCONFIG
				FOR [' + @AX_SERVER_NAME + '].['
                        + @AX_DATABASE_NAME + '].dbo.SYSCONFIG'
         END
    ELSE
      SET @SQL = '
				CREATE SYNONYM DYN_AVI_AX_SYSCONFIG
				FOR [' + @AX_DATABASE_NAME
                 + '].dbo.SYSCONFIG'

    IF @DEBUG = 'Y'
         BEGIN
             PRINT '@SQL= ' + @SQL
         END

    EXEC (@SQL)

     /********************************************************************************************************************************
     *   STARTING TASK
     *********************************************************************************************************************************/
     BEGIN TRY
         SELECT TOP 1 @KERNEL_BUILD_OUT = KERNELBUILD, @AX_VERSION = VERSION
         FROM   DYN_AVI_AX_SYSSETUPLOG WITH (NOLOCK)
         ORDER  BY RECID DESC

         SELECT TOP 1 @AX_APP_BUILD_OUT = VALUE
         FROM   DYN_AVI_AX_SYSCONFIG WITH (NOLOCK)
         WHERE  CONFIGTYPE = 4
                AND ID = 6

		IF ISNULL(@KERNEL_BUILD_OUT,'') = ''
			BEGIN
				SET @AX_APP_BUILD_OUT = @AX_VERSION  --REH work around for AX7 atm
				SET @KERNEL_BUILD_OUT = @AX_VERSION 
			END
		SELECT @AX_APP_BUILD_OUT AS AX_APP_BUILD, @KERNEL_BUILD_OUT AS AX_KERNEL_BUILD


		    IF EXISTS (SELECT *
               FROM   sys.synonyms
               WHERE  name = 'DYN_AVI_AX_SYSSETUPLOG')
      DROP SYNONYM [dbo].DYN_AVI_AX_SYSSETUPLOG

	      IF EXISTS (SELECT *
               FROM   sys.synonyms
               WHERE  name = 'DYN_AVI_AX_SYSCONFIG')
      DROP SYNONYM [dbo].DYN_AVI_AX_SYSCONFIG

     END TRY

     /********************************************************************************************************************************
     *   END OF TASK
     *********************************************************************************************************************************/
     BEGIN CATCH
         PRINT 'ERROR IN COLLECTING AX VERSION INFORAMTION '

		 		    IF EXISTS (SELECT *
               FROM   sys.synonyms
               WHERE  name = 'DYN_AVI_AX_SYSSETUPLOG')
      DROP SYNONYM [dbo].DYN_AVI_AX_SYSSETUPLOG

	      IF EXISTS (SELECT *
               FROM   sys.synonyms
               WHERE  name = 'DYN_AVI_AX_SYSCONFIG')
      DROP SYNONYM [dbo].DYN_AVI_AX_SYSCONFIG


     END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_AX_NUMBERSEQUENCE]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_AX_NUMBERSEQUENCE (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @ROW_COUNT BIGINT
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/


--REH All versions have this table so it's here in the code
-- version specific synonyms are in the appropriate AX version below


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCETABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCETABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCETABLE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCETABLE
				FOR [' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCETABLE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 











/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


--REH Get AX version

DECLARE @AX_SERVER_NAME   NVARCHAR(128) = NULL,
        @AX_DATABASE_NAME NVARCHAR(128),
        @AX_APP_BUILD     NVARCHAR(120),
        @KERNEL_BUILD     NVARCHAR(20)
   
   CREATE TABLE #AX_VERSION_NUM
     (
        AX_APP_BUILD NVARCHAR(120),
        KERNEL_BUILD NVARCHAR(20)
     )
   
   SET NOCOUNT ON
   
   INSERT #AX_VERSION_NUM
   EXECUTE DYNPERF_AX_VERSION_INFO
     @AX_SERVER_NAME = @SERVER_NAME,
     @AX_DATABASE_NAME = @DATABASE_NAME--, @DEBUG = 'N'
   SELECT @AX_APP_BUILD = AX_APP_BUILD,
          @KERNEL_BUILD = KERNEL_BUILD
   FROM   #AX_VERSION_NUM
   
   --PRINT 'AX BUILD = ' + ISNULL(@AX_APP_BUILD, '')
   
   --PRINT 'KERNEL BUILD = '+ ISNULL(@KERNEL_BUILD, '')
   
   IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = '#AX_VERSION_NUM') 
	BEGIN
	  DROP TABLE #AX_VERSION_NUM 
	END
   
   
  
IF Substring(@AX_APP_BUILD, 1, 1) BETWEEN N'4' AND N'5'
BEGIN



--REH  Have to check if the NUMBERSEQUENCETABLE is shared or not, aka. does DATAAREAID exist in the table

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSTABLES')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSTABLES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSTABLES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.tables'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSTABLES
				FOR [' + @DATABASE_NAME + '].sys.tables'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSCOLUMNS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSCOLUMNS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.columns'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSCOLUMNS
				FOR [' + @DATABASE_NAME + '].sys.columns'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


		--REH store data by company, most common scenario
		IF EXISTS (SELECT * FROM DYN_AXNUM_SYSTABLES t INNER JOIN DYN_AXNUM_SYSCOLUMNS c
		ON t.object_id=c.object_id
		WHERE t.name = 'NUMBERSEQUENCETABLE' AND c.name = 'DATAAREAID') 
		BEGIN
			INSERT INTO AX_NUM_SEQUENCES
			SELECT @SERVER_NAME,
				   @STATS_DATE,
				   @DATABASE_NAME,
				   0,
				   NUMBERSEQUENCE,
				   TXT,
				   LOWEST,
				   HIGHEST,
				   NEXTREC,
				   0,
				   0,
				   CASE CONTINUOUS
					 WHEN 0 THEN 'No'
					 WHEN 1 THEN 'Yes'
				   END,
				   FETCHAHEAD,
				   FETCHAHEADQTY,
				   0,
				   0,
				   NULL,
				   NULL,
				   DATAAREAID,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   FORMAT
			FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE 


		END
		ELSE
		BEGIN
		
			INSERT INTO AX_NUM_SEQUENCES
			SELECT @SERVER_NAME,
				   @STATS_DATE,
				   @DATABASE_NAME,
				   0,
				   NUMBERSEQUENCE,
				   TXT,
				   LOWEST,
				   HIGHEST,
				   NEXTREC,
				   0,
				   0,
				   CASE CONTINUOUS
					 WHEN 0 THEN 'No'
					 WHEN 1 THEN 'Yes'
				   END,
				   FETCHAHEAD,
				   FETCHAHEADQTY,
				   0,
				   0,
				   NULL,
				   NULL,
				   '',			--blank out dataareid, field doesn't exist
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   FORMAT
			FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE 


		
		END

		SET @ROW_COUNT = @@ROWCOUNT
	
END

--REH Synonyms for all version of AX2012 --------------------------------------------------

IF Substring(@AX_APP_BUILD, 1, 1) = '6'
BEGIN
	

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
 EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.DATAAREA'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @DATABASE_NAME + '].dbo.DATAAREA'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)
	
END



IF Substring(@AX_APP_BUILD, 1, 1) = '7'
BEGIN
	

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.DATAAREA'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @DATABASE_NAME + '].dbo.DATAAREA'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)
	
		
	
	
PRINT ''	
END

-------------------------------------------End of AX2012 common synonyms -------------------


IF Substring(@AX_APP_BUILD, 1, 3) = '6.0'
BEGIN




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_COMPANYINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_COMPANYINFO')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_COMPANYINFO
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.COMPANYINFO'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_COMPANYINFO
				FOR [' + @DATABASE_NAME + '].dbo.COMPANYINFO'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_OMOPERATINGUNIT')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_OMOPERATINGUNIT')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_OMOPERATINGUNIT
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.OMOPERATINGUNIT'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_OMOPERATINGUNIT
				FOR [' + @DATABASE_NAME + '].dbo.OMOPERATINGUNIT'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

INSERT INTO AX_NUM_SEQUENCES
SELECT @SERVER_NAME,
       @STATS_DATE,
       @DATABASE_NAME,
       NST.RECID,
       NST.NUMBERSEQUENCE                                                                                                                                 AS [NumberSequence],
       NST.TXT                                                                                                                                            AS [Text],
       NST.LOWEST,
       NST.HIGHEST,
       NST.NEXTREC,
       CAST (( CAST(( NST.HIGHEST - NST.NEXTREC ) AS DECIMAL(20, 2)) / ( CAST(( NST.HIGHEST - NST.LOWEST ) AS DECIMAL(20, 2)) ) * 100 ) AS DECIMAL(5, 2)) AS [PercentRemaining],
       NST.HIGHEST - NST.NEXTREC                                                                                                                          AS [NumbersRemaining],
       CASE NST.CONTINUOUS
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Continuous],
       NST.FETCHAHEAD                                                                                                                                     AS FetchAhead,
       NST.FETCHAHEADQTY                                                                                                                                  AS FetchAheadQty,
       NST.CLEANINTERVAL                                                                                                                                  AS CleanInterval,
       NST.CLEANATACCESS                                                                                                                                  AS CleanAtAccess,
       'N/A'                                                                                                                                              AS [PartitionName],
       NST.NUMBERSEQUENCESCOPE,
       DA.ID                                                                                                                                              [CompanyId],
       DA.NAME                                                                                                                                            [CompanyName],
       CASE DA.ISVIRTUAL
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Shared],
       CI.DATAAREA                                                                                                                                        [LegalEntityName],
       CASE OU.OMOPERATINGUNITTYPE
         WHEN 0 THEN 'None'
         WHEN 1 THEN 'Department'
         WHEN 2 THEN 'Cost center'
         WHEN 3 THEN 'Value stream'
         WHEN 4 THEN 'Business unit'
         WHEN 5 THEN 'All operating units'
         WHEN 6 THEN 'Retail channel'
       END                                                                                                                                                [OperatingUnitType],
       OU.OMOPERATINGUNITNUMBER                                                                                                                           [OperatingUnitNumber],
       FC.CALENDARID                                                                                                                                      [FiscalCalendar],
       FCY.NAME                                                                                                                                           [FiscalCalendarYear],
       FCP.NAME                                                                                                                                           [Period],
       NST.FORMAT
FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE NST
       JOIN DYN_AXNUM_AX_NUMBERSEQUENCESCOPE NSS
         ON NSS.RECID = NST.NUMBERSEQUENCESCOPE
       LEFT JOIN DYN_AXNUM_AX_DATAAREA DA
              ON NSS.DATAAREA = DA.ID
       LEFT JOIN DYN_AXNUM_AX_COMPANYINFO CI
              ON NSS.LEGALENTITY = CI.RECID
       LEFT JOIN DYN_AXNUM_AX_OMOPERATINGUNIT OU
              ON NSS.OPERATINGUNIT = OU.RECID
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARPERIOD FCP
              ON NSS.FISCALCALENDARPERIOD = FCP.RECID
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDAR FC
              ON FC.RECID = FCP.FISCALCALENDAR
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARYEAR FCY
              ON FCY.RECID = FCP.FISCALCALENDARYEAR

	
	SET @ROW_COUNT = @@ROWCOUNT
END
	
IF Substring(@AX_APP_BUILD, 1, 3) IN ( '6.2', '6.3', '7.0')
BEGIN
	


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_PARTITIONS')
  EXEC('DROP SYNONYM [dbo].DYN_AXNUM_AX_PARTITIONS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_PARTITIONS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.PARTITIONS'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_PARTITIONS
				FOR [' + @DATABASE_NAME + '].dbo.PARTITIONS'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DIRPARTYTABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DIRPARTYTABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DIRPARTYTABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.DIRPARTYTABLE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DIRPARTYTABLE
				FOR [' + @DATABASE_NAME + '].dbo.DIRPARTYTABLE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

INSERT INTO AX_NUM_SEQUENCES
SELECT @SERVER_NAME,
       @STATS_DATE,
       @DATABASE_NAME,
       NST.RECID,
       NST.NUMBERSEQUENCE                                                                                                                                 AS [NumberSequence],
       NST.TXT                                                                                                                                            AS [Text],
       NST.LOWEST,
       NST.HIGHEST,
       NST.NEXTREC,
       CAST (( CAST(( NST.HIGHEST - NST.NEXTREC ) AS DECIMAL(20, 2)) / ( CAST(( NST.HIGHEST - NST.LOWEST ) AS DECIMAL(20, 2)) ) * 100 ) AS DECIMAL(5, 2)) AS [PercentRemaining],
       NST.HIGHEST - NST.NEXTREC                                                                                                                          AS [NumbersRemaining],
       CASE NST.CONTINUOUS
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Continuous],
       NST.FETCHAHEAD                                                                                                                                     AS FetchAhead,
       NST.FETCHAHEADQTY                                                                                                                                  AS FetchAheadQty,
       NST.CLEANINTERVAL                                                                                                                                  AS CleanInterval,
       NST.CLEANATACCESS                                                                                                                                  AS CleanAtAccess,
       P.NAME                                                                                                                                             AS [PartitionName],
       NST.NUMBERSEQUENCESCOPE,
       DA.ID                                                                                                                                              [CompanyId],
       DA.NAME                                                                                                                                            [CompanyName],
       CASE DA.ISVIRTUAL
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Shared],
       DI.DATAAREA                                                                                                                                        [LegalEntityName],
       CASE DI.OMOPERATINGUNITTYPE
         WHEN 0 THEN 'None'
         WHEN 1 THEN 'Department'
         WHEN 2 THEN 'Cost center'
         WHEN 3 THEN 'Value stream'
         WHEN 4 THEN 'Business unit'
         WHEN 5 THEN 'All operating units'
         WHEN 6 THEN 'Retail channel'
       END                                                                                                                                                [OperatingUnitType],
       DI.OMOPERATINGUNITNUMBER                                                                                                                           [OperatingUnitNumber],
       FC.CALENDARID                                                                                                                                      [FiscalCalendar],
       FCY.NAME                                                                                                                                           [FiscalCalendarYear],
       FCP.NAME                                                                                                                                           [Period],
       NST.FORMAT
FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE NST
       JOIN DYN_AXNUM_AX_PARTITIONS P
         ON NST.PARTITION = P.RECID
       JOIN DYN_AXNUM_AX_NUMBERSEQUENCESCOPE NSS
         ON NSS.RECID = NST.NUMBERSEQUENCESCOPE
       LEFT JOIN DYN_AXNUM_AX_DATAAREA DA
              ON NSS.DATAAREA = DA.ID
       LEFT JOIN DYN_AXNUM_AX_DIRPARTYTABLE DI
              ON ( NSS.LEGALENTITY = DI.RECID )
                  OR ( NSS.OPERATINGUNIT = DI.RECID )
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARPERIOD FCP
              ON NSS.FISCALCALENDARPERIOD = FCP.RECID
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDAR FC
              ON FC.RECID = FCP.FISCALCALENDAR
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARYEAR FCY
              ON FCY.RECID = FCP.FISCALCALENDARYEAR


	SET @ROW_COUNT = @@ROWCOUNT

END
    


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@ROW_COUNT as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


--REH Drop all synonyms

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCETABLE')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSTABLES')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSTABLES')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSCOLUMNS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
 EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_COMPANYINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_COMPANYINFO')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_OMOPERATINGUNIT')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_OMOPERATINGUNIT')



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_PARTITIONS')
  EXEC('DROP SYNONYM [dbo].DYN_AXNUM_AX_PARTITIONS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DIRPARTYTABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DIRPARTYTABLE')




RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/




BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

--REH Drop all synonyms

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCETABLE')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSTABLES')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSTABLES')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSCOLUMNS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
 EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_COMPANYINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_COMPANYINFO')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_OMOPERATINGUNIT')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_OMOPERATINGUNIT')



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_PARTITIONS')
  EXEC('DROP SYNONYM [dbo].DYN_AXNUM_AX_PARTITIONS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DIRPARTYTABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DIRPARTYTABLE')





    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_AX_SQLTRACE]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_AX_SQLTRACE (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/
--REH Moved the synonms to avoid SQL runtime error that columns don't exists.  

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')




/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures

--REH @LAST_RUN IS UTC TIME WHICH IS WHAT WE NEED IN THIS SPROC AND THIS SPROC ALONE


--IF @LAST_RUN > '1/1/1901'
--  BEGIN
--      IF @REMOTE_SERVER = 'N'
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
--        END
--      ELSE
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
--        END
--  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = '#AX_VERSION') 
 DROP TABLE  #AX_VERSION 

--REH Get AX version

DECLARE @AX_SERVER_NAME   NVARCHAR(128) = NULL,
        @AX_DATABASE_NAME NVARCHAR(128),
        @AX_APP_BUILD     NVARCHAR(120),
        @KERNEL_BUILD     NVARCHAR(20)
   
   CREATE TABLE #AX_VERSION
     (
        AX_APP_BUILD NVARCHAR(120),
        KERNEL_BUILD NVARCHAR(20)
     )
   
   SET NOCOUNT ON
   
   INSERT #AX_VERSION
   EXECUTE DYNPERF_AX_VERSION_INFO
     @AX_SERVER_NAME = @SERVER_NAME,
     @AX_DATABASE_NAME = @DATABASE_NAME--, @DEBUG = 'N'
   SELECT @AX_APP_BUILD = AX_APP_BUILD,
          @KERNEL_BUILD = KERNEL_BUILD
   FROM   #AX_VERSION
   
   --PRINT 'AX BUILD = ' + ISNULL(@AX_APP_BUILD, '')
   
   --PRINT 'KERNEL BUILD = '+ ISNULL(@KERNEL_BUILD, '')
   
IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = '#AX_VERSION') 
 BEGIN 
	DROP TABLE  #AX_VERSION 
 END
   

  
IF Substring(@AX_APP_BUILD, 1, 1) BETWEEN N'3' AND N'4'
BEGIN


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  EXEC('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


INSERT INTO AX_SQLTRACE WITH (TABLOCK) 
		   (SERVER_NAME
		   ,STATS_TIME
		   ,DATABASE_NAME
		   ,SQL_DURATION
		   ,TRACE_CATEGORY
		   ,SQL_TEXT
		   ,CALL_STACK
		   ,TRACE_EVENT_CODE
		   ,TRACE_EVENT_DESC
		   ,TRACE_EVENT_DETAILS
		   ,CONNECTION_TYPE
		   ,SQL_SESSION_ID
		   ,AX_CONNECTION_ID
		   ,IS_LOBS_INCLUDED
		   ,IS_MORE_DATA_PENDING
		   ,ROWS_AFFECTED
		   ,ROW_SIZE
		   ,ROWS_PER_FETCH
		   ,IS_SELECTED_FOR_UPDATE
		   ,IS_STARTED_WITHIN_TRANSACTION
		   ,SQL_TYPE
		   ,STATEMENT_ID
		   ,STATEMENT_REUSE_COUNT
		   ,DETAIL_TYPE
		   ,CREATED_DATETIME
		   ,AX_USER_ID)
		SELECT @SERVER_NAME,
			@STATS_DATE,
			@DATABASE_NAME,
			TRACETIME
			,CATEGORY
			,STATEMENT
			,CALLSTACK
			,CODE
			,TEXT
			,TEXTDETAILS
			,CONNECTIONTYPE
			,CONNECTIONSPID
			,CONNECTIONID
			,ISLOBSINCLUDED
			,ISMOREDATAPENDING
			,ROWSAFFECTED
			,ROWSIZE
			,ROWSPERFETCH
			,ISSELECTEDFORUPDATE
			,ISSTARTEDWITHINTRANSACTION
			,STATEMENTTYPE
			,STATEMENTID
			,STATEMENTREUSECOUNT
			,DETAILTYPE
			,  DATEADD(MI, @SQL_TZ_OFFSET, DATEADD(S, CREATEDTIME, CREATEDDATE))      
			,CREATEDBY
			
			
		FROM DYN_AXTRACE_AX_SYSTRACETABLE WITH (NOLOCK)
		WHERE DATEADD(S, CREATEDTIME, CREATEDDATE) >= @LAST_RUN
	 AND DATEADD(D, 14, CREATEDDATE) >= GETDATE()


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')
	
END

IF Substring(@AX_APP_BUILD, 1, 2) IN ('5.', '6.', '7.') 
    BEGIN	
	
	
IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

INSERT INTO AX_SQLTRACE WITH (TABLOCK) 
		   (SERVER_NAME
		   ,STATS_TIME
		   ,DATABASE_NAME
		   ,SQL_DURATION
		   ,TRACE_CATEGORY
		   ,SQL_TEXT
		   ,CALL_STACK
		   ,TRACE_EVENT_CODE
		   ,TRACE_EVENT_DESC
		   ,TRACE_EVENT_DETAILS
		   ,CONNECTION_TYPE
		   ,SQL_SESSION_ID
		   ,AX_CONNECTION_ID
		   ,IS_LOBS_INCLUDED
		   ,IS_MORE_DATA_PENDING
		   ,ROWS_AFFECTED
		   ,ROW_SIZE
		   ,ROWS_PER_FETCH
		   ,IS_SELECTED_FOR_UPDATE
		   ,IS_STARTED_WITHIN_TRANSACTION
		   ,SQL_TYPE
		   ,STATEMENT_ID
		   ,STATEMENT_REUSE_COUNT
		   ,DETAIL_TYPE
		   ,CREATED_DATETIME
		   ,AX_USER_ID)
		SELECT @SERVER_NAME,
			@STATS_DATE,
			@DATABASE_NAME,
			TRACETIME
			,CATEGORY
			,STATEMENT
			,CALLSTACK
			,CODE
			,TEXT
			,TEXTDETAILS
			,CONNECTIONTYPE
			,CONNECTIONSPID
			,CONNECTIONID
			,ISLOBSINCLUDED
			,ISMOREDATAPENDING
			,ROWSAFFECTED
			,ROWSIZE
			,ROWSPERFETCH
			,ISSELECTEDFORUPDATE
			,ISSTARTEDWITHINTRANSACTION
			,STATEMENTTYPE
			,STATEMENTID
			,STATEMENTREUSECOUNT
			,DETAILTYPE
			,DATEADD(MI, @SQL_TZ_OFFSET, CREATEDDATETIME)
			,CREATEDBY
	
		FROM DYN_AXTRACE_AX_SYSTRACETABLE WITH (NOLOCK)
		WHERE CREATEDDATETIME >= @LAST_RUN
	 AND DATEADD(D, 14, CREATEDDATETIME) >= GETDATE()
	
	END
	
IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
 EXEC('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')
  
  	
 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')



    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_AX_SYSGLOBALCONFIG]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_AX_SYSGLOBALCONFIG (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



DELETE FROM AX_SYSGLOBALCONFIGURATION WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME

--REH Get AX version

DECLARE @AX_SERVER_NAME   NVARCHAR(128) = NULL,
        @AX_DATABASE_NAME NVARCHAR(128),
        @AX_APP_BUILD     NVARCHAR(120),
        @KERNEL_BUILD     NVARCHAR(20)
   
   CREATE TABLE #AX_VERSION_SGC
     (
        AX_APP_BUILD NVARCHAR(120),
        KERNEL_BUILD NVARCHAR(20)
     )
   
   SET NOCOUNT ON
   
   INSERT #AX_VERSION_SGC
   EXECUTE DYNPERF_AX_VERSION_INFO
     @AX_SERVER_NAME = @SERVER_NAME,
     @AX_DATABASE_NAME = @DATABASE_NAME--, @DEBUG = 'N'
   SELECT @AX_APP_BUILD = AX_APP_BUILD,
          @KERNEL_BUILD = KERNEL_BUILD
   FROM   #AX_VERSION_SGC
   
   --PRINT 'AX BUILD = ' + ISNULL(@AX_APP_BUILD, '')
   
   --PRINT 'KERNEL BUILD = '+ ISNULL(@KERNEL_BUILD, '')
   
IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = '#AX_VERSION_SGC') 
 BEGIN 
	DROP TABLE  #AX_VERSION_SGC 
 END
   
   
  
IF Substring(@AX_APP_BUILD, 1, 1) BETWEEN N'4' AND N'5'
BEGIN

		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AXSGC_AX_SQLSYSTEMVARIABLES')
		  EXEC ('DROP SYNONYM [dbo].DYN_AXSGC_AX_SQLSYSTEMVARIABLES')

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL = '
						CREATE SYNONYM DYN_AXSGC_AX_SQLSYSTEMVARIABLES
						FOR [' + @SERVER_NAME + '].['
							+ @DATABASE_NAME
							+ '].dbo.SQLSYSTEMVARIABLES'
			 END
		ELSE
		  SET @SQL = '
						CREATE SYNONYM DYN_AXSGC_AX_SQLSYSTEMVARIABLES
						FOR [' + @DATABASE_NAME
					 + '].dbo.SQLSYSTEMVARIABLES'

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END

		EXEC (@SQL) 

	INSERT DynamicsPerf..AX_SYSGLOBALCONFIGURATION 
	SELECT @SERVER_NAME, @DATABASE_NAME,PARM, VALUE
	FROM DYN_AXSGC_AX_SQLSYSTEMVARIABLES
	






END

IF Substring(@AX_APP_BUILD, 1, 1) = N'6'  
    BEGIN	
		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')
		  EXEC('DROP SYNONYM [dbo].DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL = '
						CREATE SYNONYM DYN_AXSGC_AX_SYSGLOBALCONFIGURATION
						FOR [' + @SERVER_NAME + '].['
							+ @DATABASE_NAME
							+ '].dbo.SYSGLOBALCONFIGURATION'
			 END
		ELSE
		  SET @SQL = '
						CREATE SYNONYM DYN_AXSGC_AX_SYSGLOBALCONFIGURATION
						FOR [' + @DATABASE_NAME
					 + '].dbo.SYSGLOBALCONFIGURATION'

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END

		EXEC (@SQL) 

	INSERT DynamicsPerf..AX_SYSGLOBALCONFIGURATION 
	SELECT @SERVER_NAME, @DATABASE_NAME,NAME, VALUE
	FROM DYN_AXSGC_AX_SYSGLOBALCONFIGURATION
	
	
	END
	

	
IF Substring(@AX_APP_BUILD, 1, 1) = N'7'  
    BEGIN	
		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')
		  EXEC('DROP SYNONYM [dbo].DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL = '
						CREATE SYNONYM DYN_AXSGC_AX_SYSGLOBALCONFIGURATION
						FOR [' + @SERVER_NAME + '].['
							+ @DATABASE_NAME
							+ '].dbo.SYSGLOBALCONFIGURATION'
			 END
		ELSE
		  SET @SQL = '
						CREATE SYNONYM DYN_AXSGC_AX_SYSGLOBALCONFIGURATION
						FOR [' + @DATABASE_NAME
					 + '].dbo.SYSGLOBALCONFIGURATION'

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END

		EXEC (@SQL) 

	INSERT DynamicsPerf..AX_SYSGLOBALCONFIGURATION 
	SELECT @SERVER_NAME, @DATABASE_NAME,NAME, VALUE
	FROM DYN_AXSGC_AX_SYSGLOBALCONFIGURATION
	
	
	END
	
	
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) + ', ' + CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AXSGC_AX_SQLSYSTEMVARIABLES')
		  EXEC ('DROP SYNONYM [dbo].DYN_AXSGC_AX_SQLSYSTEMVARIABLES')

		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')
		  EXEC('DROP SYNONYM [dbo].DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')






RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'


		  		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AXSGC_AX_SQLSYSTEMVARIABLES')
		  EXEC ('DROP SYNONYM [dbo].DYN_AXSGC_AX_SQLSYSTEMVARIABLES')

		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')
		  EXEC('DROP SYNONYM [dbo].DYN_AXSGC_AX_SYSGLOBALCONFIGURATION')







    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_AX_SQLSTORAGE]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_AX_SQLSTORAGE (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXSTOR_AX_SQLSTORAGE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXSTOR_AX_SQLSTORAGE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXSTOR_AX_SQLSTORAGE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SQLSTORAGE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXSTOR_AX_SQLSTORAGE
				FOR [' + @DATABASE_NAME + '].dbo.SQLSTORAGE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



		DELETE FROM AX_SQLSTORAGE
		WHERE  SERVER_NAME = @SERVER_NAME
			   AND DATABASE_NAME = @DATABASE_NAME 


		INSERT AX_SQLSTORAGE
		SELECT @SERVER_NAME,
			   @DATABASE_NAME,
			   *
		FROM   DYN_AXSTOR_AX_SQLSTORAGE 

	
	 



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXSTOR_AX_SQLSTORAGE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXSTOR_AX_SQLSTORAGE')


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'


		  IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXSTOR_AX_SQLSTORAGE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXSTOR_AX_SQLSTORAGE')




    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_AZURE_EVENTLOG]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
ALTER PROCEDURE [dbo].[DYNPERF_COLLECT_AZURE_EVENTLOG]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30), @START_POS INT, @END_POS INT
    DECLARE @INSTANCE_NAME NVARCHAR(128)
    
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/




IF @AZURE_DB = 0 RETURN(0)  --REH THIS SPROC IS MEANT FOR AZURE ONLY





IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AZURE_EVENTS')
  EXEC ('DROP SYNONYM [dbo].DYN_AZURE_EVENTS')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_AZURE_EVENTS
				FOR [' + @SERVER_NAME + '].[master].sys.event_log'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AZURE_EVENTS
				FOR master.sys.event_log'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 




/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH The end_time column in this event is in UTC time so we do not need to convert ours since we pass to this sproc in UTC time


----REH  Time Zone code for all procedures
--IF @LAST_RUN > '1/1/1901'
--  BEGIN
--      IF @REMOTE_SERVER = 'N'
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
--        END
--      ELSE
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
--        END
--  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

		--SET @END_POS = LEN(@SERVER_NAME)
		--SET @START_POS = CHARINDEX('\', @SERVER_NAME,1)+1
		--IF @START_POS > 0
		--BEGIN
		--	SET @INSTANCE_NAME = 'MSSQL$' + SUBSTRING(@SERVER_NAME, @START_POS, @END_POS) + ':'
		--END
		--ELSE
		--BEGIN
		--	SET @INSTANCE_NAME = 'SQLServer:'
		--END
		
		

INSERT AZURE_EVENTS
SELECT @SERVER_NAME,
       @STATS_DATE,
       @DATABASE_NAME,
       AE.[database_name],
       AE.[start_time],
       AE.[end_time],
       AE.[event_category],
       AE.[event_type],
       AE.[event_subtype],
       AE.[event_subtype_desc],
       AE.[severity],
       AE.[event_count],
       AE.[description],
       AE.[additional_data]
FROM   DYN_AZURE_EVENTS AE
WHERE  AE.severity > 0 --Warnings and above
AND AE.database_name = @DATABASE_NAME
AND AE.[end_time] > @LAST_RUN  --REH LAST_RUN is UTC time in this case


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_CHANGE_DATA_CONTROL]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_CHANGE_DATA_CONTROL (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @RC INT, @CDC_ENABLED CHAR(1) = 'N'
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SYN_CDC')
  EXEC ('DROP SYNONYM [dbo].DYN_SYN_CDC')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SYN_CDC
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.sp_cdc_help_change_data_capture'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SYN_CDC
				FOR [' + @DATABASE_NAME + '].sys.sp_cdc_help_change_data_capture'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SYN_SYSDATABASES')
 EXEC ('DROP SYNONYM [dbo].DYN_SYN_SYSDATABASES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SYN_SYSDATABASES
				FOR [' + @SERVER_NAME + '].master.sys.databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SYN_SYSDATABASES
				FOR master.sys.databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC(@SQL) 

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

SELECT @RC = is_cdc_enabled FROM DYN_SYN_SYSDATABASES WHERE name = @DATABASE_NAME

IF @RC = 1  SET  @CDC_ENABLED = 'Y' 

IF @DEBUG = 'Y' 
BEGIN
PRINT 'CDC FLAG ' + @CDC_ENABLED
END



IF @CDC_ENABLED = 'Y' 
BEGIN 


		DELETE FROM [DynamicsPerf]..CDC WHERE DATABASE_NAME = @DATABASE_NAME AND SERVER_NAME = @SERVER_NAME 


			CREATE TABLE #CDC
			  (
				 source_schema		sysname,
				 source_table		sysname,
				 capture_instance	sysname,
				 object_id			int,
				 source_object_id	int,
				 start_lsn			binary(10),
				 end_lsn			binary(10),
				 supports_net_changes bit,
				 has_drop_pending	bit,
				 role_name			sysname,
				 index_name			sysname,
				 filegroup_name		sysname,
				 create_date		datetime,
				 index_column_list	nvarchar(max),
				 captured_column_list nvarchar(max)
				   ); 


			INSERT INTO #CDC (
				 source_schema,		
				 source_table,		
				 capture_instance,
				 object_id,
				 source_object_id,
				 start_lsn,
				 end_lsn,
				 supports_net_changes,
				 has_drop_pending,
				 role_name,
				 index_name,
				 filegroup_name,
				 create_date,
				 index_column_list,
				 captured_column_list
			)


			EXECUTE DYN_SYN_CDC;

			INSERT INTO DynamicsPerf..CDC
			SELECT @SERVER_NAME, @STATS_DATE,@DATABASE_NAME, * FROM #CDC
END
	
	



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_CHANGE_TRACKING]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_CHANGE_TRACKING (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CT_SYSDATABASES')
  EXEC ('DROP SYNONYM [dbo].DYN_CT_SYSDATABASES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_CT_SYSDATABASES
				FOR [' + @SERVER_NAME + '].master.sys.databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CT_SYSDATABASES
				FOR master.sys.databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CT_CT_DB')
  EXEC ('DROP SYNONYM [dbo].DYN_CT_CT_DB')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_CT_CT_DB
				FOR [' + @SERVER_NAME + '].master.sys.change_tracking_databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CT_CT_DB
				FOR master.sys.change_tracking_databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL)  

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CT_SYSOBJECTS')
  EXEC ('DROP SYNONYM [dbo].DYN_CT_SYSOBJECTS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CT_SYSOBJECTS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.objects'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CT_SYSOBJECTS
				FOR [' + @DATABASE_NAME + '].sys.objects'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CT_TRACKING_TABLES')
  EXEC ('DROP SYNONYM [dbo].DYN_CT_TRACKING_TABLES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CT_TRACKING_TABLES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.change_tracking_tables'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CT_TRACKING_TABLES
				FOR [' + @DATABASE_NAME + '].sys.change_tracking_tables'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

DELETE FROM DynamicsPerf..SQL_CHANGETRACKING_DBS WHERE SERVER_NAME = @SERVER_NAME
DELETE FROM DynamicsPerf..SQL_CHANGETRACKING_TABLES WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME

IF @AZURE_DB = 0
BEGIN

INSERT DynamicsPerf..SQL_CHANGETRACKING_DBS
SELECT @SERVER_NAME,d.name,d.database_id,ct.is_auto_cleanup_on,ct.max_cleanup_version,ct.retention_period,ct.retention_period_units,ct.retention_period_units_desc
FROM   DYN_CT_CT_DB ct
       INNER JOIN DYN_CT_SYSDATABASES d
               ON ct.database_id = d.database_id 
               
               INSERT DynamicsPerf..SQL_CHANGETRACKING_TABLES
SELECT @SERVER_NAME, @DATABASE_NAME,o.name,o.[object_id],ct.is_track_columns_updated_on,ct.min_valid_version,ct.begin_version,ct.cleanup_version
FROM   DYN_CT_TRACKING_TABLES ct
       INNER JOIN DYN_CT_SYSOBJECTS o
               ON ct.object_id = o.object_id 
END

IF @AZURE_DB = 1
BEGIN




		SET @SQL2 = ' 
						  SET QUOTED_IDENTIFIER OFF
						  	INSERT DynamicsPerf.dbo.SQL_CHANGETRACKING_DBS
			
					SELECT ' + '''' + @SERVER_NAME + '''' + 
					', * FROM OPENQUERY(['+@SERVER_NAME+ '],"


		SELECT d.name,d.database_id,ct.is_auto_cleanup_on,ct.max_cleanup_version,ct.retention_period,ct.retention_period_units,ct.retention_period_units_desc
			   FROM   sys.change_tracking_databases ct
       INNER JOIN sys.databases d
               ON ct.database_id = d.database_id ")'

			
		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL2
			 END

		EXEC (@SQL2) 


				SET @SQL2 = ' 
						  SET QUOTED_IDENTIFIER OFF
						  	INSERT DynamicsPerf.dbo.SQL_CHANGETRACKING_DBS
			
					SELECT ' + '''' + @SERVER_NAME + '''' + ','+  '''' + @DATABASE_NAME + '''' + 
					', * FROM OPENQUERY(['+@SERVER_NAME+ '],"


		SELECT o.name,o.[object_id],ct.is_track_columns_updated_on,ct.min_valid_version,ct.begin_version,ct.cleanup_version
			   FROM   sys.change_tracking_tables ct
       INNER JOIN sys.objects o
              ON ct.object_id = o.object_id ")'

			
		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL2
			 END

		EXEC (@SQL2) 

END
             
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_CRM_ORGANIZATION]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_CRM_ORGANIZATION (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMO_CRMORGANIZATION')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMO_CRMORGANIZATION')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMO_CRMORGANIZATION
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..Organization'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMO_CRMORGANIZATION
				FOR [' + @DATABASE_NAME + ']..Organization'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


INSERT INTO [DynamicsPerf]..CRM_ORGANIZATION
SELECT @SERVER_NAME,
       CONVERT(NVARCHAR(50), @STATS_DATE, 121),
       @DATABASE_NAME,
       sharetopreviousowneronassign,
       minoutlooksyncinterval,
       tagpollingperiod,
       MinAddressBookSyncInterval,
       AllowAddressBookSyncs,
       emailsendpollingperiod,
       ispresenceenabled,
       GetStartedPaneContentEnabled,
       orgdborgsettings
FROM   DYN_CRMO_CRMORGANIZATION 


    


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_CRM_PLUGINS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_CRM_PLUGINS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_PLUGINTYPE')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_PLUGINTYPE')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINTYPE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..PluginType'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINTYPE
				FOR [' + @DATABASE_NAME + ']..PluginType'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_PLUGINASSEMBLY')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_PLUGINASSEMBLY')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINASSEMBLY
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..PluginAssembly'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINASSEMBLY
				FOR [' + @DATABASE_NAME + ']..PluginAssembly'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_PLUGINTYPESTATISTIC')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_PLUGINTYPESTATISTIC')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINTYPESTATISTIC
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..PluginTypeStatistic'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINTYPESTATISTIC
				FOR [' + @DATABASE_NAME + ']..PluginTypeStatistic'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_SDKMESSAGEPROCESSINGSTEP')
 EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_SDKMESSAGEPROCESSINGSTEP')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGEPROCESSINGSTEP
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..SdkMessageProcessingStep'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGEPROCESSINGSTEP
				FOR [' + @DATABASE_NAME + ']..SdkMessageProcessingStep'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_SDKMESSAGEFILTER')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_SDKMESSAGEFILTER')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGEFILTER
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..SdkMessageFilter'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGEFILTER
				FOR [' + @DATABASE_NAME + ']..SdkMessageFilter'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_SDKMESSAGE')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_SDKMESSAGE')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..SdkMessage'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGE
				FOR [' + @DATABASE_NAME + ']..SdkMessage'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_ENTITYLOGICALVIEW')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_ENTITYLOGICALVIEW')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_ENTITYLOGICALVIEW
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..EntityLogicalView'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_ENTITYLOGICALVIEW
				FOR [' + @DATABASE_NAME + ']..EntityLogicalView'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

INSERT INTO [DynamicsPerf]..CRM_PLUGINS
SELECT @SERVER_NAME,
       CONVERT(NVARCHAR(50), @STATS_DATE, 121),
       @DATABASE_NAME,
       CASE sdkmessageprocessingstep0.StateCode
         WHEN 0 THEN 'Enabled'
         WHEN 1 THEN 'Disabled'
         ELSE 'n/a'
       END                                                        AS 'StatusName',
       ISNULL(e.NAME, 'None')                                     AS 'EntityName',
       CASE sdkmessageprocessingstep0.Stage
         WHEN 10 THEN 'Pre-Out Of Trx'
         WHEN 20 THEN 'Pre in Trx'
         WHEN 40 THEN 'Post in Trx'
         WHEN 50 THEN 'Post-Out of Trx'
         ELSE 'Workflow Activity'
       END                                                        AS 'StageName',
       CASE PluginAssembly.IsolationMode
         WHEN 1 THEN 'Full'
         WHEN 2 THEN 'Isolated-SandBox'
         ELSE 'Unknown'
       END                                                        AS 'IsolationModeName',
       PluginAssembly.IsolationMode,
       PluginAssembly.Version,
       PluginAssembly.IsManaged,
       ISNULL(sm.Name, 'None')                                    AS 'MessageName',
       PluginType0.componentstate                                 AS 'Assembly',
       PluginType0.typename                                       AS 'Plugin',
       CASE sdkmessageprocessingstep0.Mode
         WHEN 1 THEN 'Asynchronous'
         WHEN 0 THEN 'Synchronous'
         ELSE 'None'
       END                                                        AS 'ModeName',
       CASE ( ( COALESCE(sdkmessageprocessingstep0.AsyncAutoDelete, 0) * sdkmessageprocessingstep0.Mode ) + sdkmessageprocessingstep0.Mode )
         WHEN 1 THEN 'No'
         WHEN 2 THEN 'Yes'
         ELSE '-'
       END                                                        AS 'AsyncAutoDeleteName',
       ISNULL(sdkmessageprocessingstep0.Rank, '')                 AS 'Rank',
       --CASE sdkmessageprocessingstep0.InvocationSource WHEN 0 Then 'Parent' WHEN 1 Then 'Child' END as 'PipelineName',
       ISNULL(sdkmessageprocessingstep0.FilteringAttributes, '-') AS 'FilteringAttributes',
       ISNULL(sdkmessageprocessingstep0.Description, '-')         AS 'StepName',
       ISNULL(sdkmessageprocessingstep0.AsyncAutoDelete, '')      AS 'AsyncAutoDelete',
       ISNULL(sdkmessageprocessingstep0.Mode, '')                 'Mode',
       ISNULL(sdkmessageprocessingstep0.Stage, '')                'Stage',
       COALESCE(pts.AverageExecuteTimeInMilliseconds, -1)         'AvgExecTimeMs',
       COALESCE(pts.ExecuteCount, -1)                             'Executes',
       COALESCE(pts.FailureCount, -1)                             'Failures'
FROM   DYN_CRMPLUG_CRM_PLUGINTYPE PluginType0
       INNER JOIN DYN_CRMPLUG_CRM_PLUGINASSEMBLY PluginAssembly
               ON PluginType0.PluginAssemblyId = PluginAssembly.PluginAssemblyId
       INNER JOIN DYN_CRMPLUG_CRM_PLUGINTYPESTATISTIC pts
               ON pts.PluginTypeId = PluginType0.PluginTypeId
       LEFT JOIN DYN_CRMPLUG_CRM_SDKMESSAGEPROCESSINGSTEP AS sdkmessageprocessingstep0
              ON PluginType0.PluginTypeId = sdkmessageprocessingstep0.PluginTypeId
       LEFT JOIN DYN_CRMPLUG_CRM_SDKMESSAGEFILTER filter
              ON filter.SdkMessageFilterId = sdkmessageprocessingstep0.SdkMessageFilterId
       LEFT JOIN DYN_CRMPLUG_CRM_SDKMESSAGE sm
              ON sm.SdkMessageId = filter.SdkMessageId
       LEFT JOIN DYN_CRMPLUG_CRM_ENTITYLOGICALVIEW e
              ON filter.PrimaryObjectTypeCode = e.ObjectTypeCode
WHERE  ( ( sdkmessageprocessingstep0.CustomizationLevel != 2
            OR sdkmessageprocessingstep0.CustomizationLevel IS NULL )
         AND ( sdkmessageprocessingstep0.Stage IS NULL
                OR ( sdkmessageprocessingstep0.Stage IN ( 10, 20, 40, 50 ) ) ) )
       AND FriendlyName NOT IN ( 'InternalOperation' )
       AND IsolationMode = 2 


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_CRM_POA_TOTALS]...';


GO


ALTER PROCEDURE DYNPERF_COLLECT_CRM_POA_TOTALS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPOA_CRM_POA')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPOA_CRM_POA')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPOA_CRM_POA
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..PrincipalObjectAccess'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPOA_CRM_POA
				FOR [' + @DATABASE_NAME + ']..PrincipalObjectAccess'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPOA_CRM_EV')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPOA_CRM_EV')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPOA_CRM_EV
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + ']..EntityAsIfPublishedLogicalView'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPOA_CRM_EV
				FOR [' + @DATABASE_NAME + ']..EntityAsIfPublishedLogicalView'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


INSERT INTO [DynamicsPerf]..CRM_POA_TOTALS
SELECT @SERVER_NAME,
       CONVERT(NVARCHAR(50), @STATS_DATE, 121),
       @DATABASE_NAME,
       e.NAME   AS [EntityName],
       Sum(CASE
             WHEN p.AccessRightsMask > 0 THEN 1
             ELSE 0
           END) AS [DirectShares],
       Sum(CASE
             WHEN p.InheritedAccessRightsMask > 0 THEN 1
             ELSE 0
           END) AS [InheritedShares],
       Sum(CASE
             WHEN p.AccessRightsMask = 0
                  AND p.InheritedAccessRightsMask = 0 THEN 1
             ELSE 0
           END) AS[QueuedForDeletion],
       Sum(CASE
             WHEN p.AccessRightsMask > 0
                  AND p.InheritedAccessRightsMask > 0 THEN 1
             ELSE 0
           END) AS[InheritedAndDirect],
       Count(*) AS TotalShares
FROM   DYN_CRMPOA_CRM_POA p
       JOIN DYN_CRMPOA_CRM_EV e
         ON p.ObjectTypeCode = e.ObjectTypeCode
GROUP  BY e.Name
ORDER  BY TotalShares DESC 

    


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_DATABASE_REPLICATION_INFO]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_DATABASE_REPLICATION_INFO (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @RC INT
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DRI_SYSDATABASES')
  EXEC ('DROP SYNONYM [dbo].DYN_DRI_SYSDATABASES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSDATABASES
				FOR [' + @SERVER_NAME + '].master.sys.databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSDATABASES
				FOR master.sys.databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 



--REH validate publication is on for this database otherwise bailout
SELECT @RC = is_published FROM DYN_DRI_SYSDATABASES WHERE name = @DATABASE_NAME
IF @RC<> 1 RETURN(0)





IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DRI_SYSSERVERS')
  EXEC('DROP SYNONYM [dbo].DYN_DRI_SYSSERVERS')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSSERVERS
				FOR [' + @SERVER_NAME + '].master.dbo.sysservers'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSSERVERS
				FOR master.dbo.sysservers'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DRI_SYSPUBLICATIONS')
  EXEC ('DROP SYNONYM [dbo].DYN_DRI_SYSPUBLICATIONS')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSPUBLICATIONS
				FOR [' + @SERVER_NAME + '].['+@DATABASE_NAME + '].dbo.syspublications'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSPUBLICATIONS
				FOR ['+@DATABASE_NAME + '].dbo.syspublications'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DRI_SYSARTICLES')
  EXEC ('DROP SYNONYM [dbo].DYN_DRI_SYSARTICLES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSARTICLES
				FOR [' + @SERVER_NAME + '].['+@DATABASE_NAME + '].dbo.sysarticles'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSARTICLES
				FOR ['+@DATABASE_NAME + '].dbo.sysarticles'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DRI_SYSSUBSCRIPTIONS')
  EXEC ('DROP SYNONYM [dbo].DYN_DRI_SYSSUBSCRIPTIONS')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSSUBSCRIPTIONS
				FOR [' + @SERVER_NAME + '].['+@DATABASE_NAME + '].dbo.syssubscriptions'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DRI_SYSSUBSCRIPTIONS
				FOR ['+@DATABASE_NAME + '].dbo.syssubscriptions'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



SELECT @RC = is_published FROM DYN_DRI_SYSDATABASES WHERE name = @DATABASE_NAME

IF @RC = 1
BEGIN


INSERT INTO SQL_REPLICATION
SELECT  @SERVER_NAME,@STATS_DATE,@DATABASE_NAME,
db_name() PUBLISHER_DB 
, sp.name as PUBLISHER_NAME 
, sa.name as TABLE_NAME 
, UPPER(srv.srvname) as SUBSCRIBER_SERVER_NAME 
from DYN_DRI_SYSPUBLICATIONS sp  
join DYN_DRI_SYSARTICLES sa on sp.pubid = sa.pubid 
join DYN_DRI_SYSSUBSCRIPTIONS s on sa.artid = s.artid 
join DYN_DRI_SYSSERVERS srv on s.srvid = srv.srvid 


END


 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_DATABASE_STATISTICS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_DATABASE_STATISTICS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @ROW_COUNT BIGINT = 0
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_SYSOBJECTS')
  EXEC ('DROP SYNONYM [dbo].DYN_DS_SYSOBJECTS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSOBJECTS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.sysobjects'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSOBJECTS
				FOR [' + @DATABASE_NAME + '].sys.sysobjects'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)
 

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_DS_SYSCOLUMNS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSCOLUMNS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.columns'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSCOLUMNS
				FOR [' + @DATABASE_NAME + '].sys.columns'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_SYSINDEXES')
 EXEC ('DROP SYNONYM [dbo].DYN_DS_SYSINDEXES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSINDEXES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.indexes'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSINDEXES
				FOR [' + @DATABASE_NAME + '].sys.indexes'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_SYSSCHEMAS')
  EXEC ('DROP SYNONYM [dbo].DYN_DS_SYSSCHEMAS')
  
  
IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSSCHEMAS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.schemas'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSSCHEMAS
				FOR [' + @DATABASE_NAME + '].sys.schemas'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_INDEX_COLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_DS_INDEX_COLUMNS')
  
IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_INDEX_COLUMNS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.index_columns'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_INDEX_COLUMNS
				FOR [' + @DATABASE_NAME + '].sys.index_columns'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_STATS_COLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_DS_STATS_COLUMNS')
  
IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_STATS_COLUMNS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.stats_columns'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_STATS_COLUMNS
				FOR [' + @DATABASE_NAME + '].sys.stats_columns'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_SYS_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_DS_SYS_STATS')
  
IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYS_STATS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYS_STATS
				FOR [' + @DATABASE_NAME + '].sys.stats'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[#table_stat_header]'))
BEGIN 
DROP TABLE #table_stat_header
END

create table #table_stat_header (
    [Name] sysname
,   [Updated] datetime2
,   [Rows] int
,   [Rows Sampled] int
,   [Steps] int
,   [Density] numeric(10,5)
,   [Average key length] numeric(10,5)
,   [String index] varchar(10)
,   [Filter_Expression] nvarchar(max),
	[Unfiltered_Rows] int
)

--insert into #table_stat_header exec ('dbcc show_statistics ( "tab", "i1") with  STAT_HEADER')



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[#TableStats]'))
BEGIN 
DROP TABLE #TableStats
END


CREATE TABLE #TableStats
  (
     Density FLOAT,
     Length  INT NULL,
     columns NVARCHAR(2078)
  ) 
  


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[#TableHistogram]'))
 BEGIN
DROP TABLE #TableHistogram
END

CREATE TABLE #TableHistogram
  (
     Range_HI_Key        SQL_VARIANT,
     Range_Rows          BIGINT NULL,
     EQ_Rows             BIGINT,
     Distinct_Range_Rows BIGINT,
     Avg_Range_Rows      BIGINT
  ) 



DELETE FROM INDEX_STAT_HEADER WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME
DELETE FROM INDEX_DENSITY_VECTOR WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME
DELETE FROM INDEX_HISTOGRAM WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME


TRUNCATE TABLE #TableStats
TRUNCATE TABLE #TableHistogram
TRUNCATE TABLE #table_stat_header


DECLARE @tablename sysname
DECLARE @indexname sysname
DECLARE @colname sysname
DECLARE @schemaname sysname


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

DECLARE table_cursor CURSOR
   FOR SELECT O.name,
              ST.name,
              C.name,
              SCH.name
       FROM   DYN_DS_SYSOBJECTS O
              INNER JOIN DYN_DS_SYS_STATS ST
                      ON O.id = ST.object_id
              INNER JOIN DYN_DS_STATS_COLUMNS AS SC
                      ON ST.object_id = SC.object_id
                         AND ST.stats_id = SC.stats_id
              INNER JOIN DYN_DS_SYSCOLUMNS AS C
                      ON SC.object_id = C.object_id
                         AND C.column_id = SC.column_id
              INNER JOIN DYN_DS_SYSSCHEMAS AS SCH
                      ON O.uid = SCH.schema_id
       WHERE  O.xtype = 'u'
              AND SC.stats_column_id = 1
              AND C.system_type_id <> 189
              AND SCH.name <> 'sys' --remove timestamps, incompatiable with sql_variant datatype we used
              AND ( ST.auto_created = 1
               OR ST.user_created = 1)
       UNION ALL
       SELECT O.name,
              ST.name,
              C.name,
              SCH.name
       FROM   DYN_DS_SYSOBJECTS O
              INNER JOIN DYN_DS_SYS_STATS ST
                      ON O.id = ST.object_id
              INNER JOIN DYN_DS_STATS_COLUMNS AS SC
                      ON ST.object_id = SC.object_id
                         AND ST.stats_id = SC.stats_id
              INNER JOIN DYN_DS_SYSCOLUMNS AS C
                      ON SC.object_id = C.object_id
                         AND C.column_id = SC.column_id
              INNER JOIN DYN_DS_SYSSCHEMAS AS SCH
                      ON O.uid = SCH.schema_id
       WHERE  O.xtype = 'u'
              AND SC.stats_column_id = 1
              AND C.system_type_id <> 189
              AND SCH.name <> 'sys' --remove timestamps, incompatiable with sql_variant datatype we used
              AND (ST.auto_created = 0
              AND ST.user_created = 0 )
       

/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN table_cursor 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM table_cursor INTO @tablename, @indexname, @colname, @schemaname

/* Verify that we got a record*/
/* status 0 means we got a good record*/



WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */
--	print @tablename + '    ' + @indexname




--------------------------------------STATS HEADER --------------------------------------------------------------		


	SELECT @SQL = 'DBCC SHOW_STATISTICS('+'''' +@DATABASE_NAME +'.'+@schemaname+'.' +@tablename + '''' +',' +QUOTENAME(@indexname,'''')+') WITH  STAT_HEADER, NO_INFOMSGS'
		
		IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL
		END
		
	--REH Truncate the table before we insert data into it
	TRUNCATE TABLE #table_stat_header
		
		IF @REMOTE_SERVER = 'N'
			 BEGIN
				 BEGIN TRY
					 INSERT #table_stat_header
					 EXEC (@SQL ) --DBCC SHOW_STATISTICS STAT_HEADER
				 END TRY

				 BEGIN CATCH
				 --ignore the error
				 END CATCH
			 END

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
							 + @SERVER_NAME + ']'

				 IF @DEBUG = 'Y'
					  BEGIN
						  PRINT '@SQL= ' + @SQL2
					  END

				 BEGIN TRY
					 INSERT #table_stat_header
					 EXEC (@SQL2 ) --DBCC SHOW_STATISTICS STAT_HEADER
				 END TRY

				 BEGIN CATCH
				 --ignore the error
				 END CATCH
				 
				 
			 END 


	--REH Now insert the records from the temp table into our table
			INSERT INDEX_STAT_HEADER
			SELECT @SERVER_NAME,
				   @DATABASE_NAME,
				   @tablename,
				   @indexname,
				   *
			FROM   #table_stat_header 





--------------------------------------DENSITY VECTOR --------------------------------------------------------------		


	SELECT @SQL = 'DBCC SHOW_STATISTICS('+'''' +@DATABASE_NAME +'.'+@schemaname+'.' +@tablename + '''' +',' +QUOTENAME(@indexname,'''')+') WITH DENSITY_VECTOR, NO_INFOMSGS'
		
		IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL
		END
		
	--REH Truncate the table before we insert data into it
	TRUNCATE TABLE #TableStats
		
		IF @REMOTE_SERVER = 'N'
			 BEGIN
				 BEGIN TRY
					 INSERT #TableStats
					 EXEC (@SQL ) --DBCC SHOW_STATISTICS DENSITY VECTOR
				 END TRY

				 BEGIN CATCH
				 --ignore the error
				 END CATCH
			 END

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
							 + @SERVER_NAME + ']'

				 IF @DEBUG = 'Y'
					  BEGIN
						  PRINT '@SQL= ' + @SQL2
					  END

				 BEGIN TRY
					 INSERT #TableStats
					 EXEC (@SQL2 ) --DBCC SHOW_STATISTICS DENSITY VECTOR
				 END TRY

				 BEGIN CATCH
				 --ignore the error
				 END CATCH
				 
				 
			 END 


	--REH Now insert the records from the temp table into our table
			INSERT INDEX_DENSITY_VECTOR
			SELECT @SERVER_NAME,
				   @DATABASE_NAME,
				   @tablename,
				   @indexname,
				   *
			FROM   #TableStats 

--------------------------------------HISTOGRAM --------------------------------------------------------------		


	SELECT @SQL = 'DBCC SHOW_STATISTICS('+'''' +@DATABASE_NAME +'.'+@schemaname+'.' +@tablename + '''' +',' +QUOTENAME(@indexname,'''')+') WITH HISTOGRAM, NO_INFOMSGS'
		
		IF @DEBUG = 'Y' 
		BEGIN
			PRINT '@SQL= ' + @SQL
		END
		
		
--REH Truncate the table before we insert data into it
	TRUNCATE TABLE #TableHistogram
		
			IF @REMOTE_SERVER = 'N'
				 BEGIN
					 BEGIN TRY
						 INSERT #TableHistogram
						 EXEC (@SQL ) --DBCC SHOW_STATISTICS DENSITY VECTOR
					 END TRY

					 BEGIN CATCH
					 --ignore the error
					 END CATCH
				 END 

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
							 + @SERVER_NAME + ']'

				 IF @DEBUG = 'Y'
					  BEGIN
						  PRINT '@SQL= ' + @SQL2
					  END

				 BEGIN TRY
					 INSERT #TableHistogram
					 EXEC (@SQL2 ) --DBCC SHOW_STATISTICS DENSITY VECTOR
				 END TRY

				 BEGIN CATCH
				 --ignore the error
				 END CATCH
				 
				 
			 END 	
			 
	--REH Now insert the records from the temp table into our table
				INSERT INDEX_HISTOGRAM
				SELECT @SERVER_NAME,
					   @DATABASE_NAME,
					   @tablename,
					   @indexname,
					   @colname,
					   *
				FROM   #TableHistogram 

				SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

---------------------------------------BOTTOM OF LOOP----------------------------------------------

	FETCH NEXT FROM table_cursor INTO @tablename,@indexname,@colname,@schemaname
END  /*End of the loop */
CLOSE table_cursor  /*close the cursor to free memory in SQL*/
DEALLOCATE table_cursor /*Must deallocate the cursor to destroy it and free SQL resources*/
 
 
 
 
 
 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_DATABASE_VLFS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_DATABASE_VLFS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION VARCHAR(30), @C_DATABASE_NAME NVARCHAR(128), @ROW_COUNT BIGINT = 0
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_VLF_SYSDATABASES')
  EXEC ('DROP SYNONYM [dbo].DYN_VLF_SYSDATABASES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_VLF_SYSDATABASES
				FOR [' + @SERVER_NAME + '].master.sys.databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_VLF_SYSDATABASES
				FOR master.sys.databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_VLF_SQLVERSION')
  EXEC ('DROP SYNONYM [dbo].DYN_VLF_SQLVERSION')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_VLF_SQLVERSION
				FOR [' + @SERVER_NAME + '].master.sys.xp_msver'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_VLF_SQLVERSION
				FOR master.sys.xp_msver'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


CREATE  table #SQLVERSION(
[INDEX] INT,
NAME NVARCHAR(128),
INTERNAL_VALUE NVARCHAR(128),
VALUE NVARCHAR(128)
);

INSERT #SQLVERSION
exec DYN_VLF_SQLVERSION 'ProductVersion' --[master].sys.[xp_msver]

SELECT @SQLVERSION = VALUE FROM #SQLVERSION WHERE NAME = 'ProductVersion'

DROP TABLE #SQLVERSION


--REH  can't use temp table because they only last for the the exec(@sql) after it comes back they are gone

IF OBJECT_ID('VLFS') > 0
DROP TABLE VLFS


IF SUBSTRING(@SQLVERSION, 1, 3) = '10.'
     BEGIN
         SET @SQL = '
			CREATE TABLE VLFS (
			 FileId int, FileSize bigint, StartOffset bigint, FSeqNo int, Status tinyint, Parity tinyint, CreateLSN numeric(25,0) )
			'

         EXEC (@SQL)
     END
ELSE
     BEGIN
         SET @SQL = '
				CREATE TABLE VLFS (
				Q char, FileId int, FileSize bigint, StartOffset bigint, FSeqNo int, Status tinyint, Parity tinyint, CreateLSN numeric(25,0) )
				'

         EXEC(@SQL)
     END 


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''




DECLARE DB_CURSOR CURSOR  LOCAL
FOR
SELECT name from DYN_VLF_SYSDATABASES


OPEN DB_CURSOR

FETCH NEXT FROM DB_CURSOR INTO @C_DATABASE_NAME

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

--REH Zero it out for each pass

TRUNCATE TABLE VLFS

SET @SQL = 'DBCC LOGINFO ([' + @C_DATABASE_NAME + ']) WITH NO_INFOMSGS'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

IF @REMOTE_SERVER = 'N'
BEGIN

		INSERT VLFS EXEC (@SQL) 

END
ELSE
BEGIN

		          
		SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT ['
					+ @SERVER_NAME + ']' 

		  
		  IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL2
		END

		INSERT VLFS  EXEC (@SQL2)


END


INSERT INTO LOGINFO



SELECT @SERVER_NAME,
		@STATS_DATE,
       @C_DATABASE_NAME,
       RH.*
FROM   (SELECT FileId,
               COUNT(*) AS VLF_COUNT,
               SUM(CASE
                     WHEN Status = 0 THEN 1
                     ELSE 0
                   END) AS FREE,
               SUM(CASE
                     WHEN Status != 0 THEN 1
                     ELSE 0
                   END) AS INUSE
        FROM   VLFS
        GROUP  BY FileId
        ) AS RH 
    
	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT    
        
FETCH NEXT FROM DB_CURSOR INTO @C_DATABASE_NAME

END  /*End of the loop */
CLOSE DB_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE DB_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 

 

--REH CLEANUP THE TABLES

IF OBJECT_ID('VLFS') > 0 DROP TABLE VLFS

    
 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH


--REH CLEANUP THE TABLES

IF OBJECT_ID('VLFS') > 0 DROP TABLE VLFS



    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_INDEX_USAGE_STATS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_INDEX_USAGE_STATS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @DATABASE_ID INT, @PREV_STATS_TIME DATETIME
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_INDEX_USAGE')
  EXEC ('DROP SYNONYM [dbo].DYN_INDEX_USAGE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_INDEX_USAGE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.dm_db_index_usage_stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_INDEX_USAGE
				FOR [' + @DATABASE_NAME + '].sys.dm_db_index_usage_stats'

IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


--IF EXISTS (SELECT *
--           FROM   sys.synonyms
--           WHERE  name = 'DYN_SYSDBS')
--  DROP SYNONYM [dbo].DYN_SYSDBS


--IF @REMOTE_SERVER = 'Y'
--     BEGIN
--         SET @SQL = '
--				CREATE SYNONYM DYN_SYSDBS
--				FOR [' + @SERVER_NAME + '].[master].sys.sysdatabases'
--     END
--ELSE

--         SET @SQL = '
--				CREATE SYNONYM DYN_SYSDBS
--				FOR master.sys.sysdatabases'


--IF @DEBUG = 'Y'
--     BEGIN
--         PRINT '@SQL= ' + @SQL
--     END

--EXEC(@SQL) 

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


--SELECT @DATABASE_ID = dbid FROM DYN_SYSDBS WITH (NOLOCK) WHERE name = @DATABASE_NAME
INSERT INTO [DynamicsPerf].dbo.INDEX_USAGE_STATS
SELECT DISTINCT @SERVER_NAME,
                @STATS_DATE,
                @DATABASE_NAME,
                object_id,
                index_id,
                user_seeks,
                user_scans,
                user_lookups,
                user_updates,
                last_user_seek,
                last_user_scan,
                last_user_lookup,
                last_user_update,
                system_seeks,
                system_scans,
                system_lookups,
                system_updates,
                last_system_seek,
                last_system_scan,
                last_system_lookup,
                last_system_update
FROM   DYN_INDEX_USAGE AS DIU
       INNER JOIN (SELECT TOP 1 DATABASE_ID,
                                SERVER_NAME,
                                DATABASE_NAME
                   FROM   [DynamicsPerf].dbo.SQL_DATABASES
                   WHERE  SERVER_NAME = @SERVER_NAME
                          AND DATABASE_NAME = @DATABASE_NAME
                   ORDER  BY STATS_TIME DESC) SD
               ON DIU.database_id = SD.DATABASE_ID
                  AND SD.SERVER_NAME = @SERVER_NAME
                  AND SD.DATABASE_NAME = @DATABASE_NAME
WHERE  object_id > 99 


 
 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_INDEXSTATS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_INDEXSTATS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @PREV_STATS_TIME DATETIME
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_INDEX_COLS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_INDEX_COLS')


IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_INDEX_COLS
				FOR [' + @DATABASE_NAME + '].sys.index_columns'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_SYS_COLS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_SYS_COLS')


IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_SYS_COLS
				FOR [' + @DATABASE_NAME + '].sys.columns'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_INDEXES')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_INDEXES')


IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_INDEXES
				FOR [' + @DATABASE_NAME + '].sys.indexes'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_SYS_INDEXES')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_SYS_INDEXES')


IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_SYS_INDEXES
				FOR [' + @DATABASE_NAME + '].sys.sysindexes'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_OBJECTS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_OBJECTS')


IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_OBJECTS
				FOR [' + @DATABASE_NAME + '].sys.objects'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_SCHEMAS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_SCHEMAS')

IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_SCHEMAS
				FOR [' + @DATABASE_NAME + '].sys.schemas'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_PARTITIONS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_PARTITIONS')

IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_PARTITIONS
				FOR [' + @DATABASE_NAME + '].sys.partitions'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_PARTITION_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_PARTITION_STATS')

IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_PARTITION_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_db_partition_stats'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


IF @REMOTE_SERVER = 'N'
BEGIN
	INSERT INTO INDEX_DETAIL
	SELECT	@SERVER_NAME, CONVERT(NVARCHAR(50), @STATS_DATE, 121), @DATABASE_NAME ,
 			si.object_id,
			si.index_id,
			CASE 
			WHEN ss.name in ('sys', 'dbo') THEN so.name
			ELSE 
				ss.name + '.' + so.name
			END, 
			si.name,  
			si.type_desc+
			CASE
				WHEN is_unique = 1 THEN ', UNIQUE'
				ELSE ''
			END
			+	
			CASE
				WHEN is_primary_key = 1 THEN ', PRIMARY KEY'
				ELSE ''
			END
			+
			CASE
				WHEN has_filter = 1 THEN ', FILTERED'
				ELSE ''
			END			
			
			,
    	stuff
    		(
    				
    			(
    			SELECT	', ' + sc.name FROM DYN_CI_INDEX_COLS sic
    			JOIN	DYN_CI_SYS_COLS sc ON sc.column_id = sic.column_id
    			WHERE	so.object_id = sic.object_id
    			AND		sic.index_id = si.index_id
    			AND		sc.object_id = so.object_id
    			AND		sic.is_included_column=0
    			ORDER	BY sic.key_ordinal
    			FOR		xml path('')
    			)
    		,1,1,''
    		)  AS key_columns,
    	stuff
    		(
    			(
    			SELECT	', ' + sc.name FROM DYN_CI_INDEX_COLS sic
    			JOIN	DYN_CI_SYS_COLS sc ON sc.column_id = sic.column_id
    			WHERE	so.object_id = sic.object_id
    			AND		sic.index_id = si.index_id
    			AND		sc.object_id = so.object_id
    			AND		sic.is_included_column=1
    			ORDER BY sic.key_ordinal
    			FOR XML path('')
    			)
    		,1,1,''
    		)  AS included_columns,
    	PS.DATA_SIZE AS PAGE_COUNT,
    	PS.ROW_COUNT AS ROW_COUNT,
    	sp.data_compression
  	FROM	DYN_CI_INDEXES si
    	JOIN	DYN_CI_SYS_INDEXES ii ON si.object_id = ii.id AND si.index_id = ii.indid
    	JOIN	DYN_CI_OBJECTS so ON so.object_id = si.object_id
    	JOIN	DYN_CI_SCHEMAS ss ON ss.schema_id = so.schema_id
    	JOIN	DYN_CI_PARTITIONS sp ON so.object_id = sp.object_id AND sp.index_id = ii.indid
    	INNER JOIN  (SELECT object_id, index_id,SUM(row_count) AS ROW_COUNT,SUM(in_row_data_page_count + lob_used_page_count + row_overflow_used_page_count) AS DATA_SIZE
    	FROM DYN_CI_PARTITION_STATS GROUP BY  object_id, index_id) AS PS ON PS.index_id = si.index_id AND PS.object_id = si.object_id
    	   	
     WHERE	so.type = 'U'
    	AND		si.type > 0  --other than heap tables
    	AND     sp.partition_number = 1  -- fix issue with partiioned tables multiplying the number or records we return
    
	
	UNION ALL
    
    
SELECT	@SERVER_NAME, CONVERT(NVARCHAR(50), @STATS_DATE, 121), @DATABASE_NAME ,
    
			si.object_id,
			si.index_id,
			so.name, 
			so.name, 
			'HEAP',
			'N/A', 
			'N/A',
	PS.DATA_SIZE AS PAGE_COUNT,
	PS.ROW_COUNT AS ROW_COUNT,
	sp.data_compression 
    	FROM	DYN_CI_INDEXES si
	JOIN	DYN_CI_SYS_INDEXES ii ON si.object_id = ii.id AND si.index_id = ii.indid
	JOIN	DYN_CI_OBJECTS so ON so.object_id = si.object_id
	JOIN	DYN_CI_SCHEMAS ss ON ss.schema_id = so.schema_id
	JOIN	DYN_CI_PARTITIONS sp ON so.object_id = sp.object_id AND sp.index_id = ii.indid
	
    INNER JOIN  (SELECT object_id, index_id,SUM(row_count) AS ROW_COUNT,SUM(in_row_data_page_count + lob_used_page_count + row_overflow_used_page_count) AS DATA_SIZE
	FROM DYN_CI_PARTITION_STATS GROUP BY  object_id, index_id) AS PS ON PS.index_id = si.index_id AND PS.object_id = si.object_id
		
 WHERE	so.type = 'U'
	AND		si.type = 0  --only heap tables
	AND     sp.partition_number = 1  -- fix issue with partiioned tables multiplying the number or records we return

 END
 
 IF @REMOTE_SERVER = 'Y'
 BEGIN
 
 
    		SET @SQL = '	
			
			
			SELECT	
 			si.object_id,
			si.index_id,
			CASE 
			WHEN ss.name in (''sys'', ''dbo'') THEN so.name
			ELSE 
				ss.name + ''.'' + so.name
			END, 
			si.name,  
			si.type_desc+
			CASE
				WHEN is_unique = 1 THEN '', UNIQUE''
				ELSE ''''
			END
			+	
			CASE
				WHEN is_primary_key = 1 THEN '', PRIMARY KEY''
				ELSE ''''
			END
			+
			CASE
				WHEN has_filter = 1 THEN '', FILTERED''
				ELSE ''''
			END,
			

    	stuff
    		(
    				
    			(
    			SELECT '', '' + sc.name FROM	['+ @DATABASE_NAME+ '].sys.index_columns sic
    			JOIN	['+ @DATABASE_NAME+ '].sys.columns sc ON sc.column_id = sic.column_id
    			WHERE	so.object_id = sic.object_id
    			AND		sic.index_id = si.index_id
    			AND		sc.object_id = so.object_id
    			AND		sic.is_included_column=0
    			ORDER	BY sic.key_ordinal
    			FOR		xml path('''')
    			)
    		,1,1,''''
    		)  AS key_columns,
    	stuff
    		(
    			(
    			SELECT	'', '' + sc.name FROM ['+ @DATABASE_NAME+ '].sys.index_columns sic
    			JOIN	['+ @DATABASE_NAME+ '].sys.columns sc ON sc.column_id = sic.column_id
    			WHERE	so.object_id = sic.object_id
    			AND		sic.index_id = si.index_id
    			AND		sc.object_id = so.object_id
    			AND		sic.is_included_column=1
    			ORDER BY sic.key_ordinal
    			FOR XML path('''')
    			)
    		,1,1,''''
    		)  AS included_columns,
    	PS.DATA_SIZE AS PAGE_COUNT,
    	PS.ROW_COUNT AS ROW_COUNT,
    	sp.data_compression
    	FROM	['+ @DATABASE_NAME+ '].sys.indexes si
    	JOIN	['+ @DATABASE_NAME+ '].sys.sysindexes ii ON si.object_id = ii.id AND si.index_id = ii.indid
    	JOIN	['+ @DATABASE_NAME+ '].sys.objects so ON so.object_id = si.object_id
    	JOIN	['+ @DATABASE_NAME+ '].sys.schemas ss ON ss.schema_id = so.schema_id
    	JOIN	['+ @DATABASE_NAME+ '].sys.partitions sp ON so.object_id = sp.object_id AND sp.index_id = ii.indid
    	INNER JOIN  (SELECT object_id, index_id,SUM(row_count) AS ROW_COUNT,SUM(in_row_data_page_count + lob_used_page_count + row_overflow_used_page_count) AS DATA_SIZE
    	FROM ['+ @DATABASE_NAME+ '].sys.dm_db_partition_stats GROUP BY  object_id, index_id) AS PS ON PS.index_id = si.index_id AND PS.object_id = si.object_id
    	
     WHERE	so.type = ''U''
    	AND		si.type > 0 
    	AND     sp.partition_number = 1 
    
	
	UNION ALL
    
    
SELECT	
    
			si.object_id,
			si.index_id,
			so.name, 
			so.name, 
			''HEAP'',

			''N/A'', 
			''N/A'',
	PS.DATA_SIZE AS PAGE_COUNT,
	PS.ROW_COUNT AS ROW_COUNT,
	sp.data_compression 
    	FROM	['+ @DATABASE_NAME+ '].sys.indexes si
	JOIN	['+ @DATABASE_NAME+ '].sys.sysindexes ii ON si.object_id = ii.id AND si.index_id = ii.indid
	JOIN	['+ @DATABASE_NAME+ '].sys.objects so ON so.object_id = si.object_id
	JOIN	['+ @DATABASE_NAME+ '].sys.schemas ss ON ss.schema_id = so.schema_id
	JOIN	['+ @DATABASE_NAME+ '].sys.partitions sp ON so.object_id = sp.object_id AND sp.index_id = ii.indid
	
    INNER JOIN  (SELECT object_id, index_id,SUM(row_count) AS ROW_COUNT,SUM(in_row_data_page_count + lob_used_page_count + row_overflow_used_page_count) AS DATA_SIZE
	FROM ['+ @DATABASE_NAME+ '].sys.dm_db_partition_stats GROUP BY  object_id, index_id) AS PS ON PS.index_id = si.index_id AND PS.object_id = si.object_id
	
 WHERE	so.type = ''U''
	AND		si.type = 0  --only heap tables
	AND     sp.partition_number = 1 ' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  INSERT INTO DynamicsPerf.dbo.INDEX_DETAIL
						 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + ','
				  + '''' + @DATABASE_NAME + '''' + ',*
		                   FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ')'


		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)

 END
 
    
    
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_PERF_COUNTERS]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_COLLECT_PERF_COUNTERS]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30), @START_POS INT, @END_POS INT
    DECLARE @INSTANCE_NAME NVARCHAR(128)
    
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CPC_PERF_COUNTERS')
  EXEC ('DROP SYNONYM [dbo].DYN_CPC_PERF_COUNTERS')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_CPC_PERF_COUNTERS
				FOR [' + @SERVER_NAME + '].master.sys.dm_os_performance_counters '
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CPC_PERF_COUNTERS
				FOR master.sys.dm_os_performance_counters '

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 




/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

		--SET @END_POS = LEN(@SERVER_NAME)
		--SET @START_POS = CHARINDEX('\', @SERVER_NAME,1)+1
		--IF @START_POS > 0
		--BEGIN
		--	SET @INSTANCE_NAME = 'MSSQL$' + SUBSTRING(@SERVER_NAME, @START_POS, @END_POS) + ':'
		--END
		--ELSE
		--BEGIN
		--	SET @INSTANCE_NAME = 'SQLServer:'
		--END
		
		

INSERT PERF_COUNTER_DATA
SELECT @SERVER_NAME,
       @STATS_DATE,
       PTC.OBJECT_NAME,
       PTC.COUNTER_NAME,
       PTC.INSTANCE_NAME,
       DPC.cntr_value,
       DPC.cntr_type
FROM   PERF_COUNTER_2_COLLECT PTC 
        JOIN DYN_CPC_PERF_COUNTERS as DPC
               ON DPC.counter_name = PTC.COUNTER_NAME
                  AND PTC.INSTANCE_NAME = DPC.instance_name
                  AND  DPC.object_name   LIKE '%' + PTC.OBJECT_NAME + '%'



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_PERF_COUNTERS_AZURE]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_COLLECT_PERF_COUNTERS_AZURE]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30), @START_POS INT, @END_POS INT
    DECLARE @INSTANCE_NAME NVARCHAR(128)
    
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF @AZURE_DB = 0 RETURN(0)  --REH THIS SPROC IS MEANT FOR AZURE ONLY


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CPC_PERF_COUNTERS')
  EXEC ('DROP SYNONYM [dbo].DYN_CPC_PERF_COUNTERS')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_CPC_PERF_COUNTERS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.dm_os_performance_counters '
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CPC_PERF_COUNTERS
				FOR master.sys.dm_os_performance_counters '

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 




/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

		--SET @END_POS = LEN(@SERVER_NAME)
		--SET @START_POS = CHARINDEX('\', @SERVER_NAME,1)+1
		--IF @START_POS > 0
		--BEGIN
		--	SET @INSTANCE_NAME = 'MSSQL$' + SUBSTRING(@SERVER_NAME, @START_POS, @END_POS) + ':'
		--END
		--ELSE
		--BEGIN
		--	SET @INSTANCE_NAME = 'SQLServer:'
		--END
		
		

INSERT PERF_COUNTER_DATA
SELECT @SERVER_NAME,
       @STATS_DATE,
       PTC.OBJECT_NAME,
       PTC.COUNTER_NAME,
       PTC.INSTANCE_NAME,
       DPC.cntr_value,
       DPC.cntr_type
FROM   PERF_COUNTER_2_COLLECT PTC 
        JOIN DYN_CPC_PERF_COUNTERS as DPC
               ON DPC.counter_name = PTC.COUNTER_NAME
                  AND PTC.INSTANCE_NAME = DPC.instance_name
                  AND  DPC.object_name   LIKE '%' + PTC.OBJECT_NAME + '%'



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_QUERY_STATS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_QUERY_STATS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQL_BUILD NVARCHAR(128)

	--REH Get the build so we can add the new columns to the query_stats table from SQL2016 and above
    SELECT @SQL_BUILD = SQL_VERSION  FROM STATS_COLLECTION_SUMMARY SCS WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME=@DATABASE_NAME AND STATS_TIME = @STATS_DATE
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_QS_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_QS_STATS') 
  
IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_PLAN_ATTRIBUTES')
  EXEC ('DROP SYNONYM [dbo].DYN_PLAN_ATTRIBUTES')



         SET @SQL = '
				CREATE SYNONYM DYN_QS_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_query_stats'

EXEC (@SQL)


         SET @SQL = '
				CREATE SYNONYM DYN_PLAN_ATTRIBUTES
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_plan_attributes'

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 





PRINT 'TIME ZONE OFFSET AT TASK ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
PRINT 'LAST RUN AT TASK ' + CAST(@LAST_RUN AS VARCHAR(20))


PRINT 'LAST RUN WITH OFFSET ' + CAST(@LAST_RUN AS VARCHAR(20))
 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, ' TASK')
PRINT ''




IF @DEBUG = 'Y'
  BEGIN
      PRINT '@LAST_RUN = '

      PRINT @LAST_RUN
  END 
  
  
  IF @REMOTE_SERVER = 'N'
       BEGIN
			--IF @SQL_BUILD >= '13.' --REH  SQL2016 or above
		          
 SET @SQL =  ' INSERT INTO DynamicsPerf.dbo.QUERY_STATS

          SELECT MIN(' + '''' + @SERVER_NAME + '''' + '), MAX(' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + '),MIN('
				  + '''' + @DATABASE_NAME + '''' + '), 
                  MIN(plan_handle),
                  MAX(plan_generation_num),
                  creation_time,
                  MAX(last_execution_time),
                  SUM(execution_count),
                  SUM(total_worker_time),
                  AVG(last_worker_time),
                  MIN(min_worker_time),
                  MAX(max_worker_time),
                  SUM(total_physical_reads),
                  AVG(last_physical_reads),
                  MIN(min_physical_reads),
                  MAX(max_physical_reads),
                  SUM(total_logical_writes),
                  AVG(last_logical_writes),
                  MIN(min_logical_writes),
                  MAX(max_logical_writes),
                  SUM(total_logical_reads),
                  AVG(last_logical_reads),
                  MIN(min_logical_reads),
                  MAX(max_logical_reads),
                  SUM(total_clr_time),
                  AVG(last_clr_time),
                  MIN(min_clr_time),
                  MAX(max_clr_time),
                  SUM(total_elapsed_time),
                  AVG(last_elapsed_time),
                  MIN(min_elapsed_time),
                  MAX(max_elapsed_time),
                  query_hash,
                  query_plan_hash,
                  SUM ( total_rows),
                  SUM ( last_rows),
                  MAX ( max_rows),
                  MIN ( min_rows),'

				  IF @SQL_BUILD >= '13.' or (@SQL_BUILD >= '11.0.6020' and @SQL_BUILD < '12.') --REH correct build per version
				  BEGIN
					  SELECT @SQL = @SQL + 'SUM(total_dop), SUM(last_dop), SUM(min_dop), SUM(max_dop) '

				  END
				  ELSE
				  BEGIN
					SELECT @SQL = @SQL + 'SUM(-1), SUM(-1), SUM(-1), SUM(-1) '


				  END
SELECT @SQL = @SQL + '

           FROM   sys.dm_exec_query_stats
                  OUTER APPLY sys.dm_exec_plan_attributes (plan_handle)
           WHERE  attribute = N''dbid''
                  AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
                  AND dateadd(ms,last_elapsed_time/1000,last_execution_time) >= ''' +CONVERT(NVARCHAR(24), @LAST_RUN, 121) + '''
           GROUP  BY query_hash,
                     query_plan_hash,
					 creation_time'


					 
			IF @DEBUG = 'Y'
			  BEGIN
				  PRINT @SQL
			  END 
  
			  EXEC (@SQL)

		END

  IF @REMOTE_SERVER = 'Y'
       BEGIN
       
    

           --INSERT INTO QUERY_STATS
           
 SET @SQL = '
           SELECT 
                  MIN(plan_handle),
                  MAX(plan_generation_num),
                  creation_time,
                  MAX(last_execution_time),
                  SUM(execution_count),
                  SUM(total_worker_time),
                  AVG(last_worker_time),
                  MIN(min_worker_time),
                  MAX(max_worker_time),
                  SUM(total_physical_reads),
                  AVG(last_physical_reads),
                  MIN(min_physical_reads),
                  MAX(max_physical_reads),
                  SUM(total_logical_writes),
                  AVG(last_logical_writes),
                  MIN(min_logical_writes),
                  MAX(max_logical_writes),
                  SUM(total_logical_reads),
                  AVG(last_logical_reads),
                  MIN(min_logical_reads),
                  MAX(max_logical_reads),
                  SUM(total_clr_time),
                  AVG(last_clr_time),
                  MIN(min_clr_time),
                  MAX(max_clr_time),
                  SUM(total_elapsed_time),
                  AVG(last_elapsed_time),
                  MIN(min_elapsed_time),
                  MAX(max_elapsed_time),
                  query_hash,
                  query_plan_hash,
                  SUM ( total_rows),
                  SUM ( last_rows),
                  MAX ( max_rows),
                  MIN ( min_rows),'

				   IF @SQL_BUILD >= '13.' or (@SQL_BUILD >= '11.0.6020' and @SQL_BUILD < '12.') --REH correct build per version
				  BEGIN
					  SELECT @SQL = @SQL + 'SUM(total_dop), SUM(last_dop), SUM(min_dop), SUM(max_dop) '

				  END
				  ELSE
				  BEGIN
					SELECT @SQL = @SQL + 'SUM(-1), SUM(-1), SUM(-1), SUM(-1) '


				  END
SELECT @SQL = @SQL + '

           FROM   sys.dm_exec_query_stats
                  OUTER APPLY sys.dm_exec_plan_attributes (plan_handle)
           WHERE  attribute = N''dbid''
                  AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
                  AND dateadd(ms,last_elapsed_time/1000,last_execution_time) >= ''' +CONVERT(NVARCHAR(24), @LAST_RUN, 121) + '''
           GROUP  BY query_hash,
                     query_plan_hash,
					 creation_time'
                    



                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  INSERT INTO DynamicsPerf.dbo.QUERY_STATS
				 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + ','
				  + '''' + @DATABASE_NAME + '''' + ',
                    
                    RH.* FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '

				 
				 EXECUTE (@SQL2)
				 
       END 
  




UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SERVER_DISKVOLUMES]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SERVER_DISKVOLUMES (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30)
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDV_SQLVERSION')
  EXEC ('DROP SYNONYM [dbo].DYN_SDV_SQLVERSION')
  

IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SDV_SQLVERSION
				FOR [' + @SERVER_NAME + '].master.sys.xp_msver'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDV_SQLVERSION
				FOR master.sys.xp_msver'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


CREATE  table #SQLVERSION(
[INDEX] INT,
NAME NVARCHAR(128),
INTERNAL_VALUE NVARCHAR(128),
VALUE NVARCHAR(128)
);

INSERT #SQLVERSION
exec DYN_SDV_SQLVERSION  --[master].sys.[xp_msver]

SELECT @SQLVERSION = VALUE FROM #SQLVERSION WHERE NAME = 'ProductVersion'

DROP TABLE #SQLVERSION


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @SQLVERSION >= '10.50.2500'
BEGIN

DELETE FROM SERVER_DISKVOLUMES WHERE SERVER_NAME = @SERVER_NAME


SET @SQL = '
SELECT DISTINCT ' + ''''+ @SERVER_NAME +'''' + ',vs.volume_mount_point,  
                vs.volume_id,
                vs.logical_volume_name,
                vs.file_system_type,
                vs.total_bytes / 1024 / 1024,
                vs.available_bytes / 1024 / 1024,
                CONVERT(DECIMAL(5, 2), vs.available_bytes * 100.0 / vs.total_bytes),
                vs.supports_compression,
                vs.supports_alternate_streams,
                vs.supports_sparse_files,
                vs.is_read_only,
                vs.is_compressed
FROM   sys.sysaltfiles AS f
       CROSS APPLY sys.dm_os_volume_stats(f.dbid, f.fileid) AS vs
WHERE  f.dbid < 32767
ORDER  BY 7 DESC '


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


IF @REMOTE_SERVER = 'N'
BEGIN

		INSERT SERVER_DISKVOLUMES EXEC (@SQL) 

END
ELSE
BEGIN

		          
		SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT ['
					+ @SERVER_NAME + ']' 

		  
		  IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL2
		END

		INSERT SERVER_DISKVOLUMES EXEC (@SQL2) 


END



END

ELSE
BEGIN
    PRINT 'SQL older than 2008 R2 SP1, Please update'
END 

 
 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SERVER_OS_INFO]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SERVER_OS_INFO (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30)
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOI_SERVER_OS_INFO')
  EXEC ('DROP SYNONYM [dbo].DYN_SOI_SERVER_OS_INFO')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SOI_SERVER_OS_INFO
				FOR [' + @SERVER_NAME + '].master.sys.dm_os_windows_info'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOI_SERVER_OS_INFO
				FOR master.sys.dm_os_windows_info'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOI_SQLVERSION')
  EXEC ('DROP SYNONYM [dbo].DYN_SOI_SQLVERSION')
  

IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SOI_SQLVERSION
				FOR [' + @SERVER_NAME + '].master.sys.xp_msver'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOI_SQLVERSION
				FOR master.sys.xp_msver'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


CREATE  table #SQLVERSION(
[INDEX] INT,
NAME NVARCHAR(128),
INTERNAL_VALUE NVARCHAR(128),
VALUE NVARCHAR(128)
);

INSERT #SQLVERSION
exec DYN_SOI_SQLVERSION  --[master].sys.[xp_msver]

SELECT @SQLVERSION = VALUE FROM #SQLVERSION WHERE NAME = 'ProductVersion'

DROP TABLE #SQLVERSION


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @SQLVERSION >= '10.50.2500'
BEGIN

DELETE FROM SERVER_OS_VERSION WHERE SERVER_NAME = @SERVER_NAME

INSERT SERVER_OS_VERSION
SELECT @SERVER_NAME,
       windows_release,
       windows_service_pack_level,
       windows_sku,
       os_language_version
FROM   DYN_SOI_SERVER_OS_INFO 


END

ELSE
BEGIN
    PRINT 'SQL older than 2008 R2 SP1, Please update'
END 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SERVER_REGISTRY]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SERVER_REGISTRY (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30)
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SR_SERVER_REGISTRY')
  EXEC ('DROP SYNONYM [dbo].DYN_SR_SERVER_REGISTRY')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SR_SERVER_REGISTRY
				FOR [' + @SERVER_NAME + '].master.sys.dm_server_registry'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SR_SERVER_REGISTRY
				FOR master.sys.dm_server_registry'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SR_SQLVERSION')
  EXEC ('DROP SYNONYM [dbo].DYN_SR_SQLVERSION')
  

IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SR_SQLVERSION
				FOR [' + @SERVER_NAME + '].master.sys.xp_msver'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SR_SQLVERSION
				FOR master.sys.xp_msver'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


CREATE  table #SQLVERSION(
[INDEX] INT,
NAME NVARCHAR(128),
INTERNAL_VALUE NVARCHAR(128),
VALUE NVARCHAR(128)
);

INSERT #SQLVERSION
exec DYN_SR_SQLVERSION  --[master].sys.[xp_msver]

SELECT @SQLVERSION = VALUE FROM #SQLVERSION WHERE NAME = 'ProductVersion'

DROP TABLE #SQLVERSION


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @SQLVERSION >= '10.50.2500'
BEGIN

DELETE FROM SERVER_REGISTRY WHERE SERVER_NAME = @SERVER_NAME

INSERT SERVER_REGISTRY
SELECT @SERVER_NAME,
       registry_key,
       value_name,
       value_data
FROM   DYN_SR_SERVER_REGISTRY 



END

ELSE
BEGIN
    PRINT 'SQL older than 2008 R2 SP1, Please update'
END 

 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SERVERINFO]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SERVERINFO (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF @AZURE_DB = 0
BEGIN

		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_SI_SQLVERSION')
		 EXEC ('DROP SYNONYM [dbo].DYN_SI_SQLVERSION')


		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL = '
						CREATE SYNONYM DYN_SI_SQLVERSION
						FOR [' + @SERVER_NAME + '].master.sys.xp_msver'
			 END
		ELSE

				 SET @SQL = '
						CREATE SYNONYM DYN_SI_SQLVERSION
						FOR master.sys.xp_msver'

		IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL
		END

		EXEC (@SQL) 


		CREATE  table #SQLVERSION(
		[INDEX] INT,
		NAME NVARCHAR(128),
		INTERNAL_VALUE NVARCHAR(128),
		VALUE NVARCHAR(128)
		);

		INSERT #SQLVERSION
		exec DYN_SI_SQLVERSION  --[master].sys.[xp_msver]

		SELECT @SQLVERSION = VALUE FROM #SQLVERSION WHERE NAME = 'ProductVersion'

END
ELSE
BEGIN 
	SET @SQLVERSION = '12.0' 
END



SELECT @SQL = 'SELECT '+QUOTENAME(@SERVER_NAME,'''')+ ',
       '+ QUOTENAME(CONVERT(NVARCHAR(50), @STATS_DATE, 121),'''') +',sqlserver_start_time,
       Serverproperty(''ComputerNamePhysicalNetBIOS'') AS PhysicalComputerName,
       Serverproperty(''IsClustered'')                 AS IsClustered,
       Serverproperty(''MachineName'')                 AS MachineName,
       Serverproperty(''InstanceName'')                AS InstanceName,
       Serverproperty(''ProductVersion'')              AS ProductVersion,
       Serverproperty(''ProductLevel'')                AS ProductLevel,
       Serverproperty(''Edition'')                     AS Edition,
       Serverproperty(''EngineEdition'')               AS EngineEdition,
       Serverproperty(''SqlCharSet'')                  AS SqlCharSet,
       Serverproperty(''SqlCharSetName'')              AS SqlCharSetName,
       Serverproperty(''SqlSortOrder'')                AS SqlSortOrder,
       Serverproperty(''SqlSortOrderName'')            AS SqlSortOrderName,
       cpu_count,
       hyperthread_ratio,'

	   IF @SQLVERSION >= '11.0'
	   BEGIN
	   SELECT @SQL = @SQL +'
       committed_kb / 1024                     AS Bpool_Committed_MB,
       committed_target_kb / 1024                 AS Bpool_Commit_Target_MB,
       visible_target_kb / 1024                       AS Bpool_Visible_MB,
       (select count(*) from sys.dm_os_schedulers where status like ''VISIBLE ONLINE'' )  AS SQL_SCHEDULER_COUNT
	   '
		END
		ELSE
		BEGIN
		SELECT  @SQL = @SQL + 'bpool_committed / 1024 * 8                    AS Bpool_Committed_MB,
       bpool_commit_target / 1024 * 8                AS Bpool_Commit_Target_MB,
       bpool_visible / 1024 * 8                      AS Bpool_Visible_MB,
       (select count(*) from sys.dm_os_schedulers where status like ''VISIBLE ONLINE'' )  AS SQL_SCHEDULER_COUNT
	   '
		END

SELECT @SQL = @SQL + '
FROM   sys.dm_os_sys_info
       '



IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END




/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @REMOTE_SERVER = 'N'
BEGIN


INSERT INTO SERVERINFO 
EXEC( @SQL)

END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
 
		SET @SQL2 = ' 
						  SET QUOTED_IDENTIFIER OFF
						  	INSERT DynamicsPerf.dbo.SERVERINFO

								SELECT ' + '''' + @SERVER_NAME + '''' + ',' + ''''
					+ CONVERT(NVARCHAR(50), @STATS_DATE, 121) + ''''
					+ ', * FROM OPENQUERY(['+@SERVER_NAME+ '],"
	
	SELECT sqlserver_start_time ,
       Serverproperty(''ComputerNamePhysicalNetBIOS'') AS PhysicalComputerName,
       Serverproperty(''IsClustered'')                 AS IsClustered,
       Serverproperty(''MachineName'')                 AS MachineName,
       Serverproperty(''InstanceName'')                AS InstanceName,
       Serverproperty(''ProductVersion'')              AS ProductVersion,
       Serverproperty(''ProductLevel'')                AS ProductLevel,
       Serverproperty(''Edition'')                     AS Edition,
       Serverproperty(''EngineEdition'')               AS EngineEdition,
       Serverproperty(''SqlCharSet'')                  AS SqlCharSet,
       Serverproperty(''SqlCharSetName'')              AS SqlCharSetName,
       Serverproperty(''SqlSortOrder'')                AS SqlSortOrder,
       Serverproperty(''SqlSortOrderName'')            AS SqlSortOrderName,
       cpu_count,
       hyperthread_ratio,
       committed_kb / 1024                     AS Bpool_Committed_MB,
       committed_target_kb / 1024                 AS Bpool_Commit_Target_MB,
       visible_target_kb / 1024                       AS Bpool_Visible_MB,
       (select count(*) from sys.dm_os_schedulers where status like ''VISIBLE ONLINE'' )  AS SQL_SCHEDULER_COUNT
FROM   sys.dm_os_sys_info
	"
	)'

	
		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL2
			 END

		EXEC (@SQL2) 

 
 
 END
 
    

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SQL_CONFIGURATION]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SQL_CONFIGURATION (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SC_SYSCONFIGS')
  EXEC ('DROP SYNONYM [dbo].DYN_SC_SYSCONFIGS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SC_SYSCONFIGS
				FOR [' + @SERVER_NAME + '].master.sys.configurations'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SC_SYSCONFIGS
				FOR master.sys.configurations'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 





BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

INSERT INTO [DynamicsPerf]..SQL_CONFIGURATION 
SELECT @SERVER_NAME, @STATS_DATE, 
	name,
      convert(int, minimum) as minimum,
      convert(int, maximum) as maximum,
      convert(int, isnull(value, value_in_use)) as config_value,
      convert(int, value_in_use) as run_value
from  DYN_SC_SYSCONFIGS
order by lower(name)

 
    
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SQL_DATA_BUFFER_CACHE]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SQL_DATA_BUFFER_CACHE (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF @AZURE_DB = 0
BEGIN

		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_SDBC_OS_BUFFERS')
		  EXEC ('DROP SYNONYM [dbo].DYN_SDBC_OS_BUFFERS')


		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL = '
						CREATE SYNONYM DYN_SDBC_OS_BUFFERS
						FOR [' + @SERVER_NAME + '].master.sys.dm_os_buffer_descriptors'
			 END
		ELSE

				 SET @SQL = '
						CREATE SYNONYM DYN_SDBC_OS_BUFFERS
						FOR master.sys.dm_os_buffer_descriptors'

		IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL
		END

		EXEC (@SQL) 

END



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @REMOTE_SERVER = 'N'
BEGIN

		INSERT INTO [DynamicsPerf]..BUFFER_DETAIL
		SELECT @SERVER_NAME,
			   CONVERT(NVARCHAR(50), @STATS_DATE, 121),
			   CASE
				 WHEN database_id = 32767 THEN 'resourceDb'
				 ELSE CAST(DB_NAME(database_id) AS NVARCHAR(128))
			   END,
			   COUNT(*) * 8 / 1024
		FROM   DYN_SDBC_OS_BUFFERS WITH(nolock)
		GROUP  BY database_id 
END

IF @REMOTE_SERVER = 'Y'
BEGIN

		SET @SQL2 = ' 
						  SET QUOTED_IDENTIFIER OFF
						  	INSERT DynamicsPerf.dbo.BUFFER_DETAIL
			
					SELECT ' + '''' + @SERVER_NAME + '''' + ',' + ''''
					+ CONVERT(NVARCHAR(50), @STATS_DATE, 121) + ''''
					+ ', * FROM OPENQUERY(['+@SERVER_NAME+ '],"


		SELECT 
			   CASE
				 WHEN database_id = 32767 THEN ''resourceDb''
				 ELSE CAST(DB_NAME(database_id) AS NVARCHAR(128))
			   END,
			   COUNT(*) * 8 / 1024
		FROM   sys.dm_os_buffer_descriptors
		GROUP  BY database_id ")'

			
		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL2
			 END

		EXEC (@SQL2) 

END

 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/




BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SQL_DATABASE_FILES]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SQL_DATABASE_FILES (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @C_DATABASE_NAME NVARCHAR(128), @ROW_COUNT BIGINT = 0
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDF_SYSDATABASES')
  EXEC ('DROP SYNONYM [dbo].DYN_SDF_SYSDATABASES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES
				FOR [' + @SERVER_NAME + '].master.sys.databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES
				FOR master.sys.databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


-- sys.master_files



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDF_SYSMASTERFILES')
  EXEC ('DROP SYNONYM [dbo].DYN_SDF_SYSMASTERFILES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSMASTERFILES
				FOR [' + @SERVER_NAME + '].master.sys.master_files'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSMASTERFILES 
				FOR master.sys.master_files'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


Create Table #DBFILES
(
    DatabaseName sysname,
    Name sysname,
    physical_name nvarchar(500),
    size decimal (18,2),
    FreeSpace decimal (18,2),
	Initial_size decimal (18,2)
)   


IF @REMOTE_SERVER = 'N'
BEGIN


Exec sp_MSforeachdb '
Use [?];
Insert Into #DBFILES (DatabaseName, Name, physical_name, Size, FreeSpace,Initial_size)
    Select DB_NAME() AS [DatabaseName], Name,  physical_name,
    Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) as nvarchar) Size,
    Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) -
        Cast(FILEPROPERTY(name, ''SpaceUsed'') * 8.0/1024.0 as decimal(18,2)) as nvarchar) As FreeSpace,
		0 as Initial_size
    From sys.database_files
'

--drop table #DBFILES

END


IF @REMOTE_SERVER = 'Y'
		BEGIN

	SET QUOTED_IDENTIFIER OFF

		SET @SQL = 'SET QUOTED_IDENTIFIER OFF
				exec sp_msforeachdb "Use [?];
					Insert Into #DBFILES (DatabaseName, Name, physical_name, Size, FreeSpace, Initial_size)
					Select DB_NAME() AS [DatabaseName], Name,  physical_name,
					Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) as nvarchar) Size,
					Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) -
						Cast(FILEPROPERTY(name, '+''''+'SpaceUsed'+'''' +') * 8.0/1024.0 as decimal(18,2)) as nvarchar) As FreeSpace,
						0 as Initial_size
					From sys.database_files"
				'

			SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
						EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']'

			IF @DEBUG = 'Y'
				BEGIN
					PRINT '@SQL= ' + @SQL2
				END

			BEGIN TRY
				INSERT #DBFILES
				EXEC (@SQL2 ) 
			END TRY

			BEGIN CATCH
			--ignore the error
			END CATCH
				 
				 
		END 


		 
--REH  Add initial size of TempDB

UPDATE SDF SET [Initial_size] = MF.size * 8 /1024
FROM #DBFILES SDF  JOIN
(
  SELECT size, physical_name FROM DYN_SDF_SYSMASTERFILES ) AS MF 
  ON MF.physical_name COLLATE DATABASE_DEFAULT = SDF.physical_name COLLATE DATABASE_DEFAULT




DECLARE DB_CURSOR CURSOR  LOCAL
FOR
SELECT name from DYN_SDF_SYSDATABASES


OPEN DB_CURSOR

FETCH NEXT FROM DB_CURSOR INTO @C_DATABASE_NAME

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

--REH  Build the Synonym as we loop through each database

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDF_SYSDATABASES_FILES')
  EXEC ('DROP SYNONYM [dbo].DYN_SDF_SYSDATABASES_FILES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES_FILES
				FOR [' + @SERVER_NAME + '].[' + @C_DATABASE_NAME + '].sys.database_files'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES_FILES
				FOR [' + @C_DATABASE_NAME + '].sys.database_files'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 

INSERT INTO [DynamicsPerf]..SQL_DATABASEFILES
SELECT @SERVER_NAME                                                                           AS [RUN_NAME],
       CONVERT(NVARCHAR(50), @STATS_DATE, 121)                                             AS [STATS_TIME],
       @C_DATABASE_NAME,
       [file_id],
       [File Name] COLLATE DATABASE_DEFAULT,
       [Physical Name] COLLATE DATABASE_DEFAULT,
       [File Type],
       [Total Size in Mb],
       [Available Space in Mb],
       CEILING(CAST([Available Space in Mb] AS DECIMAL(10, 1)) / [Total Size in Mb] * 100) AS [Free Space %],
       [Growth Units],
       [max File Size in Mb],
       [DB_INITAL_SIZE(MB)]
FROM   (SELECT [file_id],
               [name]   COLLATE DATABASE_DEFAULT     AS [File Name],
               physical_name COLLATE DATABASE_DEFAULT AS [Physical Name],
               [File Type] = CASE type
                               WHEN 0 THEN 'Data'
                               WHEN 1 THEN 'Log'
                             END,
               [Total Size in Mb] = CASE CEILING([size] / 128)
                                      WHEN 0 THEN 1
                                      ELSE CEILING([size] / 128)
                                    END,
               [Available Space in Mb] = (SELECT FreeSpace FROM #DBFILES TDB WHERE DYN_SDF.physical_name COLLATE DATABASE_DEFAULT = TDB.physical_name COLLATE DATABASE_DEFAULT),
			   
									--CASE CEILING([size] / 128)
         --                                  WHEN 0 THEN ( 1 - CAST(FILEPROPERTY([name], 'SpaceUsed') AS INT) / 128 )
         --                                  ELSE ( ( [size] / 128 ) - CAST(FILEPROPERTY([name], 'SpaceUsed') AS INT) / 128 )
         --                                END,
               [Growth Units] = CASE [is_percent_growth]
                                  WHEN 1 THEN CAST(growth AS VARCHAR(20)) + '%'
                                  ELSE CAST(growth/128 AS VARCHAR(20)) + 'Mb'
                                END,
               [max File Size in Mb] = CASE [max_size]
                                         WHEN -1 THEN NULL
                                         WHEN 268435456 THEN NULL
                                         ELSE [max_size]
                                       END,
				[DB_INITAL_SIZE(MB)] = (SELECT Initial_size FROM #DBFILES TDB WHERE DYN_SDF.physical_name COLLATE DATABASE_DEFAULT = TDB.physical_name COLLATE DATABASE_DEFAULT)
        FROM   DYN_SDF_SYSDATABASES_FILES DYN_SDF) AS RH
ORDER  BY [File Type],
          [file_id] 


SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

FETCH NEXT FROM DB_CURSOR INTO @C_DATABASE_NAME

END  /*End of the loop */
CLOSE DB_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE DB_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 



IF OBJECT_ID('tempdb..#DBFILES') IS NOT NULL
/*Then it exists*/
   DROP TABLE #DBFILES
 


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SQL_DATABASES]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SQL_DATABASES (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDB_SYSDATABASES')
  EXEC ('DROP SYNONYM [dbo].DYN_SDB_SYSDATABASES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SDB_SYSDATABASES
				FOR [' + @SERVER_NAME + '].master.sys.databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDB_SYSDATABASES
				FOR master.sys.databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

INSERT INTO [DynamicsPerf]..SQL_DATABASES
SELECT @SERVER_NAME, CONVERT(NVARCHAR(50), @STATS_DATE, 121),
[name]
      ,[database_id]
      ,[source_database_id]
      ,[owner_sid]
      ,[create_date]
      ,[compatibility_level]
      ,[collation_name]
      ,[user_access]
      ,[user_access_desc]
      ,[is_read_only]
      ,[is_auto_close_on]
      ,[is_auto_shrink_on]
      ,[state]
      ,[state_desc]
      ,[is_in_standby]
      ,[is_cleanly_shutdown]
      ,[is_supplemental_logging_enabled]
      ,[snapshot_isolation_state]
      ,[snapshot_isolation_state_desc]
      ,[is_read_committed_snapshot_on]
      ,[recovery_model]
      ,[recovery_model_desc]
      ,[page_verify_option]
      ,[page_verify_option_desc]
      ,[is_auto_create_stats_on]
      ,[is_auto_update_stats_on]
      ,[is_auto_update_stats_async_on]
      ,[is_ansi_null_default_on]
      ,[is_ansi_nulls_on]
      ,[is_ansi_padding_on]
      ,[is_ansi_warnings_on]
      ,[is_arithabort_on]
      ,[is_concat_null_yields_null_on]
      ,[is_numeric_roundabort_on]
      ,[is_quoted_identifier_on]
      ,[is_recursive_triggers_on]
      ,[is_cursor_close_on_commit_on]
      ,[is_local_cursor_default]
      ,[is_fulltext_enabled]
      ,[is_trustworthy_on]
      ,[is_db_chaining_on]
      ,[is_parameterization_forced]
      ,[is_master_key_encrypted_by_server]
      ,[is_published]
      ,[is_subscribed]
      ,[is_merge_published]
      ,[is_distributor]
      ,[is_sync_with_backup]
      ,[service_broker_guid]
      ,[is_broker_enabled]
      ,[log_reuse_wait]
      ,[log_reuse_wait_desc]
      ,[is_date_correlation_on]
      ,[is_cdc_enabled]
	FROM DYN_SDB_SYSDATABASES

    



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SQL_ERRORLOG]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SQL_ERRORLOG (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/
IF @AZURE_DB = 0
BEGIN
IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SEL_XP_READERRORLOG')
  EXEC ('DROP SYNONYM [dbo].DYN_SEL_XP_READERRORLOG')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SEL_XP_READERRORLOG
				FOR [' + @SERVER_NAME + '].master.sys.xp_readerrorlog'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SEL_XP_READERRORLOG
				FOR master.sys.xp_readerrorlog'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 
END


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH limit us to last 2 weeks if this is first run on this server

IF @LAST_RUN < (DATEADD(DD, -14, GETDATE()))  
BEGIN
 SET @LAST_RUN = (DATEADD(DD, -14, GETDATE()))
END

IF @AZURE_DB = 0
BEGIN


		CREATE TABLE #ERRORLOG
		  (
			 LogDate     DATETIME,
			 ProcessInfo NVARCHAR(255),
			 LogText     NVARCHAR(MAX)
		  ); 


		INSERT INTO #ERRORLOG (
		   [LogDate],
		   [ProcessInfo],
		   [LogText]
		)

		EXEC DYN_SEL_XP_READERRORLOG 0,1,NULL,NULL,@LAST_RUN, @STATS_DATE, 'ASC'
 

 
		INSERT INTO SQLERRORLOG 
		SELECT @SERVER_NAME,* FROM #ERRORLOG 
		DROP TABLE #ERRORLOG;  
END

 IF @AZURE_DB = 1
BEGIN

SET @LAST_RUN = DATEADD(hh, DATEDIFF(hh, GETDATE(), GETUTCDATE()), @LAST_RUN)


		SET @SQL2 = ' 
						  SET QUOTED_IDENTIFIER OFF
						  	INSERT DynamicsPerf.dbo.SQL_AZURE_EVENTS
			
					SELECT ' + '''' + @SERVER_NAME + '''' 
					+ ', * FROM OPENQUERY(['+@SERVER_NAME+ '],"


	 select database_name, start_time, end_time, event_category, event_type, event_subtype,
	event_subtype_desc, severity, event_count, description, cast(additional_data as nvarchar(max)) from sys.event_log
		WHERE end_time >= ' + '''' + CONVERT(VARCHAR(30),@LAST_RUN, 109) + '''' + ' 
		AND database_name = ' + '''' + @DATABASE_NAME + ''''
	 +'")'

			
		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL2
			 END

		EXEC (@SQL2) 


END
    
   


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SQL_JOBS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SQL_JOBS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SJ_SYSSCHEDULES')
  EXEC ('DROP SYNONYM [dbo].DYN_SJ_SYSSCHEDULES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSSCHEDULES
				FOR [' + @SERVER_NAME + '].msdb.dbo.sysschedules'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSSCHEDULES
				FOR msdb.dbo.sysschedules'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SJ_SYSJOBSCHEDULES')
  EXEC ('DROP SYNONYM [dbo].DYN_SJ_SYSJOBSCHEDULES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSJOBSCHEDULES
				FOR [' + @SERVER_NAME + '].msdb.dbo.sysjobschedules'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSJOBSCHEDULES
				FOR msdb.dbo.sysjobschedules'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SJ_SYSJOBS')
  EXEC ('DROP SYNONYM [dbo].DYN_SJ_SYSJOBS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSJOBS
				FOR [' + @SERVER_NAME + '].msdb.dbo.sysjobs'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSJOBS
				FOR msdb.dbo.sysjobs'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SJ_SYSJOBSTEPS')
  EXEC ('DROP SYNONYM [dbo].DYN_SJ_SYSJOBSTEPS')

IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSJOBSTEPS
				FOR [' + @SERVER_NAME + '].msdb.dbo.sysjobsteps'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SJ_SYSJOBSTEPS
				FOR msdb.dbo.sysjobsteps'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


DECLARE @weekDay TABLE (
  mask      INT,
  maskValue VARCHAR(32)); 

INSERT INTO @weekDay
SELECT 1, 'Sunday'  UNION All
SELECT 2, 'Monday'  UNION All
SELECT 4, 'Tuesday'  UNION All
SELECT 8, 'Wednesday'  UNION All
SELECT 16, 'Thursday'  UNION All
SELECT 32, 'Friday'  UNION All
SELECT 64, 'Saturday';
 
WITH myCTE
AS(
 SELECT sched.name                                                                                     AS 'scheduleName',
        sched.schedule_id,
        jobsched.job_id,
        CASE
          WHEN sched.freq_type = 1 THEN 'Once'
          WHEN sched.freq_type = 4
               AND sched.freq_interval = 1 THEN 'Daily'
          WHEN sched.freq_type = 4 THEN 'Every ' + CAST(sched.freq_interval AS VARCHAR(5)) + ' days'
          WHEN sched.freq_type = 8 THEN REPLACE(REPLACE(REPLACE((SELECT maskValue
                                                                 FROM   @weekDay AS x
                                                                 WHERE  sched.freq_interval & x.mask <> 0
                                                                 ORDER  BY mask
                                                                 FOR XML RAW), '"/><row maskValue="', ', '), '<row maskValue="', ''), '"/>', '') + CASE
                                                                                                                                                     WHEN sched.freq_recurrence_factor <> 0
                                                                                                                                                          AND sched.freq_recurrence_factor = 1 THEN '; weekly'
                                                                                                                                                     WHEN sched.freq_recurrence_factor <> 0 THEN '; every ' + CAST(sched.freq_recurrence_factor AS VARCHAR(10)) + ' weeks'
                                                                                                                                                   END
          WHEN sched.freq_type = 16 THEN 'On day ' + CAST(sched.freq_interval AS VARCHAR(10)) + ' of every ' + CAST(sched.freq_recurrence_factor AS VARCHAR(10)) + ' months'
          WHEN sched.freq_type = 32 THEN CASE
                                           WHEN sched.freq_relative_interval = 1 THEN 'First'
                                           WHEN sched.freq_relative_interval = 2 THEN 'Second'
                                           WHEN sched.freq_relative_interval = 4 THEN 'Third'
                                           WHEN sched.freq_relative_interval = 8 THEN 'Fourth'
                                           WHEN sched.freq_relative_interval = 16 THEN 'Last'
                                         END + CASE
                                                 WHEN sched.freq_interval = 1 THEN ' Sunday'
                                                 WHEN sched.freq_interval = 2 THEN ' Monday'
                                                 WHEN sched.freq_interval = 3 THEN ' Tuesday'
                                                 WHEN sched.freq_interval = 4 THEN ' Wednesday'
                                                 WHEN sched.freq_interval = 5 THEN ' Thursday'
                                                 WHEN sched.freq_interval = 6 THEN ' Friday'
                                                 WHEN sched.freq_interval = 7 THEN ' Saturday'
                                                 WHEN sched.freq_interval = 8 THEN ' Day'
                                                 WHEN sched.freq_interval = 9 THEN ' Weekday'
                                                 WHEN sched.freq_interval = 10 THEN ' Weekend'
                                               END + CASE
                                                       WHEN sched.freq_recurrence_factor <> 0
                                                            AND sched.freq_recurrence_factor = 1 THEN '; monthly'
                                                       WHEN sched.freq_recurrence_factor <> 0 THEN '; every ' + CAST(sched.freq_recurrence_factor AS VARCHAR(10)) + ' months'
                                                     END
          WHEN sched.freq_type = 64 THEN 'StartUp'
          WHEN sched.freq_type = 128 THEN 'Idle'
        END                                                                                            AS 'frequency',
        Isnull('Every ' + CAST(sched.freq_subday_interval AS VARCHAR(10)) + CASE
                                                                              WHEN sched.freq_subday_type = 2 THEN ' seconds'
                                                                              WHEN sched.freq_subday_type = 4 THEN ' minutes'
                                                                              WHEN sched.freq_subday_type = 8 THEN ' hours'
                                                                            END, 'Once')               AS 'subFrequency',
        Replicate('0', 6 - Len(sched.active_start_time)) + CAST(sched.active_start_time AS VARCHAR(6)) AS 'startTime',
        Replicate('0', 6 - Len(sched.active_end_time)) + CAST(sched.active_end_time AS VARCHAR(6))     AS 'endTime',
        Replicate('0', 6 - Len(jobsched.next_run_time)) + CAST(jobsched.next_run_time AS VARCHAR(6))   AS 'nextRunTime',
        CAST(jobsched.next_run_date AS CHAR(8))                                                        AS 'nextRunDate'
 FROM   DYN_SJ_SYSSCHEDULES AS sched
        JOIN DYN_SJ_SYSJOBSCHEDULES AS jobsched
          ON sched.schedule_id = jobsched.schedule_id
 WHERE  sched.enabled = 1 
 
)
INSERT INTO SQL_JOBS
SELECT @SERVER_NAME                                                                                                                                                                                                   AS [SERVER_NAME],
       CONVERT(NVARCHAR(50), @STATS_DATE, 121)                                                                                                                                                                        AS [STATS_TIME],
       job.name                                                                                                                                                                                                       AS 'jobName',
       sched.scheduleName,
       sched.frequency,
       sched.subFrequency,
       substring(sched.startTime, 1, 2) + ':' + substring(sched.startTime, 3, 2) + ' - ' + substring(sched.endTime, 1, 2) + ':' + substring(sched.endTime, 3, 2)                                                      AS 'scheduleTime' -- HH:MM
       ,
       substring(sched.nextRunDate, 1, 4) + '/' + substring(sched.nextRunDate, 5, 2) + '/' + substring(sched.nextRunDate, 7, 2) + ' ' + substring(sched.nextRunTime, 1, 2) + ':' + substring(sched.nextRunTime, 3, 2) AS 'nextRunDate'
       /* Note: the sysjobschedules table refreshes every 20 min, 
         so nextRunDate may be out of date */
       ,
       steps.step_id,
       steps.step_name,
       steps.subsystem,
       steps.command
FROM   DYN_SJ_SYSJOBS AS job
       JOIN myCTE AS sched
         ON job.job_id = sched.job_id
       INNER JOIN DYN_SJ_SYSJOBSTEPS steps
               ON steps.job_id = job.job_id
WHERE  job.enabled = 1 -- do not display disabled jobs
ORDER  BY nextRunDate 



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SQL_PLAN_GUIDES]...';


GO


ALTER PROCEDURE DYNPERF_COLLECT_SQL_PLAN_GUIDES (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SPG_PLANGUIDES')
  EXEC ('DROP SYNONYM [dbo].DYN_SPG_PLANGUIDES')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SPG_PLANGUIDES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.plan_guides'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SPG_PLANGUIDES
				FOR [' + @DATABASE_NAME + '].sys.plan_guides'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


--REH Needs to be lower case for case sensitive databases

INSERT INTO [DynamicsPerf]..SQL_PLAN_GUIDES
SELECT @SERVER_NAME, CONVERT(NVARCHAR(50), @STATS_DATE, 121),
@DATABASE_NAME

      ,[plan_guide_id]
      ,[name]
      ,[create_date]
      ,[modify_date]
      ,[is_disabled]
      ,[query_text]
      ,[scope_type]
      ,[scope_type_desc]
      ,[scope_object_id]
      ,[scope_batch]
      ,[parameters]
      ,[hints]
	FROM DYN_SPG_PLANGUIDES

    



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SQL_TRACEFLAGS_RUNNING]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SQL_TRACEFLAGS_RUNNING (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


  IF EXISTS (SELECT * FROM   sys.synonyms  WHERE  name = 'DYN_QUERY_TRACE_FLAGS')
  EXEC ('DROP SYNONYM [dbo].DYN_QUERY_TRACE_FLAGS')



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 

  

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


CREATE TABLE #TRACEFLAGS
  (
     TRACEFLAG    INT,
     STATUS       BIT,
     GLOBAL       BIT,
     SESSIONS     BIT
  ) 

SET @SQL = 'DBCC TRACESTATUS(-1) WITH NO_INFOMSGS '

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END



IF @REMOTE_SERVER = 'N'
BEGIN

INSERT  #TRACEFLAGS
EXEC (@SQL)

INSERT TRACEFLAGS 
SELECT @SERVER_NAME, @STATS_DATE,@DATABASE_NAME,*  FROM #TRACEFLAGS

END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
 
 /****************************************************************************
 
 REH Too avoid some nasty challenges of calling DBCC remotely in this case
	we will create a table in the remote TempDb and populate it with 
	DBCC on that side, then use normal Linked Server to insert that data
	back into DynamicsPerf
	
	Remote DBCC commands present all sort of challenges, particularly
		error 7411
 
 
 *****************************************************************************/
 
 
 --REH Drop the table on the remote server if it exists
         SET @SQL = '
				  use [tempdb]  
				  
				IF OBJECT_ID(' + ''''
									+ 'DYNPERF_TRACE_FLAGS' + ''''
									+ ' , ''U'' 
				) IS NOT NULL
				 DROP TABLE DYNPERF_TRACE_FLAGS'
				 
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)
         
         
--REH  Now create the table and populate it on the remote server


         SET @SQL = '
				CREATE TABLE [tempdb].dbo.DYNPERF_TRACE_FLAGS
					  (
						 TRACEFLAG    INT,
						 STATUS       BIT,
						 GLOBAL       BIT,
						 SESSIONS     BIT
					  ) 
					  
					  INSERT INTO [tempdb].dbo.DYNPERF_TRACE_FLAGS
					 EXEC (' +''''+ 'DBCC TRACESTATUS(-1) WITH NO_INFOMSGS' +'''' + ')
					  
					  '

         PRINT @SQL

         SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT [' + @SERVER_NAME
									 + ']'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)







--REH  Create Synonym for the table with just created and populated on the remote server.

  IF EXISTS (SELECT * FROM   sys.synonyms  WHERE  name = 'DYN_QUERY_TRACE_FLAGS')
  EXEC ('DROP SYNONYM [dbo].DYN_QUERY_TRACE_FLAGS')



         SET @SQL = '
				CREATE SYNONYM DYN_QUERY_TRACE_FLAGS
				FOR [' + @SERVER_NAME + '].[tempdb].dbo.DYNPERF_TRACE_FLAGS'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 
		


INSERT TRACEFLAGS 
SELECT @SERVER_NAME, @STATS_DATE,@DATABASE_NAME, *  FROM DYN_QUERY_TRACE_FLAGS

  --REH Now Drop the table to cleanup the process
  
         SET @SQL = '
				  use [tempdb]  
				  
				IF OBJECT_ID(' + ''''
									+ 'DYNPERF_TRACE_FLAGS' + ''''
									+ ' , ''U'' 
				) IS NOT NULL
				 DROP TABLE DYNPERF_TRACE_FLAGS'
				 
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)
 
 END
 
    

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



  IF EXISTS (SELECT * FROM   sys.synonyms  WHERE  name = 'DYN_QUERY_TRACE_FLAGS')
  EXEC ('DROP SYNONYM [dbo].DYN_QUERY_TRACE_FLAGS')




PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/

BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)

  IF EXISTS (SELECT * FROM   sys.synonyms  WHERE  name = 'DYN_QUERY_TRACE_FLAGS')
  EXEC ('DROP SYNONYM [dbo].DYN_QUERY_TRACE_FLAGS')


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SYSOBJECTS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SYSOBJECTS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOBJ_SYSOBJECTS')
  EXEC ('DROP SYNONYM [dbo].DYN_SOBJ_SYSOBJECTS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSOBJECTS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.objects'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSOBJECTS
				FOR [' + @DATABASE_NAME + '].sys.objects'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOBJ_SYSINDEXES')
  EXEC ('DROP SYNONYM [dbo].DYN_SOBJ_SYSINDEXES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSINDEXES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.indexes'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSINDEXES
				FOR [' + @DATABASE_NAME + '].sys.indexes'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOBJ_SYS_SYSINDEXES')
  EXEC ('DROP SYNONYM [dbo].DYN_SOBJ_SYS_SYSINDEXES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYS_SYSINDEXES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.sysindexes'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYS_SYSINDEXES
				FOR [' + @DATABASE_NAME + '].sys.sysindexes'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)





IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOBJ_SYSPARTITIONS')
  EXEC ('DROP SYNONYM [dbo].DYN_SOBJ_SYSPARTITIONS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSPARTITIONS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.partitions'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSPARTITIONS
				FOR [' + @DATABASE_NAME + '].sys.partitions'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOBJ_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_SOBJ_SYSCOLUMNS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSCOLUMNS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.columns'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSCOLUMNS
				FOR [' + @DATABASE_NAME + '].sys.columns'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SOBJ_SYSTYPES')
  EXEC ('DROP SYNONYM [dbo].DYN_SOBJ_SYSTYPES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSTYPES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.types'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SOBJ_SYSTYPES
				FOR [' + @DATABASE_NAME + '].sys.types'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

DELETE FROM DYNSYSINDEXES WHERE DATABASE_NAME = @DATABASE_NAME AND RUN_NAME LIKE @SERVER_NAME + '%'
DELETE FROM DYNSYSOBJECTS WHERE DATABASE_NAME = @DATABASE_NAME AND RUN_NAME LIKE @SERVER_NAME + '%'
DELETE FROM DYNSYSPARTITIONS WHERE DATABASE_NAME = @DATABASE_NAME AND RUN_NAME LIKE @SERVER_NAME + '%'
DELETE FROM DYNSYSCOLUMNS WHERE DATABASE_NAME = @DATABASE_NAME AND RUN_NAME LIKE @SERVER_NAME + '%'






INSERT INTO DYNSYSOBJECTS
SELECT @RUN_NAME,
       @DATABASE_NAME,   
       [name],
       [object_id],
       [principal_id],
       [schema_id],
       [parent_object_id],
       [type],
       [type_desc],
       [create_date],
       [modify_date],
       [is_ms_shipped],
       [is_published],
       [is_schema_published]
FROM   DYN_SOBJ_SYSOBJECTS WHERE type = 'U'

      
  
INSERT INTO DYNSYSPARTITIONS
SELECT @RUN_NAME,
       @DATABASE_NAME, 
       [partition_id],
       [object_id],
       [index_id],
       [partition_number],
       [hobt_id],
       [rows],
       [filestream_filegroup_id],
       [data_compression],
       [data_compression_desc]
FROM   DYN_SOBJ_SYSPARTITIONS 



IF @REMOTE_SERVER = 'N'
BEGIN

	  --REH performance is not impacted on same server by multi-table synonym joins, this code works great with multiple databases on same server 
		INSERT INTO DYNSYSINDEXES
		SELECT @RUN_NAME,
			   @DATABASE_NAME,
			   si.[object_id],
			   si.[name],
			   si.[index_id],
			   si.[type],
			   si.[type_desc],
			   si.[is_unique],
			   si.[data_space_id],
			   si.[ignore_dup_key],
			   si.[is_primary_key],
			   si.[is_unique_constraint],
			   si.[fill_factor],
			   si.[is_padded],
			   si.[is_disabled],
			   si.[is_hypothetical],
			   si.[allow_row_locks],
			   si.[allow_page_locks],
			   si.[has_filter],
			   si.[filter_definition],
			   ssi.[xmaxlen],
			   ssi.[maxirow]
		FROM   DYN_SOBJ_SYSINDEXES si
			   INNER JOIN DYN_SOBJ_SYS_SYSINDEXES ssi
					   ON si.object_id = ssi.id
						  AND si.index_id = ssi.indid
			   INNER JOIN DYN_SOBJ_SYSOBJECTS so
					   ON si.object_id = so.object_id
						  AND so.type = 'U' 


		INSERT INTO DYNSYSCOLUMNS
		SELECT @RUN_NAME,
			   @DATABASE_NAME,   
			   c.object_id,
			   c.name,
			   c.column_id,
			   t.name AS datatype,
			   c.max_length
		FROM   DYN_SOBJ_SYSCOLUMNS c
			   INNER JOIN DYN_SOBJ_SYSTYPES t
					   ON t.system_type_id = c.system_type_id
			   INNER JOIN DYN_SOBJ_SYSOBJECTS so
					   ON so.object_id = c.object_id
						  AND so.type = 'U' 



	  END

	  IF @REMOTE_SERVER = 'Y'
	  BEGIN
    		SET @SQL = '	
			
			SELECT	
 			 si.[object_id],
			   si.[name],
			   si.[index_id],
			   si.[type],
			   si.[type_desc],
			   si.[is_unique],
			   si.[data_space_id],
			   si.[ignore_dup_key],
			   si.[is_primary_key],
			   si.[is_unique_constraint],
			   si.[fill_factor],
			   si.[is_padded],
			   si.[is_disabled],
			   si.[is_hypothetical],
			   si.[allow_row_locks],
			   si.[allow_page_locks],
			   si.[has_filter],
			   si.[filter_definition],
			   ssi.[xmaxlen],
			   ssi.[maxirow]
    	FROM	['+ @DATABASE_NAME+ '].sys.indexes si
    	JOIN	['+ @DATABASE_NAME+ '].sys.sysindexes ssi ON si.object_id = ssi.id AND si.index_id = ssi.indid
    	JOIN	['+ @DATABASE_NAME+ '].sys.objects so ON si.object_id = so.object_id
    
     WHERE	so.type = ''U''
    	 '
             IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  INSERT INTO DynamicsPerf.dbo.DYNSYSINDEXES
						 SELECT ' + '''' + @RUN_NAME + '''' + ',' + '''' + @DATABASE_NAME + '''' + ',*
		                   FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ')'


		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)



		 		SET @SQL = '	
			
			SELECT	
 			  c.object_id,
			   c.name,
			   c.column_id,
			   t.name AS datatype,
			   c.max_length
    	FROM	['+ @DATABASE_NAME+ '].sys.columns c
    	JOIN	['+ @DATABASE_NAME+ '].sys.types t ON t.system_type_id = c.system_type_id
    	JOIN	['+ @DATABASE_NAME+ '].sys.objects so ON so.object_id = c.object_id
						  WHERE	so.type = ''U''
    	 '
             IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  INSERT INTO DynamicsPerf.dbo.DYNSYSCOLUMNS
						 SELECT ' + '''' + @RUN_NAME + '''' + ',' + '''' + @DATABASE_NAME + '''' + ',*
		                   FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ')'


		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)



END

   
   
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_TRIGGER_INFO]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_TRIGGER_INFO (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_TRIG_SYSOBJECTS')
  EXEC ('DROP SYNONYM [dbo].DYN_TRIG_SYSOBJECTS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_TRIG_SYSOBJECTS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.objects'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_TRIG_SYSOBJECTS
				FOR [' + @DATABASE_NAME + '].sys.objects'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_TRIG_SYS_SYSOBJECTS')
  EXEC ('DROP SYNONYM [dbo].DYN_TRIG_SYS_SYSOBJECTS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_TRIG_SYS_SYSOBJECTS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.sysobjects'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_TRIG_SYS_SYSOBJECTS
				FOR [' + @DATABASE_NAME + '].sys.sysobjects'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_TRIG_SYSSCHEMAS')
  EXEC ('DROP SYNONYM [dbo].DYN_TRIG_SYSSCHEMAS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_TRIG_SYSSCHEMAS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.schemas'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_TRIG_SYSSCHEMAS
				FOR [' + @DATABASE_NAME + '].sys.schemas'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

DELETE FROM [DynamicsPerf]..TRIGGER_TABLE WHERE DATABASE_NAME = @DATABASE_NAME AND RUN_NAME LIKE @SERVER_NAME + '%'

INSERT TRIGGER_TABLE
SELECT @RUN_NAME,
       @DATABASE_NAME,
       p.name,
       t.name
FROM   DYN_TRIG_SYS_SYSOBJECTS t
       INNER JOIN DYN_TRIG_SYSOBJECTS p
               ON t.parent_obj = p.object_id
       INNER JOIN DYN_TRIG_SYSSCHEMAS SCH
               ON t.uid = SCH.schema_id
WHERE  t.type = 'TR' 

    
  
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_WAITSTATS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_WAITSTATS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @PREV_STATS_TIME DATETIME
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_WS_WAITSTATS')
  EXEC ('DROP SYNONYM [dbo].DYN_WS_WAITSTATS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_WS_WAITSTATS
				FOR [' + @SERVER_NAME + '].[master].sys.dm_os_wait_stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_WS_WAITSTATS
				FOR [master].sys.dm_os_wait_stats'
IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)






--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 





BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


INSERT 	INTO WAIT_STATS 
SELECT 	@SERVER_NAME, @STATS_DATE, *
FROM 	DYN_WS_WAITSTATS
WHERE WAIT_TYPE <> 'MISCELLANEOUS'


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_PROCESS_AXSQLTRACE]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PROCESS_AXSQLTRACE]
		(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



UPDATE AST
SET    QUERY_HASH = COALESCE((SELECT TOP 1 QUERY_HASH
                     FROM   QUERY_TEXT QT
                     WHERE  QT.SERVER_NAME = AST.SERVER_NAME
                            AND QT.DATABASE_NAME = AST.DATABASE_NAME
                            AND QT.SQL_TEXT LIKE REPLACE(AST.SQL_TEXT, '?', '%')), 0X00) --REH There could be several. We are only getting the first
FROM   AX_SQLTRACE AST
WHERE  SERVER_NAME = @SERVER_NAME
       AND DATABASE_NAME = @DATABASE_NAME
       AND AST.QUERY_HASH IS NULL 
	   AND LEN(AST.SQL_TEXT) < 4000 --REH LIKE command is limited to 8k characters

--UPDATE AST
--SET    QUERY_HASH = (SELECT TOP 1 QUERY_HASH
--                     FROM   QUERY_TEXT QT
--                     WHERE  QT.SERVER_NAME = AST.SERVER_NAME
--                            AND QT.DATABASE_NAME = AST.DATABASE_NAME
--                            AND QT.SQL_TEXT LIKE REPLACE(AST.SQL_TEXT, '?', '%')) --REH There could be several. We are only getting the first
--FROM   AX_SQLTRACE AST WITH (READPAST)
--WHERE  SERVER_NAME = @SERVER_NAME
--       AND DATABASE_NAME = @DATABASE_NAME
--       AND AST.QUERY_HASH IS NULL 
--	   AND LEN(AST.SQL_TEXT) <= 4000 --REH LIKE command is limited to 8k characters NVARCHAR 4k = 8k characters
--	   AND AST.CREATED_DATETIME > DATEADD(DD,CAST(@TASK_PARAMS as INT) * -1,@LAST_RUN)  --REH keep trying to parse queries for X days, based on @task_params


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_PROCESS_QUERY_PLANS]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PROCESS_QUERY_PLANS]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH Need to delete any old data in case QUERY_PLAN refresh updates the flag.  We need to delete old parsed plans

DELETE QPP
FROM   QUERY_PLANS_PARSED QPP
       INNER JOIN QUERY_PLANS QP WITH (NOLOCK)
               ON QPP.SERVER_NAME = QP.SERVER_NAME
                  AND QPP.DATABASE_NAME = QP.DATABASE_NAME
                  AND QPP.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
WHERE  QP.PARSED_FLAG = 0 


SELECT TOP 10000 SERVER_NAME,DATABASE_NAME, QUERY_PLAN_HASH
INTO #PARSE_PLANS
FROM QUERY_PLANS
WHERE PARSED_FLAG = 0

--REH Parse out the QUERY_PLANS table into it's vital statistics

 ;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)

 INSERT QUERY_PLANS_PARSED
 SELECT *
FROM   (SELECT QUERY_PLANS.SERVER_NAME, QUERY_PLANS.DATABASE_NAME, QUERY_PLANS.QUERY_PLAN_HASH,
			   CAST(isnull(index_node.value('(..//@NodeId)[1]', 'nvarchar(128)'),'0') AS INT) AS NodeID,
               CAST(Replace(Replace(index_node.value('(.//@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '') AS NVARCHAR(128))  AS TABLE_NAME,
               CAST(Replace(Replace(index_node.value('(.//@Index)[1]', 'NVARCHAR(128)'), '[', ''), ']', '') AS NVARCHAR(128)) AS INDEX_NAME,
			   CAST(isnull(index_node.value('(.//@Lookup)[1]', 'nvarchar(128)'),'0') AS INT) AS LOOKUP,
			   CAST(isnull(index_node.value('(..//@Parallel)[1]', 'nvarchar(128)'),'0') AS INT) AS PARALLEL,
			   CAST(index_node.value('(..//@PhysicalOp)[1]', 'nvarchar(128)') AS NVARCHAR(128)) AS PHYSICALOP,
			   CAST(index_node.value('(..//@LogicalOp)[1]', 'nvarchar(128)') AS NVARCHAR(128)) AS LOGICALOP,
			   CAST(str(ISNULL(index_node.value('(..//@EstimateRows)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(14,0)) AS ESTIMATEROWS,
			   CAST(str(ISNULL(index_node.value('(..//@EstimateIO)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(20,7)) AS EstimateIO,
			   CAST(str(ISNULL(index_node.value('(..//@EstimateCPU)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(20,7)) AS ESTIMATECPU,
			   CAST(str(ISNULL(index_node.value('(..//@AvgRowSize)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(14,0)) AS AVGROWSIZE,
			   CAST(str(isnull(index_node.value('(..//@EstimatedTotalSubtreeCost)[1]', 'nvarchar(128)') ,'0.0'),30,17) AS DECIMAL (20,7)) AS ESTIMATEDTOTALSUBTREECOST,
               CONVERT(NVARCHAR(MAX), index_node.query('for $seekpredicate in ./sp:SeekPredicates,
                                                            $rangecolumns in $seekpredicate//sp:RangeColumns,
                                                            $columnreference in $rangecolumns/sp:ColumnReference
                                        return string($columnreference/@Column)'))        AS SEEK_COLUMNS,

              CONVERT(NVARCHAR(MAX), index_node.query('for $predicate2 in ./sp:Predicate,
                                                           $Ident in  $predicate2//sp:Identifier,
														   $COLREF2 in  $Ident/sp:ColumnReference
                                                            
                                        return string($COLREF2/@Column)')) AS PREDICATES,

		    REPLACE( REPLACE( CONVERT(NVARCHAR(MAX), index_node.query('for $predicate in ./sp:Predicate,
                                                $rangecolumn in $predicate//sp:ScalarOperator
                                                            
                            return string($rangecolumn/@ScalarString)'))
							,'&lt;', '<')   ,'&gt;', '>')         AS PREDICATE_TEXT
        FROM   QUERY_PLANS
			INNER JOIN #PARSE_PLANS ON QUERY_PLANS.SERVER_NAME = #PARSE_PLANS.SERVER_NAME
			AND QUERY_PLANS.DATABASE_NAME = #PARSE_PLANS.DATABASE_NAME
			AND QUERY_PLANS.QUERY_PLAN_HASH = #PARSE_PLANS.QUERY_PLAN_HASH
			   OUTER APPLY QUERY_PLAN.nodes('//sp:RelOp/sp:IndexScan') AS SeekPredicates(index_node)
               --CROSS APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node2)
			   WHERE QUERY_PLANS.SERVER_NAME = @SERVER_NAME AND QUERY_PLANS.PARSED_FLAG = 0

			   ) A
			   OPTION(MAXDOP 1)



;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
UPDATE QP SET SQL_PARMS = A.SQL_PARAMS
, MI_FLAG = A.MI_FLAG
, PARSED_FLAG = 1

FROM QUERY_PLANS QP
	INNER JOIN #PARSE_PLANS ON QP.SERVER_NAME = #PARSE_PLANS.SERVER_NAME
			AND QP.DATABASE_NAME = #PARSE_PLANS.DATABASE_NAME
			AND QP.QUERY_PLAN_HASH = #PARSE_PLANS.QUERY_PLAN_HASH

INNER JOIN  (
SELECT    QT.[QUERY_PLAN_HASH],
 CONVERT (NVARCHAR(MAX), index_node.query('for $qplan in //sp:QueryPlan, $plist in $qplan/sp:ParameterList, $colref in $plist/sp:ColumnReference  return concat(string($colref/@Column),":",string($colref/@ParameterCompiledValue),",   "),"  "')) as SQL_PARAMS,
 CASE WHEN CAST(QT.QUERY_PLAN AS NVARCHAR(MAX)) LIKE '%MissingIndex%' THEN 1 ELSE 0 END as MI_FLAG
 
  FROM [QUERY_PLANS] QT
      OUTER APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node)
     WHERE SERVER_NAME = @SERVER_NAME AND PARSED_FLAG = 0
 ) as A ON A.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
 WHERE QP.PARSED_FLAG = 0
 OPTION(MAXDOP 1)
 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[SP_CAPTURESTATS]...';


GO



ALTER	PROCEDURE [dbo].[SP_CAPTURESTATS]
		@SERVER_NAME	NVARCHAR(128) = NULL,
		@DATABASE_NAME	NVARCHAR(128) = NULL ,
		@DYNAMICS_PRODUCT NVARCHAR(3)  = NULL,
		@TASK_TYPE		VARCHAR(50) = 'COLLECT',
		@AZURE_DB		BIT = 0,
		@TOP_ROWS		INT = 0,
		@TOP_COLUMN		NVARCHAR(128) = 'total_elapsed_time',
		@RUN_NAME		NVARCHAR(128) = NULL,
		@INDEX_PHYSICAL_STATS 	NCHAR(1)= 'N',
		@DEBUG			NVARCHAR(1)= 'N'

AS


SET NOCOUNT ON
SET DATEFORMAT MDY

SET ANSI_NULLS ON
SET ANSI_WARNINGS ON
SET ANSI_NULL_DFLT_ON ON
SET ANSI_PADDING ON


DECLARE @STATS_DATE		DATETIME, 
		@SQL_VERSION	NVARCHAR(1000), 
		@DYNAMICS_VERSION NVARCHAR(MAX),
		@DATABASE_ID	INT,
		@RETURN_CODE	INT,
		@SQL			NVARCHAR(MAX),
		@RUN_DESCRIPTION NVARCHAR(1000),
		@SQL_TOP_CLAUSE	NVARCHAR(128),
		@SQL_ORDERBY_CLAUSE	NVARCHAR(128),
		@PARM			NVARCHAR(500),
		@SQL_SERVER_STARTTIME DATETIME,
		@RC INT,
		@TASK_PROCEDURE NVARCHAR(128),
		@TASK_PARAMETERS NVARCHAR(1024),
		@TASK_DESCRIPTION NVARCHAR(256),
		@LAST_SERVER_NAME NVARCHAR(128) = 'ZZZ',  --REH This is used to trigger inserting a new STATS_COLLECTION_SUMMARY record
		@LAST_DATABASE_NAME NVARCHAR(128) = 'ZZZ',
		@LAST_STATS_DATE DATETIME,
		@REMOTE_SERVER NVARCHAR(1) = 'N',
		@TASK_STARTTIME DATETIME,
		@TASK_ENDTIME DATETIME,
		@TASK_TIME BIGINT,
		@SQL_STARTTIME DATETIME,
		@SQL_BUILD NVARCHAR(20),
		@SQL2 NVARCHAR(MAX),
		@MANUAL_CAPTURE NVARCHAR(1) = 'N',
		@SQL_TZ_OFFSET INT,
		@DPA_TZ_OFFSET INT 

		
		
DECLARE
	@C_SERVER_NAME NVARCHAR(128),
	@C_DATABASE_NAME NVARCHAR(128),
	@C_TASK_ID INT,
	@C_TASK_PROCEDURE NVARCHAR(128),
	@C_TASK_PARAMS NVARCHAR(1024),
	@C_TASK_DESC NVARCHAR(256),
	@C_SERVER_LEVEL_TASK BIT,
	@C_AZURE_DB  BIT,
	@C_LAST_RUN DATETIME
	
		
--REH Time zone off set for the DynamicsPerf database at time of collection
		SET @DPA_TZ_OFFSET = DATEDIFF(MI,GETUTCDATE(),GETDATE())

	IF @DATABASE_NAME IS NOT NULL SET @MANUAL_CAPTURE = 'Y'

	SET @STATS_DATE = GETDATE()
--REH  Verify database exists if being manually passed, skip check if Azure DB, no access to sys.databases catalogue

IF ( @AZURE_DB = 0 and ( @SERVER_NAME IS NOT NULL
      OR @DATABASE_NAME IS NOT NULL ))
     BEGIN

	 
	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_CS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_CS_QUERY_SYSDATABASES')

         IF @REMOTE_SERVER = 'Y'
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_CS_QUERY_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_CS_QUERY_SYSDATABASES
				FOR master.sys.databases'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END

         EXEC (@SQL) -- SELECT * FROM DYN_CS_QUERY_SYSDATABASES

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_CS_QUERY_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

         --REH Make sure there is a record in DATABASES_2_COLLECT or insert if new combination
         IF (SELECT COUNT(*)
             FROM   DATABASES_2_COLLECT
             WHERE  LINKED_SERVER = ISNULL(@SERVER_NAME, @@SERVERNAME)
                    AND DATABASE_NAME = @DATABASE_NAME) < 1
              BEGIN
                  INSERT DATABASES_2_COLLECT
                  VALUES(ISNULL(@SERVER_NAME,@@SERVERNAME),
                         @DATABASE_NAME,
                         ISNULL(@DYNAMICS_PRODUCT, 'ALL'),
                         1,
                         2,
                         24,
						 60,
						 2,
						 90,
						 7)
              END
     END 


	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END



---------------------------------------------------------------------------------------------
--
--  Insert Capture_log entry with paramater values used for the run
--
----------------------------------------------------------------------------------------------

INSERT CAPTURE_LOG  SELECT @TASK_TYPE, @STATS_DATE, 'SP_CAPTURESTATS PARMS PASSED @SERVER_NAME = ' + ISNULL(@SERVER_NAME,'NOT PASSED') + ' @DATABASE_NAME = ' + ISNULL(@DATABASE_NAME,'NOT PASSED') +  ' @DEBUG = ' + @DEBUG + '  ' + CHAR(10) + CHAR(13)



SET @RETURN_CODE = 0

DELETE FROM  COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH Default is 'COLLECT' for this sproc.  CAN'T TRUNCATE MULTIPLE SPROCS USING THIS TABLE



IF @DATABASE_NAME IS NULL  --REH AKA, not a manual capture
  BEGIN
      INSERT COLLECTIONDATABASES
      SELECT ISNULL(LINKED_SERVER, @@SERVERNAME),
             [DATABASE_NAME],
             [DYNAMICS_PRODUCT],
             [AZURE_DB],
             [ENABLED],
			 @TASK_TYPE
      FROM   DATABASES_2_COLLECT
      WHERE  ENABLED = 1 -- db must be enabled for autostats collection to work with it
  END
ELSE
  BEGIN   --REH  Insert DBname of the manual capture
      INSERT COLLECTIONDATABASES
      VALUES(ISNULL(@SERVER_NAME, @@SERVERNAME),
             @DATABASE_NAME,
             @DYNAMICS_PRODUCT,
             @AZURE_DB,
             1,
			 @TASK_TYPE)
  END 


--REH Insert any missing task history records in case it's a new database being collected, so we don't fail to capture against the db because of no records
-- yes, this is a cartesian join between these 2 tables

INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE	--REH default is 'COLLECT' in parm definition of this sproc
       AND NOT EXISTS (SELECT 'X'
                       FROM   DYNPERF_TASK_HISTORY DTH
                       WHERE  DTS.TASK_ID = DTH.TASK_ID
                              AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                              AND CD.DATABASE_NAME = DTH.DATABASE_NAME)
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 0 --REH Ok, to put 1 record per database in for DB type tasks


	   
--REH Need to insert 1 bogus record for each server level task, or the join on the cursor will fail

INSERT COLLECTIONDATABASES 
 SELECT	DISTINCT [LINKED_SERVER],
             'N/A',
            'ALL',
             [AZURE_DB],
             [ENABLED],
			 [TASK_TYPE]
FROM COLLECTIONDATABASES CD
WHERE DATABASE_NAME <> 'N/A'
AND TASK_TYPE = @TASK_TYPE
AND NOT EXISTS (SELECT 'X' FROM COLLECTIONDATABASES CD2 WHERE CD2.LINKED_SERVER = CD.LINKED_SERVER AND CD2.DATABASE_NAME = 'N/A')



--REH now lets insert server level tasks with a blank DB name so we only do them once per server
INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       'N/A',
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE  --REH default is 'COLLECT' in parm definition of this sproc
		AND CD.DATABASE_NAME <> 'N/A'
       AND NOT EXISTS (SELECT 'X'
                   FROM   DYNPERF_TASK_HISTORY DTH
                   WHERE  DTS.TASK_ID = DTH.TASK_ID
                          AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                          AND DTH.DATABASE_NAME = 'N/A') --REH making the db name = 'N/A' for server level tasks
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 1 






	IF @DEBUG = 'Y'
	BEGIN
		PRINT 'MANUAL_CAPTURE = ' + @MANUAL_CAPTURE
	END

	--REH Create here and truncate table in each loop

	   CREATE TABLE #SQL_INFO
     (
        SQL_STARTTIME DATETIME,
        SQL_BUILD NVARCHAR(20),
		TZ_OFFSET INT
     )


/********************************************************************************
Rod Hansen

Added a trigger to DATABASES_2_COLLECT so that we always have a 
DYNPERF_TASK_HISTORY record for this code 

********************************************************************************/

DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT DISTINCT DTS.TASK_ID,
       CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_PROCEDURE,
       DTS.TASK_PARAMETERS,
       DTS.TASK_DESCRIPTION,
       DTS.SERVER_LEVEL_TASK,
       CD.AZURE_DB,
       ISNULL(DTH.LAST_RUN, '1/1/1900')
FROM   DynamicsPerf..[DYNPERF_TASK_SCHEDULER] DTS
       LEFT OUTER JOIN DynamicsPerf..[DYNPERF_TASK_HISTORY] DTH
                    ON DTH.TASK_ID = DTS.TASK_ID
       INNER JOIN DynamicsPerf..COLLECTIONDATABASES CD
               ON CD.DATABASE_NAME = DTH.DATABASE_NAME
                  AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
WHERE
  --REH Task is enabled
  DTS.ENABLED = 1
  AND
  --REH It's the correct task type C = COLLECTOR, P = PROCESS, M = MONITOR, ETC
  DTS.TASK_TYPE = @TASK_TYPE
  AND
  --REH database is enabled
  CD.ENABLED = 1
  AND
  --REH Azure_db, if Azure db, then task must support it
  ( CD.AZURE_DB = DTS.AZURE_DB_SUPPORTED
     OR CD.AZURE_DB = 0 )
  --REH Either its an Azure Task, all Azure tasks will run locally, so if task supports AZ and we pass 0, run it anyways
  AND ( DTS.AZURE_DB_SUPPORTED = @AZURE_DB
         OR ( DTS.AZURE_DB_SUPPORTED = 1
              AND @AZURE_DB = 0 ) )
  AND
  --REH it's either All products or matches the Dynamics Product
  ( DTS.DYNAMICS_PRODUCT = 'ALL'
     OR DTS.DYNAMICS_PRODUCT = CD.DYNAMICS_PRODUCT )
  AND
  --REH Scheduling options now
(
  --REH In the case of minutes or hous, we ignore schedule time and just figure out if it's time to run again
  ( @MANUAL_CAPTURE = 'Y'
     OR ( @MANUAL_CAPTURE = 'N'
          AND ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                  WHEN 'MI' THEN DATEADD(MINUTE, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                END ) <= GETDATE()
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'HH' THEN DATEADD(HOUR, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                --REH and it is on the hour
                AND ( ABS(DATEDIFF(MI, DATEADD(Hour, DATEDIFF(Hour, 0, GETDATE()), 0), GETDATE())) <= 1 ) )
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'DD' THEN DATEADD(DAY, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'WK' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'MM' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'QQ' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'YY' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                AND ( --REH TIME IS NULL SO IGNORE IT
                    COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) IS NULL
                     OR --REH Current time = Scheduled time 
                    ( SUBSTRING((SELECT REPLACE(CONVERT(VARCHAR(10), GETDATE(), 108), ':', '')), 1, 4) = (SELECT REPLICATE('0', 4 - LEN( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME)))
                                                                                                                 + CAST( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) AS VARCHAR(4))) ) ) )
         --REH and last_run < current time
         )--AND CONVERT(VARCHAR(10), LAST_RUN, 108) <= CONVERT(VARCHAR(10), Getdate(), 108) ) 
   )
)
ORDER  BY CD.LINKED_SERVER,
          CD.DATABASE_NAME,
          DTS.TASK_ID 



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */


	          SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


--Insert new STATS_COLLECTION_SUMMARY RECORD, we want 1 RUN_NAME per server not per database
IF @C_SERVER_NAME <> @LAST_SERVER_NAME OR @C_DATABASE_NAME <> @LAST_DATABASE_NAME
BEGIN
    SET @RUN_NAME = ISNULL(@C_SERVER_NAME, @@SERVERNAME)+ ' '
                    + CAST(@STATS_DATE AS VARCHAR(30))

TRUNCATE TABLE #SQL_INFO   --REH clear out table to repopulate

 DELETE FROM COLLECTIONDATABASES WHERE LINKED_SERVER = @LAST_SERVER_NAME AND DATABASE_NAME = @LAST_DATABASE_NAME AND TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE


 
SELECT @SQL = 'SELECT create_date AS SQL_STARTTIME,
       CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))    AS SQL_BUILD,
	   DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
		FROM sys.databases WHERE name = ''TempDB'''

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


   
   SET NOCOUNT ON
 
IF @REMOTE_SERVER = 'N'
BEGIN
		   INSERT #SQL_INFO
		EXEC( @SQL)
END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
			IF @C_AZURE_DB = 0
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT create_date AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROM sys.databases WHERE name = ''TempDB''"	)'
			END
			IF @C_AZURE_DB = 1
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT DATEADD(ms,AVG(-wait_time_ms), GETDATE()) AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROMsys.dm_os_wait_stats w WHEREwait_type
IN(''DIRTY_PAGE_POLL'',''HADR_FILESTREAM_IOMGR_IOCOMPLETION'',''LAZYWRITER_SLEEP'',''LOGMGR_QUEUE'',''REQUEST_FOR_DEADLOCK_SEARCH'',''XE_DISPATCHER_WAIT'',''XE_TIMER_EVENT'') "	)'
			END


				IF @DEBUG = 'Y'
                  BEGIN
                      PRINT '@SQL= ' + @SQL2
                  END 
                
			INSERT #SQL_INFO
				EXEC (@SQL2) 
 
 END
 
 SELECT @SQL_STARTTIME = SQL_STARTTIME, @SQL_BUILD = SQL_BUILD, @SQL_TZ_OFFSET = TZ_OFFSET FROM #SQL_INFO





		INSERT INTO [DynamicsPerf].[dbo].[STATS_COLLECTION_SUMMARY]
					([SERVER_NAME],
					 [STATS_TIME],
					 [RUN_NAME],
					 [DATABASE_NAME],
					 [SQL_VERSION],
					 [DYNAMICS_VERSION],
					 [RUN_DESCRIPTION],
					 [SQL_SERVER_STARTTIME],
					 [SQL_SERVER_TZ_OFFSET] ,
					 [DPA_TZ_OFFSET])
		VALUES      (@C_SERVER_NAME,
					 @STATS_DATE,
					 @RUN_NAME,
					 @C_DATABASE_NAME,
					 @SQL_BUILD,--<SQL_VERSION>
					 '',--<DYNAMICS_VERSION>
					 '',--<RUN_DESCRIPTION>
					 @SQL_STARTTIME, -- <SQL_SERVER_STARTTIME>
					 @SQL_TZ_OFFSET,  -- Time Zone offset in minutes of database collected
					 @DPA_TZ_OFFSET  -- Time Zone of the DynamicsPerf database
					) 
				
END 

SET @LAST_SERVER_NAME = @C_SERVER_NAME
SET @LAST_DATABASE_NAME = @C_DATABASE_NAME


SET @REMOTE_SERVER = CASE @C_SERVER_NAME
                       WHEN @@SERVERNAME THEN 'N'
                       ELSE 'Y'
                     END 



--Create synonyms for the sproc

--IF  EXISTS (SELECT * FROM sys.synonyms WHERE name = 'DYN_CS_CAPTURE_SPROC')
--DROP SYNONYM [dbo].[DYN_CS_CAPTURE_SPROC]
--SET @SQL = '
--CREATE SYNONYM DYN_CS_CAPTURE_SPROC
--FOR [DynamicsPerf].dbo.[' + @C_TASK_PROCEDURE + ']'

--IF @DEBUG = 'Y' 
--BEGIN
--PRINT '@SQL= ' + @SQL
--END

--EXEC(@SQL) 

IF @DEBUG = 'Y' 
BEGIN
PRINT 'TASK ID = ' + CAST(@C_TASK_ID AS VARCHAR(10))
PRINT 'SERVER NAME = ' + @C_SERVER_NAME 
PRINT 'DATABASE NAME = ' + @C_DATABASE_NAME
PRINT 'TASK PARMS = ' + ISNULL(@C_TASK_PARAMS, '')
PRINT 'TASK DESC = ' + ISNULL(@C_TASK_DESC,'')
PRINT 'LAST RUN = ' + ISNULL(CAST(@C_LAST_RUN AS VARCHAR(30)),'')
PRINT 'RUN NAME = ' + ISNULL(@RUN_NAME,'')
PRINT 'STATS DATE = ' + CAST(@STATS_DATE AS VARCHAR(30))
PRINT 'REMNOTE SERVER FLAG = ' + ISNULL(@REMOTE_SERVER,'')
PRINT 'AZURE DB = ' + CAST(@C_AZURE_DB AS CHAR(1))


END
			
	

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@C_TASK_DESC, '') + CONVERT(VARCHAR, GETDATE(), 109)
PRINT ''


SET @TASK_STARTTIME = GETDATE()
SET @C_TASK_PARAMS = ISNULL(@C_TASK_PARAMS,'')


IF @DEBUG = 'Y'
BEGIN

	PRINT 'SERVER TIME ZONE OFFSET = ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
	PRINT 'AT LAST RUN  = ' + CAST(@C_LAST_RUN AS VARCHAR(30))

END

--REH Adjust the last_run time to UTC Time, the called sproc's will adjust it to local time unless we've never collected
IF @C_LAST_RUN > '1/1/1901'
BEGIN
SET @C_LAST_RUN = DATEADD(MI,@DPA_TZ_OFFSET *-1 ,@C_LAST_RUN)
END



IF @DEBUG = 'Y'
BEGIN
	PRINT 'AT LAST RUN TIME BEING PASSED TO SPROC ' + CAST(@C_LAST_RUN AS VARCHAR(30))
END

SELECT @SQL = 'EXEC ' + @C_TASK_PROCEDURE + '  @TASK_ID=' + CAST(@C_TASK_ID AS NVARCHAR(10)) + 
' ,@SERVER_NAME = ' + '''' +  @C_SERVER_NAME + '''' +
' ,@DATABASE_NAME = ' + '''' +  @C_DATABASE_NAME + '''' +
' ,@TASK_PARAMS = ' +  '''' +  @C_TASK_PARAMS + '''' +
' ,@TASK_DESC = ' + '''' +  @C_TASK_DESC + '''' +
' ,@LAST_RUN = ' + '''' + CONVERT(VARCHAR, @C_LAST_RUN, 109) + '''' +
' ,@RUN_NAME = ' + '''' +  @RUN_NAME + '''' +
' ,@STATS_DATE = ' + '''' + CONVERT(VARCHAR, @STATS_DATE, 109) + '''' +
' ,@REMOTE_SERVER = ' + '''' +  @REMOTE_SERVER + '''' +
' ,@AZURE_DB = ' + CAST(@C_AZURE_DB AS NVARCHAR(10)) + 
' ,@SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET AS NVARCHAR(10)) + 
' ,@DPA_TZ_OFFSET = ' + CAST(@DPA_TZ_OFFSET AS NVARCHAR(10)) + 


' ,@DEBUG = '  + '''' +  @DEBUG + ''''



UPDATE CAPTURE_LOG
SET    TEXT = TEXT  + CHAR(13) + CHAR(10) + '***** ' + @C_TASK_PROCEDURE
			+ CHAR(13) + CHAR(10)
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE



EXECUTE @RC = sp_executesql @SQL

   					  
SET @TASK_ENDTIME = GETDATE()

SET @TASK_TIME = DATEDIFF(ss,@TASK_STARTTIME, @TASK_ENDTIME)

  
--REH update last  [DYNPERF_TASK_HISTORY] IF THE TASK WAS SUCCESSFUL


  
 IF @RC = 0
      BEGIN
          PRINT ''
 
          PRINT 'SUCCESSFULLY CAPTURED '
                + ISNULL(@C_TASK_DESC, '') +  ' for SERVER '
              + ISNULL(@C_SERVER_NAME, '') + ' on database '
              + ISNULL(@C_DATABASE_NAME, '') + ' in ' + cast(@TASK_TIME AS VARCHAR(20)) + ' SECONDS '
 
       --REH if a manual capture don't update last run so we don't mess up the scheduling engine
				 IF @MANUAL_CAPTURE = 'N'
				 BEGIN
						  MERGE DynamicsPerf..[DYNPERF_TASK_HISTORY] AS target
						  USING (SELECT @C_SERVER_NAME   AS SERVER_NAME,
										@C_DATABASE_NAME AS DATABASE_NAME,
										@C_TASK_ID       AS TASK_ID,
										@STATS_DATE      AS LAST_RUN,
										@TASK_TIME	AS LAST_EXECUTION_TIME_SECS 
												) AS source
						  ON ( source.SERVER_NAME = target.LINKEDSERVER_NAME
							   AND source.DATABASE_NAME = target.DATABASE_NAME
							   AND source.TASK_ID = target.TASK_ID )
						  WHEN MATCHED THEN
							UPDATE SET LAST_RUN = source.LAST_RUN, [LAST_EXECUTION_TIME_SECS] = source.[LAST_EXECUTION_TIME_SECS]
						  WHEN NOT MATCHED THEN
							INSERT ( [LINKEDSERVER_NAME],
									 [DATABASE_NAME],
									 [TASK_ID],
									 [LAST_RUN],
									 [LAST_EXECUTION_TIME_SECS])
							VALUES (source.SERVER_NAME,
									source.DATABASE_NAME,
									source.TASK_ID,
									source.LAST_RUN,
									source.LAST_EXECUTION_TIME_SECS );
				END
      END
 ELSE
	IF @RC = 1  --REH SPROC HANDLED THE ERROR
      BEGIN
          PRINT ''
 
          PRINT 'FAILED !!!!!! ' + ISNULL(@C_TASK_DESC, '')
 
          PRINT ''
      END 
 
  


           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_CS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_CS_QUERY_SYSDATABASES')



END TRY 

BEGIN CATCH


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PROCEDURE FAILED !!! '
              + ISNULL(@C_TASK_DESC, 'TASK') + ' for SERVER
	'
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) + ', '
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE

PRINT 'ERROR WHILE COLLECTING ' + ISNULL(@C_TASK_DESC, '') +' !!!!!!!!!!!!!!'




         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_CS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_CS_QUERY_SYSDATABASES')

END CATCH



FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
	  DELETE FROM COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
		

ENDPROC:
PRINT 'RUN NAME = '+ @RUN_NAME
GO
PRINT N'Altering [dbo].[SP_PROCESS_STATS]...';


GO
ALTER PROCEDURE [dbo].[SP_PROCESS_STATS]
		@SERVER_NAME	NVARCHAR(128) = NULL,
		@DATABASE_NAME	NVARCHAR(128) = NULL ,
		@DYNAMICS_PRODUCT NVARCHAR(3)  = NULL,
		@TASK_TYPE		VARCHAR(50) = 'PROCESS',
		@AZURE_DB		BIT = 0,
		@TOP_ROWS		INT = 0,
		@TOP_COLUMN		NVARCHAR(128) = 'total_elapsed_time',
		@RUN_NAME		NVARCHAR(128) = NULL,
		@INDEX_PHYSICAL_STATS 	NCHAR(1)= 'N',
		@DEBUG			NVARCHAR(1)= 'N'

AS


SET NOCOUNT ON
SET DATEFORMAT MDY

DECLARE @STATS_DATE		DATETIME, 
		@SQL_VERSION	NVARCHAR(1000), 
		@DYNAMICS_VERSION NVARCHAR(MAX),
		@DATABASE_ID	INT,
		@RETURN_CODE	INT,
		@SQL			NVARCHAR(MAX),
		@RUN_DESCRIPTION NVARCHAR(1000),
		@SQL_TOP_CLAUSE	NVARCHAR(128),
		@SQL_ORDERBY_CLAUSE	NVARCHAR(128),
		@PARM			NVARCHAR(500),
		@SQL_SERVER_STARTTIME DATETIME,
		@RC INT,
		@TASK_PROCEDURE NVARCHAR(128),
		@TASK_PARAMETERS NVARCHAR(1024),
		@TASK_DESCRIPTION NVARCHAR(256),
		@LAST_SERVER_NAME NVARCHAR(128) = 'ZZZ',  --REH This is used to trigger inserting a new STATS_COLLECTION_SUMMARY record
		@LAST_DATABASE_NAME NVARCHAR(128) = 'ZZZ',
		@LAST_STATS_DATE DATETIME,
		@REMOTE_SERVER NVARCHAR(1) = 'N',
		@TASK_STARTTIME DATETIME,
		@TASK_ENDTIME DATETIME,
		@TASK_TIME BIGINT,
		@SQL_STARTTIME DATETIME,
		@SQL_BUILD NVARCHAR(20),
		@SQL2 NVARCHAR(MAX),
		@MANUAL_CAPTURE NVARCHAR(1) = 'N',
		@SQL_TZ_OFFSET INT,
		@DPA_TZ_OFFSET INT 

		
		
DECLARE
	@C_SERVER_NAME NVARCHAR(128),
	@C_DATABASE_NAME NVARCHAR(128),
	@C_TASK_ID INT,
	@C_TASK_PROCEDURE NVARCHAR(128),
	@C_TASK_PARAMS NVARCHAR(1024),
	@C_TASK_DESC NVARCHAR(256),
	@C_SERVER_LEVEL_TASK BIT,
	@C_AZURE_DB  BIT,
	@C_LAST_RUN DATETIME
	
		
--REH Time zone off set for the DynamicsPerf database at time of collection
		SET @DPA_TZ_OFFSET = DATEDIFF(MI,GETUTCDATE(),GETDATE())

	IF @DATABASE_NAME IS NOT NULL SET @MANUAL_CAPTURE = 'Y'

	SET @STATS_DATE = GETDATE()
--REH  Verify database exists if being manually passed, skip check if Azure DB, no access to sys.databases catalogue

IF ( @AZURE_DB = 0 and ( @SERVER_NAME IS NOT NULL
      OR @DATABASE_NAME IS NOT NULL ))
     BEGIN

	 
	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_QUERY_SYSDATABASES')

         IF @REMOTE_SERVER = 'Y'
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_PS_QUERY_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_PS_QUERY_SYSDATABASES
				FOR master.sys.databases'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END

         EXEC (@SQL) -- SELECT * FROM DYN_PS_QUERY_SYSDATABASES

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_PS_QUERY_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

         --REH Make sure there is a record in DATABASES_2_COLLECT or insert if new combination
         IF (SELECT COUNT(*)
             FROM   DATABASES_2_COLLECT
             WHERE  LINKED_SERVER = ISNULL(@SERVER_NAME, @@SERVERNAME)
                    AND DATABASE_NAME = @DATABASE_NAME) < 1
              BEGIN
                  INSERT DATABASES_2_COLLECT
                  VALUES(ISNULL(@SERVER_NAME,@@SERVERNAME),
                         @DATABASE_NAME,
                         ISNULL(@DYNAMICS_PRODUCT, 'ALL'),
                         0,
                         2,
                         24,
						 60,
						 2,
						 90,
						 7)
              END
     END 


	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END



---------------------------------------------------------------------------------------------
--
--  Insert Capture_log entry with paramater values used for the run
--
----------------------------------------------------------------------------------------------

INSERT CAPTURE_LOG  SELECT @TASK_TYPE, @STATS_DATE, 'SP_PROCESS_STATS PARMS PASSED @SERVER_NAME = ' + ISNULL(@SERVER_NAME,'NOT PASSED') + ' @DATABASE_NAME = ' + ISNULL(@DATABASE_NAME,'NOT PASSED') +  ' @DEBUG = ' + @DEBUG + '  ' + CHAR(10) + CHAR(13)



SET @RETURN_CODE = 0

DELETE FROM  COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH Default is 'COLLECT' for this sproc.  CAN'T TRUNCATE MULTIPLE SPROCS USING THIS TABLE




IF @DATABASE_NAME IS NULL  --REH AKA, not a manual capture
  BEGIN
      INSERT COLLECTIONDATABASES
      SELECT ISNULL(LINKED_SERVER, @@SERVERNAME),
             [DATABASE_NAME],
             [DYNAMICS_PRODUCT],
             [AZURE_DB],
             [ENABLED],
			 @TASK_TYPE
      FROM   DATABASES_2_COLLECT
      WHERE  ENABLED = 1 -- db must be enabled for autostats collection to work with it
  END
ELSE
  BEGIN   --REH  Insert DBname of the manual capture
      INSERT COLLECTIONDATABASES
      VALUES(ISNULL(@SERVER_NAME, @@SERVERNAME),
             @DATABASE_NAME,
             @DYNAMICS_PRODUCT,
             @AZURE_DB,
             1,
			 @TASK_TYPE)
  END 


--REH Insert any missing task history records in case it's a new database being collected, so we don't fail to capture against the db because of no records
-- yes, this is a cartesian join between these 2 tables

INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE	--REH default is 'PROCESS' in parm definition of this sproc
       AND NOT EXISTS (SELECT 'X'
                       FROM   DYNPERF_TASK_HISTORY DTH
                       WHERE  DTS.TASK_ID = DTH.TASK_ID
                              AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                              AND CD.DATABASE_NAME = DTH.DATABASE_NAME)
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 0 --REH Ok, to put 1 record per database in for DB type tasks


	   
--REH Need to insert 1 bogus record for each server level task, or the join on the cursor will fail

INSERT COLLECTIONDATABASES 
 SELECT	DISTINCT [LINKED_SERVER],
             'N/A',
            'ALL',
             [AZURE_DB],
             [ENABLED],
			 [TASK_TYPE]
FROM COLLECTIONDATABASES CD
WHERE DATABASE_NAME <> 'N/A'
AND TASK_TYPE = @TASK_TYPE
AND NOT EXISTS (SELECT 'X' FROM COLLECTIONDATABASES CD2 WHERE CD2.LINKED_SERVER = CD.LINKED_SERVER AND CD2.DATABASE_NAME = 'N/A')



--REH now lets insert server level tasks with a blank DB name so we only do them once per server
INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       'N/A',
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE  --REH default is 'COLLECT' in parm definition of this sproc
		AND CD.DATABASE_NAME <> 'N/A'
       AND NOT EXISTS (SELECT 'X'
                   FROM   DYNPERF_TASK_HISTORY DTH
                   WHERE  DTS.TASK_ID = DTH.TASK_ID
                          AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                          AND DTH.DATABASE_NAME = 'N/A') --REH making the db name = 'N/A' for server level tasks
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 1 





	IF @DEBUG = 'Y'
	BEGIN
		PRINT 'MANUAL_CAPTURE = ' + @MANUAL_CAPTURE
	END

	--REH Create here and truncate table in each loop
	   CREATE TABLE #SQL_INFO
     (
        SQL_STARTTIME DATETIME,
        SQL_BUILD NVARCHAR(20),
		TZ_OFFSET INT
     )
   

/********************************************************************************
Rod Hansen

Added a trigger to DATABASES_2_COLLECT so that we always have a 
DYNPERF_TASK_HISTORY record for this code 

********************************************************************************/

DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT DISTINCT DTS.TASK_ID,
       CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_PROCEDURE,
       DTS.TASK_PARAMETERS,
       DTS.TASK_DESCRIPTION,
       DTS.SERVER_LEVEL_TASK,
       CD.AZURE_DB,
       ISNULL(DTH.LAST_RUN, '1/1/1900')
FROM   DynamicsPerf..[DYNPERF_TASK_SCHEDULER] DTS
       LEFT OUTER JOIN DynamicsPerf..[DYNPERF_TASK_HISTORY] DTH
                    ON DTH.TASK_ID = DTS.TASK_ID
       INNER JOIN DynamicsPerf..COLLECTIONDATABASES CD
               ON CD.DATABASE_NAME = DTH.DATABASE_NAME
                  AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
WHERE
  --REH Task is enabled
  DTS.ENABLED = 1
  AND
  --REH It's the correct task type C = COLLECTOR, P = PROCESS, M = MONITOR, ETC
  DTS.TASK_TYPE = @TASK_TYPE
  AND
  --REH database is enabled
  CD.ENABLED = 1
  AND
  --REH Azure_db, if Azure db, then task must support it
  ( CD.AZURE_DB = DTS.AZURE_DB_SUPPORTED
     OR CD.AZURE_DB = 0 )
  --REH Either its an Azure Task, all Azure tasks will run locally, so if task supports AZ and we pass 0, run it anyways
  AND ( DTS.AZURE_DB_SUPPORTED = @AZURE_DB
         OR ( DTS.AZURE_DB_SUPPORTED = 1
              AND @AZURE_DB = 0 ) )
  AND
  --REH it's either All products or matches the Dynamics Product
  ( DTS.DYNAMICS_PRODUCT = 'ALL'
     OR DTS.DYNAMICS_PRODUCT = CD.DYNAMICS_PRODUCT )
  AND
  --REH Scheduling options now
(
  --REH In the case of minutes or hous, we ignore schedule time and just figure out if it's time to run again
  ( @MANUAL_CAPTURE = 'Y'
     OR ( @MANUAL_CAPTURE = 'N'
          AND ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                  WHEN 'MI' THEN DATEADD(MINUTE, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                END ) <= GETDATE()
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'HH' THEN DATEADD(HOUR, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                --REH and it is on the hour
                AND ( ABS(DATEDIFF(MI, DATEADD(Hour, DATEDIFF(Hour, 0, GETDATE()), 0), GETDATE())) <= 1 ) )
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'DD' THEN DATEADD(DAY, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'WK' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'MM' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'QQ' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'YY' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                AND ( --REH TIME IS NULL SO IGNORE IT
                    COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) IS NULL
                     OR --REH Current time = Scheduled time 
                    ( SUBSTRING((SELECT REPLACE(CONVERT(VARCHAR(10), GETDATE(), 108), ':', '')), 1, 4) = (SELECT REPLICATE('0', 4 - LEN( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME)))
                                                                                                                 + CAST( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) AS VARCHAR(4))) ) ) )
         --REH and last_run < current time
         )--AND CONVERT(VARCHAR(10), LAST_RUN, 108) <= CONVERT(VARCHAR(10), Getdate(), 108) ) 
   )
)
ORDER  BY CD.LINKED_SERVER,
          CD.DATABASE_NAME,
          DTS.TASK_ID 



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

	SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                    WHEN @@SERVERNAME THEN 'N'
                    ELSE 'Y'
                    END

--Insert new STATS_COLLECTION_SUMMARY RECORD, we want 1 RUN_NAME per server not per database
IF @C_SERVER_NAME <> @LAST_SERVER_NAME OR @C_DATABASE_NAME <> @LAST_DATABASE_NAME
BEGIN
    SET @RUN_NAME = ISNULL(@C_SERVER_NAME, @@SERVERNAME)+ ' '
                    + CAST(@STATS_DATE AS VARCHAR(30))


TRUNCATE TABLE #SQL_INFO   

 DELETE FROM COLLECTIONDATABASES WHERE LINKED_SERVER = @LAST_SERVER_NAME AND DATABASE_NAME = @LAST_DATABASE_NAME AND TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
 
SELECT @SQL = 'SELECT create_date AS SQL_STARTTIME,
       CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))    AS SQL_BUILD,
	   DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
		FROM sys.databases WHERE name = ''TempDB'''

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


   SET NOCOUNT ON
 
IF @REMOTE_SERVER = 'N'
BEGIN
		   INSERT #SQL_INFO
		EXEC( @SQL)
END


 IF @REMOTE_SERVER = 'Y'
 BEGIN
			IF @C_AZURE_DB = 0
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT create_date AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROM sys.databases WHERE name = ''TempDB''"	)'
			END
			IF @C_AZURE_DB = 1
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT DATEADD(ms,AVG(-wait_time_ms), GETDATE()) AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROMsys.dm_os_wait_stats w WHEREwait_type
IN(''DIRTY_PAGE_POLL'',''HADR_FILESTREAM_IOMGR_IOCOMPLETION'',''LAZYWRITER_SLEEP'',''LOGMGR_QUEUE'',''REQUEST_FOR_DEADLOCK_SEARCH'',''XE_DISPATCHER_WAIT'',''XE_TIMER_EVENT'') "	)'
			END


				IF @DEBUG = 'Y'
                  BEGIN
                      PRINT '@SQL= ' + @SQL2
                  END 
                
			INSERT #SQL_INFO
				EXEC (@SQL2) 
 
 END
 
 SELECT @SQL_STARTTIME = SQL_STARTTIME, @SQL_BUILD = SQL_BUILD, @SQL_TZ_OFFSET = TZ_OFFSET FROM #SQL_INFO



  --REH NOT Collecting so don't need this code in this sproc


		--INSERT INTO [DynamicsPerf].[dbo].[STATS_COLLECTION_SUMMARY]
		--			([SERVER_NAME],
		--			 [STATS_TIME],
		--			 [RUN_NAME],
		--			 [DATABASE_NAME],
		--			 [SQL_VERSION],
		--			 [DYNAMICS_VERSION],
		--			 [RUN_DESCRIPTION],
		--			 [SQL_SERVER_STARTTIME],
		--			 [SQL_SERVER_TZ_OFFSET] ,
		--			 [DPA_TZ_OFFSET])
		--VALUES      (@C_SERVER_NAME,
		--			 @STATS_DATE,
		--			 @RUN_NAME,
		--			 @C_DATABASE_NAME,
		--			 @SQL_BUILD,--<SQL_VERSION>
		--			 '',--<DYNAMICS_VERSION>
		--			 '',--<RUN_DESCRIPTION>
		--			 @SQL_STARTTIME, -- <SQL_SERVER_STARTTIME>
		--			 @SQL_TZ_OFFSET,  -- Time Zone offset in minutes of database collected
		--			 @DPA_TZ_OFFSET  -- Time Zone of the DynamicsPerf database
		--			) 
				
END 

SET @LAST_SERVER_NAME = @C_SERVER_NAME
SET @LAST_DATABASE_NAME = @C_DATABASE_NAME


SET @REMOTE_SERVER = CASE @C_SERVER_NAME
                       WHEN @@SERVERNAME THEN 'N'
                       ELSE 'Y'
                     END 



--Create synonyms for the sproc

--IF  EXISTS (SELECT * FROM sys.synonyms WHERE name = 'DYN_PS_CAPTURE_SPROC')
--DROP SYNONYM [dbo].[DYN_PS_CAPTURE_SPROC]
--SET @SQL = '
--CREATE SYNONYM DYN_PS_CAPTURE_SPROC
--FOR [DynamicsPerf].dbo.[' + @C_TASK_PROCEDURE + ']'

--IF @DEBUG = 'Y' 
--BEGIN
--PRINT '@SQL= ' + @SQL
--END

--EXEC(@SQL) 

IF @DEBUG = 'Y' 
BEGIN
PRINT 'TASK ID = ' + CAST(@C_TASK_ID AS VARCHAR(10))
PRINT 'SERVER NAME = ' + @C_SERVER_NAME 
PRINT 'DATABASE NAME = ' + @C_DATABASE_NAME
PRINT 'TASK PARMS = ' + ISNULL(@C_TASK_PARAMS, '')
PRINT 'TASK DESC = ' + ISNULL(@C_TASK_DESC,'')
PRINT 'LAST RUN = ' + ISNULL(CAST(@C_LAST_RUN AS VARCHAR(30)),'')
PRINT 'RUN NAME = ' + ISNULL(@RUN_NAME,'')
PRINT 'STATS DATE = ' + CAST(@STATS_DATE AS VARCHAR(30))
PRINT 'REMNOTE SERVER FLAG = ' + ISNULL(@REMOTE_SERVER,'')
PRINT 'AZURE DB = ' + CAST(@C_AZURE_DB AS CHAR(1))


END
			
	

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@C_TASK_DESC, '') + CONVERT(VARCHAR, GETDATE(), 109)
PRINT ''


SET @TASK_STARTTIME = GETDATE()
SET @C_TASK_PARAMS = ISNULL(@C_TASK_PARAMS,'')


IF @DEBUG = 'Y'
BEGIN

	PRINT 'SERVER TIME ZONE OFFSET = ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
	PRINT 'AT LAST RUN  = ' + CAST(@C_LAST_RUN AS VARCHAR(30))

END

--REH Adjust the last_run time to UTC Time, the called sproc's will adjust it to local time unless we've never collected
IF @C_LAST_RUN > '1/1/1901'
BEGIN
SET @C_LAST_RUN = DATEADD(MI,@DPA_TZ_OFFSET *-1 ,@C_LAST_RUN)
END



IF @DEBUG = 'Y'
BEGIN
	PRINT 'AT LAST RUN TIME BEING PASSED TO SPROC ' + CAST(@C_LAST_RUN AS VARCHAR(30))
END

SELECT @SQL = 'EXEC ' + @C_TASK_PROCEDURE + '  @TASK_ID=' + CAST(@C_TASK_ID AS NVARCHAR(10)) + 
' ,@SERVER_NAME = ' + '''' +  @C_SERVER_NAME + '''' +
' ,@DATABASE_NAME = ' + '''' +  @C_DATABASE_NAME + '''' +
' ,@TASK_PARAMS = ' +  '''' +  @C_TASK_PARAMS + '''' +
' ,@TASK_DESC = ' + '''' +  @C_TASK_DESC + '''' +
' ,@LAST_RUN = ' + '''' + CONVERT(VARCHAR, @C_LAST_RUN, 109) + '''' +
' ,@RUN_NAME = ' + '''' +  @RUN_NAME + '''' +
' ,@STATS_DATE = ' + '''' + CONVERT(VARCHAR, @STATS_DATE, 109) + '''' +
' ,@REMOTE_SERVER = ' + '''' +  @REMOTE_SERVER + '''' +
' ,@AZURE_DB = ' + CAST(@C_AZURE_DB AS NVARCHAR(10)) + 
' ,@SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET AS NVARCHAR(10)) + 
' ,@DPA_TZ_OFFSET = ' + CAST(@DPA_TZ_OFFSET AS NVARCHAR(10)) + 


' ,@DEBUG = '  + '''' +  @DEBUG + ''''


UPDATE CAPTURE_LOG
SET    TEXT = TEXT  + CHAR(13) + CHAR(10) + '***** ' + @C_TASK_PROCEDURE
			+ CHAR(13) + CHAR(10)
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE



EXECUTE @RC = sp_executesql @SQL

   					  
SET @TASK_ENDTIME = GETDATE()

SET @TASK_TIME = DATEDIFF(ss,@TASK_STARTTIME, @TASK_ENDTIME)

  
--REH update last  [DYNPERF_TASK_HISTORY] IF THE TASK WAS SUCCESSFUL


  
 IF @RC = 0
      BEGIN
          PRINT ''
 
          PRINT 'SUCCESSFULLY CAPTURED '
                + ISNULL(@C_TASK_DESC, '') +  ' for SERVER
	'
              + ISNULL(@C_SERVER_NAME, '') + ' on database '
              + ISNULL(@C_DATABASE_NAME, '') + ' in ' + cast(@TASK_TIME AS VARCHAR(20)) + ' SECONDS '
 
       --REH if a manual capture don't update last run so we don't mess up the scheduling engine
				 IF @MANUAL_CAPTURE = 'N'
				 BEGIN
						  MERGE DynamicsPerf..[DYNPERF_TASK_HISTORY] AS target
						  USING (SELECT @C_SERVER_NAME   AS SERVER_NAME,
										@C_DATABASE_NAME AS DATABASE_NAME,
										@C_TASK_ID       AS TASK_ID,
										@STATS_DATE      AS LAST_RUN,
										@TASK_TIME	AS LAST_EXECUTION_TIME_SECS 
												) AS source
						  ON ( source.SERVER_NAME = target.LINKEDSERVER_NAME
							   AND source.DATABASE_NAME = target.DATABASE_NAME
							   AND source.TASK_ID = target.TASK_ID )
						  WHEN MATCHED THEN
							UPDATE SET LAST_RUN = source.LAST_RUN, [LAST_EXECUTION_TIME_SECS] = source.[LAST_EXECUTION_TIME_SECS]
						  WHEN NOT MATCHED THEN
							INSERT ( [LINKEDSERVER_NAME],
									 [DATABASE_NAME],
									 [TASK_ID],
									 [LAST_RUN],
									 [LAST_EXECUTION_TIME_SECS])
							VALUES (source.SERVER_NAME,
									source.DATABASE_NAME,
									source.TASK_ID,
									source.LAST_RUN,
									source.LAST_EXECUTION_TIME_SECS );
				END
      END
 ELSE
	IF @RC = 1  --REH SPROC HANDLED THE ERROR
      BEGIN
          PRINT ''
 
          PRINT 'FAILED !!!!!! ' + ISNULL(@C_TASK_DESC, '')
 
          PRINT ''
      END 
 

 
 

           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_QUERY_SYSDATABASES')

  
END TRY 

BEGIN CATCH


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PROCEDURE FAILED !!! '
              + ISNULL(@C_TASK_DESC, 'TASK') + ' for SERVER
	'
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) + ', '
WHERE  STATS_TIME = @STATS_DATE  AND TASK_TYPE = @TASK_TYPE

PRINT 'ERROR WHILE COLLECTING ' + ISNULL(@C_TASK_DESC, '') +' !!!!!!!!!!!!!!'


           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_QUERY_SYSDATABASES')


END CATCH



FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
 DELETE FROM COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
 
			

ENDPROC:
PRINT 'RUN NAME = '+ @RUN_NAME
GO
PRINT N'Refreshing [dbo].[DYNPERF_PURGE_DATA]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[DYNPERF_PURGE_DATA]';


GO
PRINT N'Refreshing [dbo].[DYNPERF_REFRESH_QUERY_TEXT]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[DYNPERF_REFRESH_QUERY_TEXT]';


GO
PRINT N'Refreshing [dbo].[DYNPERF_UPDATE_QUERY_HISTORY]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[DYNPERF_UPDATE_QUERY_HISTORY]';


GO
PRINT N'Update complete.';


GO
