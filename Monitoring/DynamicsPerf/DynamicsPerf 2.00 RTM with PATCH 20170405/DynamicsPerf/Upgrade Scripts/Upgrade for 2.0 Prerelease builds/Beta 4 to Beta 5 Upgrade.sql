/*
Deployment script for DynamicsPerf

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


USE [DynamicsPerf];

declare @n char(1)
set @n = char(10)

declare @stmt nvarchar(max)

select @stmt = isnull( @stmt + @n, '' ) +
'drop synonym [' + SCHEMA_NAME(schema_id) + '].[' + name + ']'
from sys.synonyms

exec sp_executesql @stmt

GO

--ALTER DATABASE [DynamicsPerf] SET ANSI_NULL_DEFAULT OFF 

--ALTER DATABASE [DynamicsPerf] SET ANSI_NULLS OFF 

--ALTER DATABASE [DynamicsPerf] SET ANSI_PADDING OFF 

--ALTER DATABASE [DynamicsPerf] SET ANSI_WARNINGS OFF 

--ALTER DATABASE [DynamicsPerf] SET ARITHABORT OFF 

--ALTER DATABASE [DynamicsPerf] SET AUTO_CLOSE OFF 

--ALTER DATABASE [DynamicsPerf] SET AUTO_CREATE_STATISTICS ON 

--ALTER DATABASE [DynamicsPerf] SET AUTO_SHRINK OFF 

--ALTER DATABASE [DynamicsPerf] SET AUTO_UPDATE_STATISTICS ON 

--ALTER DATABASE [DynamicsPerf] SET CURSOR_CLOSE_ON_COMMIT OFF 

--ALTER DATABASE [DynamicsPerf] SET CURSOR_DEFAULT  GLOBAL 

--ALTER DATABASE [DynamicsPerf] SET CONCAT_NULL_YIELDS_NULL OFF 

--ALTER DATABASE [DynamicsPerf] SET NUMERIC_ROUNDABORT OFF 

--ALTER DATABASE [DynamicsPerf] SET QUOTED_IDENTIFIER OFF 

--ALTER DATABASE [DynamicsPerf] SET RECURSIVE_TRIGGERS OFF 

--ALTER DATABASE [DynamicsPerf] SET  ENABLE_BROKER 

--ALTER DATABASE [DynamicsPerf] SET AUTO_UPDATE_STATISTICS_ASYNC OFF 

--ALTER DATABASE [DynamicsPerf] SET DATE_CORRELATION_OPTIMIZATION OFF 

--ALTER DATABASE [DynamicsPerf] SET TRUSTWORTHY OFF 

--ALTER DATABASE [DynamicsPerf] SET READ_COMMITTED_SNAPSHOT ON

--ALTER DATABASE [DynamicsPerf] SET ALLOW_SNAPSHOT_ISOLATION ON

--ALTER DATABASE [DynamicsPerf] SET PARAMETERIZATION SIMPLE 

--ALTER DATABASE [DynamicsPerf] SET  READ_WRITE 

--ALTER DATABASE [DynamicsPerf] SET RECOVERY SIMPLE 

--ALTER DATABASE [DynamicsPerf] SET  MULTI_USER 

--ALTER DATABASE [DynamicsPerf] SET PAGE_VERIFY NONE  

--ALTER DATABASE [DynamicsPerf] SET DB_CHAINING OFF 

GO


TRUNCATE TABLE [DYNPERF_PURGETABLES]


INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_BATCHJOB_DETAIL' ,'STATS_TIME', 1, 1,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_BATCHSERVERGROUP_CONFIG' ,'STATS_TIME', 1, 1,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_INDEX_DETAIL' ,'STATS_TIME', 1, 1,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_LICENSEKEY_DETAIL' ,'STATS_TIME', 1, 1,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_NUM_SEQUENCES' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_SERVER_CONFIG' ,'STATS_TIME', 1, 1,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_SQLTRACE' ,'STATS_TIME', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_TABLE_DETAIL' ,'STATS_TIME', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AZURE_EVENTS' ,'STATS_TIME', 1, 1,90) 


-- HANDLED BY SPROC  INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_SYSGLOBALCONFIGURATION' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('BLOCKS' ,'BLOCKED_DTTM', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('BUFFER_DETAIL' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('CAPTURE_LOG' ,'STATS_TIME', 0, 0,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('CDC' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('CRM_ORGANIZATION' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('CRM_PLUGINS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('CRM_POA_TOTALS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('DISKSTATS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_DENSITY_VECTOR' ,'', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_DETAIL' ,'STATS_TIME', 1, 1,2) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_HISTOGRAM' ,'', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_HISTORY' ,'DATE', 1, 1,999) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_OPERATIONAL_STATS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_PHYSICAL_STATS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_STAT_HEADER' ,'', 1, 1,14)
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_USAGE_STATS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('LOGINFO' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('PERF_COUNTER_DATA' ,'STATS_TIME', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_ALERTS' ,'STATS_TIME', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_ALERTS_CONFIG' ,'', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_HISTORY' ,'DATE', 1, 1,999) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_PLANS' ,'DATE_UPDATED', 1, 1,999) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_PLANS_PARSED' ,'', 1, 1,999) 

INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_STATS' ,'STATS_TIME', 1, 1,2) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_TEXT' ,' ', 1, 1,999) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SERVERINFO' ,'STATS_TIME', 1, 0,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_AZURE_EVENTS' ,'END_TIME', 1, 1,14) 

INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_CONFIGURATION' ,'STATS_TIME', 1, 0,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_DATABASEFILES' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_DATABASES' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_JOBS' ,'STATS_TIME', 1, 0,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_PLAN_GUIDES' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_REPLICATION' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQLERRORLOG' ,'LOGDATE', 1, 0,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SSRS_EXECUTIONLOG' ,'TIMEEND', 1, 0,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('STATS_COLLECTION_SUMMARY' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('TRACEFLAGS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('TRIGGER_TABLE' ,'', 1, 1,14) 

INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('WAIT_STATS' ,'STATS_TIME', 1, 0,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SSRS_HISTORY' ,'REPORT_DATE', 1, 0,730) 


GO
PRINT N'Starting rebuilding table [dbo].[QUERY_PLANS]...';


GO
ALTER TABLE [dbo].[QUERY_PLANS] SET (LOCK_ESCALATION = DISABLE);


IF EXISTS 
(SELECT * FROM sys.objects 
WHERE object_id = OBJECT_ID(N'FN_HASH_FROM_UINT64_TO_BINARY') 
AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))

DROP FUNCTION FN_HASH_FROM_UINT64_TO_BINARY
GO


CREATE FUNCTION [dbo].[FN_HASH_FROM_UINT64_TO_BINARY](@QUERY_PLAN_HASH DECIMAL(38,0))
RETURNS BINARY(8)
WITH EXECUTE AS CALLER
AS
	BEGIN
		DECLARE	@NEW_QUERY_PLAN_HASH BINARY(8),
				@BITMASK BIGINT

		SET @BITMASK = 0x8000000000000000
		IF @QUERY_PLAN_HASH < CONVERT(DECIMAL(38,0),@BITMASK)*-1
			SET @NEW_QUERY_PLAN_HASH = CONVERT(BINARY(8),CONVERT(BIGINT,@QUERY_PLAN_HASH))
		ELSE 
			SET @NEW_QUERY_PLAN_HASH = CONVERT(BINARY(8),CONVERT(BIGINT,@QUERY_PLAN_HASH - CONVERT(DECIMAL(38,0),@BITMASK)*-1)|@BITMASK)

		RETURN (@NEW_QUERY_PLAN_HASH);
	END

GO
PRINT N'Creating [dbo].[AX_USERINFO]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;

IF EXISTS (SELECT * FROM sys.objects WHERE name = 'AX_USERINFO' and type = 'u')
    DROP TABLE [AX_USERINFO]
GO
CREATE TABLE [dbo].[AX_USERINFO] (
    [SERVER_NAME]   NVARCHAR (128) NOT NULL,
    [STATS_TIME]    DATETIME       NOT NULL,
    [DATABASE_NAME] NVARCHAR (128) NOT NULL,
    [Id]            NVARCHAR (30)  NOT NULL,
    [NAME]          NVARCHAR (128) NOT NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[AX_USERINFO].[IX_AX_USERINFO]...';


GO
CREATE CLUSTERED INDEX [IX_AX_USERINFO]
    ON [dbo].[AX_USERINFO]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC) WITH (DATA_COMPRESSION = ROW);


GO
PRINT N'Creating [dbo].[WRK_CS_SQL_INFO]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;

IF EXISTS (SELECT * FROM sys.objects WHERE name = 'WRK_CS_SQL_INFO' and type = 'u')
    DROP TABLE [WRK_CS_SQL_INFO]
    
GO
CREATE TABLE [dbo].[WRK_CS_SQL_INFO] (
    [SQL_STARTTIME] DATETIME      NULL,
    [SQL_BUILD]     NVARCHAR (20) NULL,
    [TZ_OFFSET]     INT           NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[WRK_PS_SQL_INFO]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;

IF EXISTS (SELECT * FROM sys.objects WHERE name = 'WRK_PS_SQL_INFO' and type = 'u')
    DROP TABLE [WRK_PS_SQL_INFO]
GO
CREATE TABLE [dbo].[WRK_PS_SQL_INFO] (
    [SQL_STARTTIME] DATETIME      NULL,
    [SQL_BUILD]     NVARCHAR (20) NULL,
    [TZ_OFFSET]     INT           NULL
);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[QUERY_PLANS_PARSED].[IX_QUERY_PLANS_PARSED_HASH]...';

GO



IF EXISTS(SELECT * FROM sys.indexes WHERE object_id = object_id('dbo.QUERY_PLANS') AND NAME ='IX_QUERY_PLANS_PARSED_HASH')
    DROP INDEX IX_QUERY_PLANS_PARSED_HASH ON dbo.QUERY_PLANS;
GO


IF EXISTS(SELECT * FROM sys.indexes WHERE object_id = object_id('dbo.QUERY_PLANS_PARSED') AND NAME ='IX_QUERY_PLANS_PARSED_HASH')
    DROP INDEX IX_QUERY_PLANS_PARSED_HASH ON dbo.QUERY_PLANS_PARSED;
    
GO
CREATE CLUSTERED INDEX [IX_QUERY_PLANS_PARSED_HASH]
    ON [dbo].[QUERY_PLANS_PARSED]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [QUERY_PLAN_HASH] ASC) WITH (DATA_COMPRESSION = ROW);


GO
PRINT N'Refreshing [dbo].[MISSING_INDEXES_CURR_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[MISSING_INDEXES_CURR_VW]';


GO
PRINT N'Refreshing [dbo].[MISSING_INDEXES_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[MISSING_INDEXES_VW]';


GO
PRINT N'Refreshing [dbo].[PARSED_PLAN_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[PARSED_PLAN_VW]';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;

GO

PRINT N'Altering [dbo].[PERF_HOURLY_WAITSTATS_VW]...';
GO
ALTER VIEW [dbo].[PERF_HOURLY_WAITSTATS_VW]
AS

WITH MyCTE (SERVER_NAME, STATS_TIME, WAIT_TYPE, WAITING_TASKS_COUNT, WAIT_TIME_MS, SIGNAL_WAIT_TIME_MS, RowVersion)
     AS (SELECT WS.SERVER_NAME,
                WS.STATS_TIME,
                WS.WAIT_TYPE,
                WS.WAITING_TASKS_COUNT,
                WS.WAIT_TIME_MS,
                WS.SIGNAL_WAIT_TIME_MS,
                Row_number()
                  OVER(
                    PARTITION BY SERVER_NAME, WAIT_TYPE
                    ORDER BY STATS_TIME DESC) RowVersion
         FROM   WAIT_STATS WS)
SELECT TOP 100 PERCENT WS.SERVER_NAME,WS.STATS_TIME,
                       WS.WAIT_TYPE,
                       WS.WAITING_TASKS_COUNT - PREV.WAITING_TASKS_COUNT                                                  AS WAITING_TASKS_LAST_HOUR,
                       WS.WAIT_TIME_MS - PREV.WAIT_TIME_MS                                                                AS WAIT_TIME_MS_LAST_HOUR,
                       Cast (( WS.WAIT_TIME_MS - PREV.WAIT_TIME_MS ) / ( CASE
                                                                           WHEN ( WS.WAITING_TASKS_COUNT = PREV.WAITING_TASKS_COUNT ) THEN 1.0
                                                                           ELSE ( WS.WAITING_TASKS_COUNT - PREV.WAITING_TASKS_COUNT ) * 1.0
                                                                         END ) AS NUMERIC (10, 0))                        AS AVG_WAIT_TIME_MS_LAST_HOUR,
                       WS.SIGNAL_WAIT_TIME_MS - PREV.SIGNAL_WAIT_TIME_MS                                                  AS SIGNAL_WAIT_TIME_MS_LAST_HOUR,
                       Cast (( WS.SIGNAL_WAIT_TIME_MS - PREV.SIGNAL_WAIT_TIME_MS ) / ( CASE
                                                                                         WHEN ( WS.WAITING_TASKS_COUNT = PREV.WAITING_TASKS_COUNT ) THEN 1.0
                                                                                         ELSE ( WS.WAITING_TASKS_COUNT - PREV.WAITING_TASKS_COUNT ) * 1.0
                                                                                       END ) AS NUMERIC (10, 0))          AS AVG_SIGNAL_WAIT_TIME_MS_LAST_HOUR,
                       Cast ((( WS.SIGNAL_WAIT_TIME_MS - PREV.SIGNAL_WAIT_TIME_MS )) * 100. / ( CASE
                                                                                                  WHEN ( WS.WAIT_TIME_MS = PREV.WAIT_TIME_MS ) THEN 1
                                                                                                  ELSE ( WS.WAIT_TIME_MS - PREV.WAIT_TIME_MS )
                                                                                                END ) AS NUMERIC (10, 0)) AS RATIO_SIGNAL_WAIT_TIME_TO_WAITTIME_LAST_HOUR,
                       Rank()
                         OVER (
                           partition BY WS.STATS_TIME
                           ORDER BY WS.STATS_TIME DESC, ( (WS.WAIT_TIME_MS)-(PREV.WAIT_TIME_MS)) DESC)                    AS RANK
FROM   MyCTE WS
       INNER JOIN MyCTE PREV
               ON WS.SERVER_NAME = PREV.SERVER_NAME
                  AND WS.WAIT_TYPE = PREV.WAIT_TYPE
                  AND WS.RowVersion = PREV.RowVersion - 1
ORDER  BY WS.STATS_TIME DESC,
          WS.WAIT_TIME_MS - PREV.WAIT_TIME_MS DESC,
          WS.WAIT_TYPE
GO




GO
PRINT N'Refreshing [dbo].[QUERY_PLANS_MISSING_INDEX_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[QUERY_PLANS_MISSING_INDEX_VW]';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Refreshing [dbo].[QUERY_PLANS_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[QUERY_PLANS_VW]';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Refreshing [dbo].[QUERY_STATS_CURR_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[QUERY_STATS_CURR_VW]';


GO
PRINT N'Refreshing [dbo].[QUERY_STATS_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[QUERY_STATS_VW]';


GO
PRINT N'Refreshing [dbo].[HIDDEN_SCANS_CURR_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[HIDDEN_SCANS_CURR_VW]';


GO
PRINT N'Refreshing [dbo].[USER_SCANS_CURR_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[USER_SCANS_CURR_VW]';


GO
PRINT N'Altering [dbo].[QUERY_HISTORY_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
ALTER VIEW [dbo].[QUERY_HISTORY_VW]
AS
  SELECT QH.SERVER_NAME,
         QH.DATABASE_NAME,
         QH.FLAG                                                                                                                                                                                 AS FLAG,
         DATE,
         EXECUTION_COUNT_TODAY                                                                                                                                                                   AS EXECUTION_COUNT,
         Cast(ELAPSED_TIME_TODAY / 1000.000 AS DECIMAL(29, 3))                                                                                                                                   AS TOTAL_ELAPSED_TIME,
         QH.AVG_TIME_TODAY_MS                                                                                                                                                                    AS AVG_ELAPSED_TIME,
         Cast(MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                                                                                                     AS MAX_ELAPSED_TIME,
         AVG_LOGICAL_READS = CASE EXECUTION_COUNT_TODAY
                               WHEN 0 THEN 0
                               ELSE TOTAL_LOGICAL_READS_TODAY / EXECUTION_COUNT_TODAY
                             END,
         AVG_LOGICAL_READS_MB = CASE EXECUTION_COUNT_TODAY
                                  WHEN 0 THEN 0
                                  ELSE ( TOTAL_LOGICAL_READS_TODAY / EXECUTION_COUNT_TODAY ) * 8 / 1024
                                END,
         Cast(ELAPSED_TIME_TODAY / 1000.000 AS DECIMAL(29, 3)) - Cast(TOTAL_WORKER_TIME_TODAY / 1000.000 AS DECIMAL(29, 3))                                                                      AS TOTAL_WAIT_TIME,
         AVG_ROWS_RETURNED = CASE EXECUTION_COUNT_TODAY
                               WHEN 0 THEN 0
                               ELSE TOTAL_ROWS_TODAY / EXECUTION_COUNT_TODAY
                             END,
         Replace(Replace(QT.SQL_TEXT, 'SELECT ', Char(10)+'SELECT '), ' FROM', Char(10)+' FROM')
         + Char(10) + Char(10) + Replicate('-', 50)
         + 'QUERY PARAMETERS' + Replicate('-', 61)
         + Char(10) + QP.SQL_PARMS + Char(10) + Char(10)
         + Replicate('-', 50)
         + 'TABLE NODES FROM QUERY PLAN'
         + Replicate('-', 50) + Char(10)
         + Isnull((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE QH.SERVER_NAME = QPV.SERVER_NAME AND QH.DATABASE_NAME = QPV.DATABASE_NAME AND QH.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '') AS QUERY_PLAN_PARSED,
         Isnull((SELECT MISSING_INDEX_INFO
                 FROM   QUERY_PLANS_MISSING_INDEX_VW QPV
                 WHERE  QH.SERVER_NAME = QPV.SERVER_NAME
                        AND QH.DATABASE_NAME = QPV.DATABASE_NAME
                        AND QH.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '')                                                                                                                       AS MISSING_INDEXES,
         QP.SQL_PARMS                                                                                                                                                                            AS QUERY_PARAMETER_VALUES,
         QP.QUERY_PLAN,
         QH.QUERY_PLAN_HASH,
         QH.QUERY_HASH,
         QT.SQL_TEXT                                                                                                                                                                             AS SQL_TEXT,
         TOTAL_ROWS_TODAY                                                                                                                                                                        AS TOTAL_ROWS,
         LAST_EXECUTION_TIME                                                                                                                                                                     AS LAST_EXECUTION_TIME,
         TOTAL_LOGICAL_READS_TODAY                                                                                                                                                               AS TOTAL_LOGICAL_READS,
         QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN)
  FROM   QUERY_HISTORY QH WITH (NOLOCK)
         INNER LOOP JOIN QUERY_PLANS QP WITH (NOLOCK)
                      ON QP.QUERY_PLAN_HASH = QH.QUERY_PLAN_HASH
                         AND QP.SERVER_NAME = QH.SERVER_NAME
                         AND QP.DATABASE_NAME = QH.DATABASE_NAME
         LEFT OUTER LOOP JOIN QUERY_TEXT AS QT
                           ON QH.QUERY_HASH = QT.QUERY_HASH
                              AND QH.SERVER_NAME = QT.SERVER_NAME
                              AND QH.DATABASE_NAME = QT.DATABASE_NAME
         LEFT OUTER LOOP JOIN COMMENTS C
                           ON QH.QUERY_HASH = C.QUERY_HASH
                              AND QH.SERVER_NAME = C.SERVER_NAME
                              AND QH.DATABASE_NAME = C.DATABASE_NAME
  WHERE  EXECUTION_COUNT_TODAY > 0
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Refreshing [dbo].[QUERY_ALERTS_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[QUERY_ALERTS_VW]';


GO

PRINT N'Altering [dbo].[SP_INDEX_CHANGES]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;

GO

ALTER PROCEDURE [dbo].[SP_INDEX_CHANGES] @START_DATE AS VARCHAR(128),
                                          @START_FLAG VARCHAR(1),
                                          @END_DATE   AS VARCHAR(128),
                                          @END_FLAG   VARCHAR(1)
AS
    SELECT *
    FROM   (SELECT LAST.DATABASE_NAME,
                   LAST.TABLE_NAME,
                   LAST.INDEX_NAME,
                   'INDEX CHANGED' AS DIFFERENCE
            FROM   INDEX_HISTORY LAST
                   INNER JOIN INDEX_HISTORY START
                           ON LAST.SERVER_NAME = START.SERVER_NAME
                              AND LAST.DATABASE_NAME = START.DATABASE_NAME
                              AND LAST.TABLE_NAME = START.TABLE_NAME
                              AND LAST.INDEX_NAME = START.INDEX_NAME
                              AND LAST.INDEX_KEYS <> START.INDEX_KEYS
            WHERE  LAST.DATE = @END_DATE
                   AND LAST.FLAG = @END_FLAG
                   AND START.DATE = @START_DATE
                   AND START.FLAG = @START_FLAG
            UNION
            SELECT START.DATABASE_NAME,
                   START.TABLE_NAME,
                   START.INDEX_NAME,
                   'INDEX DELETED' AS DIFFERENCE
            FROM   INDEX_HISTORY START
            WHERE  NOT EXISTS (SELECT INDEX_NAME
                               FROM   INDEX_HISTORY LAST
                               WHERE  LAST.SERVER_NAME = START.SERVER_NAME
                                      AND LAST.DATABASE_NAME = START.DATABASE_NAME
                                      AND LAST.TABLE_NAME = START.TABLE_NAME
                                      AND LAST.INDEX_NAME = START.INDEX_NAME
                                      AND LAST.DATE = @END_DATE
                                      AND LAST.FLAG = @END_FLAG)
                   AND START.DATE = @START_DATE
                   AND START.FLAG = @START_FLAG
            UNION
            SELECT LAST.DATABASE_NAME,
                   LAST.TABLE_NAME,
                   LAST.INDEX_NAME,
                   'INDEX ADDED' AS DIFFERENCE
            FROM   INDEX_HISTORY LAST
            WHERE  NOT EXISTS (SELECT INDEX_NAME
                               FROM   INDEX_HISTORY START
                               WHERE  LAST.SERVER_NAME = START.SERVER_NAME
                                      AND LAST.DATABASE_NAME = START.DATABASE_NAME
                                      AND LAST.TABLE_NAME = START.TABLE_NAME
                                      AND LAST.INDEX_NAME = START.INDEX_NAME
                                      AND START.DATE = @START_DATE
                                      AND START.FLAG = @START_FLAG)
                   AND LAST.DATE = @END_DATE
                   AND LAST.FLAG = @END_FLAG) AS A
    ORDER  BY A.DATABASE_NAME,
              A.TABLE_NAME 
              

GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;

GO

GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SQL_DATABASE_FILES]...';


GO

ALTER  PROCEDURE DYNPERF_COLLECT_SQL_DATABASE_FILES (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @C_DATABASE_NAME NVARCHAR(128), @ROW_COUNT BIGINT = 0
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDF_SYSDATABASES')
  EXEC ('DROP SYNONYM [dbo].DYN_SDF_SYSDATABASES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES
				FOR [' + @SERVER_NAME + '].master.sys.databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES
				FOR master.sys.databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


-- sys.master_files



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDF_SYSMASTERFILES')
  EXEC ('DROP SYNONYM [dbo].DYN_SDF_SYSMASTERFILES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSMASTERFILES
				FOR [' + @SERVER_NAME + '].master.sys.master_files'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSMASTERFILES 
				FOR master.sys.master_files'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


Create Table #DBFILES
(
    DatabaseName sysname,
    Name sysname,
    physical_name nvarchar(500),
    size decimal (18,2),
    FreeSpace decimal (18,2),
	Initial_size decimal (18,2)
)   


IF @REMOTE_SERVER = 'N'
BEGIN


Exec sp_MSforeachdb '
Use [?];
Insert Into #DBFILES (DatabaseName, Name, physical_name, Size, FreeSpace,Initial_size)
    Select DB_NAME() AS [DatabaseName], Name,  physical_name,
    Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) as nvarchar) Size,
    Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) -
        Cast(FILEPROPERTY(name, ''SpaceUsed'') * 8.0/1024.0 as decimal(18,2)) as nvarchar) As FreeSpace,
		0 as Initial_size
    From sys.database_files
'

--drop table #DBFILES

END


IF @REMOTE_SERVER = 'Y'
		BEGIN


		SET @SQL = 'Exec sp_MSforeachdb ' + ''''+ '
Use [?];

    Select DB_NAME() AS [DatabaseName], Name,  physical_name,
    Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) as nvarchar) Size,
    Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) -
        Cast(FILEPROPERTY(name,' + '''' + ''''+ 'SpaceUsed' +'''' + ''''+ ') * 8.0/1024.0 as decimal(18,2)) as nvarchar) As FreeSpace,
		0 as Initial_size
    From sys.database_files' + ''''


				PRINT @SQL

			SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
						EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']'

			IF @DEBUG = 'Y'
				BEGIN
					PRINT '@SQL= ' + @SQL2
				END

			BEGIN TRY
				INSERT #DBFILES
				EXEC (@SQL2 ) 
			END TRY

			BEGIN CATCH
			--ignore the error
			END CATCH
				 
				 
		END 


		 
--REH  Add initial size of TempDB

UPDATE SDF SET [Initial_size] = MF.size * 8 /1024
FROM #DBFILES SDF  JOIN
(
  SELECT size, physical_name FROM DYN_SDF_SYSMASTERFILES ) AS MF 
  ON MF.physical_name COLLATE DATABASE_DEFAULT = SDF.physical_name COLLATE DATABASE_DEFAULT




DECLARE DB_CURSOR CURSOR  LOCAL
FOR
SELECT name from DYN_SDF_SYSDATABASES


OPEN DB_CURSOR

FETCH NEXT FROM DB_CURSOR INTO @C_DATABASE_NAME

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

--REH  Build the Synonym as we loop through each database

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDF_SYSDATABASES_FILES')
  EXEC ('DROP SYNONYM [dbo].DYN_SDF_SYSDATABASES_FILES')


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES_FILES
				FOR [' + @SERVER_NAME + '].[' + @C_DATABASE_NAME + '].sys.database_files'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES_FILES
				FOR [' + @C_DATABASE_NAME + '].sys.database_files'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 

INSERT INTO [DynamicsPerf]..SQL_DATABASEFILES
SELECT @SERVER_NAME                                                                           AS [RUN_NAME],
       CONVERT(NVARCHAR(50), @STATS_DATE, 121)                                             AS [STATS_TIME],
       @C_DATABASE_NAME,
       [file_id],
       [File Name] COLLATE DATABASE_DEFAULT,
       [Physical Name] COLLATE DATABASE_DEFAULT,
       [File Type],
       [Total Size in Mb],
       [Available Space in Mb],
       CEILING(CAST([Available Space in Mb] AS DECIMAL(10, 1)) / [Total Size in Mb] * 100) AS [Free Space %],
       [Growth Units],
       [max File Size in Mb],
       [DB_INITAL_SIZE(MB)]
FROM   (SELECT [file_id],
               [name]   COLLATE DATABASE_DEFAULT     AS [File Name],
               physical_name COLLATE DATABASE_DEFAULT AS [Physical Name],
               [File Type] = CASE type
                               WHEN 0 THEN 'Data'
                               WHEN 1 THEN 'Log'
                             END,
               [Total Size in Mb] = CASE CEILING([size] / 128)
                                      WHEN 0 THEN 1
                                      ELSE CEILING([size] / 128)
                                    END,
               [Available Space in Mb] = (SELECT FreeSpace FROM #DBFILES TDB WHERE DYN_SDF.physical_name COLLATE DATABASE_DEFAULT = TDB.physical_name COLLATE DATABASE_DEFAULT),
			   
									--CASE CEILING([size] / 128)
         --                                  WHEN 0 THEN ( 1 - CAST(FILEPROPERTY([name], 'SpaceUsed') AS INT) / 128 )
         --                                  ELSE ( ( [size] / 128 ) - CAST(FILEPROPERTY([name], 'SpaceUsed') AS INT) / 128 )
         --                                END,
               [Growth Units] = CASE [is_percent_growth]
                                  WHEN 1 THEN CAST(growth AS VARCHAR(20)) + '%'
                                  ELSE CAST(growth/128 AS VARCHAR(20)) + 'Mb'
                                END,
               [max File Size in Mb] = CASE [max_size]
                                         WHEN -1 THEN NULL
                                         WHEN 268435456 THEN NULL
                                         ELSE [max_size]
                                       END,
				[DB_INITAL_SIZE(MB)] = (SELECT Initial_size FROM #DBFILES TDB WHERE DYN_SDF.physical_name COLLATE DATABASE_DEFAULT = TDB.physical_name COLLATE DATABASE_DEFAULT)
        FROM   DYN_SDF_SYSDATABASES_FILES DYN_SDF) AS RH
ORDER  BY [File Type],
          [file_id] 


SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

FETCH NEXT FROM DB_CURSOR INTO @C_DATABASE_NAME

END  /*End of the loop */
CLOSE DB_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE DB_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 



IF OBJECT_ID('tempdb..#DBFILES') IS NOT NULL
/*Then it exists*/
   DROP TABLE #DBFILES
 


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO


PRINT N'Altering [dbo].[DYNPERF_UPDATE_SSRS_HISTORY]...';
GO



ALTER PROCEDURE [dbo].[DYNPERF_UPDATE_SSRS_HISTORY]
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @ROW_COUNT BIGINT = 0
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH Deal with default instance

IF CHARINDEX(@SERVER_NAME, '\',0) =0
SET @SERVER_NAME = @SERVER_NAME + '\MSSQLSERVER'


/******************************************************************************
NEED TO SUBTRACT OUT PREVIOUS DAYS AMOUNTS IF COMPILE_TIME WAS BEFORE TODAY

SUBTRACT THE LAST QUERY_STATS RECORD FROM PREVIOUS DAY WITH SAME COMPILE_TIME


*******************************************************************************/
--REH This sums up to the totals of the day

MERGE SSRS_HISTORY AS target
		USING (
		SELECT SERVER_NAME,
       REPORTPATH,
       REPORTNAME                                      AS REPORT_NAME,
       MAX(DATEADD(DAY, DATEDIFF(DAY, 0, TIMEEND), 0)) AS REPORT_DATE,
       SUM([TIME_DATARETRIEVAL])                       AS TOTAL_TIME_DATA,
       SUM([TIME_PROCESSING])                          AS TOTAL_TIME_PROCESSING,
       SUM([TIME_RENDERING])                           AS TOTAL_TIME_RENDERING,
       MAX(TIME_DATARETRIEVAL + TIME_PROCESSING
           + TIME_RENDERING)                           AS MAX_REPORT_TIME_MS,
       MIN(TIME_DATARETRIEVAL + TIME_PROCESSING
           + TIME_RENDERING)                           AS MIN_REPORT_TIME_MS,
       COUNT(REPORTPATH)                               AS EXECUTION_COUNT,
       MAX(BYTECOUNT)                                  AS MAX_SIZE_BYTES,
       MAX([ROWCOUNT])                                 AS MAX_ROW_COUNT,
       MAX('D')                                        AS FLAG
FROM   SSRS_EXECUTIONLOG
WHERE SERVER_NAME = @SERVER_NAME AND DATEADD(DAY, DATEDIFF(DAY, 0, TIMEEND), 0) = DATEADD(DAY, DATEDIFF(DAY, 0, @LAST_RUN), 0)
GROUP  BY SERVER_NAME,
DATEADD(DAY, DATEDIFF(DAY, 0, TIMEEND), 0) ,
          REPORTPATH,
          REPORTNAME ) AS source
ON ( source.SERVER_NAME = target.SERVER_NAME
			 AND source.REPORTPATH = target.REPORTPATH
			 AND source.REPORT_NAME = target.REPORT_NAME
			 AND source.REPORT_DATE = target.REPORT_DATE
			 AND source.FLAG = target.FLAG )
		WHEN MATCHED THEN
		 UPDATE SET TOTAL_TIME_DATA = source.TOTAL_TIME_DATA,
					 TOTAL_TIME_PROCESSING = source.TOTAL_TIME_PROCESSING,
					 TOTAL_TIME_RENDERING = source.TOTAL_TIME_RENDERING,
					 MAX_REPORT_TIME_MS = source.MAX_REPORT_TIME_MS,
					 MIN_REPORT_TIME_MS = source.MIN_REPORT_TIME_MS,
					 EXECUTION_COUNT = source.EXECUTION_COUNT,
					 MAX_SIZE_BYTES = source.MAX_SIZE_BYTES,
					 MAX_ROW_COUNT = source.MAX_ROW_COUNT


		WHEN NOT MATCHED THEN
		  INSERT ([SERVER_NAME]
           ,[REPORTPATH]
           ,[REPORT_NAME]
           ,[REPORT_DATE]
           ,[TOTAL_TIME_DATA]
           ,[TOTAL_TIME_PROCESSING]
           ,[TOTAL_TIME_RENDERING]
           ,[MAX_REPORT_TIME_MS]
           ,[MIN_REPORT_TIME_MS]
           ,[EXECUTION_COUNT]
           ,[MAX_SIZE_BYTES]
           ,[MAX_ROW_COUNT]
           ,[FLAG])
		  VALUES (source.[SERVER_NAME]
           ,source.[REPORTPATH]
           ,source.[REPORT_NAME]
           ,source.[REPORT_DATE]
           ,source.[TOTAL_TIME_DATA]
           ,source.[TOTAL_TIME_PROCESSING]
           ,source.[TOTAL_TIME_RENDERING]
           ,source.[MAX_REPORT_TIME_MS]
           ,source.[MIN_REPORT_TIME_MS]
           ,source.[EXECUTION_COUNT]
           ,source.[MAX_SIZE_BYTES]
           ,source.[MAX_ROW_COUNT]
           ,source.[FLAG]);


		   SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

 --REH Rollup the daily total into the Monthly total


MERGE SSRS_HISTORY AS target
		USING (
		SELECT [SERVER_NAME]
           ,[REPORTPATH]
           ,[REPORT_NAME]
           ,DATEADD(MONTH, DATEDIFF(MONTH, 0, REPORT_DATE), 0) AS REPORT_DATE --REH floor the date to the month level
           ,SUM([TOTAL_TIME_DATA]) AS TOTAL_TIME_DATA
           ,SUM([TOTAL_TIME_PROCESSING]) AS TOTAL_TIME_PROCESSING
           ,SUM([TOTAL_TIME_RENDERING]) AS TOTAL_TIME_RENDERING
           ,MAX([MAX_REPORT_TIME_MS]) AS MAX_REPORT_TIME_MS
           ,MIN([MIN_REPORT_TIME_MS]) AS MIN_REPORT_TIME_MS
           ,SUM([EXECUTION_COUNT]) AS EXECUTION_COUNT
           ,MAX([MAX_SIZE_BYTES]) AS MAX_SIZE_BYTES
           ,MAX([MAX_ROW_COUNT]) AS MAX_ROW_COUNT
           ,'M' AS FLAG
FROM   SSRS_HISTORY
WHERE SERVER_NAME = @SERVER_NAME AND FLAG = 'D' -- ONLY sum up the Daily totals into the monthly totals
	AND DATEADD(MONTH, DATEDIFF(MONTH, 0, REPORT_DATE), 0) = DATEADD(MONTH, DATEDIFF(MONTH, 0, @LAST_RUN), 0) 
GROUP  BY SERVER_NAME,
DATEADD(MONTH, DATEDIFF(MONTH, 0, REPORT_DATE), 0) ,
          REPORTPATH,
          REPORT_NAME ) AS source
ON ( source.SERVER_NAME = target.SERVER_NAME
			 AND source.REPORTPATH = target.REPORTPATH
			 AND source.REPORT_NAME = target.REPORT_NAME
			 AND source.REPORT_DATE = target.REPORT_DATE
			 AND source.FLAG = target.FLAG )
		WHEN MATCHED THEN
		 UPDATE SET TOTAL_TIME_DATA = source.TOTAL_TIME_DATA,
					 TOTAL_TIME_PROCESSING = source.TOTAL_TIME_PROCESSING,
					 TOTAL_TIME_RENDERING = source.TOTAL_TIME_RENDERING,
					 MAX_REPORT_TIME_MS = source.MAX_REPORT_TIME_MS,
					 MIN_REPORT_TIME_MS = source.MIN_REPORT_TIME_MS,
					 EXECUTION_COUNT = source.EXECUTION_COUNT,
					 MAX_SIZE_BYTES = source.MAX_SIZE_BYTES,
					 MAX_ROW_COUNT = source.MAX_ROW_COUNT


		WHEN NOT MATCHED THEN
		  INSERT ([SERVER_NAME]
           ,[REPORTPATH]
           ,[REPORT_NAME]
           ,[REPORT_DATE]
           ,[TOTAL_TIME_DATA]
           ,[TOTAL_TIME_PROCESSING]
           ,[TOTAL_TIME_RENDERING]
           ,[MAX_REPORT_TIME_MS]
           ,[MIN_REPORT_TIME_MS]
           ,[EXECUTION_COUNT]
           ,[MAX_SIZE_BYTES]
           ,[MAX_ROW_COUNT]
           ,[FLAG])
		  VALUES (source.[SERVER_NAME]
           ,source.[REPORTPATH]
           ,source.[REPORT_NAME]
           ,source.[REPORT_DATE]
           ,source.[TOTAL_TIME_DATA]
           ,source.[TOTAL_TIME_PROCESSING]
           ,source.[TOTAL_TIME_RENDERING]
           ,source.[MAX_REPORT_TIME_MS]
           ,source.[MIN_REPORT_TIME_MS]
           ,source.[EXECUTION_COUNT]
           ,source.[MAX_SIZE_BYTES]
           ,source.[MAX_ROW_COUNT]
           ,source.[FLAG]);

		   SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH 

GO




PRINT N'Altering [dbo].[DYNPERF_COLLECT_SQL_TEXT]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SQL_TEXT (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



IF @REMOTE_SERVER = 'N'
     BEGIN ;
         WITH Query_Stats_CTE ( QUERY_HASH, PLAN_HANDLE)
              AS (SELECT DISTINCT QUERY_HASH, PLAN_HANDLE
                  FROM   QUERY_STATS QS
                  WHERE  QS.STATS_TIME >= @LAST_RUN
                         AND DATABASE_NAME = @DATABASE_NAME
                         AND SERVER_NAME = @SERVER_NAME 
                         AND NOT EXISTS (SELECT 'X'
                                         FROM   QUERY_TEXT QT
                                         WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                                AND QS.SERVER_NAME = QT.SERVER_NAME ))
         INSERT QUERY_TEXT
         SELECT @SERVER_NAME,
                @DATABASE_NAME,
                QUERY_HASH,
                SQL_TEXT,
				@STATS_DATE
         FROM   (SELECT RN = ROW_NUMBER()
                               OVER (
                                 PARTITION BY CTE.QUERY_HASH
                                 ORDER BY CTE.QUERY_HASH DESC),
                        qs.query_hash                                                                                              AS QUERY_HASH,
                        SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                        WHEN -1 THEN DATALENGTH(st.text)
                                                                                        ELSE qs.statement_end_offset
                                                                                      END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
                 FROM   Query_Stats_CTE CTE
                        INNER JOIN sys.dm_exec_query_stats AS qs
                                ON CTE.QUERY_HASH = qs.query_hash and CTE.PLAN_HANDLE = qs.plan_handle
                        OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                        CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
                 WHERE  attribute = N'dbid'
                        AND DB_NAME(CONVERT(INT, value)) = @DATABASE_NAME
                        AND last_execution_time >= @LAST_RUN
						) AS RH
         WHERE  RN = 1
     END 


 IF @REMOTE_SERVER = 'Y'
 BEGIN
 


				 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)



 SET @SQL = '
CREATE TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH
(
QUERY_HASH VARBINARY(64),
PLAN_HANDLE VARBINARY(64)
)' 



 SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  EXEC ('+'"' + @SQL +'"' + ') AT [' + @SERVER_NAME + ']'
  
 IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END

EXEC (@SQL2)


SET @SQL = '

;WITH Query_Stats_CTE ( QUERY_HASH, PLAN_HANDLE)
     AS (SELECT DISTINCT QUERY_HASH,PLAN_HANDLE
         FROM   QUERY_STATS QS
         WHERE  QS.STATS_TIME >= '  +'''' + CONVERT(NVARCHAR(24), @LAST_RUN, 121) +'''' +  '
                AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + '
                AND SERVER_NAME = ' + '''' + +@SERVER_NAME + '''' + ' 
                AND NOT EXISTS (SELECT ''X''
                                FROM   QUERY_TEXT QT
                                WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                AND QS.SERVER_NAME = QT.SERVER_NAME 
                                ))
INSERT INTO OPENQUERY([' + @SERVER_NAME + '], ''SELECT QUERY_HASH, PLAN_HANDLE FROM  [tempdb].dbo.DYNPERF_QUERY_HASH'')

SELECT QUERY_HASH, PLAN_HANDLE
FROM   (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_HASH, CTE.PLAN_HANDLE
                        ORDER BY CTE.QUERY_HASH ,  CTE.PLAN_HANDLE DESC),
               QUERY_HASH,
			   PLAN_HANDLE
            
            FROM   Query_Stats_CTE CTE
           ) AS RH
WHERE  RN = 1 '

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


EXEC (@SQL)


        
 SET @SQL = '
         SELECT QUERY_HASH, SQL_TEXT
         FROM (
         SELECT RN = ROW_NUMBER() OVER (PARTITION BY CTE.QUERY_HASH ORDER BY CTE.QUERY_HASH DESC),
          qs.query_hash AS QUERY_HASH,
                         SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                         WHEN -1 THEN DATALENGTH(st.text)
                                                                                         ELSE qs.statement_end_offset
                                                                                       END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
         FROM    [tempdb].dbo.DYNPERF_QUERY_HASH CTE
                INNER JOIN sys.dm_exec_query_stats AS qs
                        ON CTE.QUERY_HASH = qs.query_hash AND CTE.PLAN_HANDLE = qs.plan_handle
                OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
         WHERE  attribute = N''dbid''
                AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
				AND last_execution_time >= ' +'''' + CONVERT(NVARCHAR(24), @LAST_RUN, 121) +'''' + '
                ) AS RH  
                WHERE RN = 1 '
PRINT ''
PRINT ''
                  
IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  INSERT INTO DynamicsPerf.dbo.QUERY_TEXT
				 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + '''' + @DATABASE_NAME + '''' + ',
                    
                    RH.*, ' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + ' FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END
				 
				 EXECUTE (@SQL2)
				 
 --REH  Delete the table back out
 
 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

 
 END
 
    

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_SERVER_ACTIVITY]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_SERVER_ACTIVITY]
	(@SERVER_NAME NVARCHAR(128) = @@SERVERNAME)

AS

SET QUOTED_IDENTIFIER OFF
DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
 


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SERVER_ACTIVITY]') AND type in (N'U'))
DROP TABLE [dbo].[SERVER_ACTIVITY]



      
 SET @SQL = '
SELECT r.session_id                                     AS SPID,
       r.blocking_session_id                            AS BLOCKED_BY_SPID,
       se.host_name                                     AS HOSTNAME,
       se.login_name                                    AS LOGIN_NAME,
       DB_NAME(r.database_id)                           AS DATABASE_NAME,
       r.status                                         AS STATUS,
       r.command                                        AS COMMAND,
       r.cpu_time                                       AS CPU_TIME,
       r.total_elapsed_time                             AS TOTAL_ELAPSED_TIME,
       r.reads                                          AS READS,
       r.logical_reads                                  AS LOGICAL_READS,
       r.writes                                         AS WRITES,
       r.context_info                                   AS AX_SESSION_ID,
       r.context_info                                   AS AX_USER_ID,
       CAST(r.context_info AS VARCHAR(128))             AS CONTEXT_INFO,
       s.text                                           AS SQL_TEXT,
       CAST(p.query_plan AS NVARCHAR(MAX))              AS QUERY_PLAN,
       SQL_CURSORSQL.text                               AS CURSOR_SQL_TEXT,
       CAST(SQL_CURSORPLAN.query_plan AS NVARCHAR(MAX)) AS CURSOR_QUERY_PLAN,
       BLOCKING_DATA.ctext                              AS BLOCKING_TEXT,
       BLOCKING_DATA.BLOCKING_CONTEXT                   AS BLOCKING_CONTEXT,
       BLOCKING_DATA.BLOCKING_QUERY_PLAN                AS BLOCKING_QUERY_PLAN,
       BLOCKING_DATA.BLOCKING_CURSOR_PLAN               AS BLOCKING_CURSOR_PLAN,
       r.wait_time                                      AS WAIT_TIME,
       r.wait_type                                      AS WAIT_TYPE,
       r.open_transaction_count                         AS OPEN_TRANS_COUNT,
       r.estimated_completion_time                      AS ESTIMATED_COMPLETION_TIME,
       TSU.TEMPDBUSEROBJECTSALLOCATED                   AS TEMPDB_USER_OBJECTS_ALLOCATED,
       TSU.TEMPDBUSEROBJECTSDEALLOCATED                 AS TEMPDB_USER_OBJECTS_DEALLOCATED,
       TSU.TEMPDBINTERNALOBJECTSALLOCATED               AS TEMPDB_INTERNAL_OBJECTS_ALLOCATED,
       TSU.TEMPDBINTERNALOBJECTSDEALLOCATED             AS TEMPDB_INTERNAL_OBJECTS_DEALLOCATED'
         
         
SELECT @SQL = @SQL + '

FROM   sys.dm_exec_requests AS r
       INNER JOIN sys.dm_exec_sessions AS se
               ON r.session_id = se.session_id
       OUTER APPLY sys.DM_EXEC_SQL_TEXT(r.sql_handle) AS s
       OUTER APPLY sys.DM_EXEC_QUERY_PLAN(r.plan_handle) AS p
       OUTER APPLY sys.DM_EXEC_CURSORS(r.session_id) AS SQL_CURSORS
       OUTER APPLY sys.DM_EXEC_SQL_TEXT(SQL_CURSORS.sql_handle) AS SQL_CURSORSQL
       LEFT JOIN sys.dm_exec_query_stats AS SQL_CURSORSTATS
              ON SQL_CURSORSTATS.sql_handle = SQL_CURSORS.sql_handle
       OUTER APPLY sys.DM_EXEC_QUERY_PLAN(SQL_CURSORSTATS.plan_handle) AS SQL_CURSORPLAN
       OUTER APPLY (SELECT r.session_id,
                           CAST(r_blk.context_info AS VARCHAR(128))         AS BLOCKING_CONTEXT,
                           s.text,
                           SQL_CURSORSQL.text                               AS CTEXT,
                           CAST(SQL_CURSORPLAN.query_plan AS NVARCHAR(MAX)) AS BLOCKING_CURSOR_PLAN,
                           CAST(p.query_plan AS NVARCHAR(MAX))              AS BLOCKING_QUERY_PLAN
                    FROM   sys.dm_exec_requests AS r_blk
                           INNER JOIN sys.dm_exec_sessions AS se
                                   ON r.session_id = se.session_id
                           OUTER APPLY sys.DM_EXEC_SQL_TEXT(r.sql_handle) AS s
                           OUTER APPLY sys.DM_EXEC_QUERY_PLAN(r.plan_handle) AS p
                           OUTER APPLY sys.DM_EXEC_CURSORS(r.session_id) AS SQL_CURSORS
                           OUTER APPLY sys.DM_EXEC_SQL_TEXT(SQL_CURSORS.sql_handle) AS SQL_CURSORSQL
                           LEFT JOIN sys.dm_exec_query_stats AS SQL_CURSORSTATS
                                  ON SQL_CURSORSTATS.sql_handle = SQL_CURSORS.sql_handle
                           OUTER APPLY sys.DM_EXEC_QUERY_PLAN(SQL_CURSORSTATS.plan_handle) AS SQL_CURSORPLAN
                    WHERE  r_blk.session_id = r.blocking_session_id) AS BLOCKING_DATA
       LEFT JOIN (SELECT SESSIONID = session_id,
                         REQUESTID = request_id,
                         TEMPDBUSEROBJECTSALLOCATED = SUM (user_objects_alloc_page_count),
                         TEMPDBUSEROBJECTSDEALLOCATED = SUM(user_objects_dealloc_page_count),
                         TEMPDBINTERNALOBJECTSALLOCATED = SUM (internal_objects_alloc_page_count),
                         TEMPDBINTERNALOBJECTSDEALLOCATED = SUM (internal_objects_dealloc_page_count)
                  FROM   sys.dm_db_task_space_usage
                  GROUP  BY session_id,
                            request_id) AS TSU
              ON TSU.SESSIONID = r.session_id
                 AND TSU.REQUESTID = r.request_id
WHERE  r.session_Id > 50 AND r.session_id <> @@SPID
       AND se.host_name IS NOT NULL 			   
				   
				   '
                    

IF @SERVER_NAME <> @@SERVERNAME
BEGIN

                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF

				 SELECT RH.*
                    INTO SERVER_ACTIVITY
                     FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '


				 
				 EXECUTE (@SQL2)
END
ELSE
BEGIN

		SET @SQL2 = '
		SELECT RH.*
			INTO SERVER_ACTIVITY
				FROM (' +@SQL + ') RH'
		
	PRINT @SQL2
				EXECUTE (@SQL2)
END
SELECT [SPID],
       [BLOCKED_BY_SPID],
       [HOSTNAME],
       [LOGIN_NAME],
       [DATABASE_NAME],
       [STATUS],
       [COMMAND],
       [CPU_TIME],
       [TOTAL_ELAPSED_TIME],
       [READS],
       [LOGICAL_READS],
       [WRITES],
       dbo.FN_RETURN_AXSESSION_FROM_CONTEXT([AX_SESSION_ID]) AS AX_SESSION_ID,
       dbo.FN_RETURN_AXID_FROM_CONTEXT([AX_USER_ID])         AS AX_USER_ID,
       [CONTEXT_INFO],
       [SQL_TEXT],
       Cast([QUERY_PLAN] AS XML)                             AS QUERY_PLAN,
       [CURSOR_SQL_TEXT],
       Cast([CURSOR_QUERY_PLAN] AS XML)                      AS CURSOR_QUERY_PLAN,
       BLOCKING_TEXT,
       BLOCKING_CONTEXT,
       BLOCKING_QUERY_PLAN,
       BLOCKING_CURSOR_PLAN,
       [WAIT_TIME],
       [WAIT_TYPE],
       [OPEN_TRANS_COUNT],
       [ESTIMATED_COMPLETION_TIME],
       [TEMPDB_USER_OBJECTS_ALLOCATED],
       [TEMPDB_USER_OBJECTS_DEALLOCATED],
       [TEMPDB_INTERNAL_OBJECTS_ALLOCATED],
       [TEMPDB_INTERNAL_OBJECTS_DEALLOCATED]
FROM   [dbo].[SERVER_ACTIVITY]
ORDER  BY [TOTAL_ELAPSED_TIME] DESC 


DROP TABLE SERVER_ACTIVITY
GO
PRINT N'Altering [dbo].[SET_AX_SQLTRACE]...';


GO


ALTER PROCEDURE [dbo].[SET_AX_SQLTRACE] @SERVER_NAME NVARCHAR(128) = @@SERVERNAME,
								@DATABASE_NAME    NVARCHAR(128),
                                 @QUERY_TIME_LIMIT INT = 5000,
                                 @AX_ID            NVARCHAR(10) = NULL,
                                 @TRACE_STATUS     NVARCHAR(3) = 'ON', 
                               --  @CLIENTACESSLOG   INT = 0,
								 @OVERRIDE		INT = 0
AS

  DECLARE @SQL NVARCHAR(1000),
          @RC  INT

  SET @RC = 0



         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_AXT_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_AXT_SYSDATABASES')

         IF @SERVER_NAME <> @@SERVERNAME
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_AXT_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_AXT_SYSDATABASES
				FOR master.sys.databases'


         EXEC (@SQL) -- CREATE SYNONYM

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_AXT_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

IF @OVERRIDE = 0 AND @QUERY_TIME_LIMIT < 5000 SET @QUERY_TIME_LIMIT = 5000

  IF @TRACE_STATUS = 'ON'
    BEGIN
        
          SET @SQL = 'UPDATE [' +@SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO
				SET QUERYTIMELIMIT = ' + Str(@QUERY_TIME_LIMIT) + ',
					DEBUGINFO =  268,
					TRACEINFO =  2048'
			IF @AX_ID IS NOT NULL	
			SET @SQL = @SQL + 	' WHERE ID = ''' + @AX_ID + ''''	
			

				MERGE AX_SQLTRACE_CONFIG AS target
				USING (SELECT @SERVER_NAME AS SERVER_NAME,
							  @DATABASE_NAME AS DATABASE_NAME,
							  @QUERY_TIME_LIMIT AS SQL_DURATION,
							  1                 AS TRACE_ON,		--REH Turns it ON
							  14 AS AXDB_DELETION_DAYS
) AS source
				ON ( source.SERVER_NAME = target.SERVER_NAME
					 AND source.DATABASE_NAME = target.DATABASE_NAME )
				WHEN MATCHED THEN
				  UPDATE SET SQL_DURATION = source.SQL_DURATION,
							 TRACE_ON = source.TRACE_ON
				WHEN NOT MATCHED THEN
				  INSERT ( [SERVER_NAME],
						   [DATABASE_NAME],
						   [SQL_DURATION],
						   [TRACE_ON],
						   [AXDB_DELETION_DAYS])
				  VALUES (source.[SERVER_NAME],
						  source.[DATABASE_NAME],
						  source.[SQL_DURATION],
						  source.[TRACE_ON],
						  14);		--REH default 14 days, DYNPERF_SET_AX_SQLTRACE sproc will delete from systracetable in the AX database using this value
									-- setting it to 0 disables this feature
			
			END
  ELSE
    IF @TRACE_STATUS = 'OFF'
      BEGIN
          IF @AX_ID IS NULL
            SET @SQL = 'UPDATE [' +@SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO
				SET QUERYTIMELIMIT = 0,
					DEBUGINFO =  12,
					TRACEINFO =  0'
					
			IF @AX_ID IS NOT NULL	
			SET @SQL = @SQL + 	' WHERE ID = ''' + @AX_ID + ''''	

        	--REH Insert a record so that our scheduled job auto updates it
MERGE AX_SQLTRACE_CONFIG AS target
				USING (SELECT @SERVER_NAME AS SERVER_NAME,
							  @DATABASE_NAME AS DATABASE_NAME,
							  @QUERY_TIME_LIMIT AS SQL_DURATION,
							  0                 AS TRACE_ON,		--REH Turns it OFF
							  14 AS AXDB_DELETION_DAYS
					  ) AS source
				ON ( source.SERVER_NAME = target.SERVER_NAME
					 AND source.DATABASE_NAME = target.DATABASE_NAME )
				WHEN MATCHED THEN
				  UPDATE SET SQL_DURATION = source.SQL_DURATION,
							 TRACE_ON = source.TRACE_ON
				WHEN NOT MATCHED THEN
				  INSERT ( [SERVER_NAME],
						   [DATABASE_NAME],
						   [SQL_DURATION],
						   [TRACE_ON],
						   [AXDB_DELETION_DAYS])
				  VALUES (source.[SERVER_NAME],
						  source.[DATABASE_NAME],
						  source.[SQL_DURATION],
						  source.[TRACE_ON],
						  14); --REH default 14 days, DYNPERF_SET_AX_SQLTRACE sproc will delete from systracetable in the AX database using this value
								-- setting it to 0 disables this feature
      END
    ELSE
      PRINT 'Invalid @TRACE_STATUS option; must be ON or OFF'

  PRINT @SQL
  EXEC (@SQL)
 

 
  ENDPROC:

  ERROR:

  RETURN @RC
GO
PRINT N'Altering [dbo].[SP_CAPTURESTATS]...';


GO



ALTER	PROCEDURE [dbo].[SP_CAPTURESTATS]
		@SERVER_NAME	NVARCHAR(128) = NULL,
		@DATABASE_NAME	NVARCHAR(128) = NULL ,
		@DYNAMICS_PRODUCT NVARCHAR(3)  = NULL,
		@TASK_TYPE		VARCHAR(50) = 'COLLECT',
		@AZURE_DB		BIT = 0,
		@TOP_ROWS		INT = 0,
		@TOP_COLUMN		NVARCHAR(128) = 'total_elapsed_time',
		@RUN_NAME		NVARCHAR(128) = NULL,
		@INDEX_PHYSICAL_STATS 	NCHAR(1)= 'N',
		@DEBUG			NVARCHAR(1)= 'N'

AS


SET NOCOUNT ON
SET DATEFORMAT MDY

SET ANSI_NULLS ON
SET ANSI_WARNINGS ON
SET ANSI_NULL_DFLT_ON ON
SET ANSI_PADDING ON


DECLARE @STATS_DATE		DATETIME, 
		@SQL_VERSION	NVARCHAR(1000), 
		@DYNAMICS_VERSION NVARCHAR(MAX),
		@DATABASE_ID	INT,
		@RETURN_CODE	INT,
		@SQL			NVARCHAR(MAX),
		@RUN_DESCRIPTION NVARCHAR(1000),
		@SQL_TOP_CLAUSE	NVARCHAR(128),
		@SQL_ORDERBY_CLAUSE	NVARCHAR(128),
		@PARM			NVARCHAR(500),
		@SQL_SERVER_STARTTIME DATETIME,
		@RC INT,
		@TASK_PROCEDURE NVARCHAR(128),
		@TASK_PARAMETERS NVARCHAR(1024),
		@TASK_DESCRIPTION NVARCHAR(256),
		@LAST_SERVER_NAME NVARCHAR(128) = 'ZZZ',  --REH This is used to trigger inserting a new STATS_COLLECTION_SUMMARY record
		@LAST_DATABASE_NAME NVARCHAR(128) = 'ZZZ',
		@LAST_STATS_DATE DATETIME,
		@REMOTE_SERVER NVARCHAR(1) = 'N',
		@TASK_STARTTIME DATETIME,
		@TASK_ENDTIME DATETIME,
		@TASK_TIME BIGINT,
		@SQL_STARTTIME DATETIME,
		@SQL_BUILD NVARCHAR(20),
		@SQL2 NVARCHAR(MAX),
		@MANUAL_CAPTURE NVARCHAR(1) = 'N',
		@SQL_TZ_OFFSET INT,
		@DPA_TZ_OFFSET INT 

		
		
DECLARE
	@C_SERVER_NAME NVARCHAR(128),
	@C_DATABASE_NAME NVARCHAR(128),
	@C_TASK_ID INT,
	@C_TASK_PROCEDURE NVARCHAR(128),
	@C_TASK_PARAMS NVARCHAR(1024),
	@C_TASK_DESC NVARCHAR(256),
	@C_SERVER_LEVEL_TASK BIT,
	@C_AZURE_DB  BIT,
	@C_LAST_RUN DATETIME
	
		
--REH Time zone off set for the DynamicsPerf database at time of collection
		SET @DPA_TZ_OFFSET = DATEDIFF(MI,GETUTCDATE(),GETDATE())

	IF @DATABASE_NAME IS NOT NULL SET @MANUAL_CAPTURE = 'Y'

	SET @STATS_DATE = GETDATE()
--REH  Verify database exists if being manually passed, skip check if Azure DB, no access to sys.databases catalogue

IF ( @AZURE_DB = 0 and ( @SERVER_NAME IS NOT NULL
      OR @DATABASE_NAME IS NOT NULL ))
     BEGIN

	 
	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_CS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_CS_QUERY_SYSDATABASES')

         IF @REMOTE_SERVER = 'Y'
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_CS_QUERY_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_CS_QUERY_SYSDATABASES
				FOR master.sys.databases'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END

         EXEC (@SQL) -- SELECT * FROM DYN_CS_QUERY_SYSDATABASES

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_CS_QUERY_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

         --REH Make sure there is a record in DATABASES_2_COLLECT or insert if new combination
         IF (SELECT COUNT(*)
             FROM   DATABASES_2_COLLECT
             WHERE  LINKED_SERVER = ISNULL(@SERVER_NAME, @@SERVERNAME)
                    AND DATABASE_NAME = @DATABASE_NAME) < 1
              BEGIN
                  INSERT DATABASES_2_COLLECT
                  VALUES(ISNULL(@SERVER_NAME,@@SERVERNAME),
                         @DATABASE_NAME,
                         ISNULL(@DYNAMICS_PRODUCT, 'ALL'),
                         1,
                         2,
                         24,
						 60,
						 2,
						 90,
						 7)
              END
     END 


	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END



---------------------------------------------------------------------------------------------
--
--  Insert Capture_log entry with paramater values used for the run
--
----------------------------------------------------------------------------------------------

INSERT CAPTURE_LOG  SELECT @TASK_TYPE, @STATS_DATE, 'SP_CAPTURESTATS PARMS PASSED @SERVER_NAME = ' + ISNULL(@SERVER_NAME,'NOT PASSED') + ' @DATABASE_NAME = ' + ISNULL(@DATABASE_NAME,'NOT PASSED') +  ' @DEBUG = ' + @DEBUG + '  ' + CHAR(10) + CHAR(13)



SET @RETURN_CODE = 0

DELETE FROM  COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH Default is 'COLLECT' for this sproc.  CAN'T TRUNCATE MULTIPLE SPROCS USING THIS TABLE



IF @DATABASE_NAME IS NULL  --REH AKA, not a manual capture
  BEGIN
      INSERT COLLECTIONDATABASES
      SELECT ISNULL(LINKED_SERVER, @@SERVERNAME),
             [DATABASE_NAME],
             [DYNAMICS_PRODUCT],
             [AZURE_DB],
             [ENABLED],
			 @TASK_TYPE
      FROM   DATABASES_2_COLLECT
      WHERE  ENABLED = 1 -- db must be enabled for autostats collection to work with it
  END
ELSE
  BEGIN   --REH  Insert DBname of the manual capture
      INSERT COLLECTIONDATABASES
      VALUES(ISNULL(@SERVER_NAME, @@SERVERNAME),
             @DATABASE_NAME,
             @DYNAMICS_PRODUCT,
             @AZURE_DB,
             1,
			 @TASK_TYPE)
  END 


--REH Insert any missing task history records in case it's a new database being collected, so we don't fail to capture against the db because of no records
-- yes, this is a cartesian join between these 2 tables

INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE	--REH default is 'COLLECT' in parm definition of this sproc
       AND NOT EXISTS (SELECT 'X'
                       FROM   DYNPERF_TASK_HISTORY DTH
                       WHERE  DTS.TASK_ID = DTH.TASK_ID
                              AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                              AND CD.DATABASE_NAME = DTH.DATABASE_NAME)
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 0 --REH Ok, to put 1 record per database in for DB type tasks


	   
--REH Need to insert 1 bogus record for each server level task, or the join on the cursor will fail

INSERT COLLECTIONDATABASES 
 SELECT	DISTINCT [LINKED_SERVER],
             'N/A',
            'ALL',
             [AZURE_DB],
             [ENABLED],
			 [TASK_TYPE]
FROM COLLECTIONDATABASES CD
WHERE DATABASE_NAME <> 'N/A'
AND TASK_TYPE = @TASK_TYPE
AND NOT EXISTS (SELECT 'X' FROM COLLECTIONDATABASES CD2 WHERE CD2.LINKED_SERVER = CD.LINKED_SERVER AND CD2.DATABASE_NAME = 'N/A')



--REH now lets insert server level tasks with a blank DB name so we only do them once per server
INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       'N/A',
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE  --REH default is 'COLLECT' in parm definition of this sproc
		AND CD.DATABASE_NAME <> 'N/A'
       AND NOT EXISTS (SELECT 'X'
                   FROM   DYNPERF_TASK_HISTORY DTH
                   WHERE  DTS.TASK_ID = DTH.TASK_ID
                          AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                          AND DTH.DATABASE_NAME = 'N/A') --REH making the db name = 'N/A' for server level tasks
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 1 






	IF @DEBUG = 'Y'
	BEGIN
		PRINT 'MANUAL_CAPTURE = ' + @MANUAL_CAPTURE
	END

	--REH Create here and truncate table in each loop

	 --  CREATE TABLE #SQL_INFO
  --   (
  --      SQL_STARTTIME DATETIME,
  --      SQL_BUILD NVARCHAR(20),
		--TZ_OFFSET INT
  --   )


/********************************************************************************
Rod Hansen

Added a trigger to DATABASES_2_COLLECT so that we always have a 
DYNPERF_TASK_HISTORY record for this code 

********************************************************************************/

DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT DISTINCT DTS.TASK_ID,
       CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_PROCEDURE,
       DTS.TASK_PARAMETERS,
       DTS.TASK_DESCRIPTION,
       DTS.SERVER_LEVEL_TASK,
       CD.AZURE_DB,
       ISNULL(DTH.LAST_RUN, '1/1/1900')
FROM   DynamicsPerf..[DYNPERF_TASK_SCHEDULER] DTS
       LEFT OUTER JOIN DynamicsPerf..[DYNPERF_TASK_HISTORY] DTH
                    ON DTH.TASK_ID = DTS.TASK_ID
       INNER JOIN DynamicsPerf..COLLECTIONDATABASES CD
               ON CD.DATABASE_NAME = DTH.DATABASE_NAME
                  AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
WHERE
  --REH Task is enabled
  DTS.ENABLED = 1
  AND
  --REH It's the correct task type C = COLLECTOR, P = PROCESS, M = MONITOR, ETC
  DTS.TASK_TYPE = @TASK_TYPE
  AND
  --REH database is enabled
  CD.ENABLED = 1
  AND
  --REH Azure_db, if Azure db, then task must support it
  ( CD.AZURE_DB = DTS.AZURE_DB_SUPPORTED
     OR CD.AZURE_DB = 0 )
  --REH Either its an Azure Task, all Azure tasks will run locally, so if task supports AZ and we pass 0, run it anyways
  AND ( DTS.AZURE_DB_SUPPORTED = @AZURE_DB
         OR ( DTS.AZURE_DB_SUPPORTED = 1
              AND @AZURE_DB = 0 ) )
  AND
  --REH it's either All products or matches the Dynamics Product
  ( DTS.DYNAMICS_PRODUCT = 'ALL'
     OR DTS.DYNAMICS_PRODUCT = CD.DYNAMICS_PRODUCT )
  AND
  --REH Scheduling options now
(
  --REH In the case of minutes or hous, we ignore schedule time and just figure out if it's time to run again
  ( @MANUAL_CAPTURE = 'Y'
     OR ( @MANUAL_CAPTURE = 'N'
          AND ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                  WHEN 'MI' THEN DATEADD(MINUTE, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                END ) <= GETDATE()
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'HH' THEN DATEADD(HOUR, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                --REH and it is on the hour
                AND ( ABS(DATEDIFF(MI, DATEADD(Hour, DATEDIFF(Hour, 0, GETDATE()), 0), GETDATE())) <= 1 ) )
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'DD' THEN DATEADD(DAY, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'WK' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'MM' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'QQ' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'YY' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                AND ( --REH TIME IS NULL SO IGNORE IT
                    COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) IS NULL
                     OR --REH Current time = Scheduled time 
                    ( SUBSTRING((SELECT REPLACE(CONVERT(VARCHAR(10), GETDATE(), 108), ':', '')), 1, 4) = (SELECT REPLICATE('0', 4 - LEN( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME)))
                                                                                                                 + CAST( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) AS VARCHAR(4))) ) ) )
         --REH and last_run < current time
         )--AND CONVERT(VARCHAR(10), LAST_RUN, 108) <= CONVERT(VARCHAR(10), Getdate(), 108) ) 
   )
)
ORDER  BY CD.LINKED_SERVER,
          CD.DATABASE_NAME,
          DTS.TASK_ID 



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */


	          SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


--Insert new STATS_COLLECTION_SUMMARY RECORD, we want 1 RUN_NAME per server not per database
IF @C_SERVER_NAME <> @LAST_SERVER_NAME OR @C_DATABASE_NAME <> @LAST_DATABASE_NAME
BEGIN
    SET @RUN_NAME = ISNULL(@C_SERVER_NAME, @@SERVERNAME)+ ' '
                    + CAST(@STATS_DATE AS VARCHAR(30))

TRUNCATE TABLE WRK_CS_SQL_INFO   --REH clear out table to repopulate

 DELETE FROM COLLECTIONDATABASES WHERE LINKED_SERVER = @LAST_SERVER_NAME AND DATABASE_NAME = @LAST_DATABASE_NAME AND TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE


 
SELECT @SQL = 'SELECT create_date AS SQL_STARTTIME,
       CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))    AS SQL_BUILD,
	   DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
		FROM sys.databases WHERE name = ''TempDB'''

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


   
   SET NOCOUNT ON
 
IF @REMOTE_SERVER = 'N'
BEGIN
		   INSERT WRK_CS_SQL_INFO
		EXEC( @SQL)
END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
			IF @C_AZURE_DB = 0
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT create_date AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROM sys.databases WHERE name = ''TempDB''"	)'
			END
			IF @C_AZURE_DB = 1
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT DATEADD(ms,AVG(-wait_time_ms), GETDATE()) AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROMsys.dm_os_wait_stats w WHEREwait_type
IN(''DIRTY_PAGE_POLL'',''HADR_FILESTREAM_IOMGR_IOCOMPLETION'',''LAZYWRITER_SLEEP'',''LOGMGR_QUEUE'',''REQUEST_FOR_DEADLOCK_SEARCH'',''XE_DISPATCHER_WAIT'',''XE_TIMER_EVENT'') "	)'
			END


				IF @DEBUG = 'Y'
                  BEGIN
                      PRINT '@SQL= ' + @SQL2
                  END 
                
			INSERT WRK_CS_SQL_INFO
				EXEC (@SQL2) 
 
 END
 
 SELECT @SQL_STARTTIME = SQL_STARTTIME, @SQL_BUILD = SQL_BUILD, @SQL_TZ_OFFSET = TZ_OFFSET FROM WRK_CS_SQL_INFO
 TRUNCATE TABLE WRK_CS_SQL_INFO --REH Cleanout the table for next loop





		INSERT INTO [DynamicsPerf].[dbo].[STATS_COLLECTION_SUMMARY]
					([SERVER_NAME],
					 [STATS_TIME],
					 [RUN_NAME],
					 [DATABASE_NAME],
					 [SQL_VERSION],
					 [DYNAMICS_VERSION],
					 [RUN_DESCRIPTION],
					 [SQL_SERVER_STARTTIME],
					 [SQL_SERVER_TZ_OFFSET] ,
					 [DPA_TZ_OFFSET])
		VALUES      (@C_SERVER_NAME,
					 @STATS_DATE,
					 @RUN_NAME,
					 @C_DATABASE_NAME,
					 @SQL_BUILD,--<SQL_VERSION>
					 '',--<DYNAMICS_VERSION>
					 '',--<RUN_DESCRIPTION>
					 @SQL_STARTTIME, -- <SQL_SERVER_STARTTIME>
					 @SQL_TZ_OFFSET,  -- Time Zone offset in minutes of database collected
					 @DPA_TZ_OFFSET  -- Time Zone of the DynamicsPerf database
					) 
				
END 

SET @LAST_SERVER_NAME = @C_SERVER_NAME
SET @LAST_DATABASE_NAME = @C_DATABASE_NAME


SET @REMOTE_SERVER = CASE @C_SERVER_NAME
                       WHEN @@SERVERNAME THEN 'N'
                       ELSE 'Y'
                     END 



--Create synonyms for the sproc

--IF  EXISTS (SELECT * FROM sys.synonyms WHERE name = 'DYN_CS_CAPTURE_SPROC')
--DROP SYNONYM [dbo].[DYN_CS_CAPTURE_SPROC]
--SET @SQL = '
--CREATE SYNONYM DYN_CS_CAPTURE_SPROC
--FOR [DynamicsPerf].dbo.[' + @C_TASK_PROCEDURE + ']'

--IF @DEBUG = 'Y' 
--BEGIN
--PRINT '@SQL= ' + @SQL
--END

--EXEC(@SQL) 

IF @DEBUG = 'Y' 
BEGIN
PRINT 'TASK ID = ' + CAST(@C_TASK_ID AS VARCHAR(10))
PRINT 'SERVER NAME = ' + @C_SERVER_NAME 
PRINT 'DATABASE NAME = ' + @C_DATABASE_NAME
PRINT 'TASK PARMS = ' + ISNULL(@C_TASK_PARAMS, '')
PRINT 'TASK DESC = ' + ISNULL(@C_TASK_DESC,'')
PRINT 'LAST RUN = ' + ISNULL(CAST(@C_LAST_RUN AS VARCHAR(30)),'')
PRINT 'RUN NAME = ' + ISNULL(@RUN_NAME,'')
PRINT 'STATS DATE = ' + CAST(@STATS_DATE AS VARCHAR(30))
PRINT 'REMNOTE SERVER FLAG = ' + ISNULL(@REMOTE_SERVER,'')
PRINT 'AZURE DB = ' + CAST(@C_AZURE_DB AS CHAR(1))


END
			
	

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@C_TASK_DESC, '') + CONVERT(VARCHAR, GETDATE(), 109)
PRINT ''


SET @TASK_STARTTIME = GETDATE()
SET @C_TASK_PARAMS = ISNULL(@C_TASK_PARAMS,'')


IF @DEBUG = 'Y'
BEGIN

	PRINT 'SERVER TIME ZONE OFFSET = ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
	PRINT 'AT LAST RUN  = ' + CAST(@C_LAST_RUN AS VARCHAR(30))

END

--REH Adjust the last_run time to UTC Time, the called sproc's will adjust it to local time unless we've never collected
IF @C_LAST_RUN > '1/1/1901'
BEGIN
SET @C_LAST_RUN = DATEADD(MI,@DPA_TZ_OFFSET *-1 ,@C_LAST_RUN)
END



IF @DEBUG = 'Y'
BEGIN
	PRINT 'AT LAST RUN TIME BEING PASSED TO SPROC ' + CAST(@C_LAST_RUN AS VARCHAR(30))
END

SELECT @SQL = 'EXEC ' + @C_TASK_PROCEDURE + '  @TASK_ID=' + CAST(@C_TASK_ID AS NVARCHAR(10)) + 
' ,@SERVER_NAME = ' + '''' +  @C_SERVER_NAME + '''' +
' ,@DATABASE_NAME = ' + '''' +  @C_DATABASE_NAME + '''' +
' ,@TASK_PARAMS = ' +  '''' +  @C_TASK_PARAMS + '''' +
' ,@TASK_DESC = ' + '''' +  @C_TASK_DESC + '''' +
' ,@LAST_RUN = ' + '''' + CONVERT(VARCHAR, @C_LAST_RUN, 109) + '''' +
' ,@RUN_NAME = ' + '''' +  @RUN_NAME + '''' +
' ,@STATS_DATE = ' + '''' + CONVERT(VARCHAR, @STATS_DATE, 109) + '''' +
' ,@REMOTE_SERVER = ' + '''' +  @REMOTE_SERVER + '''' +
' ,@AZURE_DB = ' + CAST(@C_AZURE_DB AS NVARCHAR(10)) + 
' ,@SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET AS NVARCHAR(10)) + 
' ,@DPA_TZ_OFFSET = ' + CAST(@DPA_TZ_OFFSET AS NVARCHAR(10)) + 


' ,@DEBUG = '  + '''' +  @DEBUG + ''''



UPDATE CAPTURE_LOG
SET    TEXT = TEXT  + CHAR(13) + CHAR(10) + '***** ' + @C_TASK_PROCEDURE
			+ CHAR(13) + CHAR(10)
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE



EXECUTE @RC = sp_executesql @SQL

   					  
SET @TASK_ENDTIME = GETDATE()

SET @TASK_TIME = DATEDIFF(ss,@TASK_STARTTIME, @TASK_ENDTIME)

  
--REH update last  [DYNPERF_TASK_HISTORY] IF THE TASK WAS SUCCESSFUL


  
 IF @RC = 0
      BEGIN
          PRINT ''
 
          PRINT 'SUCCESSFULLY CAPTURED '
                + ISNULL(@C_TASK_DESC, '') +  ' for SERVER '
              + ISNULL(@C_SERVER_NAME, '') + ' on database '
              + ISNULL(@C_DATABASE_NAME, '') + ' in ' + cast(@TASK_TIME AS VARCHAR(20)) + ' SECONDS '
 
       --REH if a manual capture don't update last run so we don't mess up the scheduling engine
				 IF @MANUAL_CAPTURE = 'N'
				 BEGIN
						  MERGE DynamicsPerf..[DYNPERF_TASK_HISTORY] AS target
						  USING (SELECT @C_SERVER_NAME   AS SERVER_NAME,
										@C_DATABASE_NAME AS DATABASE_NAME,
										@C_TASK_ID       AS TASK_ID,
										@STATS_DATE      AS LAST_RUN,
										@TASK_TIME	AS LAST_EXECUTION_TIME_SECS 
												) AS source
						  ON ( source.SERVER_NAME = target.LINKEDSERVER_NAME
							   AND source.DATABASE_NAME = target.DATABASE_NAME
							   AND source.TASK_ID = target.TASK_ID )
						  WHEN MATCHED THEN
							UPDATE SET LAST_RUN = source.LAST_RUN, [LAST_EXECUTION_TIME_SECS] = source.[LAST_EXECUTION_TIME_SECS]
						  WHEN NOT MATCHED THEN
							INSERT ( [LINKEDSERVER_NAME],
									 [DATABASE_NAME],
									 [TASK_ID],
									 [LAST_RUN],
									 [LAST_EXECUTION_TIME_SECS])
							VALUES (source.SERVER_NAME,
									source.DATABASE_NAME,
									source.TASK_ID,
									source.LAST_RUN,
									source.LAST_EXECUTION_TIME_SECS );
				END
      END
 ELSE
	IF @RC = 1  --REH SPROC HANDLED THE ERROR
      BEGIN
          PRINT ''
 
          PRINT 'FAILED !!!!!! ' + ISNULL(@C_TASK_DESC, '')
 
          PRINT ''
      END 
 
  


           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_CS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_CS_QUERY_SYSDATABASES')



END TRY 

BEGIN CATCH


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PROCEDURE FAILED !!! '
              + ISNULL(@C_TASK_DESC, 'TASK') + ' for SERVER
	'
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) + ', '
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE

PRINT 'ERROR WHILE COLLECTING ' + ISNULL(@C_TASK_DESC, '') +' !!!!!!!!!!!!!!'




         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_CS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_CS_QUERY_SYSDATABASES')

END CATCH



FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
	  DELETE FROM COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
		

ENDPROC:
PRINT 'RUN NAME = '+ @RUN_NAME
GO
PRINT N'Altering [dbo].[SP_PROCESS_STATS]...';


GO
ALTER PROCEDURE [dbo].[SP_PROCESS_STATS]
		@SERVER_NAME	NVARCHAR(128) = NULL,
		@DATABASE_NAME	NVARCHAR(128) = NULL ,
		@DYNAMICS_PRODUCT NVARCHAR(3)  = NULL,
		@TASK_TYPE		VARCHAR(50) = 'PROCESS',
		@AZURE_DB		BIT = 0,
		@TOP_ROWS		INT = 0,
		@TOP_COLUMN		NVARCHAR(128) = 'total_elapsed_time',
		@RUN_NAME		NVARCHAR(128) = NULL,
		@INDEX_PHYSICAL_STATS 	NCHAR(1)= 'N',
		@DEBUG			NVARCHAR(1)= 'N'

AS


SET NOCOUNT ON
SET DATEFORMAT MDY

DECLARE @STATS_DATE		DATETIME, 
		@SQL_VERSION	NVARCHAR(1000), 
		@DYNAMICS_VERSION NVARCHAR(MAX),
		@DATABASE_ID	INT,
		@RETURN_CODE	INT,
		@SQL			NVARCHAR(MAX),
		@RUN_DESCRIPTION NVARCHAR(1000),
		@SQL_TOP_CLAUSE	NVARCHAR(128),
		@SQL_ORDERBY_CLAUSE	NVARCHAR(128),
		@PARM			NVARCHAR(500),
		@SQL_SERVER_STARTTIME DATETIME,
		@RC INT,
		@TASK_PROCEDURE NVARCHAR(128),
		@TASK_PARAMETERS NVARCHAR(1024),
		@TASK_DESCRIPTION NVARCHAR(256),
		@LAST_SERVER_NAME NVARCHAR(128) = 'ZZZ',  --REH This is used to trigger inserting a new STATS_COLLECTION_SUMMARY record
		@LAST_DATABASE_NAME NVARCHAR(128) = 'ZZZ',
		@LAST_STATS_DATE DATETIME,
		@REMOTE_SERVER NVARCHAR(1) = 'N',
		@TASK_STARTTIME DATETIME,
		@TASK_ENDTIME DATETIME,
		@TASK_TIME BIGINT,
		@SQL_STARTTIME DATETIME,
		@SQL_BUILD NVARCHAR(20),
		@SQL2 NVARCHAR(MAX),
		@MANUAL_CAPTURE NVARCHAR(1) = 'N',
		@SQL_TZ_OFFSET INT,
		@DPA_TZ_OFFSET INT 

		
		
DECLARE
	@C_SERVER_NAME NVARCHAR(128),
	@C_DATABASE_NAME NVARCHAR(128),
	@C_TASK_ID INT,
	@C_TASK_PROCEDURE NVARCHAR(128),
	@C_TASK_PARAMS NVARCHAR(1024),
	@C_TASK_DESC NVARCHAR(256),
	@C_SERVER_LEVEL_TASK BIT,
	@C_AZURE_DB  BIT,
	@C_LAST_RUN DATETIME
	
		
--REH Time zone off set for the DynamicsPerf database at time of collection
		SET @DPA_TZ_OFFSET = DATEDIFF(MI,GETUTCDATE(),GETDATE())

	IF @DATABASE_NAME IS NOT NULL SET @MANUAL_CAPTURE = 'Y'

	SET @STATS_DATE = GETDATE()
--REH  Verify database exists if being manually passed, skip check if Azure DB, no access to sys.databases catalogue

IF ( @AZURE_DB = 0 and ( @SERVER_NAME IS NOT NULL
      OR @DATABASE_NAME IS NOT NULL ))
     BEGIN

	 
	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_QUERY_SYSDATABASES')

         IF @REMOTE_SERVER = 'Y'
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_PS_QUERY_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_PS_QUERY_SYSDATABASES
				FOR master.sys.databases'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END

         EXEC (@SQL) -- SELECT * FROM DYN_PS_QUERY_SYSDATABASES

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_PS_QUERY_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

         --REH Make sure there is a record in DATABASES_2_COLLECT or insert if new combination
         IF (SELECT COUNT(*)
             FROM   DATABASES_2_COLLECT
             WHERE  LINKED_SERVER = ISNULL(@SERVER_NAME, @@SERVERNAME)
                    AND DATABASE_NAME = @DATABASE_NAME) < 1
              BEGIN
                  INSERT DATABASES_2_COLLECT
                  VALUES(ISNULL(@SERVER_NAME,@@SERVERNAME),
                         @DATABASE_NAME,
                         ISNULL(@DYNAMICS_PRODUCT, 'ALL'),
                         0,
                         2,
                         24,
						 60,
						 2,
						 90,
						 7)
              END
     END 


	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END



---------------------------------------------------------------------------------------------
--
--  Insert Capture_log entry with paramater values used for the run
--
----------------------------------------------------------------------------------------------

INSERT CAPTURE_LOG  SELECT @TASK_TYPE, @STATS_DATE, 'SP_PROCESS_STATS PARMS PASSED @SERVER_NAME = ' + ISNULL(@SERVER_NAME,'NOT PASSED') + ' @DATABASE_NAME = ' + ISNULL(@DATABASE_NAME,'NOT PASSED') +  ' @DEBUG = ' + @DEBUG + '  ' + CHAR(10) + CHAR(13)



SET @RETURN_CODE = 0

DELETE FROM  COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH Default is 'COLLECT' for this sproc.  CAN'T TRUNCATE MULTIPLE SPROCS USING THIS TABLE




IF @DATABASE_NAME IS NULL  --REH AKA, not a manual capture
  BEGIN
      INSERT COLLECTIONDATABASES
      SELECT ISNULL(LINKED_SERVER, @@SERVERNAME),
             [DATABASE_NAME],
             [DYNAMICS_PRODUCT],
             [AZURE_DB],
             [ENABLED],
			 @TASK_TYPE
      FROM   DATABASES_2_COLLECT
      WHERE  ENABLED = 1 -- db must be enabled for autostats collection to work with it
  END
ELSE
  BEGIN   --REH  Insert DBname of the manual capture
      INSERT COLLECTIONDATABASES
      VALUES(ISNULL(@SERVER_NAME, @@SERVERNAME),
             @DATABASE_NAME,
             @DYNAMICS_PRODUCT,
             @AZURE_DB,
             1,
			 @TASK_TYPE)
  END 


--REH Insert any missing task history records in case it's a new database being collected, so we don't fail to capture against the db because of no records
-- yes, this is a cartesian join between these 2 tables

INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE	--REH default is 'PROCESS' in parm definition of this sproc
       AND NOT EXISTS (SELECT 'X'
                       FROM   DYNPERF_TASK_HISTORY DTH
                       WHERE  DTS.TASK_ID = DTH.TASK_ID
                              AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                              AND CD.DATABASE_NAME = DTH.DATABASE_NAME)
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 0 --REH Ok, to put 1 record per database in for DB type tasks


	   
--REH Need to insert 1 bogus record for each server level task, or the join on the cursor will fail

INSERT COLLECTIONDATABASES 
 SELECT	DISTINCT [LINKED_SERVER],
             'N/A',
            'ALL',
             [AZURE_DB],
             [ENABLED],
			 [TASK_TYPE]
FROM COLLECTIONDATABASES CD
WHERE DATABASE_NAME <> 'N/A'
AND TASK_TYPE = @TASK_TYPE
AND NOT EXISTS (SELECT 'X' FROM COLLECTIONDATABASES CD2 WHERE CD2.LINKED_SERVER = CD.LINKED_SERVER AND CD2.DATABASE_NAME = 'N/A')



--REH now lets insert server level tasks with a blank DB name so we only do them once per server
INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       'N/A',
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE  --REH default is 'COLLECT' in parm definition of this sproc
		AND CD.DATABASE_NAME <> 'N/A'
       AND NOT EXISTS (SELECT 'X'
                   FROM   DYNPERF_TASK_HISTORY DTH
                   WHERE  DTS.TASK_ID = DTH.TASK_ID
                          AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                          AND DTH.DATABASE_NAME = 'N/A') --REH making the db name = 'N/A' for server level tasks
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 1 





	IF @DEBUG = 'Y'
	BEGIN
		PRINT 'MANUAL_CAPTURE = ' + @MANUAL_CAPTURE
	END

	--REH Create here and truncate table in each loop
	 --  CREATE TABLE #SQL_INFO
  --   (
  --      SQL_STARTTIME DATETIME,
  --      SQL_BUILD NVARCHAR(20),
		--TZ_OFFSET INT
  --   )
   

/********************************************************************************
Rod Hansen

Added a trigger to DATABASES_2_COLLECT so that we always have a 
DYNPERF_TASK_HISTORY record for this code 

********************************************************************************/

DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT DISTINCT DTS.TASK_ID,
       CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_PROCEDURE,
       DTS.TASK_PARAMETERS,
       DTS.TASK_DESCRIPTION,
       DTS.SERVER_LEVEL_TASK,
       CD.AZURE_DB,
       ISNULL(DTH.LAST_RUN, '1/1/1900')
FROM   DynamicsPerf..[DYNPERF_TASK_SCHEDULER] DTS
       LEFT OUTER JOIN DynamicsPerf..[DYNPERF_TASK_HISTORY] DTH
                    ON DTH.TASK_ID = DTS.TASK_ID
       INNER JOIN DynamicsPerf..COLLECTIONDATABASES CD
               ON CD.DATABASE_NAME = DTH.DATABASE_NAME
                  AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
WHERE
  --REH Task is enabled
  DTS.ENABLED = 1
  AND
  --REH It's the correct task type C = COLLECTOR, P = PROCESS, M = MONITOR, ETC
  DTS.TASK_TYPE = @TASK_TYPE
  AND
  --REH database is enabled
  CD.ENABLED = 1
  AND
  --REH Azure_db, if Azure db, then task must support it
  ( CD.AZURE_DB = DTS.AZURE_DB_SUPPORTED
     OR CD.AZURE_DB = 0 )
  --REH Either its an Azure Task, all Azure tasks will run locally, so if task supports AZ and we pass 0, run it anyways
  AND ( DTS.AZURE_DB_SUPPORTED = @AZURE_DB
         OR ( DTS.AZURE_DB_SUPPORTED = 1
              AND @AZURE_DB = 0 ) )
  AND
  --REH it's either All products or matches the Dynamics Product
  ( DTS.DYNAMICS_PRODUCT = 'ALL'
     OR DTS.DYNAMICS_PRODUCT = CD.DYNAMICS_PRODUCT )
  AND
  --REH Scheduling options now
(
  --REH In the case of minutes or hous, we ignore schedule time and just figure out if it's time to run again
  ( @MANUAL_CAPTURE = 'Y'
     OR ( @MANUAL_CAPTURE = 'N'
          AND ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                  WHEN 'MI' THEN DATEADD(MINUTE, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                END ) <= GETDATE()
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'HH' THEN DATEADD(HOUR, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                --REH and it is on the hour
                AND ( ABS(DATEDIFF(MI, DATEADD(Hour, DATEDIFF(Hour, 0, GETDATE()), 0), GETDATE())) <= 1 ) )
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'DD' THEN DATEADD(DAY, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'WK' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'MM' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'QQ' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'YY' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                AND ( --REH TIME IS NULL SO IGNORE IT
                    COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) IS NULL
                     OR --REH Current time = Scheduled time 
                    ( SUBSTRING((SELECT REPLACE(CONVERT(VARCHAR(10), GETDATE(), 108), ':', '')), 1, 4) = (SELECT REPLICATE('0', 4 - LEN( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME)))
                                                                                                                 + CAST( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) AS VARCHAR(4))) ) ) )
         --REH and last_run < current time
         )--AND CONVERT(VARCHAR(10), LAST_RUN, 108) <= CONVERT(VARCHAR(10), Getdate(), 108) ) 
   )
)
ORDER  BY CD.LINKED_SERVER,
          CD.DATABASE_NAME,
          DTS.TASK_ID 



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

	SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                    WHEN @@SERVERNAME THEN 'N'
                    ELSE 'Y'
                    END

--Insert new STATS_COLLECTION_SUMMARY RECORD, we want 1 RUN_NAME per server not per database
IF @C_SERVER_NAME <> @LAST_SERVER_NAME OR @C_DATABASE_NAME <> @LAST_DATABASE_NAME
BEGIN
    SET @RUN_NAME = ISNULL(@C_SERVER_NAME, @@SERVERNAME)+ ' '
                    + CAST(@STATS_DATE AS VARCHAR(30))


TRUNCATE TABLE WRK_PS_SQL_INFO   

 DELETE FROM COLLECTIONDATABASES WHERE LINKED_SERVER = @LAST_SERVER_NAME AND DATABASE_NAME = @LAST_DATABASE_NAME AND TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
 
SELECT @SQL = 'SELECT create_date AS SQL_STARTTIME,
       CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))    AS SQL_BUILD,
	   DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
		FROM sys.databases WHERE name = ''TempDB'''

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


   SET NOCOUNT ON
 
IF @REMOTE_SERVER = 'N'
BEGIN
		   INSERT WRK_PS_SQL_INFO
		EXEC( @SQL)
END


 IF @REMOTE_SERVER = 'Y'
 BEGIN
			IF @C_AZURE_DB = 0
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT create_date AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROM sys.databases WHERE name = ''TempDB''"	)'
			END
			IF @C_AZURE_DB = 1
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT DATEADD(ms,AVG(-wait_time_ms), GETDATE()) AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROMsys.dm_os_wait_stats w WHEREwait_type
IN(''DIRTY_PAGE_POLL'',''HADR_FILESTREAM_IOMGR_IOCOMPLETION'',''LAZYWRITER_SLEEP'',''LOGMGR_QUEUE'',''REQUEST_FOR_DEADLOCK_SEARCH'',''XE_DISPATCHER_WAIT'',''XE_TIMER_EVENT'') "	)'
			END


				IF @DEBUG = 'Y'
                  BEGIN
                      PRINT '@SQL= ' + @SQL2
                  END 
                
			INSERT WRK_PS_SQL_INFO
				EXEC (@SQL2) 
 
 END
 
 SELECT @SQL_STARTTIME = SQL_STARTTIME, @SQL_BUILD = SQL_BUILD, @SQL_TZ_OFFSET = TZ_OFFSET FROM WRK_PS_SQL_INFO
 TRUNCATE TABLE WRK_PS_SQL_INFO  -- REH cleanout for next pass


  --REH NOT Collecting so don't need this code in this sproc


		--INSERT INTO [DynamicsPerf].[dbo].[STATS_COLLECTION_SUMMARY]
		--			([SERVER_NAME],
		--			 [STATS_TIME],
		--			 [RUN_NAME],
		--			 [DATABASE_NAME],
		--			 [SQL_VERSION],
		--			 [DYNAMICS_VERSION],
		--			 [RUN_DESCRIPTION],
		--			 [SQL_SERVER_STARTTIME],
		--			 [SQL_SERVER_TZ_OFFSET] ,
		--			 [DPA_TZ_OFFSET])
		--VALUES      (@C_SERVER_NAME,
		--			 @STATS_DATE,
		--			 @RUN_NAME,
		--			 @C_DATABASE_NAME,
		--			 @SQL_BUILD,--<SQL_VERSION>
		--			 '',--<DYNAMICS_VERSION>
		--			 '',--<RUN_DESCRIPTION>
		--			 @SQL_STARTTIME, -- <SQL_SERVER_STARTTIME>
		--			 @SQL_TZ_OFFSET,  -- Time Zone offset in minutes of database collected
		--			 @DPA_TZ_OFFSET  -- Time Zone of the DynamicsPerf database
		--			) 
				
END 

SET @LAST_SERVER_NAME = @C_SERVER_NAME
SET @LAST_DATABASE_NAME = @C_DATABASE_NAME


SET @REMOTE_SERVER = CASE @C_SERVER_NAME
                       WHEN @@SERVERNAME THEN 'N'
                       ELSE 'Y'
                     END 



--Create synonyms for the sproc

--IF  EXISTS (SELECT * FROM sys.synonyms WHERE name = 'DYN_PS_CAPTURE_SPROC')
--DROP SYNONYM [dbo].[DYN_PS_CAPTURE_SPROC]
--SET @SQL = '
--CREATE SYNONYM DYN_PS_CAPTURE_SPROC
--FOR [DynamicsPerf].dbo.[' + @C_TASK_PROCEDURE + ']'

--IF @DEBUG = 'Y' 
--BEGIN
--PRINT '@SQL= ' + @SQL
--END

--EXEC(@SQL) 

IF @DEBUG = 'Y' 
BEGIN
PRINT 'TASK ID = ' + CAST(@C_TASK_ID AS VARCHAR(10))
PRINT 'SERVER NAME = ' + @C_SERVER_NAME 
PRINT 'DATABASE NAME = ' + @C_DATABASE_NAME
PRINT 'TASK PARMS = ' + ISNULL(@C_TASK_PARAMS, '')
PRINT 'TASK DESC = ' + ISNULL(@C_TASK_DESC,'')
PRINT 'LAST RUN = ' + ISNULL(CAST(@C_LAST_RUN AS VARCHAR(30)),'')
PRINT 'RUN NAME = ' + ISNULL(@RUN_NAME,'')
PRINT 'STATS DATE = ' + CAST(@STATS_DATE AS VARCHAR(30))
PRINT 'REMNOTE SERVER FLAG = ' + ISNULL(@REMOTE_SERVER,'')
PRINT 'AZURE DB = ' + CAST(@C_AZURE_DB AS CHAR(1))


END
			
	

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@C_TASK_DESC, '') + CONVERT(VARCHAR, GETDATE(), 109)
PRINT ''


SET @TASK_STARTTIME = GETDATE()
SET @C_TASK_PARAMS = ISNULL(@C_TASK_PARAMS,'')


IF @DEBUG = 'Y'
BEGIN

	PRINT 'SERVER TIME ZONE OFFSET = ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
	PRINT 'AT LAST RUN  = ' + CAST(@C_LAST_RUN AS VARCHAR(30))

END

--REH Adjust the last_run time to UTC Time, the called sproc's will adjust it to local time unless we've never collected
IF @C_LAST_RUN > '1/1/1901'
BEGIN
SET @C_LAST_RUN = DATEADD(MI,@DPA_TZ_OFFSET *-1 ,@C_LAST_RUN)
END



IF @DEBUG = 'Y'
BEGIN
	PRINT 'AT LAST RUN TIME BEING PASSED TO SPROC ' + CAST(@C_LAST_RUN AS VARCHAR(30))
END

SELECT @SQL = 'EXEC ' + @C_TASK_PROCEDURE + '  @TASK_ID=' + CAST(@C_TASK_ID AS NVARCHAR(10)) + 
' ,@SERVER_NAME = ' + '''' +  @C_SERVER_NAME + '''' +
' ,@DATABASE_NAME = ' + '''' +  @C_DATABASE_NAME + '''' +
' ,@TASK_PARAMS = ' +  '''' +  @C_TASK_PARAMS + '''' +
' ,@TASK_DESC = ' + '''' +  @C_TASK_DESC + '''' +
' ,@LAST_RUN = ' + '''' + CONVERT(VARCHAR, @C_LAST_RUN, 109) + '''' +
' ,@RUN_NAME = ' + '''' +  @RUN_NAME + '''' +
' ,@STATS_DATE = ' + '''' + CONVERT(VARCHAR, @STATS_DATE, 109) + '''' +
' ,@REMOTE_SERVER = ' + '''' +  @REMOTE_SERVER + '''' +
' ,@AZURE_DB = ' + CAST(@C_AZURE_DB AS NVARCHAR(10)) + 
' ,@SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET AS NVARCHAR(10)) + 
' ,@DPA_TZ_OFFSET = ' + CAST(@DPA_TZ_OFFSET AS NVARCHAR(10)) + 


' ,@DEBUG = '  + '''' +  @DEBUG + ''''


UPDATE CAPTURE_LOG
SET    TEXT = TEXT  + CHAR(13) + CHAR(10) + '***** ' + @C_TASK_PROCEDURE
			+ CHAR(13) + CHAR(10)
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE



EXECUTE @RC = sp_executesql @SQL

   					  
SET @TASK_ENDTIME = GETDATE()

SET @TASK_TIME = DATEDIFF(ss,@TASK_STARTTIME, @TASK_ENDTIME)

  
--REH update last  [DYNPERF_TASK_HISTORY] IF THE TASK WAS SUCCESSFUL


  
 IF @RC = 0
      BEGIN
          PRINT ''
 
          PRINT 'SUCCESSFULLY CAPTURED '
                + ISNULL(@C_TASK_DESC, '') +  ' for SERVER
	'
              + ISNULL(@C_SERVER_NAME, '') + ' on database '
              + ISNULL(@C_DATABASE_NAME, '') + ' in ' + cast(@TASK_TIME AS VARCHAR(20)) + ' SECONDS '
 
       --REH if a manual capture don't update last run so we don't mess up the scheduling engine
				 IF @MANUAL_CAPTURE = 'N'
				 BEGIN
						  MERGE DynamicsPerf..[DYNPERF_TASK_HISTORY] AS target
						  USING (SELECT @C_SERVER_NAME   AS SERVER_NAME,
										@C_DATABASE_NAME AS DATABASE_NAME,
										@C_TASK_ID       AS TASK_ID,
										@STATS_DATE      AS LAST_RUN,
										@TASK_TIME	AS LAST_EXECUTION_TIME_SECS 
												) AS source
						  ON ( source.SERVER_NAME = target.LINKEDSERVER_NAME
							   AND source.DATABASE_NAME = target.DATABASE_NAME
							   AND source.TASK_ID = target.TASK_ID )
						  WHEN MATCHED THEN
							UPDATE SET LAST_RUN = source.LAST_RUN, [LAST_EXECUTION_TIME_SECS] = source.[LAST_EXECUTION_TIME_SECS]
						  WHEN NOT MATCHED THEN
							INSERT ( [LINKEDSERVER_NAME],
									 [DATABASE_NAME],
									 [TASK_ID],
									 [LAST_RUN],
									 [LAST_EXECUTION_TIME_SECS])
							VALUES (source.SERVER_NAME,
									source.DATABASE_NAME,
									source.TASK_ID,
									source.LAST_RUN,
									source.LAST_EXECUTION_TIME_SECS );
				END
      END
 ELSE
	IF @RC = 1  --REH SPROC HANDLED THE ERROR
      BEGIN
          PRINT ''
 
          PRINT 'FAILED !!!!!! ' + ISNULL(@C_TASK_DESC, '')
 
          PRINT ''
      END 
 

 
 

           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_QUERY_SYSDATABASES')

  
END TRY 

BEGIN CATCH


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PROCEDURE FAILED !!! '
              + ISNULL(@C_TASK_DESC, 'TASK') + ' for SERVER
	'
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) + ', '
WHERE  STATS_TIME = @STATS_DATE  AND TASK_TYPE = @TASK_TYPE

PRINT 'ERROR WHILE COLLECTING ' + ISNULL(@C_TASK_DESC, '') +' !!!!!!!!!!!!!!'


           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_QUERY_SYSDATABASES')


END CATCH



FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
 DELETE FROM COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
 
			

ENDPROC:
PRINT 'RUN NAME = '+ @RUN_NAME
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_AX_USERINFO]...';


IF OBJECTPROPERTY(object_id('dbo.DYNPERF_COLLECT_AX_USERINFO'), N'IsProcedure') = 1
DROP PROCEDURE [dbo].[DYNPERF_COLLECT_AX_USERINFO]



GO
CREATE PROCEDURE [dbo].[DYNPERF_COLLECT_AX_USERINFO](@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AX_USERINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AX_USERINFO')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AX_USERINFO
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AX_USERINFO
				FOR [' + @DATABASE_NAME + '].dbo.USERINFO'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



		DELETE FROM AX_USERINFO
		WHERE  SERVER_NAME = @SERVER_NAME
			   AND DATABASE_NAME = @DATABASE_NAME 

		INSERT AX_USERINFO
		SELECT @SERVER_NAME,
		@STATS_DATE,
			   @DATABASE_NAME,
			   ID,
			   NAME
		FROM   DYN_AX_USERINFO 

	
	 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AX_USERINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AX_USERINFO')


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'


		  IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AX_USERINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AX_USERINFO')




    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Refreshing [dbo].[SP_PARSE_PLAN_COMPARE]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[SP_PARSE_PLAN_COMPARE]';


GO
PRINT N'Refreshing [dbo].[SP_PARSE_PLAN_BASE]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[SP_PARSE_PLAN_BASE]';


GO
PRINT N'Refreshing [dbo].[SP_PARSE_PLAN]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[SP_PARSE_PLAN]';


GO
PRINT N'Altering [dbo].[DYNPERF_PROCESS_QUERY_PLANS]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PROCESS_QUERY_PLANS]
       (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
                                                                             @AZURE_DB           BIT,
                                                                             @SQL_TZ_OFFSET INT,
                                                                             @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @CPU INT
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH Need to delete any old data in case QUERY_PLAN refresh updates the flag.  We need to delete old parsed plans

DELETE QPP
FROM   QUERY_PLANS_PARSED QPP
       INNER JOIN QUERY_PLANS QP WITH (NOLOCK)
               ON QPP.SERVER_NAME = QP.SERVER_NAME
                  AND QPP.DATABASE_NAME = QP.DATABASE_NAME
                  AND QPP.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
WHERE  QP.PARSED_FLAG = 0 and QP.SERVER_NAME = @SERVER_NAME and QP.DATABASE_NAME = @DATABASE_NAME

IF EXISTS (SELECT * FROM [tempdb].sys.objects WHERE name = '#PARSE_PLANS')
DROP TABLE #PARSE_PLANS

;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT	TOP 10000	QT.SERVER_NAME, QT.DATABASE_NAME, QT.[QUERY_PLAN_HASH],
 CONVERT (NVARCHAR(MAX), index_node.query('for $qplan in //sp:QueryPlan, $plist in $qplan/sp:ParameterList, $colref in $plist/sp:ColumnReference  return concat(string($colref/@Column),":",string($colref/@ParameterCompiledValue),",   "),"  "')) as SQL_PARAMS,
 CASE WHEN CAST(QT.QUERY_PLAN AS NVARCHAR(MAX)) LIKE '%MissingIndex%' THEN 1 ELSE 0 END as MI_FLAG
INTO #PARSE_PLANS

  FROM [QUERY_PLANS] QT WITH (NOLOCK)
  	INNER LOOP JOIN QUERY_STATS QS ON QT.SERVER_NAME = QS.SERVER_NAME AND QT.DATABASE_NAME = QS.DATABASE_NAME
		AND QT.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
      OUTER APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node)
    
WHERE PARSED_FLAG = 0 AND QT.SERVER_NAME = @SERVER_NAME AND QT.DATABASE_NAME = @DATABASE_NAME
	AND QT.QUERY_PLAN_HASH > 0X000000000000000  --REH Don't process the 0 hash values
	ORDER BY QS.TOTAL_ELAPSED_TIME DESC  --REH do the top execution times first, most likely to show up in query views


--REH Parse out the QUERY_PLANS table into it's vital statistics

SET QUOTED_IDENTIFIER OFF
SELECT @CPU = CPU_COUNT * .25 FROM sys.dm_os_sys_info

IF @CPU < 2 SET @CPU = 2

SET @SQL = '
 ;WITH XMLNAMESPACES (''http://schemas.microsoft.com/sqlserver/2004/07/showplan'' AS sp)

 INSERT QUERY_PLANS_PARSED
 SELECT DISTINCT *
FROM   (SELECT QUERY_PLANS.SERVER_NAME, QUERY_PLANS.DATABASE_NAME, QUERY_PLANS.QUERY_PLAN_HASH,
			   CAST(isnull(index_node.value(''(..//@NodeId)[1]'', ''nvarchar(128)''),''0'') AS INT) AS NodeID,
               CAST(Replace(Replace(index_node.value(''(.//@Table)[1]'', ''NVARCHAR(128)''), ''['', ''''), '']'', '''') AS NVARCHAR(128))  AS TABLE_NAME,
               CAST(Replace(Replace(index_node.value(''(.//@Index)[1]'', ''NVARCHAR(128)''), ''['', ''''), '']'', '''') AS NVARCHAR(128)) AS INDEX_NAME,
			   CAST(isnull(index_node.value(''(.//@Lookup)[1]'', ''nvarchar(128)''),''0'') AS INT) AS LOOKUP,
			   CAST(isnull(index_node.value(''(..//@Parallel)[1]'', ''nvarchar(128)''),''0'') AS INT) AS PARALLEL,
			   CAST(index_node.value(''(..//@PhysicalOp)[1]'', ''nvarchar(128)'') AS NVARCHAR(128)) AS PHYSICALOP,
			   CAST(index_node.value(''(..//@LogicalOp)[1]'', ''nvarchar(128)'') AS NVARCHAR(128)) AS LOGICALOP,
			   CAST(str(ISNULL(index_node.value(''(..//@EstimateRows)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(14,0)) AS ESTIMATEROWS,
			   CAST(str(ISNULL(index_node.value(''(..//@EstimateIO)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(20,7)) AS EstimateIO,
			   CAST(str(ISNULL(index_node.value(''(..//@EstimateCPU)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(20,7)) AS ESTIMATECPU,
			   CAST(str(ISNULL(index_node.value(''(..//@AvgRowSize)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(14,0)) AS AVGROWSIZE,
			   CAST(str(isnull(index_node.value(''(..//@EstimatedTotalSubtreeCost)[1]'', ''nvarchar(128)'') ,''0.0''),30,17) AS DECIMAL (20,7)) AS ESTIMATEDTOTALSUBTREECOST,
               CONVERT(NVARCHAR(MAX), index_node.query(''for $seekpredicate in ./sp:SeekPredicates,
                                                            $rangecolumns in $seekpredicate//sp:RangeColumns,
                                                            $columnreference in $rangecolumns/sp:ColumnReference
                                        return string($columnreference/@Column)''))        AS SEEK_COLUMNS,

              CONVERT(NVARCHAR(MAX), index_node.query(''for $predicate2 in ./sp:Predicate,
                                                           $Ident in  $predicate2//sp:Identifier,
														   $COLREF2 in  $Ident/sp:ColumnReference
                                                            
                                        return string($COLREF2/@Column)'')) AS PREDICATES,

		    REPLACE( REPLACE( CONVERT(NVARCHAR(MAX), index_node.query(''for $predicate in ./sp:Predicate,
                                                $rangecolumn in $predicate//sp:ScalarOperator
                                                            
                            return string($rangecolumn/@ScalarString)''))
							,''&lt;'', ''<'')   ,''&gt;'', ''>'')         AS PREDICATE_TEXT
        FROM   QUERY_PLANS WITH (NOLOCK)
			INNER JOIN #PARSE_PLANS ON QUERY_PLANS.SERVER_NAME = #PARSE_PLANS.SERVER_NAME
					AND QUERY_PLANS.DATABASE_NAME = #PARSE_PLANS.DATABASE_NAME
					AND QUERY_PLANS.QUERY_PLAN_HASH = #PARSE_PLANS.QUERY_PLAN_HASH
			OUTER APPLY QUERY_PLAN.nodes(''//sp:RelOp/sp:IndexScan'') AS SeekPredicates(index_node)
               --CROSS APPLY QUERY_PLAN.nodes(''//sp:Batch'') AS Batch(index_node2)
			WHERE QUERY_PLANS.SERVER_NAME = ' + '''' + @SERVER_NAME + '''' +'  AND QUERY_PLANS.DATABASE_NAME = '+ '''' +  @DATABASE_NAME +'''' + ' 
			   AND QUERY_PLANS.PARSED_FLAG = 0

			   ) A
			   OPTION(MAXDOP ' + CAST(@CPU AS VARCHAR(4)) + ')'

			   IF @DEBUG = 'Y'
			   BEGIN
				 PRINT @SQL
			   END


			   EXEC (@SQL)



UPDATE QP SET SQL_PARMS = PP.SQL_PARAMS
, MI_FLAG = PP.MI_FLAG
, PARSED_FLAG = 1

FROM QUERY_PLANS QP
INNER JOIN #PARSE_PLANS PP ON QP.SERVER_NAME = PP.SERVER_NAME
			AND QP.DATABASE_NAME = PP.DATABASE_NAME
			AND QP.QUERY_PLAN_HASH = PP.QUERY_PLAN_HASH

 WHERE QP.SERVER_NAME = @SERVER_NAME AND QP.DATABASE_NAME = @DATABASE_NAME AND QP.PARSED_FLAG = 0 
 OPTION(MAXDOP 1)
 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH 


GO
PRINT N'Refreshing [dbo].[DYNPERF_COLLECT_QUERY_PLANS]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[DYNPERF_COLLECT_QUERY_PLANS]';


GO
PRINT N'Refreshing [dbo].[DYNPERF_PURGE_DATA]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[DYNPERF_PURGE_DATA]';


GO
PRINT N'Refreshing [dbo].[DYNPERF_REFRESH_QUERY_PLANS]...';


GO
PRINT N'Altering [dbo].[DYNPERF_REFRESH_QUERY_PLANS]';
 GO
 
ALTER PROCEDURE [dbo].DYNPERF_REFRESH_QUERY_PLANS
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @REFRESH_PLAN_DAYS INT
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_RQP_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_RQP_STATS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_RQP_STATS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.dm_exec_query_stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_RQP_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_query_stats'

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


  SELECT @REFRESH_PLAN_DAYS = REFRESH_PLAN_DAYS FROM DATABASES_2_COLLECT WHERE LINKED_SERVER = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @REMOTE_SERVER = 'N'
BEGIN
;WITH Query_Stats_CTE (SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH, PLAN_HANDLE )
     AS
     -- Define the CTE query.
     (SELECT  * FROM 
     (SELECT DISTINCT SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH,
                      PLAN_HANDLE
      FROM   QUERY_STATS AS QS WITH (NOLOCK)
      WHERE  STATS_TIME > DATEADD(D,-1,GETDATE())  --REH ANY QUERIES COLLECTED IN THE LAST DAY
             AND DATABASE_NAME = @DATABASE_NAME
             AND SERVER_NAME = @SERVER_NAME 
             AND QUERY_PLAN_HASH > 0x00000000
             AND  EXISTS (SELECT 'X'
                             FROM   QUERY_PLANS QP WITH (NOLOCK)
                             WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
                                    AND QS.DATABASE_NAME = QP.DATABASE_NAME
                                    AND QS.SERVER_NAME = QP.SERVER_NAME 
									AND QP.DATE_UPDATED <= DATEADD(D,-@REFRESH_PLAN_DAYS,GETDATE() ) --REH ANY PLANS THAT HAVEN'T BEEN UPDATED IN THE LAST 7 DAYS
									)) AS A)
									 
UPDATE QP 
SET QUERY_PLAN = COALESCE(RH.QUERY_PLAN,QP.QUERY_PLAN), DATE_UPDATED = GETDATE(), PARSED_FLAG = 0
FROM   QUERY_PLANS QP
INNER JOIN (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_PLAN_HASH
                        ORDER BY CTE.QUERY_PLAN_HASH DESC),
                        SERVER_NAME, 
                        DATABASE_NAME,
               CTE.QUERY_PLAN_HASH,
               query_plan AS QUERY_PLAN
        FROM   Query_Stats_CTE CTE
               OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH ON RH.SERVER_NAME = QP.SERVER_NAME AND RH.DATABASE_NAME = QP.DATABASE_NAME
               AND RH.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
WHERE  RN = 1 AND QP.SERVER_NAME = @SERVER_NAME AND QP.DATABASE_NAME = @DATABASE_NAME


END

IF @REMOTE_SERVER = 'Y'
     BEGIN
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)


         SET @SQL = '
				CREATE TABLE [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH
				(
				QUERY_PLAN_HASH VARBINARY(64), 
				PLAN_HANDLE VARBINARY(64)
				)'

		IF @DEBUG = 'Y'
		BEGIN
         PRINT @SQL
		 END


         SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT [' + @SERVER_NAME
									 + ']'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

         SET @SQL = '

					;WITH Query_Stats_CTE ( QUERY_PLAN_HASH, PLAN_HANDLE)
						 AS (SELECT DISTINCT QUERY_PLAN_HASH,
										  PLAN_HANDLE
							 FROM   QUERY_STATS QS WITH (NOLOCK)
							 WHERE  QS.STATS_TIME >=  DATEADD(D,-1,GETDATE()) 
							  AND QUERY_PLAN_HASH > 0x00000000
									AND DATABASE_NAME = '
										+ '''' + @DATABASE_NAME + ''''
										+ '
									AND SERVER_NAME = ' + '''' +
										+ @SERVER_NAME + ''''
										+ ' 
									AND EXISTS (SELECT ''X''
													FROM   QUERY_PLANS QP WITH (NOLOCK)
												 WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
														AND QS.DATABASE_NAME = QP.DATABASE_NAME
														AND QS.SERVER_NAME = QP.SERVER_NAME 
															AND QP.DATE_UPDATED <= DATEADD(D,-' + CAST(@REFRESH_PLAN_DAYS AS VARCHAR(4)) +',GETDATE() ) 
													))
						INSERT INTO OPENQUERY([' + @SERVER_NAME
										+ '], ''SELECT QUERY_PLAN_HASH, PLAN_HANDLE FROM [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH'')
					                            
					  
					SELECT QUERY_PLAN_HASH, PLAN_HANDLE 
					FROM   (SELECT RN = ROW_NUMBER()
										  OVER (
											PARTITION BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE
											ORDER BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE DESC),
								   CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE 
					            
								FROM   Query_Stats_CTE CTE
							   ) AS RH
					WHERE  RN = 1 '

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END 


         EXEC(@SQL)



			SET @SQL = 'SELECT 
				   QUERY_PLAN_HASH,
				   cast(query_plan as nvarchar(max)) as QUERY_PLAN

			FROM   (SELECT RN = ROW_NUMBER()
								  OVER (
									PARTITION BY QUERY_PLAN_HASH
									ORDER BY QUERY_PLAN_HASH DESC),
						   QUERY_PLAN_HASH,
						   query_plan 
					FROM   [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH CTE
						   OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH
			WHERE  RN = 1 ' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  UPDATE DynamicsPerf.dbo.QUERY_PLANS
						 SET QUERY_PLAN =  COALESCE( RH.QUERY_PLAN, QUERY_PLANS.QUERY_PLAN), PARSED_FLAG = 0, DATE_UPDATED = ' + '''' + CAST(GETDATE() AS VARCHAR(20)) + '''' 
						 + 'FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') AS RH
						 WHERE SERVER_NAME = ' + '''' + @SERVER_NAME + '''' +
						  '   AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + 
						  '  AND RH.QUERY_PLAN_HASH = QUERY_PLANS.QUERY_PLAN_HASH' 

		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)
         

		 --REH Drop the table at the end of the process

         SET @SQL = '

				IF EXISTS (SELECT * FROM  [' + @DATABASE_NAME + '].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
				 DROP TABLE  [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)
     
     END 




UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)

	
         SET @SQL = '

				IF EXISTS (SELECT * FROM  [' + @DATABASE_NAME + '].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
				 DROP TABLE  [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 

				EXEC(@SQL2)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH 






GO

PRINT N'Altering [dbo].[DYNPERF_REFRESH_QUERY_TEXT]...';
GO


ALTER PROCEDURE [dbo].[DYNPERF_REFRESH_QUERY_TEXT]
 (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @REFRESH_PLAN_DAYS INT
    
/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


  SELECT @REFRESH_PLAN_DAYS = REFRESH_PLAN_DAYS FROM DATABASES_2_COLLECT WHERE LINKED_SERVER = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



IF @REMOTE_SERVER = 'N'
     BEGIN ;
         WITH Query_Stats_CTE ( QUERY_HASH)
              AS (SELECT  QUERY_HASH
                  FROM   QUERY_STATS QS WITH (NOLOCK)
                  WHERE  QS.STATS_TIME >= DATEADD(D,-1,GETDATE())
                         AND DATABASE_NAME = @DATABASE_NAME
                         AND SERVER_NAME = @SERVER_NAME 
						 AND QUERY_HASH > 0x0000000000
                         AND  EXISTS (SELECT 'X'
                                         FROM   QUERY_TEXT QT WITH (NOLOCK)
                                         WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                                AND QS.SERVER_NAME = QT.SERVER_NAME
												AND QT.DATE_UPDATED <= DATEADD(D,-@REFRESH_PLAN_DAYS,GETDATE() ) --REH ANY PLANS THAT HAVEN'T BEEN UPDATED IN THE LAST 7 DAYS
												 ))
    --     INSERT QUERY_TEXT
    --     SELECT @SERVER_NAME,
    --            @DATABASE_NAME,
    --            QUERY_HASH,
    --            SQL_TEXT,
				--@STATS_DATE
				
	UPDATE QT 
	SET SQL_TEXT = COALESCE(RH.SQL_TEXT, QT.SQL_TEXT), DATE_UPDATED = @STATS_DATE
         FROM   
         QUERY_TEXT QT INNER JOIN 
         (SELECT RN = ROW_NUMBER()
                               OVER (
                                 PARTITION BY CTE.QUERY_HASH
                                 ORDER BY CTE.QUERY_HASH DESC),
                        qs.query_hash                                                                                              AS QUERY_HASH,
                        SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                        WHEN -1 THEN DATALENGTH(st.text)
                                                                                        ELSE qs.statement_end_offset
                                                                                      END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
                 FROM   Query_Stats_CTE CTE
                        INNER JOIN sys.dm_exec_query_stats AS qs
                                ON CTE.QUERY_HASH = qs.query_hash
                        OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                        CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
                 WHERE  attribute = N'dbid'
                        AND DB_NAME(CONVERT(INT, value)) = @DATABASE_NAME
                        AND last_execution_time >= @LAST_RUN
						) AS RH ON RH.QUERY_HASH = QT.QUERY_HASH AND QT.SERVER_NAME = @SERVER_NAME AND QT.DATABASE_NAME = @DATABASE_NAME
         WHERE  RN = 1
     END 


 IF @REMOTE_SERVER = 'Y'
 BEGIN
 


				 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)



 SET @SQL = '
CREATE TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH
(
QUERY_HASH VARBINARY(64)
)' 



 SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  EXEC ('+'"' + @SQL +'"' + ') AT [' + @SERVER_NAME + ']'
  
 IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END

EXEC (@SQL2)


SET @SQL = '

;WITH Query_Stats_CTE ( QUERY_HASH)
     AS (SELECT  QUERY_HASH
         FROM   QUERY_STATS QS
         WHERE  QS.STATS_TIME >= DATEADD(D,-1, GETDATE()  )
                AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + '
                AND SERVER_NAME = ' + '''' + +@SERVER_NAME + '''' + ' 
				AND QUERY_HASH > 0x0000000000
                AND  EXISTS (SELECT ''X''
                                FROM   QUERY_TEXT QT WITH (NOLOCK)
                                WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                AND QS.SERVER_NAME = QT.SERVER_NAME 
								AND QT.DATE_UPDATED <= DATEADD(D,-'+CAST(@REFRESH_PLAN_DAYS AS VARCHAR(4))+',GETDATE() )
                                ))
INSERT INTO OPENQUERY([' + @SERVER_NAME + '], ''SELECT QUERY_HASH FROM  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH'')

SELECT QUERY_HASH
FROM   (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_HASH
                        ORDER BY CTE.QUERY_HASH DESC),
               QUERY_HASH 
            
            FROM   Query_Stats_CTE CTE
           ) AS RH
WHERE  RN = 1 '

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


EXEC (@SQL)


        
 SET @SQL = '
         SELECT QUERY_HASH, SQL_TEXT
         FROM (
         SELECT RN = ROW_NUMBER() OVER (PARTITION BY CTE.QUERY_HASH ORDER BY CTE.QUERY_HASH DESC),
          qs.query_hash AS QUERY_HASH,
                         SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                         WHEN -1 THEN DATALENGTH(st.text)
                                                                                         ELSE qs.statement_end_offset
                                                                                       END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
         FROM    [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH CTE
                INNER JOIN sys.dm_exec_query_stats AS qs
                        ON CTE.QUERY_HASH = qs.query_hash
                OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
         WHERE  attribute = N''dbid''
                AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
                ) AS RH  
                WHERE RN = 1 '
PRINT ''
PRINT ''
                  
IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  	UPDATE QT 
	SET SQL_TEXT = COALESCE(A.SQL_TEXT,QT.SQL_TEXT), DATE_UPDATED =' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' +
	' FROM QUERY_TEXT QT INNER JOIN  (' +
				 '  SELECT RH.* FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH
                    ) AS A ON A.QUERY_HASH = QT.QUERY_HASH AND QT.SERVER_NAME = ' +'''' + @SERVER_NAME + '''' +
                    '   AND QT.DATABASE_NAME = ' + '''' + @DATABASE_NAME +''''
                   


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END
				 
				 EXECUTE (@SQL2)
				 
 --REH  Delete the table back out
 
 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

 
 END
 
    

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)

	
         SET @SQL = '

				IF EXISTS (SELECT * FROM  [' + @DATABASE_NAME + '].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
				 DROP TABLE  [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 

			EXEC (@SQL2)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH 








GO
PRINT N'Update complete.';


GO




TRUNCATE TABLE DYNPERF_TASK_SCHEDULER
TRUNCATE TABLE DYNPERF_TASK_HISTORY

-- Enabled, Dynamics Product, Sproc Name, Sproc Parms, Task Desc, Sched Units, Sched qty, Sched time, Azure, Linked Server , Server level task, Task group


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_QUERY_STATS', NULL, 'Collect QUERY_STATS for database','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_INDEXSTATS', NULL, 'Collect INDEX STATS for database','HH',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_TEXT', NULL, 'Collect SQL TEXT for database','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_QUERY_PLANS', NULL, 'Collect QUERY PLANS for database','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SYSOBJECTS', NULL, 'Collect SYSTEM OBJECT DEFINITIONS for database','DD',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_WAITSTATS', NULL, 'Collect SERVER WAIT STATS for server','HH',1,NULL,1,1,1,'COLLECT');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_VIRTIALIO_DISKSTATS', NULL, 'Collect VIRTUAL I/O DISK STATS for database','HH',1,NULL,1,1,0,'COLLECT');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_CHANGE_DATA_CONTROL', NULL, 'Collect CHANGE DATA CONTROL for database','DD',1,NULL,0,1,0,'COLLECT');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_CHANGE_TRACKING', NULL, 'Collect CHANGE TRACKING for database','DD',1,NULL,1,1,0,'COLLECT')


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SSRS_EXECUTIONLOG', NULL, 'Collect SSRS for database','MI',5,NULL,1,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_DATA_BUFFER_CACHE', NULL, 'Collect SQL DATA BUFFER CACHE for server','DD',1,NULL,1,1,1,'COLLECT')


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_DATABASES', NULL, 'Collect SQL DATABASES INFORMATION for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_DATABASE_REPLICATION_INFO', NULL, 'Collect REPLICATION CONFIGURATION for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_CONFIGURATION', NULL, 'Collect SQL CONFIGURATION INFORMATION for server','DD',1,NULL,0,1,1,'COLLECT')


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_DATABASE_FILES', NULL, 'Collect SQL DATABASE FILE INFORMATION for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_DATABASE_VLFS', NULL, 'Collect SQL TLOG VLFS for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_INDEX_USAGE_STATS', NULL, 'Collect INDEX USAGE STATS for database','HH',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_INDEX_OPERATIONAL_STATS', NULL, 'Collect INDEX OPERATIONAL STATS for database','HH',1,NULL,1,1,0,'COLLECT');
	

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_JOBS', NULL, 'Collect SQL JOBS for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVERINFO', NULL, 'Collect SQL INSTANCE CONFIGURATION for server','DD',1,NULL,1,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVER_REGISTRY', NULL, 'Collect SQL STARTUP PARMS IN THE REGISTRY for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVER_DISKVOLUMES', NULL, 'Collect DISKVOLUMES USED BY SQL for server','WK',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVER_OS_INFO', NULL, 'Collect WINDOW OS VERSION INFO for server','WK',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_TRIGGER_INFO', NULL, 'Collect DATABASE TRIGGER INFO for database','DD',1,NULL,1,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_TRACEFLAGS_RUNNING', NULL, 'Collect RUNNING TRACE FLAGS for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_ERRORLOG', NULL, 'Collect SQL SERVER ERROR LOG for server','MI',5,NULL,1,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_DATABASE_STATISTICS', NULL, 'Collect DATABASE STATISTICS for database','WK',1,NULL,0,1,0,'PROCESS')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_PLAN_GUIDES', NULL, 'Collect PLAN GUIDES for database','DD',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_PERF_COUNTERS', NULL, 'Collect SQL Performance Counters ','MI',5,NULL,0,1,1,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_PERF_COUNTERS_AZURE', NULL, 'Collect SQL Performance Counters for AZURE db ','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_AZURE_EVENTLOG', NULL, 'Collect sys.event_log  for AZURE db ','MI',5,NULL,1,1,0,'COLLECT');






-----------------------------------------Process Tasks -----------------------------------------------------------------------------






INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_UPDATE_QUERY_HISTORY', NULL, 'Rollup QUERY data into history tables','MI',5,NULL,1,1,1,'PROCESS');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_UPDATE_INDEX_HISTORY', NULL, 'Rollup INDEX data into history tables','HH',1,NULL,1,1,1,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PROCESS_QUERY_ALERTS', NULL, 'Query Alerts Processing','MI',5,NULL,1,1,0,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_UPDATE_SSRS_HISTORY', NULL, 'Rollup SSRS EXECUTIONLOG into History table','MI',5,NULL,1,1,1,'PROCESS');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PROCESS_AXSQLTRACE', '7' , 'Update QUERY_HASH in AX_SQLTRACE table','MI',5,NULL,1,1,0,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_REFRESH_QUERY_PLANS', NULL, 'Refresh old QUERY PLANS','DD',1,NULL,1,1,0,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_REFRESH_QUERY_TEXT', NULL, 'Refresh old QUERY TEXT','DD',1,NULL,1,1,0,'PROCESS');

--reh do this task last so everything else happens in case this task takes a long time
INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PROCESS_QUERY_PLANS', NULL, 'Parse all XML Query Plans','MI',5,NULL,1,1,0,'PROCESS');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PURGE_DATA', NULL, 'Purge data from DynamicsPerf','DD',1,NULL,1,1,1,'PROCESS');


/****************************************

AX_SCHEDULE

These are the  tasks for Dynamics AX
*****************************************/

----------------------------------------------AX ---------------------------------------

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_SQLTRACE', NULL, 'Collect SYSTRACETABLESQL for database','MI',5,NULL,0,1,0,'COLLECT')

--REH replaced by AOTEXPORT, better data
--INSERT DYNPERF_TASK_SCHEDULER
--VALUES (1,'AX', 'DYNPERF_COLLECT_AX_BATCHSERVER', NULL, 'Collect AX BATCH TABLES for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_SQLSTORAGE', NULL, 'Collect AX SQLSTORAGE TABLE for database','WK',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_NUMBERSEQUENCE', NULL, 'Collect AX NUMBER SEQUENCES for database','HH',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_SYSGLOBALCONFIG', NULL, 'Collect AX SYSGLOBALCONFIG for database','DD',1,NULL,0,1,0,'COLLECT')

--REH AOTEXPORT class goes direct to DynamicsPerf now
--INSERT DYNPERF_TASK_SCHEDULER
--VALUES (1,'AX', 'DYNPERF_COLLECT_AX_AOTEXPORT_DATA', NULL, 'Collect AX AOTEXPORT DATA for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_SET_AX_SQLTRACE', NULL, 'Set AX_SQLTRACE for database','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_USERINFO', NULL, 'Collect USERINFO for database','DD',1,NULL,0,1,0,'COLLECT')




/****************************************

CRM_SCHEDULE

These are the  tasks for Dynamics CRM
*****************************************/

----------------------------------------------CRM ---------------------------------------

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'CRM', 'DYNPERF_COLLECT_CRM_ORGANIZATION', NULL, 'Collect CRM ORGANIZATION INFO for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'CRM', 'DYNPERF_COLLECT_CRM_PLUGINS', NULL, 'Collect CRM PLUGINS INFO for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'CRM', 'DYNPERF_COLLECT_CRM_POA_TOTALS', NULL, 'Collect CRM Primary Object Access INFO for database','HH',1,NULL,0,1,0,'COLLECT')

UPDATE QUERY_PLANS SET DATE_UPDATED = '1/1/1900'
UPDATE QUERY_TEXT SET DATE_UPDATED = '1/1/1900'


GO

UPDATE [DYNAMICSPERF_SETUP]
set VERSION = '2.00 BETA 5'