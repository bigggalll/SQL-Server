/*
Deployment script for DynamicsPerf

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
USE [DynamicsPerf];



ALTER DATABASE [DynamicsPerf] SET ANSI_NULL_DEFAULT OFF 

ALTER DATABASE [DynamicsPerf] SET ANSI_NULLS OFF 

ALTER DATABASE [DynamicsPerf] SET ANSI_PADDING OFF 

ALTER DATABASE [DynamicsPerf] SET ANSI_WARNINGS OFF 

ALTER DATABASE [DynamicsPerf] SET ARITHABORT OFF 

ALTER DATABASE [DynamicsPerf] SET AUTO_CLOSE OFF 

ALTER DATABASE [DynamicsPerf] SET AUTO_CREATE_STATISTICS ON 

ALTER DATABASE [DynamicsPerf] SET AUTO_SHRINK OFF 

ALTER DATABASE [DynamicsPerf] SET AUTO_UPDATE_STATISTICS ON 

ALTER DATABASE [DynamicsPerf] SET CURSOR_CLOSE_ON_COMMIT OFF 

ALTER DATABASE [DynamicsPerf] SET CURSOR_DEFAULT  GLOBAL 

ALTER DATABASE [DynamicsPerf] SET CONCAT_NULL_YIELDS_NULL OFF 

ALTER DATABASE [DynamicsPerf] SET NUMERIC_ROUNDABORT OFF 

ALTER DATABASE [DynamicsPerf] SET QUOTED_IDENTIFIER OFF 

ALTER DATABASE [DynamicsPerf] SET RECURSIVE_TRIGGERS OFF 

ALTER DATABASE [DynamicsPerf] SET  ENABLE_BROKER 

ALTER DATABASE [DynamicsPerf] SET AUTO_UPDATE_STATISTICS_ASYNC OFF 

ALTER DATABASE [DynamicsPerf] SET DATE_CORRELATION_OPTIMIZATION OFF 

ALTER DATABASE [DynamicsPerf] SET TRUSTWORTHY OFF 

ALTER DATABASE [DynamicsPerf] SET READ_COMMITTED_SNAPSHOT ON

ALTER DATABASE [DynamicsPerf] SET ALLOW_SNAPSHOT_ISOLATION ON

ALTER DATABASE [DynamicsPerf] SET PARAMETERIZATION SIMPLE 

ALTER DATABASE [DynamicsPerf] SET  READ_WRITE 

ALTER DATABASE [DynamicsPerf] SET RECOVERY SIMPLE 

ALTER DATABASE [DynamicsPerf] SET  MULTI_USER 

ALTER DATABASE [DynamicsPerf] SET PAGE_VERIFY NONE  

ALTER DATABASE [DynamicsPerf] SET DB_CHAINING OFF 

GO
/*
The column [dbo].[AX_SQLTRACE_CONFIG].[Id] is being dropped, data loss could occur.
*/

declare @n char(1)
set @n = char(10)

declare @stmt nvarchar(max)

select @stmt = isnull( @stmt + @n, '' ) +
'drop synonym [' + SCHEMA_NAME(schema_id) + '].[' + name + ']'
from sys.synonyms

exec sp_executesql @stmt


go

TRUNCATE TABLE AX_SQLTRACE_CONFIG

TRUNCATE TABLE QUERY_PLANS_PARSED
UPDATE QUERY_PLANS SET PARSED_FLAG = 0


GO
PRINT N'Altering [dbo].[QUERY_HISTORY]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
ALTER TABLE [dbo].[QUERY_HISTORY] DROP COLUMN [AVG_TIME_TODAY_MS], COLUMN [WAIT_TIME_TODAY_MS];


GO
ALTER TABLE [dbo].[QUERY_HISTORY]
    ADD [WAIT_TIME_TODAY_MS] AS (CONVERT (DECIMAL (29, 3), ([ELAPSED_TIME_TODAY] - [TOTAL_WORKER_TIME_TODAY]) / (1000), (0))),
        [AVG_TIME_TODAY_MS]  AS (CASE WHEN [EXECUTION_COUNT_TODAY] > (0) THEN CONVERT (DECIMAL (29, 3), ([ELAPSED_TIME_TODAY] / [EXECUTION_COUNT_TODAY]) / (1000.000), (0)) ELSE (0) END);


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[FN_HASH_FROM_UINT64_TO_BINARY]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;

USE [DynamicsPerf]
GO

/****** Object:  UserDefinedFunction [dbo].[FN_HASH_FROM_UINT64_TO_BINARY]    Script Date: 2/20/2016 12:49:56 PM ******/
if object_id('FN_HASH_FROM_UINT64_TO_BINARY') is not NULL
DROP FUNCTION [dbo].[FN_HASH_FROM_UINT64_TO_BINARY]
GO


GO
CREATE FUNCTION [dbo].[FN_HASH_FROM_UINT64_TO_BINARY](@QUERY_PLAN_HASH DECIMAL(38,0))
RETURNS BINARY(8)
WITH EXECUTE AS CALLER
AS
	BEGIN
		DECLARE	@NEW_QUERY_PLAN_HASH BINARY(8),
				@BITMASK BIGINT

		SET @BITMASK = 0x8000000000000000
		IF @QUERY_PLAN_HASH < CONVERT(DECIMAL(38,0),@BITMASK)*-1
			SET @NEW_QUERY_PLAN_HASH = CONVERT(BINARY(8),CONVERT(BIGINT,@QUERY_PLAN_HASH))
		ELSE 
			SET @NEW_QUERY_PLAN_HASH = CONVERT(BINARY(8),CONVERT(BIGINT,@QUERY_PLAN_HASH - CONVERT(DECIMAL(38,0),@BITMASK)*-1)|@BITMASK)

		RETURN (@NEW_QUERY_PLAN_HASH);
	END
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[QUERY_ALERTS_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
ALTER VIEW [dbo].[QUERY_ALERTS_VW]
	AS 

	SELECT QA.SERVER_NAME,
       QA.DATABASE_NAME,
       QA.STATS_TIME                                                                                                                                                                           AS ALERT_TIME,
       QA.QUERY_HASH,
       QA.QUERY_PLAN_HASH,
       QHD.EXECUTION_COUNT_TODAY                                                                                                                                                               AS EXECUTIONS_TODAY,
       CAST(QHD.ELAPSED_TIME_TODAY / 1000.000 AS DECIMAL(29, 3))                                                                                                                               AS TOTAL_TIME_TODAY,
       QHD.AVG_TIME_TODAY_MS                                                                                                                                                                   AS AVG_TIME_TODAY,
       CAST(QHD.MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                                                                                                 AS MAX_ELAPSED_TIME,
       REPLACE(REPLACE(QT.SQL_TEXT, 'SELECT ', CHAR(10)+'SELECT '), ' FROM', CHAR(10)+' FROM')
       + CHAR(10) + CHAR(10) + REPLICATE('-', 50)
       + 'QUERY PARAMETERS' + REPLICATE('-', 61)
       + CHAR(10) + QP.SQL_PARMS + CHAR(10) + CHAR(10)
       + REPLICATE('-', 50)
       + 'TABLE NODES FROM QUERY PLAN'
       + REPLICATE('-', 50) + CHAR(10)
       + ISNULL((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE QA.SERVER_NAME = QPV.SERVER_NAME AND QA.DATABASE_NAME = QPV.DATABASE_NAME AND QA.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '') AS QUERY_PLAN_PARSED,
       ISNULL((SELECT MISSING_INDEX_INFO
               FROM   QUERY_PLANS_MISSING_INDEX_VW QPV
               WHERE  QA.SERVER_NAME = QPV.SERVER_NAME
                      AND QA.DATABASE_NAME = QPV.DATABASE_NAME
                      AND QA.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '')                                                                                                                       AS MISSING_INDEXES,
       QP.SQL_PARMS                                                                                                                                                                            AS QUERY_PARAMETER_VALUES,
       QP.QUERY_PLAN,
       QT.SQL_TEXT
FROM   QUERY_ALERTS QA WITH (NOLOCK)
       INNER JOIN QUERY_HISTORY QHD
               ON QA.SERVER_NAME = QHD.SERVER_NAME
                  AND QA.DATABASE_NAME = QHD.DATABASE_NAME
                  AND QA.QUERY_HASH = QHD.QUERY_HASH
                  AND QA.QUERY_PLAN_HASH = QHD.QUERY_PLAN_HASH
				  AND QHD.FLAG = 'D'
                  AND QHD.DATE = DATEADD(day, DATEDIFF(day, 0, QA.STATS_TIME), 0)
       INNER LOOP JOIN QUERY_PLANS QP WITH (NOLOCK)
                    ON QP.QUERY_PLAN_HASH = QA.QUERY_PLAN_HASH
                       AND QP.SERVER_NAME = QA.SERVER_NAME
                       AND QP.DATABASE_NAME = QA.DATABASE_NAME
       LEFT OUTER LOOP JOIN QUERY_TEXT AS QT
                         ON QA.QUERY_HASH = QT.QUERY_HASH
                            AND QA.SERVER_NAME = QT.SERVER_NAME
                            AND QA.DATABASE_NAME = QT.DATABASE_NAME
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[QUERY_HISTORY_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
ALTER VIEW [dbo].[QUERY_HISTORY_VW]
AS

  SELECT QH.SERVER_NAME,
         QH.DATABASE_NAME,
         DATE,
         EXECUTION_COUNT_TODAY                                                                                              AS EXECUTION_COUNT,
         Cast(ELAPSED_TIME_TODAY / 1000.000 AS DECIMAL(29, 3))                                                              AS TOTAL_ELAPSED_TIME,
         QH.AVG_TIME_TODAY_MS                                                                                               AS AVG_ELAPSED_TIME,
         Cast(MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                                AS MAX_ELAPSED_TIME,
         AVG_LOGICAL_READS = CASE EXECUTION_COUNT_TODAY
                               WHEN 0 THEN 0
                               ELSE TOTAL_LOGICAL_READS_TODAY / EXECUTION_COUNT_TODAY
                             END,
         AVG_LOGICAL_READS_MB = CASE EXECUTION_COUNT_TODAY
                               WHEN 0 THEN 0
                               ELSE (TOTAL_LOGICAL_READS_TODAY / EXECUTION_COUNT_TODAY) * 8 /1024
                             END,
         Cast(ELAPSED_TIME_TODAY / 1000.000 AS DECIMAL(29, 3)) - Cast(TOTAL_WORKER_TIME_TODAY / 1000.000 AS DECIMAL(29, 3)) AS TOTAL_WAIT_TIME,
         AVG_ROWS_RETURNED = CASE EXECUTION_COUNT_TODAY
                               WHEN 0 THEN 0
                               ELSE TOTAL_ROWS_TODAY / EXECUTION_COUNT_TODAY
                             END,
        REPLACE(REPLACE(QT.SQL_TEXT,'SELECT ', CHAR(10)+'SELECT '), ' FROM', CHAR(10)+' FROM') + CHAR(10) + CHAR(10) + REPLICATE('-',50) + 'QUERY PARAMETERS'+ REPLICATE('-',61)+CHAR(10)  +QP.SQL_PARMS + CHAR(10)+ CHAR(10)+ 
		REPLICATE('-',50)+'TABLE NODES FROM QUERY PLAN' + REPLICATE('-',50)+CHAR(10)+ISNULL((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE QH.SERVER_NAME = QPV.SERVER_NAME AND QH.DATABASE_NAME = QPV.DATABASE_NAME AND QH.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS QUERY_PLAN_PARSED,
        ISNULL((SELECT MISSING_INDEX_INFO FROM QUERY_PLANS_MISSING_INDEX_VW QPV WHERE QH.SERVER_NAME = QPV.SERVER_NAME AND QH.DATABASE_NAME = QPV.DATABASE_NAME AND QH.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS MISSING_INDEXES,
         QP.SQL_PARMS                                                                                                       AS QUERY_PARAMETER_VALUES,
         QP.QUERY_PLAN,
         QH.QUERY_PLAN_HASH,
         QH.QUERY_HASH,
         QT.SQL_TEXT																										AS SQL_TEXT,
		 TOTAL_ROWS_TODAY                                                                                                   AS TOTAL_ROWS,
         LAST_EXECUTION_TIME                                                                                                AS LAST_EXECUTION_TIME,
         TOTAL_LOGICAL_READS_TODAY                                                                                          AS TOTAL_LOGICAL_READS,
         QH.FLAG                                                                                                            AS FLAG,
		 QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN)
  FROM   QUERY_HISTORY QH WITH (NOLOCK)
         INNER LOOP JOIN QUERY_PLANS QP WITH (NOLOCK)
                      ON QP.QUERY_PLAN_HASH = QH.QUERY_PLAN_HASH
                         AND QP.SERVER_NAME = QH.SERVER_NAME
                         AND QP.DATABASE_NAME = QH.DATABASE_NAME
         LEFT OUTER LOOP JOIN QUERY_TEXT AS QT
                           ON QH.QUERY_HASH = QT.QUERY_HASH
                              AND QH.SERVER_NAME = QT.SERVER_NAME
                              AND QH.DATABASE_NAME = QT.DATABASE_NAME
         LEFT OUTER LOOP JOIN COMMENTS C
                           ON QH.QUERY_HASH = C.QUERY_HASH
                              AND QH.SERVER_NAME = C.SERVER_NAME
                              AND QH.DATABASE_NAME = C.DATABASE_NAME
  WHERE  EXECUTION_COUNT_TODAY > 0
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[MISSING_INDEXES_CURR_VW]...';


GO

ALTER VIEW [dbo].[MISSING_INDEXES_CURR_VW] AS


WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT Q.SERVER_NAME,
       Q.DATABASE_NAME,
       CREATION_TIME                                                                                                  AS COMPILED_TIME,
       EXECUTION_COUNT,
       EXECUTION_COUNT / CASE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                           WHEN 0 THEN 1
                           ELSE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                         END                                                                                          AS EXECUTION_PER_HOUR,
       cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS TOTAL_ELAPSED_TIME,
       Q.AVG_TIME_MS                                                                                                  AS AVG_ELAPSED_TIME,
       cast(MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                            AS MAX_ELAPSED_TIME,
       AVG_LOGICAL_READS = TOTAL_LOGICAL_READS / EXECUTION_COUNT,
       cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3)) - cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))   AS TOTAL_WAIT_TIME,
       AVG_ROWS_RETURNED = TOTAL_ROWS / EXECUTION_COUNT,
       QT.SQL_TEXT                                                                                                    AS SQL_TEXT,
       QP.SQL_PARMS                                                                                                   AS QUERY_PARAMETER_VALUES,
       QUERY_PLAN,
       index_nodeS.value('(../@Impact)[1]', 'float')                                                                  AS INDEX_IMPACT,
       replace(replace(index_nodeS.value('(./@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                        AS TABLE_NAME,
       replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in ./sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "EQUALITY"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') AS EQUALITY_COLUMNS,
       replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in ./sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "INEQUALITY"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') AS INEQUALITY_COLUMNS,
       replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in .//sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "INCLUDE"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') AS INCLUDED_COLUMNS,
       Q.ROW_NUM,
       Q.QUERY_HASH,
       TOTAL_ROWS,
       MAX_ROWS,
       MIN_ROWS,
       PLAN_GENERATION_NUM,
       Q.LAST_EXECUTION_TIME,
       cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS TOTAL_WORKER_TIME,
       AVG_PHYSICAL_READS = TOTAL_PHYSICAL_READS / EXECUTION_COUNT,
       AVG_LOGICAL_WRITES = TOTAL_LOGICAL_WRITES / EXECUTION_COUNT,
       cast(LAST_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS LAST_ELAPSED_TIME,
       cast(MIN_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                            AS MIN_ELAPSED_TIME,
       TOTAL_PHYSICAL_READS,
       LAST_PHYSICAL_READS,
       MIN_PHYSICAL_READS,
       MAX_PHYSICAL_READS,
       TOTAL_LOGICAL_READS,
       LAST_LOGICAL_READS,
       MIN_LOGICAL_READS,
       MAX_LOGICAL_READS,
       TOTAL_LOGICAL_WRITES,
       LAST_LOGICAL_WRITES,
       MIN_LOGICAL_WRITES,
       MAX_LOGICAL_WRITES,
       cast(LAST_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                            AS LAST_WORKER_TIME,
       cast(MIN_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                             AS MIN_WORKER_TIME,
       cast(MAX_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                             AS MAX_WORKER_TIME,
       QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN),
       Q.STATS_TIME,
       SQL_VERSION,
       S.SQL_SERVER_STARTTIME,
       Q.QUERY_PLAN_HASH,
       C.COMMENT
FROM   (SELECT QS2.SERVER_NAME,
               QS2.DATABASE_NAME,
               QUERY_HASH,
               max(QS2.STATS_TIME)      AS STATS_TIME,
               max(LAST_EXECUTION_TIME) AS LAST_EXECUTION_TIME
        FROM   QUERY_STATS QS2
               INNER JOIN STATS_COLLECTION_SUMMARY S2 WITH (NOLOCK)
                       ON QS2.STATS_TIME = S2.STATS_TIME
                          AND QS2.DATABASE_NAME = S2.DATABASE_NAME
                          AND QS2.SERVER_NAME = S2.SERVER_NAME
                          AND S2.RUN_NAME NOT LIKE 'BASE%'
        GROUP  BY QS2.SERVER_NAME,
                  QS2.DATABASE_NAME,
                  QUERY_HASH) AS A
       INNER LOOP JOIN QUERY_STATS Q WITH (NOLOCK)
                    ON A.SERVER_NAME = Q.SERVER_NAME
                       AND A.DATABASE_NAME = Q.DATABASE_NAME
                       AND A.QUERY_HASH = Q.QUERY_HASH
                       AND A.LAST_EXECUTION_TIME = Q.LAST_EXECUTION_TIME
                       AND A.STATS_TIME = Q.STATS_TIME
       INNER JOIN QUERY_PLANS QP WITH (NOLOCK)
               ON QP.QUERY_PLAN_HASH = Q.QUERY_PLAN_HASH
                  AND QP.SERVER_NAME = Q.SERVER_NAME
                  AND QP.DATABASE_NAME = Q.DATABASE_NAME
       CROSS APPLY QP.QUERY_PLAN.nodes('//sp:MissingIndexes/sp:MissingIndexGroup/sp:MissingIndex') AS missing_indexes(index_nodeS)
       INNER JOIN STATS_COLLECTION_SUMMARY S WITH (NOLOCK)
               ON Q.STATS_TIME = S.STATS_TIME
                  AND Q.DATABASE_NAME = S.DATABASE_NAME
                  AND Q.SERVER_NAME = S.SERVER_NAME
       LEFT OUTER JOIN QUERY_TEXT AS QT
                    ON Q.QUERY_HASH = QT.QUERY_HASH
                       AND Q.DATABASE_NAME = QT.DATABASE_NAME
                       AND Q.SERVER_NAME = QT.SERVER_NAME
       LEFT OUTER JOIN COMMENTS C
                    ON Q.QUERY_HASH = C.QUERY_HASH
                       AND Q.SERVER_NAME = C.SERVER_NAME
                       AND Q.DATABASE_NAME = C.DATABASE_NAME
GO
PRINT N'Altering [dbo].[MISSING_INDEXES_VW]...';


GO

ALTER VIEW [dbo].[MISSING_INDEXES_VW] 
AS


WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT Q.SERVER_NAME,
       Q.DATABASE_NAME,
       CREATION_TIME                                                                                                  AS COMPILED_TIME,
       EXECUTION_COUNT,
       EXECUTION_COUNT / CASE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                           WHEN 0 THEN 1
                           ELSE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                         END                                                                                          AS EXECUTION_PER_HOUR,
       cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS TOTAL_ELAPSED_TIME,
       Q.AVG_TIME_MS                                                                                                  AS AVG_ELAPSED_TIME,
       cast(MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                            AS MAX_ELAPSED_TIME,
       AVG_LOGICAL_READS = TOTAL_LOGICAL_READS / EXECUTION_COUNT,
       cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3)) - cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))   AS TOTAL_WAIT_TIME,
       AVG_ROWS_RETURNED = TOTAL_ROWS / EXECUTION_COUNT,
       QT.SQL_TEXT                                                                                                    AS SQL_TEXT,
       QP.SQL_PARMS                                                                                                   AS QUERY_PARAMETER_VALUES,
       QUERY_PLAN,
       index_nodeS.value('(../@Impact)[1]', 'float')                                                                  AS INDEX_IMPACT,
       replace(replace(index_nodeS.value('(./@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                        AS TABLE_NAME,
       replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in ./sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "EQUALITY"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') AS EQUALITY_COLUMNS,
       replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in ./sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "INEQUALITY"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') AS INEQUALITY_COLUMNS,
       replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in .//sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "INCLUDE"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') AS INCLUDED_COLUMNS,
       Q.ROW_NUM,
       Q.QUERY_HASH,
       TOTAL_ROWS,
       MAX_ROWS,
       MIN_ROWS,
       PLAN_GENERATION_NUM,
       LAST_EXECUTION_TIME,
       cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS TOTAL_WORKER_TIME,
       AVG_PHYSICAL_READS = TOTAL_PHYSICAL_READS / EXECUTION_COUNT,
       AVG_LOGICAL_WRITES = TOTAL_LOGICAL_WRITES / EXECUTION_COUNT,
       cast(LAST_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS LAST_ELAPSED_TIME,
       cast(MIN_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                            AS MIN_ELAPSED_TIME,
       TOTAL_PHYSICAL_READS,
       LAST_PHYSICAL_READS,
       MIN_PHYSICAL_READS,
       MAX_PHYSICAL_READS,
       TOTAL_LOGICAL_READS,
       LAST_LOGICAL_READS,
       MIN_LOGICAL_READS,
       MAX_LOGICAL_READS,
       TOTAL_LOGICAL_WRITES,
       LAST_LOGICAL_WRITES,
       MIN_LOGICAL_WRITES,
       MAX_LOGICAL_WRITES,
       cast(LAST_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                            AS LAST_WORKER_TIME,
       cast(MIN_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                             AS MIN_WORKER_TIME,
       cast(MAX_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                             AS MAX_WORKER_TIME,
       QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN),
       S.STATS_TIME,
       SQL_VERSION,
       S.SQL_SERVER_STARTTIME,
       Q.QUERY_PLAN_HASH,
       C.COMMENT
FROM   QUERY_STATS Q WITH (NOLOCK)
       INNER JOIN QUERY_PLANS QP WITH (NOLOCK)
               ON QP.QUERY_PLAN_HASH = Q.QUERY_PLAN_HASH
                  AND QP.SERVER_NAME = Q.SERVER_NAME
                  AND QP.DATABASE_NAME = Q.DATABASE_NAME
       CROSS APPLY QP.QUERY_PLAN.nodes('//sp:MissingIndexes/sp:MissingIndexGroup/sp:MissingIndex') AS missing_indexes(index_nodeS)
       CROSS APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node)
       INNER JOIN STATS_COLLECTION_SUMMARY S WITH (NOLOCK)
               ON Q.STATS_TIME = S.STATS_TIME
                  AND Q.DATABASE_NAME = S.DATABASE_NAME
                  AND Q.SERVER_NAME = S.SERVER_NAME
       LEFT OUTER JOIN QUERY_TEXT AS QT
                    ON Q.QUERY_HASH = QT.QUERY_HASH
       LEFT OUTER JOIN COMMENTS C
                    ON Q.QUERY_HASH = C.QUERY_HASH
                       AND Q.SERVER_NAME = C.SERVER_NAME
                       AND Q.DATABASE_NAME = C.DATABASE_NAME
GO
PRINT N'Altering [dbo].[QUERY_STATS_CURR_VW]...';


GO

ALTER VIEW [dbo].[QUERY_STATS_CURR_VW]
AS

WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT Q.SERVER_NAME,
       Q.DATABASE_NAME,
       CREATION_TIME                                                                                                AS COMPILED_TIME,
       EXECUTION_COUNT,
       EXECUTION_COUNT / CASE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                           WHEN 0 THEN 1
                           ELSE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                         END                                                                                        AS EXECUTION_PER_HOUR,
       cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                        AS TOTAL_ELAPSED_TIME,
       Q.AVG_TIME_MS                                                                                                AS AVG_ELAPSED_TIME,
       cast(MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS MAX_ELAPSED_TIME,
       AVG_LOGICAL_READS = TOTAL_LOGICAL_READS / EXECUTION_COUNT,
       AVG_LOGICAL_READS_MB = (TOTAL_LOGICAL_READS / EXECUTION_COUNT)*8/1024,
	   cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3)) - cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3)) AS TOTAL_WAIT_TIME,
       AVG_ROWS_RETURNED = TOTAL_ROWS / EXECUTION_COUNT,
       REPLACE(REPLACE(QT.SQL_TEXT,'SELECT ', CHAR(10)+'SELECT '), ' FROM', CHAR(10)+' FROM') + CHAR(10) + CHAR(10) + REPLICATE('-',50) + 'QUERY PARAMETERS'+ REPLICATE('-',61)+CHAR(10) +QP.SQL_PARMS + CHAR(10)+ CHAR(10)+
	   REPLICATE('-',50)+'TABLE NODES FROM QUERY PLAN' + REPLICATE('-',50) + CHAR(10) + ISNULL((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE Q.SERVER_NAME = QPV.SERVER_NAME AND Q.DATABASE_NAME = QPV.DATABASE_NAME AND Q.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS QUERY_PLAN_PARSED,
        ISNULL((SELECT MISSING_INDEX_INFO FROM QUERY_PLANS_MISSING_INDEX_VW QPV WHERE Q.SERVER_NAME = QPV.SERVER_NAME AND Q.DATABASE_NAME = QPV.DATABASE_NAME AND Q.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS MISSING_INDEXES,
	   QP.SQL_PARMS                                                                                                 AS QUERY_PARAMETER_VALUES,
       QUERY_PLAN,
       Q.ROW_NUM,
       Q.QUERY_HASH,
       QT.SQL_TEXT AS SQL_TEXT,
	   TOTAL_ROWS,
       MAX_ROWS,
       MIN_ROWS,
       PLAN_GENERATION_NUM,
       Q.LAST_EXECUTION_TIME,
       cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                         AS TOTAL_WORKER_TIME,
       AVG_PHYSICAL_READS = TOTAL_PHYSICAL_READS / EXECUTION_COUNT,
       AVG_LOGICAL_WRITES = TOTAL_LOGICAL_WRITES / EXECUTION_COUNT,
       cast(LAST_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                         AS LAST_ELAPSED_TIME,
       cast(MIN_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS MIN_ELAPSED_TIME,
       TOTAL_PHYSICAL_READS,
       LAST_PHYSICAL_READS,
       MIN_PHYSICAL_READS,
       MAX_PHYSICAL_READS,
       TOTAL_LOGICAL_READS,
       LAST_LOGICAL_READS,
       MIN_LOGICAL_READS,
       MAX_LOGICAL_READS,
       TOTAL_LOGICAL_WRITES,
       LAST_LOGICAL_WRITES,
       MIN_LOGICAL_WRITES,
       MAX_LOGICAL_WRITES,
       cast(LAST_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS LAST_WORKER_TIME,
       cast(MIN_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS MIN_WORKER_TIME,
       cast(MAX_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS MAX_WORKER_TIME,
       QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN),
       S.STATS_TIME,
       SQL_VERSION,
       S.SQL_SERVER_STARTTIME,
       Q.QUERY_PLAN_HASH,
       C.COMMENT
FROM   (SELECT QS2.SERVER_NAME,
               QS2.DATABASE_NAME,
               QUERY_HASH,
               max(QS2.STATS_TIME)      AS STATS_TIME,
               max(LAST_EXECUTION_TIME) AS LAST_EXECUTION_TIME
        FROM   QUERY_STATS QS2
               INNER JOIN STATS_COLLECTION_SUMMARY S2 WITH (NOLOCK)
                       ON QS2.STATS_TIME = S2.STATS_TIME
                          AND QS2.DATABASE_NAME = S2.DATABASE_NAME
                          AND QS2.SERVER_NAME = S2.SERVER_NAME
                          
        GROUP  BY QS2.SERVER_NAME,
                  QS2.DATABASE_NAME,
                  QUERY_HASH,
				  QUERY_PLAN_HASH) AS A
       INNER LOOP JOIN QUERY_STATS Q WITH (NOLOCK)
                    ON A.SERVER_NAME = Q.SERVER_NAME
                       AND A.DATABASE_NAME = Q.DATABASE_NAME
                       AND A.QUERY_HASH = Q.QUERY_HASH
                       AND A.LAST_EXECUTION_TIME = Q.LAST_EXECUTION_TIME
                       AND A.STATS_TIME = Q.STATS_TIME
       INNER JOIN QUERY_PLANS QP WITH (NOLOCK)
               ON QP.QUERY_PLAN_HASH = Q.QUERY_PLAN_HASH
                  AND QP.SERVER_NAME = Q.SERVER_NAME
                  AND QP.DATABASE_NAME = Q.DATABASE_NAME
       INNER JOIN STATS_COLLECTION_SUMMARY S WITH (NOLOCK)
               ON Q.STATS_TIME = S.STATS_TIME
                  AND Q.DATABASE_NAME = S.DATABASE_NAME
                  AND Q.SERVER_NAME = S.SERVER_NAME
       LEFT OUTER JOIN QUERY_TEXT AS QT
                    ON Q.QUERY_HASH = QT.QUERY_HASH
                       AND Q.DATABASE_NAME = QT.DATABASE_NAME
                       AND Q.SERVER_NAME = QT.SERVER_NAME
       LEFT OUTER JOIN COMMENTS C
                    ON Q.QUERY_HASH = C.QUERY_HASH
                       AND Q.SERVER_NAME = C.SERVER_NAME
                       AND Q.DATABASE_NAME = C.DATABASE_NAME
GO
PRINT N'Refreshing [dbo].[HIDDEN_SCANS_CURR_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[HIDDEN_SCANS_CURR_VW]';


GO
PRINT N'Refreshing [dbo].[USER_SCANS_CURR_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[USER_SCANS_CURR_VW]';


GO
PRINT N'Altering [dbo].[QUERY_STATS_VW]...';


GO

ALTER VIEW [dbo].[QUERY_STATS_VW]
AS


WITH STATS_CTE ( SERVER_NAME, DATABASE_NAME, STATS_TIME, COMPILED_TIME, EXECUTION_COUNT, TOTAL_ELAPSED_TIME, AVG_ELAPSED_TIME, MAX_ELAPSED_TIME, AVG_LOGICAL_READS, AVG_LOGICAL_READS_MB, TOTAL_WAIT_TIME, AVG_ROWS_RETURNED, QUERY_PLAN_HASH, QUERY_HASH, TOTAL_ROWS, MAX_ROWS, MIN_ROWS, PLAN_GENERATION_NUM, LAST_EXECUTION_TIME, TOTAL_WORKER_TIME, AVG_PHYSICAL_READS, AVG_LOGICAL_WRITES, LAST_ELAPSED_TIME, MIN_ELAPSED_TIME, TOTAL_PHYSICAL_READS, LAST_PHYSICAL_READS, MIN_PHYSICAL_READS, MAX_PHYSICAL_READS, TOTAL_LOGICAL_READS, LAST_LOGICAL_READS, MIN_LOGICAL_READS, MAX_LOGICAL_READS, TOTAL_LOGICAL_WRITES, LAST_LOGICAL_WRITES, MIN_LOGICAL_WRITES, MAX_LOGICAL_WRITES, LAST_WORKER_TIME, MIN_WORKER_TIME, MAX_WORKER_TIME )
     AS (SELECT QS.SERVER_NAME,
                QS.DATABASE_NAME,
                STATS_TIME,
                MIN(CREATION_TIME)                                                                                                     AS COMPILED_TIME,
                SUM(EXECUTION_COUNT)                                                                                                   AS EXECUTION_COUNT,
                CAST(SUM(TOTAL_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                             AS TOTAL_ELAPSED_TIME,
                AVG(QS.AVG_TIME_MS)                                                                                                    AS AVG_ELAPSED_TIME,
                CAST(SUM(MAX_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                               AS MAX_ELAPSED_TIME,
                AVG_LOGICAL_READS = SUM(TOTAL_LOGICAL_READS) / SUM(EXECUTION_COUNT),
                AVG_LOGICAL_READS_MB = (SUM(TOTAL_LOGICAL_READS) / SUM(EXECUTION_COUNT)) * 8 / 1024,
				CAST(SUM(TOTAL_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3)) - CAST(SUM(TOTAL_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3)) AS TOTAL_WAIT_TIME,
                AVG_ROWS_RETURNED = SUM(TOTAL_ROWS) / SUM(EXECUTION_COUNT),
                QS.QUERY_PLAN_HASH,
                QS.QUERY_HASH,
                SUM(TOTAL_ROWS)                                                                                                        AS TOTAL_ROWS,
                MAX(MAX_ROWS)                                                                                                          AS MAX_ROWS,
                MIN(MIN_ROWS)                                                                                                          AS MIN_ROWS,
                MAX(PLAN_GENERATION_NUM)                                                                                               AS PLAN_GENERATION_NUM,
                MAX(LAST_EXECUTION_TIME)                                                                                               AS LAST_EXECUTION_TIME,
                CAST(SUM(TOTAL_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                              AS TOTAL_WORKER_TIME,
                AVG_PHYSICAL_READS = SUM(TOTAL_PHYSICAL_READS) / SUM(EXECUTION_COUNT),
                AVG_LOGICAL_WRITES = SUM(TOTAL_LOGICAL_WRITES) / SUM(EXECUTION_COUNT),
                CAST(AVG(LAST_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                              AS LAST_ELAPSED_TIME,
                CAST(MIN(MIN_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                               AS MIN_ELAPSED_TIME,
                SUM(TOTAL_PHYSICAL_READS)                                                                                              AS TOTAL_PHYSICAL_READS,
                AVG(LAST_PHYSICAL_READS)                                                                                               AS LAST_PHYSICAL_READS,
                MIN(MIN_PHYSICAL_READS)                                                                                                AS MIN_PHYSICAL_READS,
                MAX(MAX_PHYSICAL_READS)                                                                                                AS MAX_PHYSICAL_READS,
                SUM(TOTAL_LOGICAL_READS)                                                                                               AS TOTAL_LOGICAL_READS,
                AVG(LAST_LOGICAL_READS)                                                                                                AS LAST_LOGICAL_READS,
                MIN(MIN_LOGICAL_READS)                                                                                                 AS MIN_LOGICAL_READS,
                MAX(MAX_LOGICAL_READS)                                                                                                 AS MAX_LOGICAL_READS,
                SUM(TOTAL_LOGICAL_WRITES)                                                                                              AS TOTAL_LOGICAL_WRITES,
                AVG(LAST_LOGICAL_WRITES)                                                                                               AS LAST_LOGICAL_WRITES,
                MIN(MIN_LOGICAL_WRITES)                                                                                                AS MIN_LOGICAL_WRITES,
                MAX(MAX_LOGICAL_WRITES)                                                                                                AS MAX_LOGICAL_WRITES,
                CAST(AVG(LAST_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                               AS LAST_WORKER_TIME,
                CAST(MIN(MIN_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                                AS MIN_WORKER_TIME,
                CAST(MAX(MAX_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                                AS MAX_WORKER_TIME
         FROM   QUERY_STATS QS WITH (NOLOCK)
         GROUP  BY QS.SERVER_NAME,
                   QS.DATABASE_NAME,
                   QS.STATS_TIME,
                   QS.QUERY_HASH,
                   QS.QUERY_PLAN_HASH)
-------------------------------------------------
SELECT CTE.SERVER_NAME,
       CTE.DATABASE_NAME,
       CTE.COMPILED_TIME,
       CTE.EXECUTION_COUNT,
       CTE.EXECUTION_COUNT / CASE ( Datediff(HOUR, CTE.COMPILED_TIME, CTE.STATS_TIME) )
                               WHEN 0 THEN 1
                               ELSE ( Datediff(HOUR, CTE.COMPILED_TIME, CTE.STATS_TIME) )
                             END                                                                                                                                                            AS EXECUTION_PER_HOUR,
       CTE.TOTAL_ELAPSED_TIME,
       CTE.AVG_ELAPSED_TIME,
       CTE.MAX_ELAPSED_TIME,
       CTE.AVG_LOGICAL_READS,
	   CTE.AVG_LOGICAL_READS_MB,
       CTE.TOTAL_WAIT_TIME,
       AVG_ROWS_RETURNED,
       Replace(Replace(QT.SQL_TEXT, 'SELECT ', Char(10)+'SELECT '), ' FROM', Char(10)+' FROM')
       + Char(10) + Char(10) + REPLICATE('-',50) + 'QUERY PARAMETERS'+ REPLICATE('-',61)+CHAR(10)  +QP.SQL_PARMS + CHAR(10)+ CHAR(10)+ 
	   REPLICATE('-',50)+'TABLE NODES FROM QUERY PLAN' + REPLICATE('-',50) + Char(10) + Isnull((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE CTE.SERVER_NAME = QPV.SERVER_NAME AND CTE.DATABASE_NAME = QPV.DATABASE_NAME AND CTE.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '') AS QUERY_PLAN_PARSED,
	    ISNULL((SELECT MISSING_INDEX_INFO FROM QUERY_PLANS_MISSING_INDEX_VW QPV WHERE CTE.SERVER_NAME = QPV.SERVER_NAME AND CTE.DATABASE_NAME = QPV.DATABASE_NAME AND CTE.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS MISSING_INDEXES,
       QP.SQL_PARMS                                                                                                                                                                         AS QUERY_PARAMETER_VALUES,
       QP.QUERY_PLAN,
       CTE.QUERY_HASH,
       CTE.QUERY_PLAN_HASH,
       QT.SQL_TEXT                                                                                                                                                                          AS SQL_TEXT,
       CTE.TOTAL_ROWS,
       CTE.MAX_ROWS,
       CTE.MIN_ROWS,
       CTE.PLAN_GENERATION_NUM,
       CTE.LAST_EXECUTION_TIME,
       CTE.TOTAL_WORKER_TIME,
       CTE.AVG_PHYSICAL_READS,
       CTE.AVG_LOGICAL_WRITES,
       CTE.LAST_ELAPSED_TIME,
       CTE.MIN_ELAPSED_TIME,
       CTE.TOTAL_PHYSICAL_READS,
       CTE.LAST_PHYSICAL_READS,
       CTE.MIN_PHYSICAL_READS,
       CTE.MAX_PHYSICAL_READS,
       CTE.TOTAL_LOGICAL_READS,
       CTE.LAST_LOGICAL_READS,
       CTE.MIN_LOGICAL_READS,
       CTE.MAX_LOGICAL_READS,
       CTE.TOTAL_LOGICAL_WRITES,
       CTE.LAST_LOGICAL_WRITES,
       CTE.MIN_LOGICAL_WRITES,
       CTE.MAX_LOGICAL_WRITES,
       CTE.LAST_WORKER_TIME,
       CTE.MIN_WORKER_TIME,
       CTE.MAX_WORKER_TIME,
       QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN),
	   CTE.STATS_TIME,
       C.COMMENT
FROM   STATS_CTE CTE
       INNER LOOP JOIN QUERY_PLANS QP WITH (NOLOCK)
                    ON QP.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH
                       AND QP.SERVER_NAME = CTE.SERVER_NAME
                       AND QP.DATABASE_NAME = CTE.DATABASE_NAME
       LEFT OUTER LOOP JOIN QUERY_TEXT AS QT
                         ON CTE.QUERY_HASH = QT.QUERY_HASH
                            AND CTE.SERVER_NAME = QT.SERVER_NAME
                            AND CTE.DATABASE_NAME = QT.DATABASE_NAME
       LEFT OUTER LOOP JOIN COMMENTS C
                         ON CTE.QUERY_HASH = C.QUERY_HASH
                            AND CTE.SERVER_NAME = C.SERVER_NAME
                            AND CTE.DATABASE_NAME = C.DATABASE_NAME
GO
PRINT N'Altering [dbo].[SQL_CONFIGURATION_CURR_VW]...';


GO



ALTER VIEW [dbo].[SQL_CONFIGURATION_CURR_VW]
AS



WITH MAX_STATS_CTE (SERVER_NAME, STATS_TIME)
AS
(
SELECT SERVER_NAME,
       max(STATS_TIME)
FROM   SQL_CONFIGURATION
GROUP  BY SERVER_NAME 

)

SELECT DISTINCT C.[SERVER_NAME],
                C.[STATS_TIME],
                S.SQL_SERVER_STARTTIME,
                [NAME],
                [MINIMUM],
                [MAXIMUM],
                [CONFIG_VALUE],
                [RUN_VALUE]
FROM   [dbo].[SQL_CONFIGURATION] C
       INNER JOIN MAX_STATS_CTE CTE
               ON CTE.SERVER_NAME = C.SERVER_NAME
                  AND CTE.STATS_TIME = C.STATS_TIME
       CROSS APPLY (SELECT TOP 1 SQL_SERVER_STARTTIME
                    FROM   STATS_COLLECTION_SUMMARY SCS
                    WHERE  SCS.SERVER_NAME = C.SERVER_NAME
                           AND SCS.STATS_TIME = C.STATS_TIME) AS S
GO
PRINT N'Altering [dbo].[SQL_DATABASEFILES_CURR_VW]...';


GO



ALTER VIEW [dbo].[SQL_DATABASEFILES_CURR_VW]
AS


WITH MAX_STATS_CTE (SERVER_NAME, STATS_TIME)
AS
(
SELECT SERVER_NAME,
       max(STATS_TIME)
FROM   SQL_DATABASEFILES
GROUP  BY SERVER_NAME 

)



SELECT DISTINCT C.[SERVER_NAME],
                C.[DATABASE_NAME],
                [FILE_NAME],
                [PHYSICAL_NAME],
                [FILE_TYPE],
                [DB_SIZE(MB)],
                [DB_INITAL_SIZE(MB)],
                [DB_FREE(MB)],
                [FREE_SPACE_%],
                [GROWTH_UNITS],
                [GROW_MAX_SIZE(MB)],
                C.[STATS_TIME]
FROM   [dbo].[SQL_DATABASEFILES] C
       INNER JOIN MAX_STATS_CTE CTE
               ON CTE.SERVER_NAME = C.SERVER_NAME
                  AND CTE.STATS_TIME = C.STATS_TIME
GO
PRINT N'Altering [dbo].[SQL_DATABASES_CURR_VW]...';


GO


ALTER VIEW [dbo].[SQL_DATABASES_CURR_VW]
AS


WITH MAX_STATS_CTE (SERVER_NAME, STATS_TIME)
AS
(
SELECT SERVER_NAME,
       max(STATS_TIME)
FROM   SQL_DATABASES
GROUP  BY SERVER_NAME 

)



  SELECT DISTINCT C.[SERVER_NAME],
         C.[DATABASE_NAME],
         [DATABASE_ID],
         [RECOVERY_MODEL_DESC],
         [IS_READ_COMMITTED_SNAPSHOT_ON],
         [CREATE_DATE],
         [COMPATIBILITY_LEVEL],
         [COLLATION_NAME],
         [IS_READ_ONLY],
         [IS_AUTO_CLOSE_ON],
         [IS_AUTO_SHRINK_ON],
         [STATE],
         [STATE_DESC],
         [IS_IN_STANDBY],
         [IS_CLEANLY_SHUTDOWN],
         [IS_SUPPLEMENTAL_LOGGING_ENABLED],
         [SNAPSHOT_ISOLATION_STATE],
         [SNAPSHOT_ISOLATION_STATE_DESC],
         [USER_ACCESS],
         [USER_ACCESS_DESC],
         [SOURCE_DATABASE_ID],
         [OWNER_SID],
         [RECOVERY_MODEL],
         [PAGE_VERIFY_OPTION],
         [PAGE_VERIFY_OPTION_DESC],
         [IS_AUTO_CREATE_STATS_ON],
         [IS_AUTO_UPDATE_STATS_ON],
         [IS_AUTO_UPDATE_STATS_ASYNC_ON],
         [IS_ANSI_NULL_DEFAULT_ON],
         [IS_ANSI_NULLS_ON],
         [IS_ANSI_PADDING_ON],
         [IS_ANSI_WARNINGS_ON],
         [IS_ARITHABORT_ON],
         [IS_CONCAT_NULL_YIELDS_NULL_ON],
         [IS_NUMERIC_ROUNDABORT_ON],
         [IS_QUOTED_IDENTIFIER_ON],
         [IS_RECURSIVE_TRIGGERS_ON],
         [IS_CURSOR_CLOSE_ON_COMMIT_ON],
         [IS_LOCAL_CURSOR_DEFAULT],
         [IS_FULLTEXT_ENABLED],
         [IS_TRUSTWORTHY_ON],
         [IS_DB_CHAINING_ON],
         [IS_PARAMETERIZATION_FORCED],
         [IS_MASTER_KEY_ENCRYPTED_BY_SERVER],
         [IS_PUBLISHED],
         [IS_SUBSCRIBED],
         [IS_MERGE_PUBLISHED],
         [IS_DISTRIBUTOR],
         [IS_SYNC_WITH_BACKUP],
         [SERVICE_BROKER_GUID],
         [IS_BROKER_ENABLED],
         [LOG_REUSE_WAIT],
         [LOG_REUSE_WAIT_DESC],
         [IS_DATE_CORRELATION_ON],
         C.[STATS_TIME]
  FROM   [dbo].[SQL_DATABASES] C
            INNER JOIN MAX_STATS_CTE CTE
               ON CTE.SERVER_NAME = C.SERVER_NAME
                  AND CTE.STATS_TIME = C.STATS_TIME
GO
PRINT N'Altering [dbo].[SQL_JOBS_CURR_VW]...';


GO

ALTER VIEW [dbo].[SQL_JOBS_CURR_VW]
AS


WITH MAX_STATS_CTE (SERVER_NAME, STATS_TIME)
AS
(
SELECT SERVER_NAME,
       max(STATS_TIME)
FROM   SQL_JOBS
GROUP  BY SERVER_NAME 

)


  SELECT DISTINCT C.[SERVER_NAME],
         [JOBNAME],
         [SCHEDULENAME],
         [FREQUENCY],
         [SUBFREQUENCY],
         [SCHEDULETIME],
         [NEXTRUNDATE],
         [STEP_ID],
         [STEP_NAME],
         [SUBSYSTEM],
         [COMMAND],
         C.[STATS_TIME]
  FROM   [dbo].[SQL_JOBS] C
            INNER JOIN MAX_STATS_CTE CTE
               ON CTE.SERVER_NAME = C.SERVER_NAME
                  AND CTE.STATS_TIME = C.STATS_TIME
GO
PRINT N'Altering [dbo].[DYNPERF_PROCESS_QUERY_ALERTS]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PROCESS_QUERY_ALERTS]
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @PCT_AVG_TIME_CHANGE_DAY int, @PCT_AVG_TIME_CHANGE_MONTH INT
	DECLARE @MIN_EXECUTION_COUNTS INT, @MIN_AVG_TIME_MS INT
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




SELECT @PCT_AVG_TIME_CHANGE_DAY = PCT_AVG_TIME_CHANGE_DAY,
       @PCT_AVG_TIME_CHANGE_MONTH = PCT_AVG_TIME_CHANGE_MONTH,
       @MIN_EXECUTION_COUNTS = MIN_EXECUTION_COUNTS,
       @MIN_AVG_TIME_MS = MIN_AVG_TIME_MS
FROM   QUERY_ALERTS_CONFIG
WHERE  SERVER_NAME = @SERVER_NAME
       AND DATABASE_NAME = @DATABASE_NAME 


--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
  --REH in this case, we are going to compare to STATS_TIME which is the DynamicsPerf Time Zone so convert last_run back into that time

     SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset

  END 


  IF @PCT_AVG_TIME_CHANGE_DAY IS NULL RETURN(0)  --REH No settings for this server/db just return and do nothing

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH SAME QUERY_HASH/PLAN_HASH , true parm sniffing query issue

INSERT QUERY_ALERTS
SELECT DISTINCT QS_CTE.SERVER_NAME,
       QS_CTE.STATS_TIME,
       QS_CTE.DATABASE_NAME,
       QS_CTE.QUERY_HASH,
       QS_CTE.QUERY_PLAN_HASH
FROM    (SELECT SERVER_NAME,
					   DATABASE_NAME,
					   STATS_TIME,
					   QUERY_HASH,
					   QUERY_PLAN_HASH,
					   SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                               AS TOTAL_TIME_MS,
					   SUM(EXECUTIONS_THIS_PERIOD)                                                            AS TOTAL_EXECUTIONS,
					   CASE SUM(EXECUTIONS_THIS_PERIOD)
						 WHEN 0 THEN 0
						 ELSE ( SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3))) / SUM(EXECUTIONS_THIS_PERIOD) )
					   END                                                                                    AS AVG_TIME_MS,
					   SUM(CAST(WORKER_TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                        AS WORK_TIME,
					   SUM(CAST(( TIME_THIS_PERIOD - WORKER_TIME_THIS_PERIOD ) / 1000.000 AS DECIMAL(14, 3))) AS WAIT_TIME
			FROM   QUERY_STATS_CTE_VW CTE WITH (NOLOCK)
			WHERE  
				--QS.SERVER_NAME = CTE.SERVER_NAME AND QS.DATABASE_NAME=CTE.DATABASE_NAME AND
				--QS.STATS_TIME = CTE.STATS_TIME 
				--AND QS.QUERY_HASH = CTE.QUERY_HASH AND QS.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH AND
				 CTE.DATABASE_NAME = @DATABASE_NAME AND CTE.SERVER_NAME = @SERVER_NAME
				AND CTE.STATS_TIME > @LAST_RUN

			GROUP  BY SERVER_NAME,
						DATABASE_NAME,
				         STATS_TIME,
						QUERY_HASH,
						QUERY_PLAN_HASH) AS QS_CTE

       INNER JOIN QUERY_HISTORY QHD 
               ON QHD.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHD.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHD.QUERY_HASH = QS_CTE.QUERY_HASH
                  AND QHD.QUERY_PLAN_HASH = QS_CTE.QUERY_PLAN_HASH
                  AND QHD.FLAG = 'D'
                  AND QHD.DATE = DATEADD(DAY, DATEDIFF(DAY, 0, QS_CTE.STATS_TIME), 0)
       INNER JOIN QUERY_HISTORY QHM
               ON QHM.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHM.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHM.QUERY_HASH = QS_CTE.QUERY_HASH
                  AND QHM.QUERY_PLAN_HASH = QS_CTE.QUERY_PLAN_HASH
                  AND QHM.FLAG = 'M'
                  AND QHM.DATE = DATEADD(MONTH, DATEDIFF(MONTH, 0, QS_CTE.STATS_TIME), 0)
WHERE  QS_CTE.SERVER_NAME = @SERVER_NAME
       AND QS_CTE.DATABASE_NAME = @DATABASE_NAME
       AND QS_CTE.STATS_TIME > @LAST_RUN
       AND ( ( QS_CTE.AVG_TIME_MS  > QHD.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_DAY/100
                OR QS_CTE.AVG_TIME_MS   > QHM.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_MONTH/100 )
             AND QS_CTE.AVG_TIME_MS   > @MIN_AVG_TIME_MS
             AND QS_CTE.TOTAL_EXECUTIONS > @MIN_EXECUTION_COUNTS ) 
			 option (maxdop 1)
--REH any variation 
INSERT QUERY_ALERTS
SELECT DISTINCT QS_CTE.SERVER_NAME,
       QS_CTE.STATS_TIME,
       QS_CTE.DATABASE_NAME,
       QS_CTE.QUERY_HASH,
       QS_CTE.QUERY_PLAN_HASH
FROM    (SELECT TOP 100 SERVER_NAME,
					   DATABASE_NAME,
					   STATS_TIME,
					   QUERY_HASH,
					   QUERY_PLAN_HASH,
					   SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                               AS TOTAL_TIME_MS,
					   SUM(EXECUTIONS_THIS_PERIOD)                                                            AS TOTAL_EXECUTIONS,
					   CASE SUM(EXECUTIONS_THIS_PERIOD)
						 WHEN 0 THEN 0
						 ELSE ( SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3))) / SUM(EXECUTIONS_THIS_PERIOD) )
					   END                                                                                    AS AVG_TIME_MS,
					   SUM(CAST(WORKER_TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                        AS WORK_TIME,
					   SUM(CAST(( TIME_THIS_PERIOD - WORKER_TIME_THIS_PERIOD ) / 1000.000 AS DECIMAL(14, 3))) AS WAIT_TIME
			FROM   QUERY_STATS_CTE_VW CTE WITH (NOLOCK)
			WHERE  
				--QS.SERVER_NAME = CTE.SERVER_NAME AND QS.DATABASE_NAME=CTE.DATABASE_NAME AND
				--QS.STATS_TIME = CTE.STATS_TIME 
				--AND QS.QUERY_HASH = CTE.QUERY_HASH AND QS.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH AND
				 CTE.DATABASE_NAME = @DATABASE_NAME AND CTE.SERVER_NAME = @SERVER_NAME
				AND CTE.STATS_TIME > @LAST_RUN

			GROUP  BY SERVER_NAME,
						DATABASE_NAME,
				         STATS_TIME,
						QUERY_HASH,
						QUERY_PLAN_HASH) AS QS_CTE

       CROSS APPLY (SELECT SERVER_NAME, DATABASE_NAME, QUERY_HASH, MAX(QHD.AVG_TIME_TODAY_MS) AS AVG_TIME_TODAY_MS
				FROM  QUERY_HISTORY QHD
               WHERE QHD.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHD.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHD.QUERY_HASH = QS_CTE.QUERY_HASH
				  AND QHD.QUERY_PLAN_HASH <> QS_CTE.QUERY_PLAN_HASH
                  AND QHD.FLAG = 'D'
                  AND QHD.DATE = DATEADD(DAY, DATEDIFF(DAY, 0, QS_CTE.STATS_TIME), 0)
				  GROUP BY SERVER_NAME, DATABASE_NAME, QUERY_HASH
				  ) AS QHDAILY
       CROSS APPLY ( SELECT SERVER_NAME, DATABASE_NAME, QUERY_HASH, MAX(QHM.AVG_TIME_TODAY_MS) AS AVG_TIME_TODAY_MS
				FROM  QUERY_HISTORY QHM
               WHERE QHM.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHM.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHM.QUERY_HASH = QS_CTE.QUERY_HASH
				  AND QHM.QUERY_PLAN_HASH <> QS_CTE.QUERY_PLAN_HASH
                  AND QHM.FLAG = 'M'
                  AND QHM.DATE = DATEADD(MONTH, DATEDIFF(MONTH, 0, QS_CTE.STATS_TIME), 0)
				  GROUP BY SERVER_NAME, DATABASE_NAME, QUERY_HASH
				  ) AS QHMONTHLY
WHERE  QS_CTE.SERVER_NAME = @SERVER_NAME
       AND QS_CTE.DATABASE_NAME = @DATABASE_NAME
       AND QS_CTE.STATS_TIME > @LAST_RUN
       AND ( ( QS_CTE.AVG_TIME_MS  > QHDAILY.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_DAY/100
                OR QS_CTE.AVG_TIME_MS   > QHMONTHLY.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_MONTH/100 )
             AND QS_CTE.AVG_TIME_MS   > @MIN_AVG_TIME_MS
             AND QS_CTE.TOTAL_EXECUTIONS > @MIN_EXECUTION_COUNTS ) 
option (maxdop 1)



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_AX_SQLTRACE]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_AX_SQLTRACE (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/
--REH Moved the synonms to avoid SQL runtime error that columns don't exists.  

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')




/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures

--REH @LAST_RUN IS UTC TIME WHICH IS WHAT WE NEED IN THIS SPROC AND THIS SPROC ALONE


--IF @LAST_RUN > '1/1/1901'
--  BEGIN
--      IF @REMOTE_SERVER = 'N'
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
--        END
--      ELSE
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
--        END
--  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = '#AX_VERSION') 
 DROP TABLE  #AX_VERSION 

--REH Get AX version

DECLARE @AX_SERVER_NAME   NVARCHAR(128) = NULL,
        @AX_DATABASE_NAME NVARCHAR(128),
        @AX_APP_BUILD     NVARCHAR(120),
        @KERNEL_BUILD     NVARCHAR(20)
   
   CREATE TABLE #AX_VERSION
     (
        AX_APP_BUILD NVARCHAR(120),
        KERNEL_BUILD NVARCHAR(20)
     )
   
   SET NOCOUNT ON
   
   INSERT #AX_VERSION
   EXECUTE DYNPERF_AX_VERSION_INFO
     @AX_SERVER_NAME = @SERVER_NAME,
     @AX_DATABASE_NAME = @DATABASE_NAME--, @DEBUG = 'N'
   SELECT @AX_APP_BUILD = AX_APP_BUILD,
          @KERNEL_BUILD = KERNEL_BUILD
   FROM   #AX_VERSION
   
   --PRINT 'AX BUILD = ' + ISNULL(@AX_APP_BUILD, '')
   
   --PRINT 'KERNEL BUILD = '+ ISNULL(@KERNEL_BUILD, '')
   
IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = '#AX_VERSION') 
 BEGIN 
	DROP TABLE  #AX_VERSION 
 END
   

  
IF Substring(@AX_APP_BUILD, 1, 1) BETWEEN N'3' AND N'4'
BEGIN


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  EXEC('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


INSERT INTO AX_SQLTRACE 
		   (SERVER_NAME
		   ,STATS_TIME
		   ,DATABASE_NAME
		   ,SQL_DURATION
		   ,TRACE_CATEGORY
		   ,SQL_TEXT
		   ,CALL_STACK
		   ,TRACE_EVENT_CODE
		   ,TRACE_EVENT_DESC
		   ,TRACE_EVENT_DETAILS
		   ,CONNECTION_TYPE
		   ,SQL_SESSION_ID
		   ,AX_CONNECTION_ID
		   ,IS_LOBS_INCLUDED
		   ,IS_MORE_DATA_PENDING
		   ,ROWS_AFFECTED
		   ,ROW_SIZE
		   ,ROWS_PER_FETCH
		   ,IS_SELECTED_FOR_UPDATE
		   ,IS_STARTED_WITHIN_TRANSACTION
		   ,SQL_TYPE
		   ,STATEMENT_ID
		   ,STATEMENT_REUSE_COUNT
		   ,DETAIL_TYPE
		   ,CREATED_DATETIME
		   ,AX_USER_ID)
		SELECT @SERVER_NAME,
			@STATS_DATE,
			@DATABASE_NAME,
			TRACETIME
			,CATEGORY
			,STATEMENT
			,CALLSTACK
			,CODE
			,TEXT
			,TEXTDETAILS
			,CONNECTIONTYPE
			,CONNECTIONSPID
			,CONNECTIONID
			,ISLOBSINCLUDED
			,ISMOREDATAPENDING
			,ROWSAFFECTED
			,ROWSIZE
			,ROWSPERFETCH
			,ISSELECTEDFORUPDATE
			,ISSTARTEDWITHINTRANSACTION
			,STATEMENTTYPE
			,STATEMENTID
			,STATEMENTREUSECOUNT
			,DETAILTYPE
			,  DATEADD(MI, @SQL_TZ_OFFSET, DATEADD(S, CREATEDTIME, CREATEDDATE))      
			,CREATEDBY
			
			
		FROM DYN_AXTRACE_AX_SYSTRACETABLE WITH (NOLOCK)
		WHERE DATEADD(S, CREATEDTIME, CREATEDDATE) >= @LAST_RUN
	 AND DATEADD(D, 14, CREATEDDATE) >= GETDATE()


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')
	
END

IF Substring(@AX_APP_BUILD, 1, 2) IN ('5.', '6.', '7.') 
    BEGIN	
	
	
IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

INSERT INTO AX_SQLTRACE 
		   (SERVER_NAME
		   ,STATS_TIME
		   ,DATABASE_NAME
		   ,SQL_DURATION
		   ,TRACE_CATEGORY
		   ,SQL_TEXT
		   ,CALL_STACK
		   ,TRACE_EVENT_CODE
		   ,TRACE_EVENT_DESC
		   ,TRACE_EVENT_DETAILS
		   ,CONNECTION_TYPE
		   ,SQL_SESSION_ID
		   ,AX_CONNECTION_ID
		   ,IS_LOBS_INCLUDED
		   ,IS_MORE_DATA_PENDING
		   ,ROWS_AFFECTED
		   ,ROW_SIZE
		   ,ROWS_PER_FETCH
		   ,IS_SELECTED_FOR_UPDATE
		   ,IS_STARTED_WITHIN_TRANSACTION
		   ,SQL_TYPE
		   ,STATEMENT_ID
		   ,STATEMENT_REUSE_COUNT
		   ,DETAIL_TYPE
		   ,CREATED_DATETIME
		   ,AX_USER_ID)
		SELECT @SERVER_NAME,
			@STATS_DATE,
			@DATABASE_NAME,
			TRACETIME
			,CATEGORY
			,STATEMENT
			,CALLSTACK
			,CODE
			,TEXT
			,TEXTDETAILS
			,CONNECTIONTYPE
			,CONNECTIONSPID
			,CONNECTIONID
			,ISLOBSINCLUDED
			,ISMOREDATAPENDING
			,ROWSAFFECTED
			,ROWSIZE
			,ROWSPERFETCH
			,ISSELECTEDFORUPDATE
			,ISSTARTEDWITHINTRANSACTION
			,STATEMENTTYPE
			,STATEMENTID
			,STATEMENTREUSECOUNT
			,DETAILTYPE
			,DATEADD(MI, @SQL_TZ_OFFSET, CREATEDDATETIME)
			,CREATEDBY
	
		FROM DYN_AXTRACE_AX_SYSTRACETABLE WITH (NOLOCK)
		WHERE CREATEDDATETIME >= @LAST_RUN
	 AND DATEADD(D, 14, CREATEDDATETIME) >= GETDATE()
	
	END
	
IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
 EXEC('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')
  
  	
 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE')



    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_PROCESS_AXSQLTRACE]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PROCESS_AXSQLTRACE]
		(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



UPDATE AST
SET    QUERY_HASH = COALESCE((SELECT TOP 1 QUERY_HASH
                     FROM   QUERY_TEXT QT WITH (NOLOCK)
                     WHERE  QT.SERVER_NAME = AST.SERVER_NAME
                            AND QT.DATABASE_NAME = AST.DATABASE_NAME
                            AND QT.SQL_TEXT LIKE REPLACE(AST.SQL_TEXT, '?', '%')), 0X00) --REH There could be several. We are only getting the first
FROM   AX_SQLTRACE AST
WHERE  SERVER_NAME = @SERVER_NAME
       AND DATABASE_NAME = @DATABASE_NAME
       AND AST.QUERY_HASH IS NULL 
	   AND LEN(AST.SQL_TEXT) < 4000 --REH LIKE command is limited to 8k characters

--UPDATE AST
--SET    QUERY_HASH = (SELECT TOP 1 QUERY_HASH
--                     FROM   QUERY_TEXT QT
--                     WHERE  QT.SERVER_NAME = AST.SERVER_NAME
--                            AND QT.DATABASE_NAME = AST.DATABASE_NAME
--                            AND QT.SQL_TEXT LIKE REPLACE(AST.SQL_TEXT, '?', '%')) --REH There could be several. We are only getting the first
--FROM   AX_SQLTRACE AST WITH (READPAST)
--WHERE  SERVER_NAME = @SERVER_NAME
--       AND DATABASE_NAME = @DATABASE_NAME
--       AND AST.QUERY_HASH IS NULL 
--	   AND LEN(AST.SQL_TEXT) <= 4000 --REH LIKE command is limited to 8k characters NVARCHAR 4k = 8k characters
--	   AND AST.CREATED_DATETIME > DATEADD(DD,CAST(@TASK_PARAMS as INT) * -1,@LAST_RUN)  --REH keep trying to parse queries for X days, based on @task_params


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_PROCESS_QUERY_PLANS]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PROCESS_QUERY_PLANS]
       (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
                                                                             @AZURE_DB           BIT,
                                                                             @SQL_TZ_OFFSET INT,
                                                                             @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH Need to delete any old data in case QUERY_PLAN refresh updates the flag.  We need to delete old parsed plans

DELETE QPP
FROM   QUERY_PLANS_PARSED QPP
       INNER JOIN QUERY_PLANS QP WITH (NOLOCK)
               ON QPP.SERVER_NAME = QP.SERVER_NAME
                  AND QPP.DATABASE_NAME = QP.DATABASE_NAME
                  AND QPP.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
WHERE  QP.PARSED_FLAG = 0 and QP.SERVER_NAME = @SERVER_NAME and QP.DATABASE_NAME = @DATABASE_NAME


;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT	TOP 10000	QT.SERVER_NAME, QT.DATABASE_NAME, QT.[QUERY_PLAN_HASH],
 CONVERT (NVARCHAR(MAX), index_node.query('for $qplan in //sp:QueryPlan, $plist in $qplan/sp:ParameterList, $colref in $plist/sp:ColumnReference  return concat(string($colref/@Column),":",string($colref/@ParameterCompiledValue),",   "),"  "')) as SQL_PARAMS,
 CASE WHEN CAST(QT.QUERY_PLAN AS NVARCHAR(MAX)) LIKE '%MissingIndex%' THEN 1 ELSE 0 END as MI_FLAG
INTO #PARSE_PLANS

  FROM [QUERY_PLANS] QT WITH (NOLOCK)
  	
      OUTER APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node)
    
WHERE PARSED_FLAG = 0 AND SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME



--REH Parse out the QUERY_PLANS table into it's vital statistics

 ;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)

 INSERT QUERY_PLANS_PARSED
 SELECT *
FROM   (SELECT QUERY_PLANS.SERVER_NAME, QUERY_PLANS.DATABASE_NAME, QUERY_PLANS.QUERY_PLAN_HASH,
			   CAST(isnull(index_node.value('(..//@NodeId)[1]', 'nvarchar(128)'),'0') AS INT) AS NodeID,
               CAST(Replace(Replace(index_node.value('(.//@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '') AS NVARCHAR(128))  AS TABLE_NAME,
               CAST(Replace(Replace(index_node.value('(.//@Index)[1]', 'NVARCHAR(128)'), '[', ''), ']', '') AS NVARCHAR(128)) AS INDEX_NAME,
			   CAST(isnull(index_node.value('(.//@Lookup)[1]', 'nvarchar(128)'),'0') AS INT) AS LOOKUP,
			   CAST(isnull(index_node.value('(..//@Parallel)[1]', 'nvarchar(128)'),'0') AS INT) AS PARALLEL,
			   CAST(index_node.value('(..//@PhysicalOp)[1]', 'nvarchar(128)') AS NVARCHAR(128)) AS PHYSICALOP,
			   CAST(index_node.value('(..//@LogicalOp)[1]', 'nvarchar(128)') AS NVARCHAR(128)) AS LOGICALOP,
			   CAST(str(ISNULL(index_node.value('(..//@EstimateRows)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(14,0)) AS ESTIMATEROWS,
			   CAST(str(ISNULL(index_node.value('(..//@EstimateIO)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(20,7)) AS EstimateIO,
			   CAST(str(ISNULL(index_node.value('(..//@EstimateCPU)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(20,7)) AS ESTIMATECPU,
			   CAST(str(ISNULL(index_node.value('(..//@AvgRowSize)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(14,0)) AS AVGROWSIZE,
			   CAST(str(isnull(index_node.value('(..//@EstimatedTotalSubtreeCost)[1]', 'nvarchar(128)') ,'0.0'),30,17) AS DECIMAL (20,7)) AS ESTIMATEDTOTALSUBTREECOST,
               CONVERT(NVARCHAR(MAX), index_node.query('for $seekpredicate in ./sp:SeekPredicates,
                                                            $rangecolumns in $seekpredicate//sp:RangeColumns,
                                                            $columnreference in $rangecolumns/sp:ColumnReference
                                        return string($columnreference/@Column)'))        AS SEEK_COLUMNS,

              CONVERT(NVARCHAR(MAX), index_node.query('for $predicate2 in ./sp:Predicate,
                                                           $Ident in  $predicate2//sp:Identifier,
														   $COLREF2 in  $Ident/sp:ColumnReference
                                                            
                                        return string($COLREF2/@Column)')) AS PREDICATES,

		    REPLACE( REPLACE( CONVERT(NVARCHAR(MAX), index_node.query('for $predicate in ./sp:Predicate,
                                                $rangecolumn in $predicate//sp:ScalarOperator
                                                            
                            return string($rangecolumn/@ScalarString)'))
							,'&lt;', '<')   ,'&gt;', '>')         AS PREDICATE_TEXT
        FROM   QUERY_PLANS WITH (NOLOCK)
			INNER JOIN #PARSE_PLANS ON QUERY_PLANS.SERVER_NAME = #PARSE_PLANS.SERVER_NAME
					AND QUERY_PLANS.DATABASE_NAME = #PARSE_PLANS.DATABASE_NAME
					AND QUERY_PLANS.QUERY_PLAN_HASH = #PARSE_PLANS.QUERY_PLAN_HASH
			OUTER APPLY QUERY_PLAN.nodes('//sp:RelOp/sp:IndexScan') AS SeekPredicates(index_node)
               --CROSS APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node2)
			WHERE QUERY_PLANS.SERVER_NAME = @SERVER_NAME AND QUERY_PLANS.DATABASE_NAME = @DATABASE_NAME
			   AND QUERY_PLANS.PARSED_FLAG = 0

			   ) A
			   OPTION(MAXDOP 1)


UPDATE QP SET SQL_PARMS = PP.SQL_PARAMS
, MI_FLAG = PP.MI_FLAG
, PARSED_FLAG = 1

FROM QUERY_PLANS QP
INNER JOIN #PARSE_PLANS PP ON QP.SERVER_NAME = PP.SERVER_NAME
			AND QP.DATABASE_NAME = PP.DATABASE_NAME
			AND QP.QUERY_PLAN_HASH = PP.QUERY_PLAN_HASH

 WHERE QP.SERVER_NAME = @SERVER_NAME AND QP.DATABASE_NAME = @DATABASE_NAME AND QP.PARSED_FLAG = 0 
 OPTION(MAXDOP 1)
 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_REFRESH_QUERY_PLANS]...';


GO
ALTER PROCEDURE [dbo].DYNPERF_REFRESH_QUERY_PLANS
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @REFRESH_PLAN_DAYS INT
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_RQP_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_RQP_STATS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_RQP_STATS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.dm_exec_query_stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_RQP_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_query_stats'

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


  SELECT @REFRESH_PLAN_DAYS = REFRESH_PLAN_DAYS FROM DATABASES_2_COLLECT WHERE LINKED_SERVER = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @REMOTE_SERVER = 'N'
BEGIN
;WITH Query_Stats_CTE (SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH, PLAN_HANDLE )
     AS
     -- Define the CTE query.
     (SELECT  * FROM 
     (SELECT DISTINCT SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH,
                      PLAN_HANDLE
      FROM   QUERY_STATS AS QS WITH (NOLOCK)
      WHERE  STATS_TIME > DATEADD(D,-1,GETDATE())  --REH ANY QUERIES COLLECTED IN THE LAST DAY
             AND DATABASE_NAME = @DATABASE_NAME
             AND SERVER_NAME = @SERVER_NAME 
             AND QUERY_PLAN_HASH > 0x00000000
             AND  EXISTS (SELECT 'X'
                             FROM   QUERY_PLANS QP WITH (NOLOCK)
                             WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
                                    AND QS.DATABASE_NAME = QP.DATABASE_NAME
                                    AND QS.SERVER_NAME = QP.SERVER_NAME 
									AND QP.DATE_UPDATED <= DATEADD(D,-@REFRESH_PLAN_DAYS,GETDATE() ) --REH ANY PLANS THAT HAVEN'T BEEN UPDATED IN THE LAST 7 DAYS
									)) AS A)
									 
UPDATE QP 
SET QUERY_PLAN = COALESCE(RH.QUERY_PLAN,QP.QUERY_PLAN), DATE_UPDATED = GETDATE(), PARSED_FLAG = 0
FROM   QUERY_PLANS QP
INNER JOIN (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_PLAN_HASH
                        ORDER BY CTE.QUERY_PLAN_HASH DESC),
                        SERVER_NAME, 
                        DATABASE_NAME,
               CTE.QUERY_PLAN_HASH,
               query_plan AS QUERY_PLAN
        FROM   Query_Stats_CTE CTE
               OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH ON RH.SERVER_NAME = QP.SERVER_NAME AND RH.DATABASE_NAME = QP.DATABASE_NAME
               AND RH.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
WHERE  RN = 1 AND QP.SERVER_NAME = @SERVER_NAME AND QP.DATABASE_NAME = @DATABASE_NAME


END

IF @REMOTE_SERVER = 'Y'
     BEGIN
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)


         SET @SQL = '
				CREATE TABLE [tempdb].dbo.DYNPERF_QUERY_HASH
				(
				QUERY_PLAN_HASH VARBINARY(64), 
				PLAN_HANDLE VARBINARY(64)
				)'

		IF @DEBUG = 'Y'
		BEGIN
         PRINT @SQL
		 END


         SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT [' + @SERVER_NAME
									 + ']'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

         SET @SQL = '

					;WITH Query_Stats_CTE ( QUERY_PLAN_HASH, PLAN_HANDLE)
						 AS (SELECT DISTINCT QUERY_PLAN_HASH,
										  PLAN_HANDLE
							 FROM   QUERY_STATS QS WITH (NOLOCK)
							 WHERE  QS.STATS_TIME >=  DATEADD(D,-1,GETDATE()) 
							  AND QUERY_PLAN_HASH > 0x00000000
									AND DATABASE_NAME = '
										+ '''' + @DATABASE_NAME + ''''
										+ '
									AND SERVER_NAME = ' + '''' +
										+ @SERVER_NAME + ''''
										+ ' 
									AND EXISTS (SELECT ''X''
													FROM   QUERY_PLANS QP WITH (NOLOCK)
												 WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
														AND QS.DATABASE_NAME = QP.DATABASE_NAME
														AND QS.SERVER_NAME = QP.SERVER_NAME 
															AND QP.DATE_UPDATED <= DATEADD(D,-' + CAST(@REFRESH_PLAN_DAYS AS VARCHAR(4)) +',GETDATE() ) 
													))
						INSERT INTO OPENQUERY([' + @SERVER_NAME
										+ '], ''SELECT QUERY_PLAN_HASH, PLAN_HANDLE FROM [tempdb].dbo.DYNPERF_QUERY_HASH'')
					                            
					  
					SELECT QUERY_PLAN_HASH, PLAN_HANDLE 
					FROM   (SELECT RN = ROW_NUMBER()
										  OVER (
											PARTITION BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE
											ORDER BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE DESC),
								   CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE 
					            
								FROM   Query_Stats_CTE CTE
							   ) AS RH
					WHERE  RN = 1 '

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END 


         EXEC(@SQL)



			SET @SQL = 'SELECT 
				   QUERY_PLAN_HASH,
				   cast(query_plan as nvarchar(max)) as QUERY_PLAN

			FROM   (SELECT RN = ROW_NUMBER()
								  OVER (
									PARTITION BY QUERY_PLAN_HASH
									ORDER BY QUERY_PLAN_HASH DESC),
						   QUERY_PLAN_HASH,
						   query_plan 
					FROM   [tempdb].dbo.DYNPERF_QUERY_HASH CTE
						   OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH
			WHERE  RN = 1 ' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  UPDATE DynamicsPerf.dbo.QUERY_PLANS
						 SET QUERY_PLAN =  COALESCE( RH.QUERY_PLAN, QUERY_PLANS.QUERY_PLAN), PARSED_FLAG = 0, DATE_UPDATED = ' + '''' + CAST(GETDATE() AS VARCHAR(20)) + '''' 
						 + 'FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') AS RH
						 WHERE SERVER_NAME = ' + '''' + @SERVER_NAME + '''' +
						  '   AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + 
						  '  AND RH.QUERY_PLAN_HASH = QUERY_PLANS.QUERY_PLAN_HASH' 

		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)
         

		 --REH Drop the table at the end of the process

         SET @SQL = '

				IF EXISTS (SELECT * FROM  [' + @DATABASE_NAME + '].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
				 DROP TABLE  [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)
     
     END 




UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_REFRESH_QUERY_TEXT]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_REFRESH_QUERY_TEXT]
 (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @REFRESH_PLAN_DAYS INT
    
/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


  SELECT @REFRESH_PLAN_DAYS = REFRESH_PLAN_DAYS FROM DATABASES_2_COLLECT WHERE LINKED_SERVER = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



IF @REMOTE_SERVER = 'N'
     BEGIN ;
         WITH Query_Stats_CTE ( QUERY_HASH)
              AS (SELECT  QUERY_HASH
                  FROM   QUERY_STATS QS WITH (NOLOCK)
                  WHERE  QS.STATS_TIME >= DATEADD(D,-1,GETDATE())
                         AND DATABASE_NAME = @DATABASE_NAME
                         AND SERVER_NAME = @SERVER_NAME 
						 AND QUERY_HASH > 0x0000000000
                         AND  EXISTS (SELECT 'X'
                                         FROM   QUERY_TEXT QT WITH (NOLOCK)
                                         WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                                AND QS.SERVER_NAME = QT.SERVER_NAME
												AND QT.DATE_UPDATED <= DATEADD(D,-@REFRESH_PLAN_DAYS,GETDATE() ) --REH ANY PLANS THAT HAVEN'T BEEN UPDATED IN THE LAST 7 DAYS
												 ))
    --     INSERT QUERY_TEXT
    --     SELECT @SERVER_NAME,
    --            @DATABASE_NAME,
    --            QUERY_HASH,
    --            SQL_TEXT,
				--@STATS_DATE
				
	UPDATE QT 
	SET SQL_TEXT = COALESCE(RH.SQL_TEXT, QT.SQL_TEXT), DATE_UPDATED = @STATS_DATE
         FROM   
         QUERY_TEXT QT INNER JOIN 
         (SELECT RN = ROW_NUMBER()
                               OVER (
                                 PARTITION BY CTE.QUERY_HASH
                                 ORDER BY CTE.QUERY_HASH DESC),
                        qs.query_hash                                                                                              AS QUERY_HASH,
                        SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                        WHEN -1 THEN DATALENGTH(st.text)
                                                                                        ELSE qs.statement_end_offset
                                                                                      END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
                 FROM   Query_Stats_CTE CTE
                        INNER JOIN sys.dm_exec_query_stats AS qs
                                ON CTE.QUERY_HASH = qs.query_hash
                        OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                        CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
                 WHERE  attribute = N'dbid'
                        AND DB_NAME(CONVERT(INT, value)) = @DATABASE_NAME
                        AND last_execution_time >= @LAST_RUN
						) AS RH ON RH.QUERY_HASH = QT.QUERY_HASH AND QT.SERVER_NAME = @SERVER_NAME AND QT.DATABASE_NAME = @DATABASE_NAME
         WHERE  RN = 1
     END 


 IF @REMOTE_SERVER = 'Y'
 BEGIN
 


				 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)



 SET @SQL = '
CREATE TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH
(
QUERY_HASH VARBINARY(64)
)' 



 SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  EXEC ('+'"' + @SQL +'"' + ') AT [' + @SERVER_NAME + ']'
  
 IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END

EXEC (@SQL2)


SET @SQL = '

;WITH Query_Stats_CTE ( QUERY_HASH)
     AS (SELECT  QUERY_HASH
         FROM   QUERY_STATS QS
         WHERE  QS.STATS_TIME >= DATEADD(D,-1, GETDATE()  )
                AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + '
                AND SERVER_NAME = ' + '''' + +@SERVER_NAME + '''' + ' 
				AND QUERY_HASH > 0x0000000000
                AND  EXISTS (SELECT ''X''
                                FROM   QUERY_TEXT QT WITH (NOLOCK)
                                WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                AND QS.SERVER_NAME = QT.SERVER_NAME 
								AND QT.DATE_UPDATED <= DATEADD(D,-'+CAST(@REFRESH_PLAN_DAYS AS VARCHAR(4))+',GETDATE() )
                                ))
INSERT INTO OPENQUERY([' + @SERVER_NAME + '], ''SELECT QUERY_HASH FROM  [tempdb].dbo.DYNPERF_QUERY_HASH'')

SELECT QUERY_HASH
FROM   (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_HASH
                        ORDER BY CTE.QUERY_HASH DESC),
               QUERY_HASH 
            
            FROM   Query_Stats_CTE CTE
           ) AS RH
WHERE  RN = 1 '

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


EXEC (@SQL)


        
 SET @SQL = '
         SELECT QUERY_HASH, SQL_TEXT
         FROM (
         SELECT RN = ROW_NUMBER() OVER (PARTITION BY CTE.QUERY_HASH ORDER BY CTE.QUERY_HASH DESC),
          qs.query_hash AS QUERY_HASH,
                         SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                         WHEN -1 THEN DATALENGTH(st.text)
                                                                                         ELSE qs.statement_end_offset
                                                                                       END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
         FROM    [tempdb].dbo.DYNPERF_QUERY_HASH CTE
                INNER JOIN sys.dm_exec_query_stats AS qs
                        ON CTE.QUERY_HASH = qs.query_hash
                OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
         WHERE  attribute = N''dbid''
                AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
                ) AS RH  
                WHERE RN = 1 '
PRINT ''
PRINT ''
                  
IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  	UPDATE QT 
	SET SQL_TEXT = COALESCE(A.SQL_TEXT,QT.SQL_TEXT), DATE_UPDATED =' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' +
	' FROM QUERY_TEXT QT INNER JOIN  (' +
				 '  SELECT RH.* FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH
                    ) AS A ON A.QUERY_HASH = QT.QUERY_HASH AND QT.SERVER_NAME = ' +'''' + @SERVER_NAME + '''' +
                    '   AND QT.DATABASE_NAME = ' + '''' + @DATABASE_NAME +''''
                   


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END
				 
				 EXECUTE (@SQL2)
				 
 --REH  Delete the table back out
 
 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

 
 END
 
    

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Refreshing [dbo].[DYNPERF_PURGE_DATA]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[DYNPERF_PURGE_DATA]';


GO
PRINT N'Refreshing [dbo].[DYNPERF_UPDATE_QUERY_HISTORY]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[DYNPERF_UPDATE_QUERY_HISTORY]';


GO
PRINT N'Update complete.';


GO



GO
ALTER TABLE QUERY_PLANS SET (LOCK_ESCALATION = DISABLE)

go



TRUNCATE TABLE DYNPERF_TASK_SCHEDULER

-- Enabled, Dynamics Product, Sproc Name, Sproc Parms, Task Desc, Sched Units, Sched qty, Sched time, Azure, Linked Server , Server level task, Task group


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_QUERY_STATS', NULL, 'Collect QUERY_STATS for database','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_INDEXSTATS', NULL, 'Collect INDEX STATS for database','HH',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_TEXT', NULL, 'Collect SQL TEXT for database','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_QUERY_PLANS', NULL, 'Collect QUERY PLANS for database','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SYSOBJECTS', NULL, 'Collect SYSTEM OBJECT DEFINITIONS for database','DD',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_WAITSTATS', NULL, 'Collect SERVER WAIT STATS for server','HH',1,NULL,1,1,1,'COLLECT');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_VIRTIALIO_DISKSTATS', NULL, 'Collect VIRTUAL I/O DISK STATS for database','HH',1,NULL,1,1,0,'COLLECT');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_CHANGE_DATA_CONTROL', NULL, 'Collect CHANGE DATA CONTROL for database','DD',1,NULL,0,1,0,'COLLECT');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_CHANGE_TRACKING', NULL, 'Collect CHANGE TRACKING for database','DD',1,NULL,1,1,0,'COLLECT')


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SSRS_EXECUTIONLOG', NULL, 'Collect SSRS for database','MI',5,NULL,1,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_DATA_BUFFER_CACHE', NULL, 'Collect SQL DATA BUFFER CACHE for server','DD',1,NULL,1,1,1,'COLLECT')


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_DATABASES', NULL, 'Collect SQL DATABASES INFORMATION for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_DATABASE_REPLICATION_INFO', NULL, 'Collect REPLICATION CONFIGURATION for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_CONFIGURATION', NULL, 'Collect SQL CONFIGURATION INFORMATION for server','DD',1,NULL,0,1,1,'COLLECT')


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_DATABASE_FILES', NULL, 'Collect SQL DATABASE FILE INFORMATION for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_DATABASE_VLFS', NULL, 'Collect SQL TLOG VLFS for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_INDEX_USAGE_STATS', NULL, 'Collect INDEX USAGE STATS for database','HH',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_INDEX_OPERATIONAL_STATS', NULL, 'Collect INDEX OPERATIONAL STATS for database','HH',1,NULL,1,1,0,'COLLECT');
	

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_JOBS', NULL, 'Collect SQL JOBS for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVERINFO', NULL, 'Collect SQL INSTANCE CONFIGURATION for server','DD',1,NULL,1,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVER_REGISTRY', NULL, 'Collect SQL STARTUP PARMS IN THE REGISTRY for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVER_DISKVOLUMES', NULL, 'Collect DISKVOLUMES USED BY SQL for server','WK',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVER_OS_INFO', NULL, 'Collect WINDOW OS VERSION INFO for server','WK',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_TRIGGER_INFO', NULL, 'Collect DATABASE TRIGGER INFO for database','DD',1,NULL,1,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_TRACEFLAGS_RUNNING', NULL, 'Collect RUNNING TRACE FLAGS for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_ERRORLOG', NULL, 'Collect SQL SERVER ERROR LOG for server','MI',5,NULL,1,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_DATABASE_STATISTICS', NULL, 'Collect DATABASE STATISTICS for database','WK',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_PLAN_GUIDES', NULL, 'Collect PLAN GUIDES for database','DD',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_PERF_COUNTERS', NULL, 'Collect SQL Performance Counters ','MI',5,NULL,0,1,1,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_PERF_COUNTERS_AZURE', NULL, 'Collect SQL Performance Counters for AZURE db ','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_AZURE_EVENTLOG', NULL, 'Collect sys.event_log  for AZURE db ','MI',5,NULL,1,1,0,'COLLECT');






-----------------------------------------Process Tasks -----------------------------------------------------------------------------






INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_UPDATE_QUERY_HISTORY', NULL, 'Rollup QUERY data into history tables','MI',5,NULL,1,1,1,'PROCESS');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_UPDATE_INDEX_HISTORY', NULL, 'Rollup INDEX data into history tables','HH',1,NULL,1,1,1,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PROCESS_QUERY_ALERTS', NULL, 'Query Alerts Processing','MI',5,NULL,1,1,0,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_UPDATE_SSRS_HISTORY', NULL, 'Rollup SSRS EXECUTIONLOG into History table','MI',5,NULL,1,1,1,'PROCESS');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PROCESS_AXSQLTRACE', '7' , 'Update QUERY_HASH in AX_SQLTRACE table','MI',5,NULL,1,1,0,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_REFRESH_QUERY_PLANS', NULL, 'Refresh old QUERY PLANS','DD',1,NULL,1,1,0,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_REFRESH_QUERY_TEXT', NULL, 'Refresh old QUERY TEXT','DD',1,NULL,1,1,0,'PROCESS');

--reh do this task last so everything else happens in case this task takes a long time
INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PROCESS_QUERY_PLANS', NULL, 'Parse all XML Query Plans','MI',5,NULL,1,1,0,'PROCESS');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PURGE_DATA', NULL, 'Purge data from DynamicsPerf','DD',1,NULL,1,1,1,'PROCESS');


/****************************************

AX_SCHEDULE

These are the  tasks for Dynamics AX
*****************************************/

----------------------------------------------AX ---------------------------------------

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_SQLTRACE', NULL, 'Collect SYSTRACETABLESQL for database','MI',5,NULL,0,1,0,'COLLECT')

--REH replaced by AOTEXPORT, better data
--INSERT DYNPERF_TASK_SCHEDULER
--VALUES (1,'AX', 'DYNPERF_COLLECT_AX_BATCHSERVER', NULL, 'Collect AX BATCH TABLES for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_SQLSTORAGE', NULL, 'Collect AX SQLSTORAGE TABLE for database','WK',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_NUMBERSEQUENCE', NULL, 'Collect AX NUMBER SEQUENCES for database','HH',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_SYSGLOBALCONFIG', NULL, 'Collect AX SYSGLOBALCONFIG for database','DD',1,NULL,0,1,0,'COLLECT')

--REH AOTEXPORT class goes direct to DynamicsPerf now
--INSERT DYNPERF_TASK_SCHEDULER
--VALUES (1,'AX', 'DYNPERF_COLLECT_AX_AOTEXPORT_DATA', NULL, 'Collect AX AOTEXPORT DATA for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_SET_AX_SQLTRACE', NULL, 'Set AX_SQLTRACE for database','DD',1,NULL,0,1,1,'COLLECT')





/****************************************

CRM_SCHEDULE

These are the  tasks for Dynamics CRM
*****************************************/

----------------------------------------------CRM ---------------------------------------

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'CRM', 'DYNPERF_COLLECT_CRM_ORGANIZATION', NULL, 'Collect CRM ORGANIZATION INFO for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'CRM', 'DYNPERF_COLLECT_CRM_PLUGINS', NULL, 'Collect CRM PLUGINS INFO for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'CRM', 'DYNPERF_COLLECT_CRM_POA_TOTALS', NULL, 'Collect CRM Primary Object Access INFO for database','HH',1,NULL,0,1,0,'COLLECT')

UPDATE QUERY_PLANS SET DATE_UPDATED = '1/1/1900'
UPDATE QUERY_TEXT SET DATE_UPDATED = '1/1/1900'


GO

UPDATE [DYNAMICSPERF_SETUP]
set VERSION = '2.00 BETA 4'