/*
Deployment script for DynamicsPerf

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


UPDATE DYNAMICSPERF_SETUP SET VERSION = '2.00 BETA 2'

--Because of the schema changes, you will have to setup SSRS data collection again

TRUNCATE TABLE SSRS_CONFIG
TRUNCATE TABLE SSRS_HISTORY
GO
/*
The column [dbo].[SSRS_CONFIG].[DATABASE_NAME] on table [dbo].[SSRS_CONFIG] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/

IF EXISTS (select top 1 1 from [dbo].[SSRS_CONFIG])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The column [dbo].[SSRS_HISTORY].[TOTAL_ROW_COUNT] is being dropped, data loss could occur.

The column [dbo].[SSRS_HISTORY].[TOTAL_SIZE_BYTES] is being dropped, data loss could occur.
*/

IF EXISTS (select top 1 1 from [dbo].[SSRS_HISTORY])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
PRINT N'Altering [dbo].[AX_BATCHJOB_DETAIL]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
ALTER TABLE [dbo].[AX_BATCHJOB_DETAIL] ALTER COLUMN [BATCH_GROUPID] NVARCHAR (20) NOT NULL;

ALTER TABLE [dbo].[AX_BATCHJOB_DETAIL] ALTER COLUMN [COMPANY] NVARCHAR (8) NOT NULL;

ALTER TABLE [dbo].[AX_BATCHJOB_DETAIL] ALTER COLUMN [CREATED_BY] NVARCHAR (16) NOT NULL;

ALTER TABLE [dbo].[AX_BATCHJOB_DETAIL] ALTER COLUMN [LOG_LEVEL] NVARCHAR (60) NOT NULL;

ALTER TABLE [dbo].[AX_BATCHJOB_DETAIL] ALTER COLUMN [RECUR_PATTERN_UNIT] NVARCHAR (40) NOT NULL;

ALTER TABLE [dbo].[AX_BATCHJOB_DETAIL] ALTER COLUMN [RECUR_RANGE_UNIT] NVARCHAR (80) NOT NULL;

ALTER TABLE [dbo].[AX_BATCHJOB_DETAIL] ALTER COLUMN [RUN_TYPE] NVARCHAR (20) NOT NULL;


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[SSRS_CONFIG]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
ALTER TABLE [dbo].[SSRS_CONFIG]
    ADD [DATABASE_NAME] NVARCHAR (128) NOT NULL;


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Starting rebuilding table [dbo].[SSRS_HISTORY]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_SSRS_HISTORY] (
    [SERVER_NAME]           NVARCHAR (128) NOT NULL,
    [REPORTPATH]            NVARCHAR (425) NULL,
    [REPORT_NAME]           NVARCHAR (512) NULL,
    [REPORT_DATE]           DATE           NULL,
    [TOTAL_TIME_DATA]       BIGINT         NULL,
    [TOTAL_TIME_PROCESSING] BIGINT         NULL,
    [TOTAL_TIME_RENDERING]  BIGINT         NULL,
    [MAX_REPORT_TIME_MS]    INT            NULL,
    [MIN_REPORT_TIME_MS]    INT            NULL,
    [EXECUTION_COUNT]       BIGINT         NULL,
    [MAX_SIZE_BYTES]        BIGINT         NULL,
    [MAX_ROW_COUNT]         BIGINT         NULL,
    [FLAG]                  CHAR (1)       NULL
);

CREATE CLUSTERED INDEX [tmp_ms_xx_index_IX_SSRS_HIST]
    ON [dbo].[tmp_ms_xx_SSRS_HISTORY]([REPORT_DATE] ASC, [SERVER_NAME] ASC);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[SSRS_HISTORY])
    BEGIN
        INSERT INTO [dbo].[tmp_ms_xx_SSRS_HISTORY] ([REPORT_DATE], [SERVER_NAME], [REPORTPATH], [REPORT_NAME], [TOTAL_TIME_DATA], [TOTAL_TIME_PROCESSING], [TOTAL_TIME_RENDERING], [MAX_REPORT_TIME_MS], [MIN_REPORT_TIME_MS], [EXECUTION_COUNT], [FLAG])
        SELECT   [REPORT_DATE],
                 [SERVER_NAME],
                 [REPORTPATH],
                 [REPORT_NAME],
                 [TOTAL_TIME_DATA],
                 [TOTAL_TIME_PROCESSING],
                 [TOTAL_TIME_RENDERING],
                 [MAX_REPORT_TIME_MS],
                 [MIN_REPORT_TIME_MS],
                 [EXECUTION_COUNT],
                 [FLAG]
        FROM     [dbo].[SSRS_HISTORY]
        ORDER BY [REPORT_DATE] ASC, [SERVER_NAME] ASC;
    END

DROP TABLE [dbo].[SSRS_HISTORY];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_SSRS_HISTORY]', N'SSRS_HISTORY';

EXECUTE sp_rename N'[dbo].[SSRS_HISTORY].[tmp_ms_xx_index_IX_SSRS_HIST]', N'IX_SSRS_HIST', N'INDEX';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[AZURE_EVENTS]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;

IF NOT EXISTS(SELECT 1 FROM sys.objects WHERE OBJECT_ID = OBJECT_ID(N'AZURE_EVENTS') AND type = (N'U'))
BEGIN
CREATE TABLE [dbo].[AZURE_EVENTS] (
    [SERVER_NAME]        NVARCHAR (128) NOT NULL,
    [STATS_TIME]         DATETIME       NOT NULL,
    [DATABASE_NAME]      NVARCHAR (128) NULL,
    [DBNAME]             NVARCHAR (128) NULL,
    [START_TIME]         DATETIME2 (7)  NULL,
    [END_TIME]           DATETIME2 (7)  NULL,
    [EVENT_CATEGORY]     NVARCHAR (128) NULL,
    [EVENT_TYPE]         NVARCHAR (128) NULL,
    [EVENT_SUBTYPE]      INT            NULL,
    [EVENT_SUBTYPE_DESC] NVARCHAR (128) NULL,
    [SEVERITY]           INT            NULL,
    [EVENT_COUNT]        INT            NULL,
    [DESCRIPTION]        NVARCHAR (MAX) NULL,
    [ADDITIONAL_DATA]    XML            NULL
);



SET ANSI_NULLS, QUOTED_IDENTIFIER ON;



PRINT N'Creating [dbo].[AZURE_EVENTS].[IX_AZURE_EVENTS]...';



CREATE CLUSTERED INDEX [IX_AZURE_EVENTS]
    ON [dbo].[AZURE_EVENTS]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] ASC);
END


GO
PRINT N'Refreshing [dbo].[AX_BATCHJOB_CONFIGURATION_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[AX_BATCHJOB_CONFIGURATION_VW]';


GO
PRINT N'Altering [dbo].[CURSOR_ACTIVITY_VW]...';


GO

ALTER VIEW [dbo].[CURSOR_ACTIVITY_VW]
AS

SELECT A.updated_time                       AS UPDATED_TIME,
       A.creation_time                      AS CREATION_TIME,
       A.dormant_duration                   AS LAST_RUN_MS,
       A.reads                              AS READS,
       A.writes                             AS WRITES,
       A.hostname                           AS HOSTNAME,
       A.loginame                           AS LOGIN_NAME,
       A.text                               AS SQL_TEXT,
       A.collectiontime                     AS COLLECTION_TIME,
       --SQL_CURSORPLAN.query_plan,
       A.session_id                         AS SQL_SPID,
       A.cursor_id                          AS CURSOR_ID,
       A.name                               AS NAME,
       A.properties                         AS PROPERTIES,
       A.sql_handle                         AS SQL_HANDLE,
       A.statement_start_offset             AS STATEMENT_START_OFFSET,
       A.statement_end_offset               AS STATEMENT_END_OFFSET,
       A.plan_generation_num                AS PLAN_NUMBER,
       A.is_open                            AS OPEN_FLAG,
       A.is_async_population                AS IS_ASYNC_POP_FLAG,
       A.is_close_on_commit                 AS IS_CLOSE_ON_COMMIT_FLAG,
       A.fetch_status                       AS FETCH_STATUS,
       A.fetch_buffer_size                  AS FETCH_BUFFER_SIZE,
       A.fetch_buffer_start                 AS FETCH_BUFFER_START,
       A.ansi_position                      AS ANSI_POSITION,
       A.worker_time                        AS CPU_TIME,
       A.plan_handle                        AS PLAN_HANDLE,
       A.query_hash                         AS QUERY_HASH,
       A.query_plan_hash                    AS QUERY_PLAN_HASH,
       Cast(A.context_info AS VARCHAR(128)) AS CONTEXT_INFO
FROM   (SELECT DISTINCT Sysdatetime() AS updated_time,
                        s1.hostname as hostname,
                        s1.loginame as loginame,
                        s3.text,
                        Getdate()     AS collectiontime,
                        s2.*,
                        SQL_CURSORSTATS.plan_handle,
                        SQL_CURSORSTATS.query_hash,
                        SQL_CURSORSTATS.query_plan_hash,
                        s1.context_info as context_info
        FROM   master.sys.sysprocesses AS s1
               CROSS APPLY sys.dm_exec_cursors(s1.spid) AS s2
               CROSS APPLY sys.dm_exec_sql_text(s2.sql_handle) AS s3
               LEFT JOIN (SELECT DISTINCT QS.plan_handle,
                                          QS.sql_handle,
                                          QS.statement_start_offset,
                                          QS.statement_end_offset,
                                          QS.plan_generation_num,
                                          QS.query_hash,
                                          QS.query_plan_hash
                          FROM   sys.dm_exec_query_stats AS QS) AS SQL_CURSORSTATS
                      ON SQL_CURSORSTATS.sql_handle = s2.sql_handle
                         AND s2.statement_start_offset = SQL_CURSORSTATS.statement_start_offset
                         AND s2.statement_end_offset = SQL_CURSORSTATS.statement_end_offset
        WHERE  SQL_CURSORSTATS.plan_generation_num = s2.plan_generation_num) AS A --This we'll join to the correct plan in cache if more then 1 plan
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SSRS_EXECUTIONLOG]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SSRS_EXECUTIONLOG (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @C_SERVER_NAME NVARCHAR(128), @C_LAST_COLLECTED DATETIME, @UTC_TIME DATETIME, @ROW_COUNT BIGINT = 0
	DECLARE @C_DATABASE_NAME NVARCHAR(128)

    
    
    
/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




SET @UTC_TIME = DATEADD(MI,@DPA_TZ_OFFSET,@STATS_DATE)




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT SERVER_NAME,
       Isnull(LAST_COLLECTED, '1/1/1900'), 
	   DATABASE_NAME
FROM   DynamicsPerf..SSRS_CONFIG SSRS



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_SERVER_NAME, @C_LAST_COLLECTED, @C_DATABASE_NAME



/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

	          SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END



--REH LAST_COLLECTED IS STORE IN UTC TIME, NEED TO CONVERT BACK TO LOCAL TIME AS TIMEEND IN EXECUTIONLOG2 IS LOCAL SQL TIME

IF @C_LAST_COLLECTED > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @C_LAST_COLLECTED = DATEADD(MI, @DPA_TZ_OFFSET*-1, @C_LAST_COLLECTED) --REH STORED AS UTC TIME, NEED TO CONVERT TO LOCAL TIME
        END
      ELSE
        BEGIN
            SET @C_LAST_COLLECTED = DATEADD(MI, @SQL_TZ_OFFSET*-1, @C_LAST_COLLECTED)  --REH STORED AS UTC TIME, NEED TO CONVERT TO LOCAL TIME
        END
  END 

  --PRINT '@C_LAST_COLLECTED ' + CAST(@C_LAST_COLLECTED AS VARCHAR(50))



IF @REMOTE_SERVER = 'N'
BEGIN

--  INSERT INTO DynamicsPerf.dbo.SSRS_EXECUTIONLOG
--SELECT 
--	InstanceName, 
--	REPLACE(COALESCE(C.Path, 'Unknown'),C.NAME,'') AS ReportPath,
--	C.Name, 
--	'removed for security reasons', --UserName,
--	ExecutionId, 
--	CASE(RequestType)
--		WHEN 0 THEN 'Interactive'
--		WHEN 1 THEN 'Subscription'
--		ELSE 'Unknown'
--		END AS RequestType, 
--	-- SubscriptionId, 
--	Format, 
--	Parameters, 
--	CASE(ReportAction)		
--		WHEN 1 THEN 'Render'
--		WHEN 2 THEN 'BookmarkNavigation'
--		WHEN 3 THEN 'DocumentMapNavigation'
--		WHEN 4 THEN 'DrillThrough'
--		WHEN 5 THEN 'FindString'
--		WHEN 6 THEN 'GetDocumentMap'
--		WHEN 7 THEN 'Toggle'
--		WHEN 8 THEN 'Sort'
--		ELSE 'Unknown'
--		END AS ReportAction,
--	TimeStart, 
--	TimeEnd, 
--	TimeDataRetrieval, 
--	TimeProcessing, 
--	TimeRendering,
--	CASE(Source)
--		WHEN 1 THEN 'Live'
--		WHEN 2 THEN 'Cache'
--		WHEN 3 THEN 'Snapshot' 
--		WHEN 4 THEN 'History'
--		WHEN 5 THEN 'AdHoc'
--		WHEN 6 THEN 'Session'
--		WHEN 7 THEN 'Rdce'
--		ELSE 'Unknown'
--		END AS Source,
--	Status,
--	ByteCount,
--	[RowCount]
--	FROM ReportServer.dbo.ExecutionLogStorage EL WITH(NOLOCK)
--LEFT OUTER JOIN ReportServer.dbo.Catalog C WITH(NOLOCK) ON (EL.ReportID = C.ItemID)
--	WHERE TimeEnd > @C_LAST_COLLECTED
	
	
		SET @SQL = '
		INSERT INTO DynamicsPerf.dbo.SSRS_EXECUTIONLOG

	SELECT 
	InstanceName, 
	REPLACE(COALESCE(C.Path, ''Unknown''),C.Name,'+'''' + ''''+') AS ReportPath, 
	C.Name,
	''Removed for security reason'', --UserName,
	ExecutionId, 
	CASE(RequestType)
		WHEN 0 THEN ''Interactive''
		WHEN 1 THEN ''Subscription''
		ELSE ''Unknown''
		END AS RequestType, 
	-- SubscriptionId, 
	Format, 
	Parameters, 
	CASE(ReportAction)		
		WHEN 1 THEN ''Render''
		WHEN 2 THEN ''BookmarkNavigation''
		WHEN 3 THEN ''DocumentMapNavigation''
		WHEN 4 THEN ''DrillThrough''
		WHEN 5 THEN ''FindString''
		WHEN 6 THEN ''GetDocumentMap''
		WHEN 7 THEN ''Toggle''
		WHEN 8 THEN ''Sort''
		ELSE ''Unknown''
		END AS ReportAction,
	TimeStart, 
	TimeEnd, 
	TimeDataRetrieval, 
	TimeProcessing, 
	TimeRendering,
	CASE(Source)
		WHEN 1 THEN ''Live''
		WHEN 2 THEN ''Cache''
		WHEN 3 THEN ''Snapshot'' 
		WHEN 4 THEN ''History''
		WHEN 5 THEN ''AdHoc''
		WHEN 6 THEN ''Session''
		WHEN 7 THEN ''Rdce''
		ELSE ''Unknown''
		END AS Source,
	Status,
	ByteCount,
	[RowCount]
FROM ['+@C_DATABASE_NAME + '].dbo.ExecutionLogStorage EL WITH(NOLOCK)
LEFT OUTER JOIN ['+@C_DATABASE_NAME + '].dbo.Catalog C WITH(NOLOCK) ON (EL.ReportID = C.ItemID)
WHERE TimeEnd > ' +'''' + CONVERT(NVARCHAR(24), @C_LAST_COLLECTED, 121) +''''

	
	
	
END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
 
 
		SET @SQL = '
	SELECT 
	InstanceName, 
	REPLACE(COALESCE(C.Path, ''Unknown''),C.Name,'+'''' + ''''+') AS ReportPath, 
	C.Name,
	''Removed for security reason'', --UserName,
	ExecutionId, 
	CASE(RequestType)
		WHEN 0 THEN ''Interactive''
		WHEN 1 THEN ''Subscription''
		ELSE ''Unknown''
		END AS RequestType, 
	-- SubscriptionId, 
	Format, 
	Parameters, 
	CASE(ReportAction)		
		WHEN 1 THEN ''Render''
		WHEN 2 THEN ''BookmarkNavigation''
		WHEN 3 THEN ''DocumentMapNavigation''
		WHEN 4 THEN ''DrillThrough''
		WHEN 5 THEN ''FindString''
		WHEN 6 THEN ''GetDocumentMap''
		WHEN 7 THEN ''Toggle''
		WHEN 8 THEN ''Sort''
		ELSE ''Unknown''
		END AS ReportAction,
	TimeStart, 
	TimeEnd, 
	TimeDataRetrieval, 
	TimeProcessing, 
	TimeRendering,
	CASE(Source)
		WHEN 1 THEN ''Live''
		WHEN 2 THEN ''Cache''
		WHEN 3 THEN ''Snapshot'' 
		WHEN 4 THEN ''History''
		WHEN 5 THEN ''AdHoc''
		WHEN 6 THEN ''Session''
		WHEN 7 THEN ''Rdce''
		ELSE ''Unknown''
		END AS Source,
	Status,
	ByteCount,
	[RowCount]
FROM ['+@C_DATABASE_NAME + '].dbo.ExecutionLogStorage EL WITH(NOLOCK)
LEFT OUTER JOIN ['+@C_DATABASE_NAME + '].dbo.Catalog C WITH(NOLOCK) ON (EL.ReportID = C.ItemID)
WHERE TimeEnd > ' +'''' + CONVERT(NVARCHAR(24), @C_LAST_COLLECTED, 121) +''''



		                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  INSERT INTO DynamicsPerf.dbo.SSRS_EXECUTIONLOG
				 SELECT * FROM OPENQUERY([' + @C_SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '
                    
                    EXEC (@SQL2)
           
               
 
 
 END
 
 SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT


 UPDATE SSRS_CONFIG SET LAST_COLLECTED = @UTC_TIME WHERE SERVER_NAME = @C_SERVER_NAME

 --PRINT '@DPA_TZ_OFFSET ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(50))
 --PRINT '@STATS_DATE ' + CAST(@STATS_DATE AS VARCHAR(50))
 --PRINT '@UTC_TIME ' + CAST(@UTC_TIME AS VARCHAR(50))



FETCH NEXT FROM TASK_CURSOR INTO @C_SERVER_NAME, @C_LAST_COLLECTED, @C_DATABASE_NAME



END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
				  + ' TRYING TO PROCESS REPORT SERVER ' + ISNULL(@C_SERVER_NAME,'') + '  '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_UPDATE_SSRS_HISTORY]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_UPDATE_SSRS_HISTORY]
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @ROW_COUNT BIGINT = 0
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



/******************************************************************************
NEED TO SUBTRACT OUT PREVIOUS DAYS AMOUNTS IF COMPILE_TIME WAS BEFORE TODAY

SUBTRACT THE LAST QUERY_STATS RECORD FROM PREVIOUS DAY WITH SAME COMPILE_TIME


*******************************************************************************/
--REH This sums up to the totals of the day

MERGE SSRS_HISTORY AS target
		USING (
		SELECT SERVER_NAME,
       REPORTPATH,
       REPORTNAME                                      AS REPORT_NAME,
       MAX(DATEADD(DAY, DATEDIFF(DAY, 0, TIMEEND), 0)) AS REPORT_DATE,
       SUM([TIME_DATARETRIEVAL])                       AS TOTAL_TIME_DATA,
       SUM([TIME_PROCESSING])                          AS TOTAL_TIME_PROCESSING,
       SUM([TIME_RENDERING])                           AS TOTAL_TIME_RENDERING,
       MAX(TIME_DATARETRIEVAL + TIME_PROCESSING
           + TIME_RENDERING)                           AS MAX_REPORT_TIME_MS,
       MIN(TIME_DATARETRIEVAL + TIME_PROCESSING
           + TIME_RENDERING)                           AS MIN_REPORT_TIME_MS,
       COUNT(REPORTPATH)                               AS EXECUTION_COUNT,
       MAX(BYTECOUNT)                                  AS MAX_SIZE_BYTES,
       MAX([ROWCOUNT])                                 AS MAX_ROW_COUNT,
       MAX('D')                                        AS FLAG
FROM   SSRS_EXECUTIONLOG
WHERE SERVER_NAME = @SERVER_NAME AND DATEADD(DAY, DATEDIFF(DAY, 0, TIMEEND), 0) = DATEADD(DAY, DATEDIFF(DAY, 0, @LAST_RUN), 0)
GROUP  BY SERVER_NAME,
DATEADD(DAY, DATEDIFF(DAY, 0, TIMEEND), 0) ,
          REPORTPATH,
          REPORTNAME ) AS source
ON ( source.SERVER_NAME = target.SERVER_NAME
			 AND source.REPORTPATH = target.REPORTPATH
			 AND source.REPORT_NAME = target.REPORT_NAME
			 AND source.REPORT_DATE = target.REPORT_DATE
			 AND source.FLAG = target.FLAG )
		WHEN MATCHED THEN
		 UPDATE SET TOTAL_TIME_DATA = source.TOTAL_TIME_DATA,
					 TOTAL_TIME_PROCESSING = source.TOTAL_TIME_PROCESSING,
					 TOTAL_TIME_RENDERING = source.TOTAL_TIME_RENDERING,
					 MAX_REPORT_TIME_MS = source.MAX_REPORT_TIME_MS,
					 MIN_REPORT_TIME_MS = source.MIN_REPORT_TIME_MS,
					 EXECUTION_COUNT = source.EXECUTION_COUNT,
					 MAX_SIZE_BYTES = source.MAX_SIZE_BYTES,
					 MAX_ROW_COUNT = source.MAX_ROW_COUNT


		WHEN NOT MATCHED THEN
		  INSERT ([SERVER_NAME]
           ,[REPORTPATH]
           ,[REPORT_NAME]
           ,[REPORT_DATE]
           ,[TOTAL_TIME_DATA]
           ,[TOTAL_TIME_PROCESSING]
           ,[TOTAL_TIME_RENDERING]
           ,[MAX_REPORT_TIME_MS]
           ,[MIN_REPORT_TIME_MS]
           ,[EXECUTION_COUNT]
           ,[MAX_SIZE_BYTES]
           ,[MAX_ROW_COUNT]
           ,[FLAG])
		  VALUES (source.[SERVER_NAME]
           ,source.[REPORTPATH]
           ,source.[REPORT_NAME]
           ,source.[REPORT_DATE]
           ,source.[TOTAL_TIME_DATA]
           ,source.[TOTAL_TIME_PROCESSING]
           ,source.[TOTAL_TIME_RENDERING]
           ,source.[MAX_REPORT_TIME_MS]
           ,source.[MIN_REPORT_TIME_MS]
           ,source.[EXECUTION_COUNT]
           ,source.[MAX_SIZE_BYTES]
           ,source.[MAX_ROW_COUNT]
           ,source.[FLAG]);


		   SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

 --REH Rollup the daily total into the Monthly total


MERGE SSRS_HISTORY AS target
		USING (
		SELECT [SERVER_NAME]
           ,[REPORTPATH]
           ,[REPORT_NAME]
           ,DATEADD(MONTH, DATEDIFF(MONTH, 0, REPORT_DATE), 0) AS REPORT_DATE --REH floor the date to the month level
           ,SUM([TOTAL_TIME_DATA]) AS TOTAL_TIME_DATA
           ,SUM([TOTAL_TIME_PROCESSING]) AS TOTAL_TIME_PROCESSING
           ,SUM([TOTAL_TIME_RENDERING]) AS TOTAL_TIME_RENDERING
           ,MAX([MAX_REPORT_TIME_MS]) AS MAX_REPORT_TIME_MS
           ,MIN([MIN_REPORT_TIME_MS]) AS MIN_REPORT_TIME_MS
           ,SUM([EXECUTION_COUNT]) AS EXECUTION_COUNT
           ,MAX([MAX_SIZE_BYTES]) AS MAX_SIZE_BYTES
           ,MAX([MAX_ROW_COUNT]) AS MAX_ROW_COUNT
           ,'M' AS FLAG
FROM   SSRS_HISTORY
WHERE SERVER_NAME = @SERVER_NAME AND FLAG = 'D' -- ONLY sum up the Daily totals into the monthly totals
	AND DATEADD(MONTH, DATEDIFF(MONTH, 0, REPORT_DATE), 0) = DATEADD(MONTH, DATEDIFF(MONTH, 0, @LAST_RUN), 0) 
GROUP  BY SERVER_NAME,
DATEADD(MONTH, DATEDIFF(MONTH, 0, REPORT_DATE), 0) ,
          REPORTPATH,
          REPORT_NAME ) AS source
ON ( source.SERVER_NAME = target.SERVER_NAME
			 AND source.REPORTPATH = target.REPORTPATH
			 AND source.REPORT_NAME = target.REPORT_NAME
			 AND source.REPORT_DATE = target.REPORT_DATE
			 AND source.FLAG = target.FLAG )
		WHEN MATCHED THEN
		 UPDATE SET TOTAL_TIME_DATA = source.TOTAL_TIME_DATA,
					 TOTAL_TIME_PROCESSING = source.TOTAL_TIME_PROCESSING,
					 TOTAL_TIME_RENDERING = source.TOTAL_TIME_RENDERING,
					 MAX_REPORT_TIME_MS = source.MAX_REPORT_TIME_MS,
					 MIN_REPORT_TIME_MS = source.MIN_REPORT_TIME_MS,
					 EXECUTION_COUNT = source.EXECUTION_COUNT,
					 MAX_SIZE_BYTES = source.MAX_SIZE_BYTES,
					 MAX_ROW_COUNT = source.MAX_ROW_COUNT


		WHEN NOT MATCHED THEN
		  INSERT ([SERVER_NAME]
           ,[REPORTPATH]
           ,[REPORT_NAME]
           ,[REPORT_DATE]
           ,[TOTAL_TIME_DATA]
           ,[TOTAL_TIME_PROCESSING]
           ,[TOTAL_TIME_RENDERING]
           ,[MAX_REPORT_TIME_MS]
           ,[MIN_REPORT_TIME_MS]
           ,[EXECUTION_COUNT]
           ,[MAX_SIZE_BYTES]
           ,[MAX_ROW_COUNT]
           ,[FLAG])
		  VALUES (source.[SERVER_NAME]
           ,source.[REPORTPATH]
           ,source.[REPORT_NAME]
           ,source.[REPORT_DATE]
           ,source.[TOTAL_TIME_DATA]
           ,source.[TOTAL_TIME_PROCESSING]
           ,source.[TOTAL_TIME_RENDERING]
           ,source.[MAX_REPORT_TIME_MS]
           ,source.[MIN_REPORT_TIME_MS]
           ,source.[EXECUTION_COUNT]
           ,source.[MAX_SIZE_BYTES]
           ,source.[MAX_ROW_COUNT]
           ,source.[FLAG]);

		   SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_AX_SQLTRACE]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_AX_SQLTRACE (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/
--REH Moved the synonms to avoid SQL runtime error that columns don't exists.  

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE




/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures

--REH @LAST_RUN IS UTC TIME WHICH IS WHAT WE NEED IN THIS SPROC AND THIS SPROC ALONE


--IF @LAST_RUN > '1/1/1901'
--  BEGIN
--      IF @REMOTE_SERVER = 'N'
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
--        END
--      ELSE
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
--        END
--  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


--REH Get AX version

DECLARE @AX_SERVER_NAME   NVARCHAR(128) = NULL,
        @AX_DATABASE_NAME NVARCHAR(128),
        @AX_APP_BUILD     NVARCHAR(120),
        @KERNEL_BUILD     NVARCHAR(20)
   
   CREATE TABLE #AX_VERSION
     (
        AX_APP_BUILD NVARCHAR(120),
        KERNEL_BUILD NVARCHAR(20)
     )
   
   SET NOCOUNT ON
   
   INSERT #AX_VERSION
   EXECUTE DYNPERF_AX_VERSION_INFO
     @AX_SERVER_NAME = @SERVER_NAME,
     @AX_DATABASE_NAME = @DATABASE_NAME--, @DEBUG = 'N'
   SELECT @AX_APP_BUILD = AX_APP_BUILD,
          @KERNEL_BUILD = KERNEL_BUILD
   FROM   #AX_VERSION
   
   --PRINT 'AX BUILD = ' + ISNULL(@AX_APP_BUILD, '')
   
   --PRINT 'KERNEL BUILD = '+ ISNULL(@KERNEL_BUILD, '')
   
   DROP TABLE #AX_VERSION 
   

  
IF Substring(@AX_APP_BUILD, 1, 1) BETWEEN N'3' AND N'4'
BEGIN


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


INSERT INTO AX_SQLTRACE WITH (TABLOCK) 
		   (SERVER_NAME
		   ,STATS_TIME
		   ,DATABASE_NAME
		   ,SQL_DURATION
		   ,TRACE_CATEGORY
		   ,SQL_TEXT
		   ,CALL_STACK
		   ,TRACE_EVENT_CODE
		   ,TRACE_EVENT_DESC
		   ,TRACE_EVENT_DETAILS
		   ,CONNECTION_TYPE
		   ,SQL_SESSION_ID
		   ,AX_CONNECTION_ID
		   ,IS_LOBS_INCLUDED
		   ,IS_MORE_DATA_PENDING
		   ,ROWS_AFFECTED
		   ,ROW_SIZE
		   ,ROWS_PER_FETCH
		   ,IS_SELECTED_FOR_UPDATE
		   ,IS_STARTED_WITHIN_TRANSACTION
		   ,SQL_TYPE
		   ,STATEMENT_ID
		   ,STATEMENT_REUSE_COUNT
		   ,DETAIL_TYPE
		   ,CREATED_DATETIME
		   ,AX_USER_ID)
		SELECT @SERVER_NAME,
			@STATS_DATE,
			@DATABASE_NAME,
			TRACETIME
			,CATEGORY
			,STATEMENT
			,CALLSTACK
			,CODE
			,TEXT
			,TEXTDETAILS
			,CONNECTIONTYPE
			,CONNECTIONSPID
			,CONNECTIONID
			,ISLOBSINCLUDED
			,ISMOREDATAPENDING
			,ROWSAFFECTED
			,ROWSIZE
			,ROWSPERFETCH
			,ISSELECTEDFORUPDATE
			,ISSTARTEDWITHINTRANSACTION
			,STATEMENTTYPE
			,STATEMENTID
			,STATEMENTREUSECOUNT
			,DETAILTYPE
			,  DATEADD(MI, @SQL_TZ_OFFSET, DATEADD(S, CREATEDTIME, CREATEDDATE))      
			,CREATEDBY
			
			
		FROM DYN_AXTRACE_AX_SYSTRACETABLE WITH (NOLOCK)
		WHERE DATEADD(S, CREATEDTIME, CREATEDDATE) >= @LAST_RUN
	 AND DATEADD(D, 14, CREATEDDATE) >= GETDATE()


	
END

IF Substring(@AX_APP_BUILD, 1, 2) IN ('5.', '6.', '7.') 
    BEGIN	
	
	
IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXTRACE_AX_SYSTRACETABLE')
  DROP SYNONYM [dbo].DYN_AXTRACE_AX_SYSTRACETABLE


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXTRACE_AX_SYSTRACETABLE
				FOR [' + @DATABASE_NAME + '].dbo.SYSTRACETABLESQL'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 

INSERT INTO AX_SQLTRACE WITH (TABLOCK) 
		   (SERVER_NAME
		   ,STATS_TIME
		   ,DATABASE_NAME
		   ,SQL_DURATION
		   ,TRACE_CATEGORY
		   ,SQL_TEXT
		   ,CALL_STACK
		   ,TRACE_EVENT_CODE
		   ,TRACE_EVENT_DESC
		   ,TRACE_EVENT_DETAILS
		   ,CONNECTION_TYPE
		   ,SQL_SESSION_ID
		   ,AX_CONNECTION_ID
		   ,IS_LOBS_INCLUDED
		   ,IS_MORE_DATA_PENDING
		   ,ROWS_AFFECTED
		   ,ROW_SIZE
		   ,ROWS_PER_FETCH
		   ,IS_SELECTED_FOR_UPDATE
		   ,IS_STARTED_WITHIN_TRANSACTION
		   ,SQL_TYPE
		   ,STATEMENT_ID
		   ,STATEMENT_REUSE_COUNT
		   ,DETAIL_TYPE
		   ,CREATED_DATETIME
		   ,AX_USER_ID)
		SELECT @SERVER_NAME,
			@STATS_DATE,
			@DATABASE_NAME,
			TRACETIME
			,CATEGORY
			,STATEMENT
			,CALLSTACK
			,CODE
			,TEXT
			,TEXTDETAILS
			,CONNECTIONTYPE
			,CONNECTIONSPID
			,CONNECTIONID
			,ISLOBSINCLUDED
			,ISMOREDATAPENDING
			,ROWSAFFECTED
			,ROWSIZE
			,ROWSPERFETCH
			,ISSELECTEDFORUPDATE
			,ISSTARTEDWITHINTRANSACTION
			,STATEMENTTYPE
			,STATEMENTID
			,STATEMENTREUSECOUNT
			,DETAILTYPE
			,DATEADD(MI, @SQL_TZ_OFFSET, CREATEDDATETIME)
			,CREATEDBY
	
		FROM DYN_AXTRACE_AX_SYSTRACETABLE WITH (NOLOCK)
		WHERE CREATEDDATETIME >= @LAST_RUN
	 AND DATEADD(D, 14, CREATEDDATETIME) >= GETDATE()
	
	END
	
	
 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_DATABASE_STATISTICS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_DATABASE_STATISTICS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @ROW_COUNT BIGINT = 0
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_SYSOBJECTS')
  DROP SYNONYM [dbo].DYN_DS_SYSOBJECTS


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSOBJECTS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.sysobjects'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSOBJECTS
				FOR [' + @DATABASE_NAME + '].sys.sysobjects'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)
 

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_SYSCOLUMNS')
  DROP SYNONYM [dbo].DYN_DS_SYSCOLUMNS


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSCOLUMNS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.columns'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSCOLUMNS
				FOR [' + @DATABASE_NAME + '].sys.columns'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_SYSINDEXES')
  DROP SYNONYM [dbo].DYN_DS_SYSINDEXES


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSINDEXES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.indexes'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSINDEXES
				FOR [' + @DATABASE_NAME + '].sys.indexes'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_SYSSCHEMAS')
  DROP SYNONYM [dbo].DYN_DS_SYSSCHEMAS
  
  
IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSSCHEMAS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.schemas'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYSSCHEMAS
				FOR [' + @DATABASE_NAME + '].sys.schemas'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_INDEX_COLUMNS')
  DROP SYNONYM [dbo].DYN_DS_INDEX_COLUMNS
  
IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_INDEX_COLUMNS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.index_columns'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_INDEX_COLUMNS
				FOR [' + @DATABASE_NAME + '].sys.index_columns'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_STATS_COLUMNS')
  DROP SYNONYM [dbo].DYN_DS_STATS_COLUMNS
  
IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_STATS_COLUMNS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.stats_columns'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_STATS_COLUMNS
				FOR [' + @DATABASE_NAME + '].sys.stats_columns'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_DS_SYS_STATS')
  DROP SYNONYM [dbo].DYN_DS_SYS_STATS
  
IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYS_STATS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_DS_SYS_STATS
				FOR [' + @DATABASE_NAME + '].sys.stats'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[#table_stat_header]'))
BEGIN 
DROP TABLE #table_stat_header
END

create table #table_stat_header (
    [Name] sysname
,   [Updated] datetime2
,   [Rows] int
,   [Rows Sampled] int
,   [Steps] int
,   [Density] numeric(10,5)
,   [Average key length] numeric(10,5)
,   [String index] varchar(10)
,   [Filter_Expression] nvarchar(max),
	[Unfiltered_Rows] int
)

--insert into #table_stat_header exec ('dbcc show_statistics ( "tab", "i1") with  STAT_HEADER')



IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[#TableStats]'))
BEGIN 
DROP TABLE #TableStats
END


CREATE TABLE #TableStats
  (
     Density FLOAT,
     Length  INT NULL,
     columns NVARCHAR(2078)
  ) 
  


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[#TableHistogram]'))
 BEGIN
DROP TABLE #TableHistogram
END

CREATE TABLE #TableHistogram
  (
     Range_HI_Key        SQL_VARIANT,
     Range_Rows          BIGINT NULL,
     EQ_Rows             BIGINT,
     Distinct_Range_Rows BIGINT,
     Avg_Range_Rows      BIGINT
  ) 



DELETE FROM INDEX_STAT_HEADER WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME
DELETE FROM INDEX_DENSITY_VECTOR WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME
DELETE FROM INDEX_HISTOGRAM WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME


TRUNCATE TABLE #TableStats
TRUNCATE TABLE #TableHistogram
TRUNCATE TABLE #table_stat_header


DECLARE @tablename sysname
DECLARE @indexname sysname
DECLARE @colname sysname
DECLARE @schemaname sysname


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

DECLARE table_cursor CURSOR
   FOR SELECT O.name,
              ST.name,
              C.name,
              SCH.name
       FROM   DYN_DS_SYSOBJECTS O
              INNER JOIN DYN_DS_SYS_STATS ST
                      ON O.id = ST.object_id
              INNER JOIN DYN_DS_STATS_COLUMNS AS SC
                      ON ST.object_id = SC.object_id
                         AND ST.stats_id = SC.stats_id
              INNER JOIN DYN_DS_SYSCOLUMNS AS C
                      ON SC.object_id = C.object_id
                         AND C.column_id = SC.column_id
              INNER JOIN DYN_DS_SYSSCHEMAS AS SCH
                      ON O.uid = SCH.schema_id
       WHERE  O.xtype = 'u'
              AND SC.stats_column_id = 1
              AND C.system_type_id <> 189
              AND SCH.name <> 'sys' --remove timestamps, incompatiable with sql_variant datatype we used
              AND ( ST.auto_created = 1
               OR ST.user_created = 1)
       UNION ALL
       SELECT O.name,
              ST.name,
              C.name,
              SCH.name
       FROM   DYN_DS_SYSOBJECTS O
              INNER JOIN DYN_DS_SYS_STATS ST
                      ON O.id = ST.object_id
              INNER JOIN DYN_DS_STATS_COLUMNS AS SC
                      ON ST.object_id = SC.object_id
                         AND ST.stats_id = SC.stats_id
              INNER JOIN DYN_DS_SYSCOLUMNS AS C
                      ON SC.object_id = C.object_id
                         AND C.column_id = SC.column_id
              INNER JOIN DYN_DS_SYSSCHEMAS AS SCH
                      ON O.uid = SCH.schema_id
       WHERE  O.xtype = 'u'
              AND SC.stats_column_id = 1
              AND C.system_type_id <> 189
              AND SCH.name <> 'sys' --remove timestamps, incompatiable with sql_variant datatype we used
              AND (ST.auto_created = 0
              AND ST.user_created = 0 )
       

/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN table_cursor 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM table_cursor INTO @tablename, @indexname, @colname, @schemaname

/* Verify that we got a record*/
/* status 0 means we got a good record*/



WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */
--	print @tablename + '    ' + @indexname




--------------------------------------STATS HEADER --------------------------------------------------------------		


	SELECT @SQL = 'DBCC SHOW_STATISTICS('+'''' +@DATABASE_NAME +'.'+@schemaname+'.' +@tablename + '''' +',' +QUOTENAME(@indexname,'''')+') WITH  STAT_HEADER, NO_INFOMSGS'
		
		IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL
		END
		
	--REH Truncate the table before we insert data into it
	TRUNCATE TABLE #table_stat_header
		
		IF @REMOTE_SERVER = 'N'
			 BEGIN
				 BEGIN TRY
					 INSERT #table_stat_header
					 EXEC (@SQL ) --DBCC SHOW_STATISTICS STAT_HEADER
				 END TRY

				 BEGIN CATCH
				 --ignore the error
				 END CATCH
			 END

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
							 + @SERVER_NAME + ']'

				 IF @DEBUG = 'Y'
					  BEGIN
						  PRINT '@SQL= ' + @SQL2
					  END

				 BEGIN TRY
					 INSERT #table_stat_header
					 EXEC (@SQL2 ) --DBCC SHOW_STATISTICS STAT_HEADER
				 END TRY

				 BEGIN CATCH
				 --ignore the error
				 END CATCH
				 
				 
			 END 


	--REH Now insert the records from the temp table into our table
			INSERT INDEX_STAT_HEADER
			SELECT @SERVER_NAME,
				   @DATABASE_NAME,
				   @tablename,
				   @indexname,
				   *
			FROM   #table_stat_header 





--------------------------------------DENSITY VECTOR --------------------------------------------------------------		


	SELECT @SQL = 'DBCC SHOW_STATISTICS('+'''' +@DATABASE_NAME +'.'+@schemaname+'.' +@tablename + '''' +',' +QUOTENAME(@indexname,'''')+') WITH DENSITY_VECTOR, NO_INFOMSGS'
		
		IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL
		END
		
	--REH Truncate the table before we insert data into it
	TRUNCATE TABLE #TableStats
		
		IF @REMOTE_SERVER = 'N'
			 BEGIN
				 BEGIN TRY
					 INSERT #TableStats
					 EXEC (@SQL ) --DBCC SHOW_STATISTICS DENSITY VECTOR
				 END TRY

				 BEGIN CATCH
				 --ignore the error
				 END CATCH
			 END

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
							 + @SERVER_NAME + ']'

				 IF @DEBUG = 'Y'
					  BEGIN
						  PRINT '@SQL= ' + @SQL2
					  END

				 BEGIN TRY
					 INSERT #TableStats
					 EXEC (@SQL2 ) --DBCC SHOW_STATISTICS DENSITY VECTOR
				 END TRY

				 BEGIN CATCH
				 --ignore the error
				 END CATCH
				 
				 
			 END 


	--REH Now insert the records from the temp table into our table
			INSERT INDEX_DENSITY_VECTOR
			SELECT @SERVER_NAME,
				   @DATABASE_NAME,
				   @tablename,
				   @indexname,
				   *
			FROM   #TableStats 

--------------------------------------HISTOGRAM --------------------------------------------------------------		


	SELECT @SQL = 'DBCC SHOW_STATISTICS('+'''' +@DATABASE_NAME +'.'+@schemaname+'.' +@tablename + '''' +',' +QUOTENAME(@indexname,'''')+') WITH HISTOGRAM, NO_INFOMSGS'
		
		IF @DEBUG = 'Y' 
		BEGIN
			PRINT '@SQL= ' + @SQL
		END
		
		
--REH Truncate the table before we insert data into it
	TRUNCATE TABLE #TableHistogram
		
			IF @REMOTE_SERVER = 'N'
				 BEGIN
					 BEGIN TRY
						 INSERT #TableHistogram
						 EXEC (@SQL ) --DBCC SHOW_STATISTICS DENSITY VECTOR
					 END TRY

					 BEGIN CATCH
					 --ignore the error
					 END CATCH
				 END 

		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
							 + @SERVER_NAME + ']'

				 IF @DEBUG = 'Y'
					  BEGIN
						  PRINT '@SQL= ' + @SQL2
					  END

				 BEGIN TRY
					 INSERT #TableHistogram
					 EXEC (@SQL2 ) --DBCC SHOW_STATISTICS DENSITY VECTOR
				 END TRY

				 BEGIN CATCH
				 --ignore the error
				 END CATCH
				 
				 
			 END 	
			 
	--REH Now insert the records from the temp table into our table
				INSERT INDEX_HISTOGRAM
				SELECT @SERVER_NAME,
					   @DATABASE_NAME,
					   @tablename,
					   @indexname,
					   @colname,
					   *
				FROM   #TableHistogram 

				SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

---------------------------------------BOTTOM OF LOOP----------------------------------------------

	FETCH NEXT FROM table_cursor INTO @tablename,@indexname,@colname,@schemaname
END  /*End of the loop */
CLOSE table_cursor  /*close the cursor to free memory in SQL*/
DEALLOCATE table_cursor /*Must deallocate the cursor to destroy it and free SQL resources*/
 
 
 
 
 
 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_QUERY_STATS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_QUERY_STATS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQL_BUILD NVARCHAR(128)

	--REH Get the build so we can add the new columns to the query_stats table from SQL2016 and above
    SELECT @SQL_BUILD = SQL_VERSION  FROM STATS_COLLECTION_SUMMARY SCS WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME=@DATABASE_NAME AND STATS_TIME = @STATS_DATE
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_QS_STATS')
  DROP SYNONYM [dbo].DYN_QS_STATS
  
IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_PLAN_ATTRIBUTES')
  DROP SYNONYM [dbo].DYN_PLAN_ATTRIBUTES



         SET @SQL = '
				CREATE SYNONYM DYN_QS_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_query_stats'

EXEC (@SQL)


         SET @SQL = '
				CREATE SYNONYM DYN_PLAN_ATTRIBUTES
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_plan_attributes'

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 





PRINT 'TIME ZONE OFFSET AT TASK ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
PRINT 'LAST RUN AT TASK ' + CAST(@LAST_RUN AS VARCHAR(20))


PRINT 'LAST RUN WITH OFFSET ' + CAST(@LAST_RUN AS VARCHAR(20))
 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, ' TASK')
PRINT ''




IF @DEBUG = 'Y'
  BEGIN
      PRINT '@LAST_RUN = '

      PRINT @LAST_RUN
  END 
  
  
  IF @REMOTE_SERVER = 'N'
       BEGIN
			--IF @SQL_BUILD >= '13.' --REH  SQL2016 or above
		          
 SET @SQL =  ' INSERT INTO DynamicsPerf.dbo.QUERY_STATS

          SELECT MIN(' + '''' + @SERVER_NAME + '''' + '), MAX(' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + '),MIN('
				  + '''' + @DATABASE_NAME + '''' + '), 
                  MIN(plan_handle),
                  MAX(plan_generation_num),
                  creation_time,
                  MAX(last_execution_time),
                  SUM(execution_count),
                  SUM(total_worker_time),
                  AVG(last_worker_time),
                  MIN(min_worker_time),
                  MAX(max_worker_time),
                  SUM(total_physical_reads),
                  AVG(last_physical_reads),
                  MIN(min_physical_reads),
                  MAX(max_physical_reads),
                  SUM(total_logical_writes),
                  AVG(last_logical_writes),
                  MIN(min_logical_writes),
                  MAX(max_logical_writes),
                  SUM(total_logical_reads),
                  AVG(last_logical_reads),
                  MIN(min_logical_reads),
                  MAX(max_logical_reads),
                  SUM(total_clr_time),
                  AVG(last_clr_time),
                  MIN(min_clr_time),
                  MAX(max_clr_time),
                  SUM(total_elapsed_time),
                  AVG(last_elapsed_time),
                  MIN(min_elapsed_time),
                  MAX(max_elapsed_time),
                  query_hash,
                  query_plan_hash,
                  SUM ( total_rows),
                  SUM ( last_rows),
                  MAX ( max_rows),
                  MIN ( min_rows),'

				  IF @SQL_BUILD >= '13.' or (@SQL_BUILD >= '11.0.6020' and @SQL_BUILD < '12.') --REH correct build per version
				  BEGIN
					  SELECT @SQL = @SQL + 'SUM(total_dop), SUM(last_dop), SUM(min_dop), SUM(max_dop) '

				  END
				  ELSE
				  BEGIN
					SELECT @SQL = @SQL + 'SUM(-1), SUM(-1), SUM(-1), SUM(-1) '


				  END
SELECT @SQL = @SQL + '

           FROM   sys.dm_exec_query_stats
                  OUTER APPLY sys.dm_exec_plan_attributes (plan_handle)
           WHERE  attribute = N''dbid''
                  AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
                  AND dateadd(ms,last_elapsed_time,last_execution_time) >= ''' +CONVERT(NVARCHAR(24), @LAST_RUN, 121) + '''
           GROUP  BY query_hash,
                     query_plan_hash,
					 creation_time'


					 
			IF @DEBUG = 'Y'
			  BEGIN
				  PRINT @SQL
			  END 
  
			  EXEC (@SQL)

		END

  IF @REMOTE_SERVER = 'Y'
       BEGIN
       
    

           --INSERT INTO QUERY_STATS
           
 SET @SQL = '
           SELECT 
                  MIN(plan_handle),
                  MAX(plan_generation_num),
                  creation_time,
                  MAX(last_execution_time),
                  SUM(execution_count),
                  SUM(total_worker_time),
                  AVG(last_worker_time),
                  MIN(min_worker_time),
                  MAX(max_worker_time),
                  SUM(total_physical_reads),
                  AVG(last_physical_reads),
                  MIN(min_physical_reads),
                  MAX(max_physical_reads),
                  SUM(total_logical_writes),
                  AVG(last_logical_writes),
                  MIN(min_logical_writes),
                  MAX(max_logical_writes),
                  SUM(total_logical_reads),
                  AVG(last_logical_reads),
                  MIN(min_logical_reads),
                  MAX(max_logical_reads),
                  SUM(total_clr_time),
                  AVG(last_clr_time),
                  MIN(min_clr_time),
                  MAX(max_clr_time),
                  SUM(total_elapsed_time),
                  AVG(last_elapsed_time),
                  MIN(min_elapsed_time),
                  MAX(max_elapsed_time),
                  query_hash,
                  query_plan_hash,
                  SUM ( total_rows),
                  SUM ( last_rows),
                  MAX ( max_rows),
                  MIN ( min_rows),'

				   IF @SQL_BUILD >= '13.' or (@SQL_BUILD >= '11.0.6020' and @SQL_BUILD < '12.') --REH correct build per version
				  BEGIN
					  SELECT @SQL = @SQL + 'SUM(total_dop), SUM(last_dop), SUM(min_dop), SUM(max_dop) '

				  END
				  ELSE
				  BEGIN
					SELECT @SQL = @SQL + 'SUM(-1), SUM(-1), SUM(-1), SUM(-1) '


				  END
SELECT @SQL = @SQL + '

           FROM   sys.dm_exec_query_stats
                  OUTER APPLY sys.dm_exec_plan_attributes (plan_handle)
           WHERE  attribute = N''dbid''
                  AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
                  AND dateadd(ms,last_elapsed_time,last_execution_time) >= ''' +CONVERT(NVARCHAR(24), @LAST_RUN, 121) + '''
           GROUP  BY query_hash,
                     query_plan_hash,
					 creation_time'
                    



                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  INSERT INTO DynamicsPerf.dbo.QUERY_STATS
				 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + ','
				  + '''' + @DATABASE_NAME + '''' + ',
                    
                    RH.* FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '

				 
				 EXECUTE (@SQL2)
				 
       END 
  




UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SQL_DATABASE_FILES]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SQL_DATABASE_FILES (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @C_DATABASE_NAME NVARCHAR(128), @ROW_COUNT BIGINT = 0
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDF_SYSDATABASES')
  DROP SYNONYM [dbo].DYN_SDF_SYSDATABASES


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES
				FOR [' + @SERVER_NAME + '].master.sys.databases'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES
				FOR master.sys.databases'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 


-- sys.master_files



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDF_SYSMASTERFILES')
  DROP SYNONYM [dbo].DYN_SDF_SYSMASTERFILES


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSMASTERFILES
				FOR [' + @SERVER_NAME + '].master.sys.master_files'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSMASTERFILES 
				FOR master.sys.master_files'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


Create Table #DBFILES
(
    DatabaseName sysname,
    Name sysname,
    physical_name nvarchar(500),
    size decimal (18,2),
    FreeSpace decimal (18,2),
	Initial_size decimal (18,2)
)   


IF @REMOTE_SERVER = 'N'
BEGIN


Exec sp_MSforeachdb '
Use [?];
Insert Into #DBFILES (DatabaseName, Name, physical_name, Size, FreeSpace,Initial_size)
    Select DB_NAME() AS [DatabaseName], Name,  physical_name,
    Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) as nvarchar) Size,
    Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) -
        Cast(FILEPROPERTY(name, ''SpaceUsed'') * 8.0/1024.0 as decimal(18,2)) as nvarchar) As FreeSpace,
		0 as Initial_size
    From sys.database_files
'

--drop table #DBFILES

END


IF @REMOTE_SERVER = 'Y'
		BEGIN

	SET QUOTED_IDENTIFIER OFF

		SET @SQL = 'SET QUOTED_IDENTIFIER OFF
				exec sp_msforeachdb "Use [?];
					Insert Into #DBFILES (DatabaseName, Name, physical_name, Size, FreeSpace, Initial_size)
					Select DB_NAME() AS [DatabaseName], Name,  physical_name,
					Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) as nvarchar) Size,
					Cast(Cast(Round(cast(size as decimal) * 8.0/1024.0,2) as decimal(18,2)) -
						Cast(FILEPROPERTY(name, '+''''+'SpaceUsed'+'''' +') * 8.0/1024.0 as decimal(18,2)) as nvarchar) As FreeSpace,
						0 as Initial_size
					From sys.database_files"
				'

			SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
						EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']'

			IF @DEBUG = 'Y'
				BEGIN
					PRINT '@SQL= ' + @SQL2
				END

			BEGIN TRY
				INSERT #DBFILES
				EXEC (@SQL2 ) 
			END TRY

			BEGIN CATCH
			--ignore the error
			END CATCH
				 
				 
		END 


		 
--REH  Add initial size of TempDB

UPDATE SDF SET [Initial_size] = MF.size * 8 /1024
FROM #DBFILES SDF  JOIN
(
  SELECT size, physical_name FROM DYN_SDF_SYSMASTERFILES ) AS MF 
  ON MF.physical_name COLLATE DATABASE_DEFAULT = SDF.physical_name COLLATE DATABASE_DEFAULT




DECLARE DB_CURSOR CURSOR  LOCAL
FOR
SELECT name from DYN_SDF_SYSDATABASES


OPEN DB_CURSOR

FETCH NEXT FROM DB_CURSOR INTO @C_DATABASE_NAME

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

--REH  Build the Synonym as we loop through each database

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_SDF_SYSDATABASES_FILES')
  DROP SYNONYM [dbo].DYN_SDF_SYSDATABASES_FILES


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES_FILES
				FOR [' + @SERVER_NAME + '].[' + @C_DATABASE_NAME + '].sys.database_files'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_SDF_SYSDATABASES_FILES
				FOR [' + @C_DATABASE_NAME + '].sys.database_files'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXECUTE (@SQL) 

INSERT INTO [DynamicsPerf]..SQL_DATABASEFILES
SELECT @SERVER_NAME                                                                           AS [RUN_NAME],
       CONVERT(NVARCHAR(50), @STATS_DATE, 121)                                             AS [STATS_TIME],
       @C_DATABASE_NAME,
       [file_id],
       [File Name] COLLATE DATABASE_DEFAULT,
       [Physical Name] COLLATE DATABASE_DEFAULT,
       [File Type],
       [Total Size in Mb],
       [Available Space in Mb],
       CEILING(CAST([Available Space in Mb] AS DECIMAL(10, 1)) / [Total Size in Mb] * 100) AS [Free Space %],
       [Growth Units],
       [max File Size in Mb],
       [DB_INITAL_SIZE(MB)]
FROM   (SELECT [file_id],
               [name]   COLLATE DATABASE_DEFAULT     AS [File Name],
               physical_name COLLATE DATABASE_DEFAULT AS [Physical Name],
               [File Type] = CASE type
                               WHEN 0 THEN 'Data'
                               WHEN 1 THEN 'Log'
                             END,
               [Total Size in Mb] = CASE CEILING([size] / 128)
                                      WHEN 0 THEN 1
                                      ELSE CEILING([size] / 128)
                                    END,
               [Available Space in Mb] = (SELECT FreeSpace FROM #DBFILES TDB WHERE DYN_SDF.physical_name COLLATE DATABASE_DEFAULT = TDB.physical_name COLLATE DATABASE_DEFAULT),
			   
									--CASE CEILING([size] / 128)
         --                                  WHEN 0 THEN ( 1 - CAST(FILEPROPERTY([name], 'SpaceUsed') AS INT) / 128 )
         --                                  ELSE ( ( [size] / 128 ) - CAST(FILEPROPERTY([name], 'SpaceUsed') AS INT) / 128 )
         --                                END,
               [Growth Units] = CASE [is_percent_growth]
                                  WHEN 1 THEN CAST(growth AS VARCHAR(20)) + '%'
                                  ELSE CAST(growth/128 AS VARCHAR(20)) + 'Mb'
                                END,
               [max File Size in Mb] = CASE [max_size]
                                         WHEN -1 THEN NULL
                                         WHEN 268435456 THEN NULL
                                         ELSE [max_size]
                                       END,
				[DB_INITAL_SIZE(MB)] = (SELECT Initial_size FROM #DBFILES TDB WHERE DYN_SDF.physical_name COLLATE DATABASE_DEFAULT = TDB.physical_name COLLATE DATABASE_DEFAULT)
        FROM   DYN_SDF_SYSDATABASES_FILES DYN_SDF) AS RH
ORDER  BY [File Type],
          [file_id] 


SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

FETCH NEXT FROM DB_CURSOR INTO @C_DATABASE_NAME

END  /*End of the loop */
CLOSE DB_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE DB_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 



IF OBJECT_ID('tempdb..#DBFILES') IS NOT NULL
/*Then it exists*/
   DROP TABLE #DBFILES
 


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SQL_TRACEFLAGS_RUNNING]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SQL_TRACEFLAGS_RUNNING (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


  IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_QUERY_TRACE_FLAGS')
  DROP SYNONYM [dbo].DYN_QUERY_TRACE_FLAGS



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 

  

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


CREATE TABLE #TRACEFLAGS
  (
     TRACEFLAG    INT,
     STATUS       BIT,
     GLOBAL       BIT,
     SESSIONS     BIT
  ) 

SET @SQL = 'DBCC TRACESTATUS(-1) WITH NO_INFOMSGS '

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END



IF @REMOTE_SERVER = 'N'
BEGIN

INSERT  #TRACEFLAGS
EXEC (@SQL)

INSERT TRACEFLAGS 
SELECT @SERVER_NAME, @STATS_DATE,@DATABASE_NAME,*  FROM #TRACEFLAGS

END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
 
 /****************************************************************************
 
 REH Too avoid some nasty challenges of calling DBCC remotely in this case
	we will create a table in the remote TempDb and populate it with 
	DBCC on that side, then use normal Linked Server to insert that data
	back into DynamicsPerf
	
	Remote DBCC commands present all sort of challenges, particularly
		error 7411
 
 
 *****************************************************************************/
 
 
 --REH Drop the table on the remote server if it exists
         SET @SQL = '
				  use [tempdb]  
				  
				IF OBJECT_ID(' + ''''
									+ 'DYNPERF_TRACE_FLAGS' + ''''
									+ ' , ''U'' 
				) IS NOT NULL
				 DROP TABLE DYNPERF_TRACE_FLAGS'
				 
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)
         
         
--REH  Now create the table and populate it on the remote server


         SET @SQL = '
				CREATE TABLE [tempdb].dbo.DYNPERF_TRACE_FLAGS
					  (
						 TRACEFLAG    INT,
						 STATUS       BIT,
						 GLOBAL       BIT,
						 SESSIONS     BIT
					  ) 
					  
					  INSERT INTO [tempdb].dbo.DYNPERF_TRACE_FLAGS
					 EXEC (' +''''+ 'DBCC TRACESTATUS(-1) WITH NO_INFOMSGS' +'''' + ')
					  
					  '

         PRINT @SQL

         SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT [' + @SERVER_NAME
									 + ']'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)







--REH  Create Synonym for the table with just created and populated on the remote server.

         SET @SQL = '
				CREATE SYNONYM DYN_QUERY_TRACE_FLAGS
				FOR [' + @SERVER_NAME + '].[tempdb].dbo.DYNPERF_TRACE_FLAGS'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 
		


INSERT TRACEFLAGS 
SELECT @SERVER_NAME, @STATS_DATE,@DATABASE_NAME, *  FROM DYN_QUERY_TRACE_FLAGS

  --REH Now Drop the table to cleanup the process
  
         SET @SQL = '
				  use [tempdb]  
				  
				IF OBJECT_ID(' + ''''
									+ 'DYNPERF_TRACE_FLAGS' + ''''
									+ ' , ''U'' 
				) IS NOT NULL
				 DROP TABLE DYNPERF_TRACE_FLAGS'
				 
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)
 
 END
 
    

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/

BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_PROCESS_QUERY_PLANS]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PROCESS_QUERY_PLANS]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH Need to delete any old data in case QUERY_PLAN refresh updates the flag.  We need to delete old parsed plans

DELETE QPP
FROM   QUERY_PLANS_PARSED QPP
       INNER JOIN QUERY_PLANS QP
               ON QPP.SERVER_NAME = QP.SERVER_NAME
                  AND QPP.DATABASE_NAME = QP.DATABASE_NAME
                  AND QPP.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
WHERE  QP.PARSED_FLAG = 0 



--REH Parse out the QUERY_PLANS table into it's vital statistics

 ;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)

 INSERT QUERY_PLANS_PARSED
 SELECT *
FROM   (SELECT TOP 10000  SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH,
			   CAST(isnull(index_node.value('(..//@NodeId)[1]', 'nvarchar(128)'),'0') AS INT) AS NodeID,
               CAST(Replace(Replace(index_node.value('(.//@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '') AS NVARCHAR(128))  AS TABLE_NAME,
               CAST(Replace(Replace(index_node.value('(.//@Index)[1]', 'NVARCHAR(128)'), '[', ''), ']', '') AS NVARCHAR(128)) AS INDEX_NAME,
			   CAST(isnull(index_node.value('(.//@Lookup)[1]', 'nvarchar(128)'),'0') AS INT) AS LOOKUP,
			   CAST(isnull(index_node.value('(..//@Parallel)[1]', 'nvarchar(128)'),'0') AS INT) AS PARALLEL,
			   CAST(index_node.value('(..//@PhysicalOp)[1]', 'nvarchar(128)') AS NVARCHAR(128)) AS PHYSICALOP,
			   CAST(index_node.value('(..//@LogicalOp)[1]', 'nvarchar(128)') AS NVARCHAR(128)) AS LOGICALOP,
			   CAST(str(ISNULL(index_node.value('(..//@EstimateRows)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(14,0)) AS ESTIMATEROWS,
			   CAST(str(ISNULL(index_node.value('(..//@EstimateIO)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(20,7)) AS EstimateIO,
			   CAST(str(ISNULL(index_node.value('(..//@EstimateCPU)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(20,7)) AS ESTIMATECPU,
			   CAST(str(ISNULL(index_node.value('(..//@AvgRowSize)[1]', 'nvarchar(128)'),'0.0'),30,17) AS DECIMAL(14,0)) AS AVGROWSIZE,
			   CAST(str(isnull(index_node.value('(..//@EstimatedTotalSubtreeCost)[1]', 'nvarchar(128)') ,'0.0'),30,17) AS DECIMAL (20,7)) AS ESTIMATEDTOTALSUBTREECOST,
               CONVERT(NVARCHAR(MAX), index_node.query('for $seekpredicate in ./sp:SeekPredicates,
                                                            $rangecolumns in $seekpredicate//sp:RangeColumns,
                                                            $columnreference in $rangecolumns/sp:ColumnReference
                                        return string($columnreference/@Column)'))        AS SEEK_COLUMNS,

              CONVERT(NVARCHAR(MAX), index_node.query('for $predicate2 in ./sp:Predicate,
                                                           $Ident in  $predicate2//sp:Identifier,
														   $COLREF2 in  $Ident/sp:ColumnReference
                                                            
                                        return string($COLREF2/@Column)')) AS PREDICATES,

		    REPLACE( REPLACE( CONVERT(NVARCHAR(MAX), index_node.query('for $predicate in ./sp:Predicate,
                                                $rangecolumn in $predicate//sp:ScalarOperator
                                                            
                            return string($rangecolumn/@ScalarString)'))
							,'&lt;', '<')   ,'&gt;', '>')         AS PREDICATE_TEXT
        FROM   QUERY_PLANS
			   OUTER APPLY QUERY_PLAN.nodes('//sp:RelOp/sp:IndexScan') AS SeekPredicates(index_node)
               --CROSS APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node2)
			   WHERE QUERY_PLANS.SERVER_NAME = @SERVER_NAME AND QUERY_PLANS.PARSED_FLAG = 0

			   ) A
			   OPTION(MAXDOP 1)



;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
UPDATE QP SET SQL_PARMS = A.SQL_PARAMS
, MI_FLAG = A.MI_FLAG
, PARSED_FLAG = 1

FROM QUERY_PLANS QP

INNER JOIN  (
SELECT  TOP 10000   QT.[QUERY_PLAN_HASH],
 CONVERT (NVARCHAR(MAX), index_node.query('for $qplan in //sp:QueryPlan, $plist in $qplan/sp:ParameterList, $colref in $plist/sp:ColumnReference  return concat(string($colref/@Column),":",string($colref/@ParameterCompiledValue),",   "),"  "')) as SQL_PARAMS,
 CASE WHEN CAST(QT.QUERY_PLAN AS NVARCHAR(MAX)) LIKE '%MissingIndex%' THEN 1 ELSE 0 END as MI_FLAG
 
  FROM [QUERY_PLANS] QT
      OUTER APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node)
     WHERE SERVER_NAME = @SERVER_NAME AND PARSED_FLAG = 0
 ) as A ON A.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
 WHERE QP.PARSED_FLAG = 0
 OPTION(MAXDOP 1)
 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_PURGE_DATA]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PURGE_DATA]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


SET NOCOUNT ON
SET DATEFORMAT MDY
DECLARE @PURGE_DATE smalldatetime, @PURGE_DAYS INT, @SQL NVARCHAR(MAX), @ROW_COUNT BIGINT = 0


DECLARE  @C_TABLE_NAME NVARCHAR(128), @C_TIME_COLUMN NVARCHAR(128), @C_SERVER_FLAG BIT, @C_DATABASE_FLAG BIT, @C_PURGE_DAYS INT
DECLARE @DC_SERVER_NAME NVARCHAR(128), @DC_DATABASE_NAME NVARCHAR(128), @DC_HISTORY_MONTHS INT, @DC_HISTORY_DAYS INT, @DC_DETAILS_DAYS INT






/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''




DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT TABLE_NAME, TIME_COLUMN, SERVER_NAME_FLAG, DATABASE_NAME_FLAG, RETENTION_DAYS
FROM   DynamicsPerf..[DYNPERF_PURGETABLES] WHERE TIME_COLUMN > ''  ---REH Ignore tables without some form of time column.  The collection sproc will handle deletion of data in those tables
ORDER BY RETENTION_DAYS, TABLE_NAME    --REH this sort is to force QUERY_STATS to delete before QUERY_PLANS/QUERY_TEXT so we don't wait a day to delete records not attached to data



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TABLE_NAME, @C_TIME_COLUMN, @C_SERVER_FLAG, @C_DATABASE_FLAG, @C_PURGE_DAYS


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */



	SET @PURGE_DAYS = @C_PURGE_DAYS * -1  --set to negative so we go back in time not forward in time
	SET @PURGE_DATE = DATEADD(DD,@PURGE_DAYS,GETDATE())



	UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PURGING TABLE ' + ISNULL(@C_TABLE_NAME, 'TABLE ')
              + ' using PURGE_DAYS ' + CAST(@PURGE_DAYS AS VARCHAR(10)) + ' on DATE '
              + CONVERT(VARCHAR, @PURGE_DATE, 109) + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




IF @C_TABLE_NAME IN ('QUERY_PLANS', 'QUERY_TEXT')  --REH Use special handling for QUERY_PLANS and QUERY_TEXT TABLE delete based on no dependent records
BEGIN
--REH All associated records in other tables must be deleted first, QUERY_STATS, QUERY_HISTORY, ETC

		IF @C_TABLE_NAME = 'QUERY_PLANS'

			DELETE QP FROM QUERY_PLANS QP WHERE QP.SERVER_NAME = @SERVER_NAME AND
			 NOT EXISTS (SELECT QS.QUERY_PLAN_HASH FROM QUERY_STATS QS WHERE QS.DATABASE_NAME = QP.DATABASE_NAME AND QS.SERVER_NAME = QP.SERVER_NAME AND QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH) 
				AND NOT EXISTS (SELECT QUERY_PLAN_HASH FROM QUERY_HISTORY QH WHERE QH.DATABASE_NAME = QP.DATABASE_NAME AND QH.SERVER_NAME = QP.SERVER_NAME AND QP.QUERY_PLAN_HASH = QH.QUERY_PLAN_HASH) 
				
				SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

	   IF @C_TABLE_NAME = 'QUERY_TEXT'
			DELETE QT FROM QUERY_TEXT QT WHERE QT.SERVER_NAME = @SERVER_NAME AND
			 NOT EXISTS (SELECT QS.QUERY_HASH FROM QUERY_STATS QS WHERE QS.DATABASE_NAME = QT.DATABASE_NAME AND QS.SERVER_NAME = QT.SERVER_NAME AND QT.QUERY_HASH = QS.QUERY_HASH) 
				AND NOT EXISTS (SELECT QUERY_HASH FROM QUERY_HISTORY QH WHERE QH.DATABASE_NAME = QT.DATABASE_NAME AND QH.SERVER_NAME = QT.SERVER_NAME AND QT.QUERY_HASH = QH.QUERY_HASH) 

				SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

END
ELSE
IF @C_TABLE_NAME IN ('QUERY_STATS', 'INDEX_DETAIL')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE

		BEGIN

				IF @C_TABLE_NAME = 'QUERY_STATS'
					DELETE QS FROM QUERY_STATS QS INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE QS.SERVER_NAME = @SERVER_NAME AND QS.STATS_TIME < DATEADD(D,DC.RETAIN_DETAILS_DAYS * -1, GETDATE())

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

				IF @C_TABLE_NAME = 'INDEX_DETAIL'
					DELETE ID FROM INDEX_DETAIL ID INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.STATS_TIME < DATEADD(D,DC.RETAIN_DETAILS_DAYS * -1, GETDATE())

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
		
				
		END

ELSE
IF @C_TABLE_NAME IN ('CAPTURE_LOG')


	BEGIN

	
	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE  ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

	END
ELSE

IF @C_TABLE_NAME IN ('INDEX_HISTORY', 'QUERY_HISTORY')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE

		BEGIN

				IF @C_TABLE_NAME = 'QUERY_HISTORY'
				BEGIN
					--REH DELETE MONTHLY QUERY TOTALS 
					DELETE QS FROM QUERY_HISTORY QS INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE  QS.SERVER_NAME = @SERVER_NAME AND QS.DATE < DATEADD(MM,DC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) AND QS.FLAG = 'M'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



					--REH DELETE DAYS TOTALS FROM QUERY_HISTORY		
					DELETE QS FROM QUERY_HISTORY QS INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE  QS.SERVER_NAME = @SERVER_NAME AND QS.DATE < DATEADD(MM,DC.RETAIN_HISTORY_DAYS * -1, GETDATE()) AND QS.FLAG = 'D'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

											--REH STALE QUERY delete

							;WITH CTE_HIST (SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, MAX_DATE)
								 AS (SELECT SERVER_NAME,
											DATABASE_NAME,
											QUERY_HASH,
											QUERY_PLAN_HASH,
											MAX(DATE)
									 FROM   QUERY_HISTORY
									 GROUP  BY SERVER_NAME,
											   DATABASE_NAME,
											   QUERY_HASH,
											   QUERY_PLAN_HASH)
							DELETE QS
							FROM   QUERY_HISTORY QS
								   INNER JOIN DATABASES_2_COLLECT DC
										   ON QS.SERVER_NAME = DC.LINKED_SERVER
											  AND QS.DATABASE_NAME = DC.DATABASE_NAME
								   INNER JOIN CTE_HIST CTE
										   ON CTE.SERVER_NAME = QS.SERVER_NAME
											  AND CTE.DATABASE_NAME = QS.DATABASE_NAME
											  AND CTE.QUERY_HASH = QS.QUERY_HASH
											  AND CTE.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
							WHERE  QS.SERVER_NAME = @SERVER_NAME
								   AND CTE.MAX_DATE < DATEADD(MM, DC.PURGE_STALE_QUERIES_DAYS * -1, GETDATE()) 


						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

				END

				IF @C_TABLE_NAME = 'INDEX_HISTORY'
				BEGIN
					DELETE ID FROM INDEX_HISTORY ID INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.DATE < DATEADD(MM,DC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) AND ID.FLAG = 'M'

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

					DELETE ID FROM INDEX_HISTORY ID INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.DATE < DATEADD(MM,DC.RETAIN_HISTORY_DAYS * -1, GETDATE()) AND ID.FLAG = 'D'

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

				END	
			
		END

ELSE

IF @C_TABLE_NAME IN ('SSRS_EXECUTIONLOG', 'SSRS_HISTORY')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE
BEGIN
	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
END


ELSE

BEGIN



	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE SERVER_NAME =  ' + ''''+ @SERVER_NAME + '''' + ' AND ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

END




FETCH NEXT FROM TASK_CURSOR INTO @C_TABLE_NAME, @C_TIME_COLUMN, @C_SERVER_FLAG, @C_DATABASE_FLAG, @C_PURGE_DAYS


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
	


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Deleted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[SET_AX_SQLTRACE]...';


GO


ALTER PROCEDURE [dbo].[SET_AX_SQLTRACE] @SERVER_NAME NVARCHAR(128) = @@SERVERNAME,
								@DATABASE_NAME    NVARCHAR(128),
                                 @QUERY_TIME_LIMIT INT = 5000,
                                 @AX_ID            NVARCHAR(10) = NULL,
                                 @TRACE_STATUS     NVARCHAR(3) = 'ON', 
                                 @CLIENTACESSLOG   INT = 0
AS

  DECLARE @SQL NVARCHAR(1000),
          @RC  INT

  SET @RC = 0

  IF NOT EXISTS (SELECT *
                 FROM   sys.databases
                 WHERE  name = @DATABASE_NAME)
    BEGIN
        PRINT @DATABASE_NAME + ' DOES NOT EXIST'
        SET @RC = 1
        GOTO ERROR
    END



  IF @TRACE_STATUS = 'ON'
    BEGIN
        
          SET @SQL = 'UPDATE [' +@SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO
				SET QUERYTIMELIMIT = ' + Str(@QUERY_TIME_LIMIT) + ',
					DEBUGINFO =  268,
					TRACEINFO =  2048'
			IF @AX_ID IS NOT NULL	
			SET @SQL = @SQL + 	' WHERE ID = ''' + @AX_ID + ''''	
			

				MERGE AX_SQLTRACE_CONFIG AS target
				USING (SELECT SERVER_NAME,
							  DATABASE_NAME,
							  @QUERY_TIME_LIMIT AS SQL_DURATION,
							  1                 AS TRACE_ON,		--REH Turns it ON
							  AXDB_DELETION_DAYS
					   FROM   AX_SQLTRACE_CONFIG
					   WHERE  SERVER_NAME = @SERVER_NAME
							  AND DATABASE_NAME = @DATABASE_NAME) AS source
				ON ( source.SERVER_NAME = target.SERVER_NAME
					 AND source.DATABASE_NAME = target.DATABASE_NAME )
				WHEN MATCHED THEN
				  UPDATE SET SQL_DURATION = source.SQL_DURATION,
							 TRACE_ON = source.TRACE_ON
				WHEN NOT MATCHED THEN
				  INSERT ( [SERVER_NAME],
						   [DATABASE_NAME],
						   [SQL_DURATION],
						   [TRACE_ON],
						   [AXDB_DELETION_DAYS])
				  VALUES (source.[SERVER_NAME],
						  source.[DATABASE_NAME],
						  source.[SQL_DURATION],
						  source.[TRACE_ON],
						  14);		--REH default 14 days, DYNPERF_SET_AX_SQLTRACE sproc will delete from systracetable in the AX database using this value
									-- setting it to 0 disables this feature
			
			END
  ELSE
    IF @TRACE_STATUS = 'OFF'
      BEGIN
          IF @AX_ID IS NULL
            SET @SQL = 'UPDATE [' +@SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO
				SET QUERYTIMELIMIT = 0,
					DEBUGINFO =  12,
					TRACEINFO =  0'
					
			IF @AX_ID IS NOT NULL	
			SET @SQL = @SQL + 	' WHERE ID = ''' + @AX_ID + ''''	

        	--REH Insert a record so that our scheduled job auto updates it
MERGE AX_SQLTRACE_CONFIG AS target
				USING (SELECT SERVER_NAME,
							  DATABASE_NAME,
							  @QUERY_TIME_LIMIT AS SQL_DURATION,
							  0                 AS TRACE_ON,			--REH turns it off
							  AXDB_DELETION_DAYS
					   FROM   AX_SQLTRACE_CONFIG
					   WHERE  SERVER_NAME = @SERVER_NAME
							  AND DATABASE_NAME = @DATABASE_NAME) AS source
				ON ( source.SERVER_NAME = target.SERVER_NAME
					 AND source.DATABASE_NAME = target.DATABASE_NAME )
				WHEN MATCHED THEN
				  UPDATE SET SQL_DURATION = source.SQL_DURATION,
							 TRACE_ON = source.TRACE_ON
				WHEN NOT MATCHED THEN
				  INSERT ( [SERVER_NAME],
						   [DATABASE_NAME],
						   [SQL_DURATION],
						   [TRACE_ON],
						   [AXDB_DELETION_DAYS])
				  VALUES (source.[SERVER_NAME],
						  source.[DATABASE_NAME],
						  source.[SQL_DURATION],
						  source.[TRACE_ON],
						  14); --REH default 14 days, DYNPERF_SET_AX_SQLTRACE sproc will delete from systracetable in the AX database using this value
								-- setting it to 0 disables this feature
      END
    ELSE
      PRINT 'Invalid @TRACE_STATUS option; must be ON or OFF'

  PRINT @SQL
  EXEC (@SQL)
 

 
  ENDPROC:

  ERROR:

  RETURN @RC
GO
PRINT N'Creating [dbo].[DYNPERF_COLLECT_AZURE_EVENTLOG]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE PROCEDURE [dbo].[DYNPERF_COLLECT_AZURE_EVENTLOG]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30), @START_POS INT, @END_POS INT
    DECLARE @INSTANCE_NAME NVARCHAR(128)
    
    
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/




IF @AZURE_DB = 0 RETURN(0)  --REH THIS SPROC IS MEANT FOR AZURE ONLY





IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AZURE_EVENTS')
  DROP SYNONYM [dbo].DYN_AZURE_EVENTS


IF @REMOTE_SERVER = 'Y'
     BEGIN

--REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS

         SET @SQL = '
				CREATE SYNONYM DYN_AZURE_EVENTS
				FOR [' + @SERVER_NAME + '].[master].sys.event_log'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AZURE_EVENTS
				FOR master.sys.event_log'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 




/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH The end_time column in this event is in UTC time so we do not need to convert ours since we pass to this sproc in UTC time


----REH  Time Zone code for all procedures
--IF @LAST_RUN > '1/1/1901'
--  BEGIN
--      IF @REMOTE_SERVER = 'N'
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
--        END
--      ELSE
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
--        END
--  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

		--SET @END_POS = LEN(@SERVER_NAME)
		--SET @START_POS = CHARINDEX('\', @SERVER_NAME,1)+1
		--IF @START_POS > 0
		--BEGIN
		--	SET @INSTANCE_NAME = 'MSSQL$' + SUBSTRING(@SERVER_NAME, @START_POS, @END_POS) + ':'
		--END
		--ELSE
		--BEGIN
		--	SET @INSTANCE_NAME = 'SQLServer:'
		--END
		
		

INSERT AZURE_EVENTS
SELECT @SERVER_NAME,
       @STATS_DATE,
       @DATABASE_NAME,
       AE.[database_name],
       AE.[start_time],
       AE.[end_time],
       AE.[event_category],
       AE.[event_type],
       AE.[event_subtype],
       AE.[event_subtype_desc],
       AE.[severity],
       AE.[event_count],
       AE.[description],
       AE.[additional_data]
FROM   DYN_AZURE_EVENTS AE
WHERE  AE.severity > 0 --Warnings and above
AND AE.database_name = @DATABASE_NAME
AND AE.[end_time] > @LAST_RUN  --REH LAST_RUN is UTC time in this case


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Refreshing [dbo].[SP_DELETE_AOTEXPORT]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[SP_DELETE_AOTEXPORT]';

PRINT 'Refreshing Scheduling table'

USE [DynamicsPerf]
GO


/************************************************************************

CORE_SCHEDULE
AX_SCHEDULE
CRM_SCHEDULE

*************************************************************************/

--REH populate the scheduling tables 
/****************************************

CORE_SCHEDULE

These are the core tasks for all databases
*****************************************/




TRUNCATE TABLE DYNPERF_TASK_SCHEDULER

-- Enabled, Dynamics Product, Sproc Name, Sproc Parms, Task Desc, Sched Units, Sched qty, Sched time, Azure, Linked Server , Server level task, Task group


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_QUERY_STATS', NULL, 'Collect QUERY_STATS for database','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_INDEXSTATS', NULL, 'Collect INDEX STATS for database','HH',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_TEXT', NULL, 'Collect SQL TEXT for database','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_QUERY_PLANS', NULL, 'Collect QUERY PLANS for database','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SYSOBJECTS', NULL, 'Collect SYSTEM OBJECT DEFINITIONS for database','DD',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_WAITSTATS', NULL, 'Collect SERVER WAIT STATS for server','HH',1,NULL,1,1,1,'COLLECT');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_VIRTIALIO_DISKSTATS', NULL, 'Collect VIRTUAL I/O DISK STATS for database','HH',1,NULL,1,1,0,'COLLECT');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_CHANGE_DATA_CONTROL', NULL, 'Collect CHANGE DATA CONTROL for database','DD',1,NULL,0,1,0,'COLLECT');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_CHANGE_TRACKING', NULL, 'Collect CHANGE TRACKING for database','DD',1,NULL,1,1,0,'COLLECT')


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SSRS_EXECUTIONLOG', NULL, 'Collect SSRS for database','MI',5,NULL,1,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_DATA_BUFFER_CACHE', NULL, 'Collect SQL DATA BUFFER CACHE for server','DD',1,NULL,1,1,1,'COLLECT')


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_DATABASES', NULL, 'Collect SQL DATABASES INFORMATION for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_DATABASE_REPLICATION_INFO', NULL, 'Collect REPLICATION CONFIGURATION for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_CONFIGURATION', NULL, 'Collect SQL CONFIGURATION INFORMATION for server','DD',1,NULL,0,1,1,'COLLECT')


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_DATABASE_FILES', NULL, 'Collect SQL DATABASE FILE INFORMATION for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_DATABASE_VLFS', NULL, 'Collect SQL TLOG VLFS for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_INDEX_USAGE_STATS', NULL, 'Collect INDEX USAGE STATS for database','HH',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_INDEX_OPERATIONAL_STATS', NULL, 'Collect INDEX OPERATIONAL STATS for database','HH',1,NULL,1,1,0,'COLLECT');
	

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_JOBS', NULL, 'Collect SQL JOBS for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVERINFO', NULL, 'Collect SQL INSTANCE CONFIGURATION for server','DD',1,NULL,1,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVER_REGISTRY', NULL, 'Collect SQL STARTUP PARMS IN THE REGISTRY for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVER_DISKVOLUMES', NULL, 'Collect DISKVOLUMES USED BY SQL for server','WK',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVER_OS_INFO', NULL, 'Collect WINDOW OS VERSION INFO for server','WK',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_TRIGGER_INFO', NULL, 'Collect DATABASE TRIGGER INFO for database','DD',1,NULL,1,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_TRACEFLAGS_RUNNING', NULL, 'Collect RUNNING TRACE FLAGS for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_ERRORLOG', NULL, 'Collect SQL SERVER ERROR LOG for server','MI',5,NULL,1,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_DATABASE_STATISTICS', NULL, 'Collect DATABASE STATISTICS for database','WK',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_PLAN_GUIDES', NULL, 'Collect PLAN GUIDES for database','DD',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_PERF_COUNTERS', NULL, 'Collect SQL Performance Counters ','MI',5,NULL,0,1,1,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_PERF_COUNTERS_AZURE', NULL, 'Collect SQL Performance Counters for AZURE db ','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_AZURE_EVENTLOG', NULL, 'Collect sys.event_log  for AZURE db ','MI',5,NULL,1,1,0,'COLLECT');






-----------------------------------------Process Tasks -----------------------------------------------------------------------------



INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_REFRESH_QUERY_PLANS', NULL, 'Refresh old QUERY PLANS','DD',1,NULL,1,1,0,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_REFRESH_QUERY_TEXT', NULL, 'Refresh old QUERY TEXT','DD',1,NULL,1,1,0,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PROCESS_AXSQLTRACE', NULL, 'Update QUERY_HASH in AX_SQLTRACE table','MI',5,NULL,1,1,0,'PROCESS');




INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_UPDATE_QUERY_HISTORY', NULL, 'Rollup QUERY data into history tables','MI',5,NULL,1,1,1,'PROCESS');



INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_UPDATE_INDEX_HISTORY', NULL, 'Rollup INDEX data into history tables','HH',1,NULL,1,1,1,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PURGE_DATA', NULL, 'Purge data from DynamicsPerf','DD',1,NULL,1,1,1,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PROCESS_QUERY_PLANS', NULL, 'Parse all XML Query Plans','MI',5,NULL,1,1,1,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_UPDATE_SSRS_HISTORY', NULL, 'Rollup SSRS EXECUTIONLOG into History table','MI',5,NULL,1,1,1,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PROCESS_QUERY_ALERTS', NULL, 'Query Alerts Processing','MI',5,NULL,1,1,1,'PROCESS');


/****************************************

AX_SCHEDULE

These are the  tasks for Dynamics AX
*****************************************/

----------------------------------------------AX ---------------------------------------

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_SQLTRACE', NULL, 'Collect SYSTRACETABLESQL for database','MI',5,NULL,0,1,0,'COLLECT')

--REH replaced by AOTEXPORT, better data
--INSERT DYNPERF_TASK_SCHEDULER
--VALUES (1,'AX', 'DYNPERF_COLLECT_AX_BATCHSERVER', NULL, 'Collect AX BATCH TABLES for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_SQLSTORAGE', NULL, 'Collect AX SQLSTORAGE TABLE for database','WK',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_NUMBERSEQUENCE', NULL, 'Collect AX NUMBER SEQUENCES for database','HH',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_SYSGLOBALCONFIG', NULL, 'Collect AX SYSGLOBALCONFIG for database','DD',1,NULL,0,1,0,'COLLECT')

--REH AOTEXPORT class goes direct to DynamicsPerf now
--INSERT DYNPERF_TASK_SCHEDULER
--VALUES (1,'AX', 'DYNPERF_COLLECT_AX_AOTEXPORT_DATA', NULL, 'Collect AX AOTEXPORT DATA for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_SET_AX_SQLTRACE', NULL, 'Set AX_SQLTRACE for database','DD',1,NULL,0,1,1,'COLLECT')





/****************************************

CRM_SCHEDULE

These are the  tasks for Dynamics CRM
*****************************************/

----------------------------------------------CRM ---------------------------------------

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'CRM', 'DYNPERF_COLLECT_CRM_ORGANIZATION', NULL, 'Collect CRM ORGANIZATION INFO for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'CRM', 'DYNPERF_COLLECT_CRM_PLUGINS', NULL, 'Collect CRM PLUGINS INFO for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'CRM', 'DYNPERF_COLLECT_CRM_POA_TOTALS', NULL, 'Collect CRM Primary Object Access INFO for database','HH',1,NULL,0,1,0,'COLLECT')



GO
PRINT N'Update complete.';


GO
