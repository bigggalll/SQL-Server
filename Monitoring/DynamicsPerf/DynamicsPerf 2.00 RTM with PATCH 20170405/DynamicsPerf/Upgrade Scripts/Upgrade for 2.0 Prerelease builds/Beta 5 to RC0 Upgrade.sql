/*
Deployment script for DynamicsPerf

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
USE [DynamicsPerf];


GO


declare @n char(1)
set @n = char(10)

declare @stmt nvarchar(max)

select @stmt = isnull( @stmt + @n, '' ) +
'drop synonym [' + SCHEMA_NAME(schema_id) + '].[' + name + ']'
from sys.synonyms

exec sp_executesql @stmt


/*
The column [dbo].[SSRS_CONFIG].[LAST_PROCESSED] on table [dbo].[SSRS_CONFIG] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/

--TRUNCATE TABLE [SSRS_CONFIG]
--IF EXISTS (select top 1 1 from [dbo].[SSRS_CONFIG])
--    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The column [dbo].[SSRS_EXECUTIONLOG].[DATABASE_NAME] on table [dbo].[SSRS_EXECUTIONLOG] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.

The column [dbo].[SSRS_EXECUTIONLOG].[INSTANCE_NAME] on table [dbo].[SSRS_EXECUTIONLOG] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.

The column [dbo].[SSRS_EXECUTIONLOG].[STATS_TIME] on table [dbo].[SSRS_EXECUTIONLOG] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/
TRUNCATE TABLE [AX_SQLTRACE]

TRUNCATE TABLE [SSRS_EXECUTIONLOG]
IF EXISTS (select top 1 1 from [dbo].[SSRS_EXECUTIONLOG])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
/*
The column [dbo].[SSRS_HISTORY].[DATABASE_NAME] on table [dbo].[SSRS_HISTORY] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.

The column [dbo].[SSRS_HISTORY].[INSTANCE_NAME] on table [dbo].[SSRS_HISTORY] must be added, but the column has no default value and does not allow NULL values. If the table contains data, the ALTER script will not work. To avoid this issue you must either: add a default value to the column, mark it as allowing NULL values, or enable the generation of smart-defaults as a deployment option.
*/

TRUNCATE TABLE [SSRS_HISTORY]


IF EXISTS (select top 1 1 from [dbo].[SSRS_HISTORY])
    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
PRINT N'Altering [dbo].[AX_SQLTRACE]...';

GO

if not exists (select
                     column_name
               from
                     INFORMATION_SCHEMA.columns
               where
                     table_name = 'AX_SQLTRACE'
                     and column_name = 'CANPROCESS')

BEGIN 


ALTER TABLE [dbo].[AX_SQLTRACE]
    ADD [CANPROCESS] AS (CASE WHEN [QUERY_HASH] IS NULL
                                   AND len([SQL_TEXT]) < (4000) THEN (1) ELSE (0) END);
END

GO
PRINT N'Creating [dbo].[AX_SQLTRACE].[IX_AX_SQLTRACE_CANPROCESS]...';


GO

/****** Object:  Index [IX_AX_SQLTRACE_CANPROCESS]    Script Date: 06/23/2016 22:29:07 ******/
IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[AX_SQLTRACE]') AND name = N'IX_AX_SQLTRACE_CANPROCESS')
DROP INDEX [IX_AX_SQLTRACE_CANPROCESS] ON [dbo].[AX_SQLTRACE] WITH ( ONLINE = OFF )
GO



GO
CREATE NONCLUSTERED INDEX [IX_AX_SQLTRACE_CANPROCESS]
    ON [dbo].[AX_SQLTRACE]([DATABASE_NAME] ASC, [SERVER_NAME] ASC, [CANPROCESS] ASC);


GO
PRINT N'Altering [dbo].[DATABASES_2_COLLECT]...';
GO

if not exists (select
                     column_name
               from
                     INFORMATION_SCHEMA.columns
               where
                     table_name = 'DATABASES_2_COLLECT'
                     and column_name = 'NUM_PLANS_TO_KEEP')

BEGIN 


ALTER TABLE [dbo].[DATABASES_2_COLLECT]
    ADD [NUM_PLANS_TO_KEEP]       INT DEFAULT ((-1)) NULL,
        [IGNORE_QUERIES_UNDER_MS] INT DEFAULT ((0)) NULL,
        [COLLECT_TOP_X_QUERIES]   INT DEFAULT ((100)) NULL,
        [COLLECT_TOP_X_PLANS]     INT DEFAULT ((30)) NULL;

END

GO

update [DATABASES_2_COLLECT] set [NUM_PLANS_TO_KEEP] = 20, [IGNORE_QUERIES_UNDER_MS] = 0,
	[COLLECT_TOP_X_QUERIES] = 100, [COLLECT_TOP_X_PLANS] = 100

GO
PRINT N'Altering [dbo].[SSRS_CONFIG]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;

if not exists (select
                     column_name
               from
                     INFORMATION_SCHEMA.columns
               where
                     table_name = 'SSRS_CONFIG'
                     and column_name = 'LAST_PROCESSED')

BEGIN 


ALTER TABLE [dbo].[SSRS_CONFIG]
    ADD [LAST_PROCESSED]        DATETIME DEFAULT ( '1/1/2000')  NULL,
        [RETAIN_HISTORY_MONTHS] INT      DEFAULT ((24)) NULL,
        [RETAIN_HISTORY_DAYS]   INT      DEFAULT ((60)) NULL,
        [RETAIN_DETAILS_DAYS]   INT      DEFAULT ((7)) NULL;

END


GO

UPDATE [SSRS_CONFIG] SET [LAST_PROCESSED] = GETDATE(), [RETAIN_HISTORY_MONTHS]= 24, 
	[RETAIN_HISTORY_DAYS] = 60, [RETAIN_DETAILS_DAYS] = 7


SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Starting rebuilding table [dbo].[SSRS_EXECUTIONLOG]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_SSRS_EXECUTIONLOG] (
    [SERVER_NAME]        NVARCHAR (128) NOT NULL,
    [STATS_TIME]         DATETIME       NOT NULL,
    [DATABASE_NAME]      NVARCHAR (128) NOT NULL,
    [INSTANCE_NAME]      NVARCHAR (128) NOT NULL,
    [REPORTPATH]         NVARCHAR (425) NULL,
    [REPORTNAME]         NVARCHAR (512) NULL,
    [USERNAME]           NVARCHAR (260) NULL,
    [EXECUTIONID]        NVARCHAR (64)  NULL,
    [REQUESTTYPE]        VARCHAR (12)   NOT NULL,
    [FORMAT]             NVARCHAR (26)  NULL,
    [PARAMETERS]         NTEXT          NULL,
    [REPORTACTION]       VARCHAR (21)   NOT NULL,
    [TIMESTART]          DATETIME       NOT NULL,
    [TIMEEND]            DATETIME       NOT NULL,
    [TIME_DATARETRIEVAL] INT            NOT NULL,
    [TIME_PROCESSING]    INT            NOT NULL,
    [TIME_RENDERING]     INT            NOT NULL,
    [SOURCE]             VARCHAR (8)    NOT NULL,
    [STATUS]             NVARCHAR (40)  NOT NULL,
    [BYTECOUNT]          BIGINT         NOT NULL,
    [ROWCOUNT]           BIGINT         NOT NULL
);

CREATE CLUSTERED INDEX [tmp_ms_xx_index_IX_SSRS_REPORT]
    ON [dbo].[tmp_ms_xx_SSRS_EXECUTIONLOG]([TIMEEND] ASC, [SERVER_NAME] ASC, [DATABASE_NAME] ASC, [INSTANCE_NAME] ASC);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[SSRS_EXECUTIONLOG])
    BEGIN
        INSERT INTO [dbo].[tmp_ms_xx_SSRS_EXECUTIONLOG] ([TIMEEND], [SERVER_NAME], [REPORTPATH], [REPORTNAME], [USERNAME], [EXECUTIONID], [REQUESTTYPE], [FORMAT], [PARAMETERS], [REPORTACTION], [TIMESTART], [TIME_DATARETRIEVAL], [TIME_PROCESSING], [TIME_RENDERING], [SOURCE], [STATUS], [BYTECOUNT], [ROWCOUNT])
        SELECT   [TIMEEND],
                 [SERVER_NAME],
                 [REPORTPATH],
                 [REPORTNAME],
                 [USERNAME],
                 [EXECUTIONID],
                 [REQUESTTYPE],
                 [FORMAT],
                 [PARAMETERS],
                 [REPORTACTION],
                 [TIMESTART],
                 [TIME_DATARETRIEVAL],
                 [TIME_PROCESSING],
                 [TIME_RENDERING],
                 [SOURCE],
                 [STATUS],
                 [BYTECOUNT],
                 [ROWCOUNT]
        FROM     [dbo].[SSRS_EXECUTIONLOG]
        ORDER BY [TIMEEND] ASC, [SERVER_NAME] ASC;
    END

DROP TABLE [dbo].[SSRS_EXECUTIONLOG];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_SSRS_EXECUTIONLOG]', N'SSRS_EXECUTIONLOG';

EXECUTE sp_rename N'[dbo].[SSRS_EXECUTIONLOG].[tmp_ms_xx_index_IX_SSRS_REPORT]', N'IX_SSRS_REPORT', N'INDEX';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Starting rebuilding table [dbo].[SSRS_HISTORY]...';


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
SET QUOTED_IDENTIFIER ON;

SET ANSI_NULLS OFF;


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_SSRS_HISTORY] (
    [SERVER_NAME]           NVARCHAR (128) NOT NULL,
    [DATABASE_NAME]         NVARCHAR (128) NOT NULL,
    [INSTANCE_NAME]         NVARCHAR (128) NOT NULL,
    [REPORTPATH]            NVARCHAR (425) NULL,
    [REPORT_NAME]           NVARCHAR (512) NULL,
    [REPORT_DATE]           DATE           NULL,
    [TOTAL_TIME_DATA]       BIGINT         NULL,
    [TOTAL_TIME_PROCESSING] BIGINT         NULL,
    [TOTAL_TIME_RENDERING]  BIGINT         NULL,
    [MAX_REPORT_TIME_MS]    INT            NULL,
    [MIN_REPORT_TIME_MS]    INT            NULL,
    [EXECUTION_COUNT]       BIGINT         NULL,
    [MAX_SIZE_BYTES]        BIGINT         NULL,
    [MAX_ROW_COUNT]         BIGINT         NULL,
    [FLAG]                  CHAR (1)       NULL
);

CREATE CLUSTERED INDEX [tmp_ms_xx_index_IX_SSRS_HIST]
    ON [dbo].[tmp_ms_xx_SSRS_HISTORY]([REPORT_DATE] ASC, [SERVER_NAME] ASC, [DATABASE_NAME] ASC, [INSTANCE_NAME] ASC);

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[SSRS_HISTORY])
    BEGIN
        INSERT INTO [dbo].[tmp_ms_xx_SSRS_HISTORY] ([REPORT_DATE], [SERVER_NAME], [REPORTPATH], [REPORT_NAME], [TOTAL_TIME_DATA], [TOTAL_TIME_PROCESSING], [TOTAL_TIME_RENDERING], [MAX_REPORT_TIME_MS], [MIN_REPORT_TIME_MS], [EXECUTION_COUNT], [MAX_SIZE_BYTES], [MAX_ROW_COUNT], [FLAG])
        SELECT   [REPORT_DATE],
                 [SERVER_NAME],
                 [REPORTPATH],
                 [REPORT_NAME],
                 [TOTAL_TIME_DATA],
                 [TOTAL_TIME_PROCESSING],
                 [TOTAL_TIME_RENDERING],
                 [MAX_REPORT_TIME_MS],
                 [MIN_REPORT_TIME_MS],
                 [EXECUTION_COUNT],
                 [MAX_SIZE_BYTES],
                 [MAX_ROW_COUNT],
                 [FLAG]
        FROM     [dbo].[SSRS_HISTORY]
        ORDER BY [REPORT_DATE] ASC, [SERVER_NAME] ASC;
    END

DROP TABLE [dbo].[SSRS_HISTORY];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_SSRS_HISTORY]', N'SSRS_HISTORY';

EXECUTE sp_rename N'[dbo].[SSRS_HISTORY].[tmp_ms_xx_index_IX_SSRS_HIST]', N'IX_SSRS_HIST', N'INDEX';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[MISSING_INDEXES]...';
GO

IF EXISTS (SELECT * FROM sys.objects WHERE name = 'MISSING_INDEXES' and type = 'u')
    DROP TABLE [MISSING_INDEXES]

GO
CREATE TABLE [dbo].[MISSING_INDEXES] (
    [SERVER_NAME]        NVARCHAR (256) NOT NULL,
    [DATABASE_NAME]      NVARCHAR (256) NOT NULL,
    [QUERY_PLAN_HASH]    BINARY (8)     NOT NULL,
    [DATE_UPDATED]       DATETIME       NOT NULL,
    [MISSING_INDEX_INFO] NVARCHAR (MAX) NULL
);


GO
PRINT N'Creating [dbo].[MISSING_INDEXES].[IX_MISSING_QUERY_PLANS_HASH]...';


GO
CREATE CLUSTERED INDEX [IX_MISSING_QUERY_PLANS_HASH]
    ON [dbo].[MISSING_INDEXES]([QUERY_PLAN_HASH] ASC, [SERVER_NAME] ASC, [DATABASE_NAME] ASC);


GO
PRINT N'Creating [dbo].[WRK_LP_SQL_INFO]...';
GO

IF EXISTS (SELECT * FROM sys.objects WHERE name = 'WRK_LP_SQL_INFO' and type = 'u')
    DROP TABLE [WRK_LP_SQL_INFO]



GO
CREATE TABLE [dbo].[WRK_LP_SQL_INFO] (
    [SQL_STARTTIME] DATETIME      NULL,
    [SQL_BUILD]     NVARCHAR (20) NULL,
    [TZ_OFFSET]     INT           NULL
);


GO
PRINT N'Creating [dbo].[WRK_TZ_SQL_INFO]...';
GO

IF EXISTS (SELECT * FROM sys.objects WHERE name = 'WRK_TZ_SQL_INFO' and type = 'u')
    DROP TABLE [WRK_TZ_SQL_INFO]

GO
CREATE TABLE [dbo].[WRK_TZ_SQL_INFO] (
    [SQL_STARTTIME] DATETIME      NULL,
    [SQL_BUILD]     NVARCHAR (20) NULL,
    [TZ_OFFSET]     INT           NULL
);


GO
PRINT N'Creating [dbo].[INDEX_DETAIL].[IX_INDEX_DETAIL2]...';


GO

/****** Object:  Index [IX_INDEX_DETAIL2]    Script Date: 06/23/2016 22:23:24 ******/
IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[INDEX_DETAIL]') AND name = N'IX_INDEX_DETAIL2')
DROP INDEX [IX_INDEX_DETAIL2] ON [dbo].[INDEX_DETAIL] WITH ( ONLINE = OFF )
GO


GO
CREATE NONCLUSTERED INDEX [IX_INDEX_DETAIL2]
    ON [dbo].[INDEX_DETAIL]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [STATS_TIME] DESC);


GO
PRINT N'Refreshing [dbo].[AX_SQLTRACE_VW]...';


GO
SET ANSI_NULLS ON;

SET QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[AX_SQLTRACE_VW]';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[INDEX_STATS_CURR_VW]...';


GO


ALTER VIEW [dbo].[INDEX_STATS_CURR_VW]
AS

WITH CTE_SERVER(SERVER_NAME, DATABASE_NAME)
     AS (SELECT LINKED_SERVER,
                DATABASE_NAME
         FROM   [dbo].[DATABASES_2_COLLECT]),


     MAX_STATS_CTE (SERVER_NAME, DATABASE_NAME, STATS_TIME)
     AS (
        --USE OF TOP 1 INSTEAD OF GROUP BY TO AVOID AN EXPENSIVE INDEX SCAN
        SELECT TOP 1 SERVER_NAME,
                     DATABASE_NAME,
                     STATS_TIME
         FROM   INDEX_DETAIL --STATS_COLLECTION_SUMMARY
         ORDER  BY SERVER_NAME ASC,
                   DATABASE_NAME ASC,
                   STATS_TIME DESC)


SELECT D.SERVER_NAME,
       S.SQL_SERVER_STARTTIME,
       D.DATABASE_NAME,
       D.TABLE_NAME,
       D.INDEX_NAME,
       INDEX_DESCRIPTION,
       D.DATA_COMPRESSION,
       INDEX_KEYS,
       INCLUDED_COLUMNS,
       USER_SEEKS,
       USER_SCANS,
       USER_LOOKUPS,
       USER_UPDATES,
       RANGE_SCAN_COUNT,
       PAGE_COUNT,
       ROW_COUNT,
       SINGLETON_LOOKUP_COUNT,
       FORWARDED_FETCH_COUNT,
       INDEX_DEPTH,
       AVG_FRAGMENTATION_IN_PERCENT,
       FRAGMENT_COUNT,
       ROW_LOCK_WAIT_IN_MS,
       PAGE_LOCK_WAIT_IN_MS,
       INDEX_LOCK_PROMOTION_ATTEMPT_COUNT,
       INDEX_LOCK_PROMOTION_COUNT,
       PAGE_LATCH_WAIT_IN_MS,
       PAGE_IO_LATCH_WAIT_IN_MS,
       LEAF_INSERT_COUNT,
       LEAF_DELETE_COUNT,
       LEAF_UPDATE_COUNT,
       LEAF_GHOST_COUNT,
       NONLEAF_INSERT_COUNT,
       NONLEAF_DELETE_COUNT,
       NONLEAF_UPDATE_COUNT,
       LEAF_ALLOCATION_COUNT,
       NONLEAF_ALLOCATION_COUNT,
       LEAF_PAGE_MERGE_COUNT,
       NONLEAF_PAGE_MERGE_COUNT,
       LOB_FETCH_IN_PAGES,
       LOB_FETCH_IN_BYTES,
       LOB_ORPHAN_CREATE_COUNT,
       LOB_ORPHAN_INSERT_COUNT,
       ROW_OVERFLOW_FETCH_IN_PAGES,
       ROW_OVERFLOW_FETCH_IN_BYTES,
       COLUMN_VALUE_PUSH_OFF_ROW_COUNT,
       COLUMN_VALUE_PULL_IN_ROW_COUNT,
       ROW_LOCK_COUNT,
       ROW_LOCK_WAIT_COUNT,
       PAGE_LOCK_COUNT,
       PAGE_LOCK_WAIT_COUNT,
       PAGE_LATCH_WAIT_COUNT,
       PAGE_IO_LATCH_WAIT_COUNT,
       D.STATS_TIME,
       D.INDEX_ID
FROM   CTE_SERVER -- FOR EVERY SERVER & DATABASE
       CROSS APPLY(SELECT *
                   FROM   MAX_STATS_CTE CTE WITH (NOLOCK)
                   WHERE  CTE.SERVER_NAME = CTE_SERVER.SERVER_NAME
                          AND CTE.DATABASE_NAME = CTE_SERVER.DATABASE_NAME) AS CTE -- GET MAX OF STATS_DATE
       OUTER APPLY(SELECT ID.*
                   FROM   INDEX_DETAIL ID WITH (NOLOCK)
                   WHERE  ID.STATS_TIME = CTE.STATS_TIME
                          AND ID.DATABASE_NAME = CTE.DATABASE_NAME
                          AND ID.SERVER_NAME = CTE.SERVER_NAME) AS D --AND GET ALL THE INDEX_DETAILS
       JOIN STATS_COLLECTION_SUMMARY S
         ON S.SERVER_NAME = D.SERVER_NAME
            AND S.STATS_TIME = D.STATS_TIME
            AND S.DATABASE_NAME = D.DATABASE_NAME
       LEFT JOIN INDEX_USAGE_STATS U WITH (NOLOCK)
              ON U.SERVER_NAME = D.SERVER_NAME
                 AND U.STATS_TIME = D.STATS_TIME
                 AND U.DATABASE_NAME = D.DATABASE_NAME
                 AND U.OBJECT_ID = D.OBJECT_ID
                 AND U.INDEX_ID = D.INDEX_ID
       LEFT JOIN INDEX_PHYSICAL_STATS P WITH (NOLOCK)
              ON D.SERVER_NAME = P.SERVER_NAME
                 AND D.STATS_TIME = P.STATS_TIME
                 AND D.DATABASE_NAME = P.DATABASE_NAME
                 AND D.OBJECT_ID = P.OBJECT_ID
                 AND D.INDEX_ID = P.INDEX_ID
       LEFT JOIN INDEX_OPERATIONAL_STATS O WITH (NOLOCK)
              ON D.SERVER_NAME = O.SERVER_NAME
                 AND D.STATS_TIME = O.STATS_TIME
                 AND D.DATABASE_NAME = O.DATABASE_NAME
                 AND D.OBJECT_ID = O.OBJECT_ID
                 AND D.INDEX_ID = O.INDEX_ID
GO
PRINT N'Refreshing [dbo].[INDEX_KEY_ORDER_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[INDEX_KEY_ORDER_VW]';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[QUERY_PLANS_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
ALTER VIEW [dbo].[QUERY_PLANS_VW]
	AS 
	
	
	
SELECT SERVER_NAME,DATABASE_NAME,QUERY_PLAN_HASH,QUERY_PLAN,SQL_PARMS, MI_FLAG,
ISNULL(STUFF(( select '| TABLE= ' + PP.TABLE_NAME + '  NODE_ID=' + cast(PP.NODE_ID AS VARCHAR(5)) + char(10) + char(9)
+ ' ||| INDEX= ' + PP.INDEX_NAME 
+ ' ||| INDEX_KEYS= ' + ISNULL((SELECT TOP 1 INDEX_KEYS FROM INDEX_STATS_CURR_VW IV WHERE IV.SERVER_NAME = PP.SERVER_NAME AND IV.DATABASE_NAME = PP.DATABASE_NAME AND IV.TABLE_NAME = PP.TABLE_NAME AND IV.INDEX_NAME = PP.INDEX_NAME),'')
+ ' ||| PHYSICAL_OP= ' + PP.PHYSICALOP 
+ ' ||| LOGICAL_OP= ' + PP.LOGICALOP 
+ char(10) + char(9)
+ ' ||| SEEK_COLUMNS= ' + replace(PP.SEEK_COLUMNS, ' ', ',')
+ char(10) + char(9)
+ ' ||| PREDICATE_COLUMNS= ' + PREDICATES 
+ ' ||| PREDICATE_TEXT= ' + PREDICATE_TEXT 
+ char(10) + char(9)
+ ' ||| LOOKUP= ' + CAST(PP.LOOKUP AS VARCHAR(1))
+ ' ||| ESTIMATED_ROWS = ' + CAST(PP.ESTIMATEROWS AS VARCHAR(30))
+ ' ||| AVG_ROW_SIZE = ' + CAST(PP.AVGROWSIZE  AS VARCHAR(30))
+ ' ||| ESTIMATED_TOTAL_COST ' + CAST(PP.ESTIMATEDTOTALSUBTREECOST AS VARCHAR(30))
+ ' ||| ESTIMATED_IO = ' + CAST(PP.ESTIMATEIO AS VARCHAR(30))
+ ' ||| ESTIMATED_CPU = ' + CAST(PP.ESTIMATECPU AS VARCHAR(30))

+char(10) +char(10) + ' ||| INDEXES FOR THIS TABLE |||' + char(10) + CHAR(10)
	+CASE PP.LOOKUP WHEN 0 THEN STUFF((SELECT CHAR(9) + CHAR(9) + 'NAME=['+ INDEX_NAME + ']  KEYS=['+  INDEX_KEYS + ']' + CHAR(9) + INDEX_DESCRIPTION +CHAR(10)  FROM INDEX_STATS_CURR_VW IV 
	WHERE IV.SERVER_NAME = PP.SERVER_NAME AND IV.DATABASE_NAME = PP.DATABASE_NAME AND IV.TABLE_NAME = PP.TABLE_NAME 
	FOR xml path('')),1,1, '') ELSE ' ' END + CHAR(10) + CHAR(10)

	from QUERY_PLANS_PARSED PP
	where QP.SERVER_NAME = PP.SERVER_NAME
		AND QP.DATABASE_NAME = PP.DATABASE_NAME
	AND QP.QUERY_PLAN_HASH = PP.QUERY_PLAN_HASH
	ORDER BY PP.ESTIMATEROWS DESC
	FOR xml path('')),1,1, ''),'')  AS QUERY_NODES



FROM QUERY_PLANS QP
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[PERF_HOURLY_WAITSTATS_VW]...';


GO


/*********  PERF DATA Wait Stats change ************************/
ALTER VIEW [dbo].[PERF_HOURLY_WAITSTATS_VW]
AS

WITH MyCTE (SERVER_NAME, STATS_TIME, WAIT_TYPE, WAITING_TASKS_COUNT, WAIT_TIME_MS, SIGNAL_WAIT_TIME_MS, RowVersion)
     AS (SELECT WS.SERVER_NAME,
                WS.STATS_TIME,
                WS.WAIT_TYPE,
                WS.WAITING_TASKS_COUNT,
                WS.WAIT_TIME_MS,
                WS.SIGNAL_WAIT_TIME_MS,
                Row_number()
                  OVER(
                    PARTITION BY SERVER_NAME, WAIT_TYPE
                    ORDER BY STATS_TIME DESC) RowVersion
         FROM   WAIT_STATS WS)
SELECT TOP 100 PERCENT WS.SERVER_NAME,WS.STATS_TIME,
                       WS.WAIT_TYPE,
                       WS.WAITING_TASKS_COUNT - PREV.WAITING_TASKS_COUNT                                                  AS WAITING_TASKS_LAST_HOUR,
                       WS.WAIT_TIME_MS - PREV.WAIT_TIME_MS                                                                AS WAIT_TIME_MS_LAST_HOUR,
                       Cast (( WS.WAIT_TIME_MS - PREV.WAIT_TIME_MS ) / ( CASE
                                                                           WHEN ( WS.WAITING_TASKS_COUNT = PREV.WAITING_TASKS_COUNT ) THEN 1.0
                                                                           ELSE ( WS.WAITING_TASKS_COUNT - PREV.WAITING_TASKS_COUNT ) * 1.0
                                                                         END ) AS NUMERIC (10, 0))                        AS AVG_WAIT_TIME_MS_LAST_HOUR,
                       WS.SIGNAL_WAIT_TIME_MS - PREV.SIGNAL_WAIT_TIME_MS                                                  AS SIGNAL_WAIT_TIME_MS_LAST_HOUR,
                       Cast (( WS.SIGNAL_WAIT_TIME_MS - PREV.SIGNAL_WAIT_TIME_MS ) / ( CASE
                                                                                         WHEN ( WS.WAITING_TASKS_COUNT = PREV.WAITING_TASKS_COUNT ) THEN 1.0
                                                                                         ELSE ( WS.WAITING_TASKS_COUNT - PREV.WAITING_TASKS_COUNT ) * 1.0
                                                                                       END ) AS NUMERIC (10, 0))          AS AVG_SIGNAL_WAIT_TIME_MS_LAST_HOUR,
                       Cast ((( WS.SIGNAL_WAIT_TIME_MS - PREV.SIGNAL_WAIT_TIME_MS )) * 100. / ( CASE
                                                                                                  WHEN ( WS.WAIT_TIME_MS = PREV.WAIT_TIME_MS ) THEN 1
                                                                                                  ELSE ( WS.WAIT_TIME_MS - PREV.WAIT_TIME_MS )
                                                                                                END ) AS NUMERIC (10, 0)) AS RATIO_SIGNAL_WAIT_TIME_TO_WAITTIME_LAST_HOUR,
                       Rank()
                         OVER (
                           partition BY WS.STATS_TIME
                           ORDER BY WS.STATS_TIME DESC, ( (WS.WAIT_TIME_MS)-(PREV.WAIT_TIME_MS)) DESC)                    AS RANK
FROM   MyCTE WS
       INNER JOIN MyCTE PREV
               ON WS.SERVER_NAME = PREV.SERVER_NAME
                  AND WS.WAIT_TYPE = PREV.WAIT_TYPE
                  AND WS.RowVersion = PREV.RowVersion - 1
ORDER  BY WS.STATS_TIME DESC,
          WS.WAIT_TIME_MS - PREV.WAIT_TIME_MS DESC,
          WS.WAIT_TYPE
GO
PRINT N'Altering [dbo].[QUERY_PLANS_MISSING_INDEX_VW]...';


GO
ALTER VIEW [dbo].[QUERY_PLANS_MISSING_INDEX_VW]
AS
  SELECT SERVER_NAME,
         DATABASE_NAME,
         QUERY_PLAN_HASH,
         REPLACE(REPLACE(Isnull(Stuff((SELECT MISSING_INDEX_INFO
                       FROM   MISSING_INDEXES M2
                       WHERE  M2.SERVER_NAME = M1.SERVER_NAME
                              AND M2.DATABASE_NAME = M1.DATABASE_NAME
                              AND M2.QUERY_PLAN_HASH = M1.QUERY_PLAN_HASH
                       FOR xml path('')), 1, 1, ''), ''), 'MISSING_INDEX_INFO>', ''), '<MISSING_INDEX_INFO>','')
										 AS MISSING_INDEX_INFO
  FROM   MISSING_INDEXES M1
  GROUP  BY SERVER_NAME,
            DATABASE_NAME,
            QUERY_PLAN_HASH
GO
PRINT N'Altering [dbo].[QUERY_ALERTS_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
ALTER VIEW [dbo].[QUERY_ALERTS_VW]
	AS 

	SELECT QA.SERVER_NAME,
       QA.DATABASE_NAME,
       QA.STATS_TIME                                                                                                                                                                           AS ALERT_TIME,
       QA.QUERY_HASH,
       QA.QUERY_PLAN_HASH,
       QHD.EXECUTION_COUNT_TODAY                                                                                                                                                               AS EXECUTIONS_TODAY,
       CAST(QHD.ELAPSED_TIME_TODAY / 1000.000 AS DECIMAL(29, 3))                                                                                                                               AS TOTAL_TIME_TODAY,
       QHD.AVG_TIME_TODAY_MS                                                                                                                                                                   AS AVG_TIME_TODAY,
       CAST(QHD.MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                                                                                                 AS MAX_ELAPSED_TIME,
       REPLACE(REPLACE(QT.SQL_TEXT, 'SELECT ', CHAR(10)+'SELECT '), ' FROM', CHAR(10)+' FROM')
       + CHAR(10) + CHAR(10) + REPLICATE('-', 50)
       + 'QUERY PARAMETERS' + REPLICATE('-', 61)
       + CHAR(10) + QP.SQL_PARMS + CHAR(10) + CHAR(10)
       + REPLICATE('-', 50)
       + 'TABLE NODES FROM QUERY PLAN'
       + REPLICATE('-', 50) + CHAR(10)
       + ISNULL((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE QA.SERVER_NAME = QPV.SERVER_NAME AND QA.DATABASE_NAME = QPV.DATABASE_NAME AND QA.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '') AS QUERY_PLAN_PARSED,
       ISNULL((SELECT MISSING_INDEX_INFO
               FROM   QUERY_PLANS_MISSING_INDEX_VW QPV
               WHERE  QA.SERVER_NAME = QPV.SERVER_NAME
                      AND QA.DATABASE_NAME = QPV.DATABASE_NAME
                      AND QA.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '')                                                                                                                       AS MISSING_INDEXES,
       QP.SQL_PARMS                                                                                                                                                                            AS QUERY_PARAMETER_VALUES,
       QP.QUERY_PLAN,
       QT.SQL_TEXT
FROM   QUERY_ALERTS QA WITH (NOLOCK)
       INNER JOIN QUERY_HISTORY QHD
               ON QA.SERVER_NAME = QHD.SERVER_NAME
                  AND QA.DATABASE_NAME = QHD.DATABASE_NAME
                  AND QA.QUERY_HASH = QHD.QUERY_HASH
                  AND QA.QUERY_PLAN_HASH = QHD.QUERY_PLAN_HASH
				  AND QHD.FLAG = 'D'
                  AND QHD.DATE = DATEADD(day, DATEDIFF(day, 0, QA.STATS_TIME), 0)
       LEFT OUTER LOOP JOIN QUERY_PLANS QP WITH (NOLOCK)
                    ON QP.QUERY_PLAN_HASH = QA.QUERY_PLAN_HASH
                       AND QP.SERVER_NAME = QA.SERVER_NAME
                       AND QP.DATABASE_NAME = QA.DATABASE_NAME
       LEFT OUTER LOOP JOIN QUERY_TEXT AS QT
                         ON QA.QUERY_HASH = QT.QUERY_HASH
                            AND QA.SERVER_NAME = QT.SERVER_NAME
                            AND QA.DATABASE_NAME = QT.DATABASE_NAME
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[QUERY_HISTORY_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
ALTER VIEW [dbo].[QUERY_HISTORY_VW]
AS
  SELECT QH.SERVER_NAME,
         QH.DATABASE_NAME,
         QH.FLAG                                                                                                                                                                                 AS FLAG,
         DATE,
         EXECUTION_COUNT_TODAY                                                                                                                                                                   AS EXECUTION_COUNT,
         Cast(ELAPSED_TIME_TODAY / 1000.000 AS DECIMAL(29, 3))                                                                                                                                   AS TOTAL_ELAPSED_TIME,
         QH.AVG_TIME_TODAY_MS                                                                                                                                                                    AS AVG_ELAPSED_TIME,
         Cast(MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                                                                                                     AS MAX_ELAPSED_TIME,
         AVG_LOGICAL_READS = CASE EXECUTION_COUNT_TODAY
                               WHEN 0 THEN 0
                               ELSE TOTAL_LOGICAL_READS_TODAY / EXECUTION_COUNT_TODAY
                             END,
         AVG_LOGICAL_READS_MB = CASE EXECUTION_COUNT_TODAY
                                  WHEN 0 THEN 0
                                  ELSE ( TOTAL_LOGICAL_READS_TODAY / EXECUTION_COUNT_TODAY ) * 8 / 1024
                                END,
         Cast(ELAPSED_TIME_TODAY / 1000.000 AS DECIMAL(29, 3)) - Cast(TOTAL_WORKER_TIME_TODAY / 1000.000 AS DECIMAL(29, 3))                                                                      AS TOTAL_WAIT_TIME,
         AVG_ROWS_RETURNED = CASE EXECUTION_COUNT_TODAY
                               WHEN 0 THEN 0
                               ELSE TOTAL_ROWS_TODAY / EXECUTION_COUNT_TODAY
                             END,
         Replace(Replace(QT.SQL_TEXT, 'SELECT ', Char(10)+'SELECT '), ' FROM', Char(10)+' FROM')
         + Char(10) + Char(10) + Replicate('-', 50)
         + 'QUERY PARAMETERS' + Replicate('-', 61)
         + Char(10) + QP.SQL_PARMS + Char(10) + Char(10)
         + Replicate('-', 50)
         + 'TABLE NODES FROM QUERY PLAN'
         + Replicate('-', 50) + Char(10)
         + Isnull((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE QH.SERVER_NAME = QPV.SERVER_NAME AND QH.DATABASE_NAME = QPV.DATABASE_NAME AND QH.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '') AS QUERY_PLAN_PARSED,
         Isnull((SELECT MISSING_INDEX_INFO
                 FROM   QUERY_PLANS_MISSING_INDEX_VW QPV
                 WHERE  QH.SERVER_NAME = QPV.SERVER_NAME
                        AND QH.DATABASE_NAME = QPV.DATABASE_NAME
                        AND QH.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '')                                                                                                                       AS MISSING_INDEXES,
         QP.SQL_PARMS                                                                                                                                                                            AS QUERY_PARAMETER_VALUES,
         QP.QUERY_PLAN,
         QH.QUERY_PLAN_HASH,
         QH.QUERY_HASH,
         QT.SQL_TEXT                                                                                                                                                                             AS SQL_TEXT,
         TOTAL_ROWS_TODAY                                                                                                                                                                        AS TOTAL_ROWS,
         LAST_EXECUTION_TIME                                                                                                                                                                     AS LAST_EXECUTION_TIME,
         TOTAL_LOGICAL_READS_TODAY                                                                                                                                                               AS TOTAL_LOGICAL_READS,
         QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN)
  FROM   QUERY_HISTORY QH WITH (NOLOCK)
         LEFT OUTER LOOP JOIN QUERY_PLANS QP WITH (NOLOCK)
                      ON QP.QUERY_PLAN_HASH = QH.QUERY_PLAN_HASH
                         AND QP.SERVER_NAME = QH.SERVER_NAME
                         AND QP.DATABASE_NAME = QH.DATABASE_NAME
         LEFT OUTER LOOP JOIN QUERY_TEXT AS QT
                           ON QH.QUERY_HASH = QT.QUERY_HASH
                              AND QH.SERVER_NAME = QT.SERVER_NAME
                              AND QH.DATABASE_NAME = QT.DATABASE_NAME
         LEFT OUTER LOOP JOIN COMMENTS C
                           ON QH.QUERY_HASH = C.QUERY_HASH
                              AND QH.SERVER_NAME = C.SERVER_NAME
                              AND QH.DATABASE_NAME = C.DATABASE_NAME
  WHERE  EXECUTION_COUNT_TODAY > 0
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[QUERY_STATS_CURR_VW]...';


GO

ALTER VIEW [dbo].[QUERY_STATS_CURR_VW]
AS

WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT Q.SERVER_NAME,
       Q.DATABASE_NAME,
       CREATION_TIME                                                                                                AS COMPILED_TIME,
       EXECUTION_COUNT,
       EXECUTION_COUNT / CASE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                           WHEN 0 THEN 1
                           ELSE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                         END                                                                                        AS EXECUTION_PER_HOUR,
       cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                        AS TOTAL_ELAPSED_TIME,
       Q.AVG_TIME_MS                                                                                                AS AVG_ELAPSED_TIME,
       cast(MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS MAX_ELAPSED_TIME,
       AVG_LOGICAL_READS = TOTAL_LOGICAL_READS / EXECUTION_COUNT,
       AVG_LOGICAL_READS_MB = (TOTAL_LOGICAL_READS / EXECUTION_COUNT)*8/1024,
	   cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3)) - cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3)) AS TOTAL_WAIT_TIME,
       AVG_ROWS_RETURNED = TOTAL_ROWS / EXECUTION_COUNT,
       REPLACE(REPLACE(QT.SQL_TEXT,'SELECT ', CHAR(10)+'SELECT '), ' FROM', CHAR(10)+' FROM') + CHAR(10) + CHAR(10) + REPLICATE('-',50) + 'QUERY PARAMETERS'+ REPLICATE('-',61)+CHAR(10) +QP.SQL_PARMS + CHAR(10)+ CHAR(10)+
	   REPLICATE('-',50)+'TABLE NODES FROM QUERY PLAN' + REPLICATE('-',50) + CHAR(10) + ISNULL((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE Q.SERVER_NAME = QPV.SERVER_NAME AND Q.DATABASE_NAME = QPV.DATABASE_NAME AND Q.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS QUERY_PLAN_PARSED,
        ISNULL((SELECT MISSING_INDEX_INFO FROM QUERY_PLANS_MISSING_INDEX_VW QPV WHERE Q.SERVER_NAME = QPV.SERVER_NAME AND Q.DATABASE_NAME = QPV.DATABASE_NAME AND Q.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS MISSING_INDEXES,
	   QP.SQL_PARMS                                                                                                 AS QUERY_PARAMETER_VALUES,
       QUERY_PLAN,
       Q.ROW_NUM,
       Q.QUERY_HASH,
       QT.SQL_TEXT AS SQL_TEXT,
	   TOTAL_ROWS,
       MAX_ROWS,
       MIN_ROWS,
       PLAN_GENERATION_NUM,
       Q.LAST_EXECUTION_TIME,
       cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                         AS TOTAL_WORKER_TIME,
       AVG_PHYSICAL_READS = TOTAL_PHYSICAL_READS / EXECUTION_COUNT,
       AVG_LOGICAL_WRITES = TOTAL_LOGICAL_WRITES / EXECUTION_COUNT,
       cast(LAST_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                         AS LAST_ELAPSED_TIME,
       cast(MIN_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS MIN_ELAPSED_TIME,
       TOTAL_PHYSICAL_READS,
       LAST_PHYSICAL_READS,
       MIN_PHYSICAL_READS,
       MAX_PHYSICAL_READS,
       TOTAL_LOGICAL_READS,
       LAST_LOGICAL_READS,
       MIN_LOGICAL_READS,
       MAX_LOGICAL_READS,
       TOTAL_LOGICAL_WRITES,
       LAST_LOGICAL_WRITES,
       MIN_LOGICAL_WRITES,
       MAX_LOGICAL_WRITES,
       cast(LAST_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS LAST_WORKER_TIME,
       cast(MIN_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS MIN_WORKER_TIME,
       cast(MAX_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS MAX_WORKER_TIME,
       QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN),
       S.STATS_TIME,
       SQL_VERSION,
       S.SQL_SERVER_STARTTIME,
       Q.QUERY_PLAN_HASH,
       C.COMMENT
FROM   (SELECT QS2.SERVER_NAME,
               QS2.DATABASE_NAME,
               QUERY_HASH,
               max(QS2.STATS_TIME)      AS STATS_TIME,
               max(LAST_EXECUTION_TIME) AS LAST_EXECUTION_TIME
        FROM   QUERY_STATS QS2
               INNER JOIN STATS_COLLECTION_SUMMARY S2 WITH (NOLOCK)
                       ON QS2.STATS_TIME = S2.STATS_TIME
                          AND QS2.DATABASE_NAME = S2.DATABASE_NAME
                          AND QS2.SERVER_NAME = S2.SERVER_NAME
                          
        GROUP  BY QS2.SERVER_NAME,
                  QS2.DATABASE_NAME,
                  QUERY_HASH,
				  QUERY_PLAN_HASH) AS A
       INNER LOOP JOIN QUERY_STATS Q WITH (NOLOCK)
                    ON A.SERVER_NAME = Q.SERVER_NAME
                       AND A.DATABASE_NAME = Q.DATABASE_NAME
                       AND A.QUERY_HASH = Q.QUERY_HASH
                       AND A.LAST_EXECUTION_TIME = Q.LAST_EXECUTION_TIME
                       AND A.STATS_TIME = Q.STATS_TIME
       LEFT OUTER JOIN QUERY_PLANS QP WITH (NOLOCK)
               ON QP.QUERY_PLAN_HASH = Q.QUERY_PLAN_HASH
                  AND QP.SERVER_NAME = Q.SERVER_NAME
                  AND QP.DATABASE_NAME = Q.DATABASE_NAME
       INNER JOIN STATS_COLLECTION_SUMMARY S WITH (NOLOCK)
               ON Q.STATS_TIME = S.STATS_TIME
                  AND Q.DATABASE_NAME = S.DATABASE_NAME
                  AND Q.SERVER_NAME = S.SERVER_NAME
       LEFT OUTER JOIN QUERY_TEXT AS QT
                    ON Q.QUERY_HASH = QT.QUERY_HASH
                       AND Q.DATABASE_NAME = QT.DATABASE_NAME
                       AND Q.SERVER_NAME = QT.SERVER_NAME
       LEFT OUTER JOIN COMMENTS C
                    ON Q.QUERY_HASH = C.QUERY_HASH
                       AND Q.SERVER_NAME = C.SERVER_NAME
                       AND Q.DATABASE_NAME = C.DATABASE_NAME
GO
PRINT N'Altering [dbo].[QUERY_STATS_VW]...';


GO

ALTER VIEW [dbo].[QUERY_STATS_VW]
AS


WITH STATS_CTE ( SERVER_NAME, DATABASE_NAME, STATS_TIME, COMPILED_TIME, EXECUTION_COUNT, TOTAL_ELAPSED_TIME, AVG_ELAPSED_TIME, MAX_ELAPSED_TIME, AVG_LOGICAL_READS, AVG_LOGICAL_READS_MB, TOTAL_WAIT_TIME, AVG_ROWS_RETURNED, QUERY_PLAN_HASH, QUERY_HASH, TOTAL_ROWS, MAX_ROWS, MIN_ROWS, PLAN_GENERATION_NUM, LAST_EXECUTION_TIME, TOTAL_WORKER_TIME, AVG_PHYSICAL_READS, AVG_LOGICAL_WRITES, LAST_ELAPSED_TIME, MIN_ELAPSED_TIME, TOTAL_PHYSICAL_READS, LAST_PHYSICAL_READS, MIN_PHYSICAL_READS, MAX_PHYSICAL_READS, TOTAL_LOGICAL_READS, LAST_LOGICAL_READS, MIN_LOGICAL_READS, MAX_LOGICAL_READS, TOTAL_LOGICAL_WRITES, LAST_LOGICAL_WRITES, MIN_LOGICAL_WRITES, MAX_LOGICAL_WRITES, LAST_WORKER_TIME, MIN_WORKER_TIME, MAX_WORKER_TIME )
     AS (SELECT QS.SERVER_NAME,
                QS.DATABASE_NAME,
                STATS_TIME,
                MIN(CREATION_TIME)                                                                                                     AS COMPILED_TIME,
                SUM(EXECUTION_COUNT)                                                                                                   AS EXECUTION_COUNT,
                CAST(SUM(TOTAL_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                             AS TOTAL_ELAPSED_TIME,
                AVG(QS.AVG_TIME_MS)                                                                                                    AS AVG_ELAPSED_TIME,
                CAST(SUM(MAX_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                               AS MAX_ELAPSED_TIME,
                AVG_LOGICAL_READS = SUM(TOTAL_LOGICAL_READS) / SUM(EXECUTION_COUNT),
                AVG_LOGICAL_READS_MB = (SUM(TOTAL_LOGICAL_READS) / SUM(EXECUTION_COUNT)) * 8 / 1024,
				CAST(SUM(TOTAL_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3)) - CAST(SUM(TOTAL_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3)) AS TOTAL_WAIT_TIME,
                AVG_ROWS_RETURNED = SUM(TOTAL_ROWS) / SUM(EXECUTION_COUNT),
                QS.QUERY_PLAN_HASH,
                QS.QUERY_HASH,
                SUM(TOTAL_ROWS)                                                                                                        AS TOTAL_ROWS,
                MAX(MAX_ROWS)                                                                                                          AS MAX_ROWS,
                MIN(MIN_ROWS)                                                                                                          AS MIN_ROWS,
                MAX(PLAN_GENERATION_NUM)                                                                                               AS PLAN_GENERATION_NUM,
                MAX(LAST_EXECUTION_TIME)                                                                                               AS LAST_EXECUTION_TIME,
                CAST(SUM(TOTAL_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                              AS TOTAL_WORKER_TIME,
                AVG_PHYSICAL_READS = SUM(TOTAL_PHYSICAL_READS) / SUM(EXECUTION_COUNT),
                AVG_LOGICAL_WRITES = SUM(TOTAL_LOGICAL_WRITES) / SUM(EXECUTION_COUNT),
                CAST(AVG(LAST_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                              AS LAST_ELAPSED_TIME,
                CAST(MIN(MIN_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                               AS MIN_ELAPSED_TIME,
                SUM(TOTAL_PHYSICAL_READS)                                                                                              AS TOTAL_PHYSICAL_READS,
                AVG(LAST_PHYSICAL_READS)                                                                                               AS LAST_PHYSICAL_READS,
                MIN(MIN_PHYSICAL_READS)                                                                                                AS MIN_PHYSICAL_READS,
                MAX(MAX_PHYSICAL_READS)                                                                                                AS MAX_PHYSICAL_READS,
                SUM(TOTAL_LOGICAL_READS)                                                                                               AS TOTAL_LOGICAL_READS,
                AVG(LAST_LOGICAL_READS)                                                                                                AS LAST_LOGICAL_READS,
                MIN(MIN_LOGICAL_READS)                                                                                                 AS MIN_LOGICAL_READS,
                MAX(MAX_LOGICAL_READS)                                                                                                 AS MAX_LOGICAL_READS,
                SUM(TOTAL_LOGICAL_WRITES)                                                                                              AS TOTAL_LOGICAL_WRITES,
                AVG(LAST_LOGICAL_WRITES)                                                                                               AS LAST_LOGICAL_WRITES,
                MIN(MIN_LOGICAL_WRITES)                                                                                                AS MIN_LOGICAL_WRITES,
                MAX(MAX_LOGICAL_WRITES)                                                                                                AS MAX_LOGICAL_WRITES,
                CAST(AVG(LAST_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                               AS LAST_WORKER_TIME,
                CAST(MIN(MIN_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                                AS MIN_WORKER_TIME,
                CAST(MAX(MAX_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                                AS MAX_WORKER_TIME
         FROM   QUERY_STATS QS WITH (NOLOCK)
         GROUP  BY QS.SERVER_NAME,
                   QS.DATABASE_NAME,
                   QS.STATS_TIME,
                   QS.QUERY_HASH,
                   QS.QUERY_PLAN_HASH)
-------------------------------------------------
SELECT CTE.SERVER_NAME,
       CTE.DATABASE_NAME,
       CTE.COMPILED_TIME,
       CTE.EXECUTION_COUNT,
       CTE.EXECUTION_COUNT / CASE ( Datediff(HOUR, CTE.COMPILED_TIME, CTE.STATS_TIME) )
                               WHEN 0 THEN 1
                               ELSE ( Datediff(HOUR, CTE.COMPILED_TIME, CTE.STATS_TIME) )
                             END                                                                                                                                                            AS EXECUTION_PER_HOUR,
       CTE.TOTAL_ELAPSED_TIME,
       CTE.AVG_ELAPSED_TIME,
       CTE.MAX_ELAPSED_TIME,
       CTE.AVG_LOGICAL_READS,
	   CTE.AVG_LOGICAL_READS_MB,
       CTE.TOTAL_WAIT_TIME,
       AVG_ROWS_RETURNED,
       Replace(Replace(QT.SQL_TEXT, 'SELECT ', Char(10)+'SELECT '), ' FROM', Char(10)+' FROM')
       + Char(10) + Char(10) + REPLICATE('-',50) + 'QUERY PARAMETERS'+ REPLICATE('-',61)+CHAR(10)  +QP.SQL_PARMS + CHAR(10)+ CHAR(10)+ 
	   REPLICATE('-',50)+'TABLE NODES FROM QUERY PLAN' + REPLICATE('-',50) + Char(10) + Isnull((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE CTE.SERVER_NAME = QPV.SERVER_NAME AND CTE.DATABASE_NAME = QPV.DATABASE_NAME AND CTE.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '') AS QUERY_PLAN_PARSED,
	    ISNULL((SELECT MISSING_INDEX_INFO FROM QUERY_PLANS_MISSING_INDEX_VW QPV WHERE CTE.SERVER_NAME = QPV.SERVER_NAME AND CTE.DATABASE_NAME = QPV.DATABASE_NAME AND CTE.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS MISSING_INDEXES,
       QP.SQL_PARMS                                                                                                                                                                         AS QUERY_PARAMETER_VALUES,
       QP.QUERY_PLAN,
       CTE.QUERY_HASH,
       CTE.QUERY_PLAN_HASH,
       QT.SQL_TEXT                                                                                                                                                                          AS SQL_TEXT,
       CTE.TOTAL_ROWS,
       CTE.MAX_ROWS,
       CTE.MIN_ROWS,
       CTE.PLAN_GENERATION_NUM,
       CTE.LAST_EXECUTION_TIME,
       CTE.TOTAL_WORKER_TIME,
       CTE.AVG_PHYSICAL_READS,
       CTE.AVG_LOGICAL_WRITES,
       CTE.LAST_ELAPSED_TIME,
       CTE.MIN_ELAPSED_TIME,
       CTE.TOTAL_PHYSICAL_READS,
       CTE.LAST_PHYSICAL_READS,
       CTE.MIN_PHYSICAL_READS,
       CTE.MAX_PHYSICAL_READS,
       CTE.TOTAL_LOGICAL_READS,
       CTE.LAST_LOGICAL_READS,
       CTE.MIN_LOGICAL_READS,
       CTE.MAX_LOGICAL_READS,
       CTE.TOTAL_LOGICAL_WRITES,
       CTE.LAST_LOGICAL_WRITES,
       CTE.MIN_LOGICAL_WRITES,
       CTE.MAX_LOGICAL_WRITES,
       CTE.LAST_WORKER_TIME,
       CTE.MIN_WORKER_TIME,
       CTE.MAX_WORKER_TIME,
       QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN),
	   CTE.STATS_TIME,
       C.COMMENT
FROM   STATS_CTE CTE
       LEFT OUTER LOOP JOIN QUERY_PLANS QP WITH (NOLOCK)
                    ON QP.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH
                       AND QP.SERVER_NAME = CTE.SERVER_NAME
                       AND QP.DATABASE_NAME = CTE.DATABASE_NAME
       LEFT OUTER LOOP JOIN QUERY_TEXT AS QT
                         ON CTE.QUERY_HASH = QT.QUERY_HASH
                            AND CTE.SERVER_NAME = QT.SERVER_NAME
                            AND CTE.DATABASE_NAME = QT.DATABASE_NAME
       LEFT OUTER LOOP JOIN COMMENTS C
                         ON CTE.QUERY_HASH = C.QUERY_HASH
                            AND CTE.SERVER_NAME = C.SERVER_NAME
                            AND CTE.DATABASE_NAME = C.DATABASE_NAME
GO
PRINT N'Refreshing [dbo].[HIDDEN_SCANS_CURR_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[HIDDEN_SCANS_CURR_VW]';


GO
PRINT N'Refreshing [dbo].[USER_SCANS_CURR_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[USER_SCANS_CURR_VW]';


GO
PRINT N'Altering [dbo].[DYNPERF_PROCESS_AXSQLTRACE]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PROCESS_AXSQLTRACE]
		(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

SELECT SERVER_NAME, DATABASE_NAME, QUERY_HASH, SQL_TEXT, ROW_NUM 
INTO #AX_SQLTRACE 
FROM AX_SQLTRACE AST
WHERE  SERVER_NAME = @SERVER_NAME
       AND DATABASE_NAME = @DATABASE_NAME
	   AND AST.CANPROCESS = 1
    --   AND AST.QUERY_HASH IS NULL 
	   --AND LEN(AST.SQL_TEXT) < 4000

UPDATE AST
SET    QUERY_HASH = COALESCE((SELECT TOP 1 QUERY_HASH
                     FROM   QUERY_TEXT QT WITH (NOLOCK)
                     WHERE  QT.SERVER_NAME = AST.SERVER_NAME
                            AND QT.DATABASE_NAME = AST.DATABASE_NAME
                            AND QT.SQL_TEXT LIKE REPLACE(AST.SQL_TEXT, '?', '%')), 0X00) --REH There could be several. We are only getting the first
FROM   #AX_SQLTRACE AST
--WHERE  SERVER_NAME = @SERVER_NAME
--       AND DATABASE_NAME = @DATABASE_NAME
--       AND AST.QUERY_HASH IS NULL 
--	   AND LEN(AST.SQL_TEXT) < 4000 --REH LIKE command is limited to 8k characters

UPDATE AST
SET QUERY_HASH = ASTEMP.QUERY_HASH
FROM AX_SQLTRACE AST
INNER JOIN #AX_SQLTRACE ASTEMP ON AST.ROW_NUM = ASTEMP.ROW_NUM

--UPDATE AST
--SET    QUERY_HASH = (SELECT TOP 1 QUERY_HASH
--                     FROM   QUERY_TEXT QT
--                     WHERE  QT.SERVER_NAME = AST.SERVER_NAME
--                            AND QT.DATABASE_NAME = AST.DATABASE_NAME
--                            AND QT.SQL_TEXT LIKE REPLACE(AST.SQL_TEXT, '?', '%')) --REH There could be several. We are only getting the first
--FROM   AX_SQLTRACE AST WITH (READPAST)
--WHERE  SERVER_NAME = @SERVER_NAME
--       AND DATABASE_NAME = @DATABASE_NAME
--       AND AST.QUERY_HASH IS NULL 
--	   AND LEN(AST.SQL_TEXT) <= 4000 --REH LIKE command is limited to 8k characters NVARCHAR 4k = 8k characters
--	   AND AST.CREATED_DATETIME > DATEADD(DD,CAST(@TASK_PARAMS as INT) * -1,@LAST_RUN)  --REH keep trying to parse queries for X days, based on @task_params


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_PURGE_DATA]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PURGE_DATA]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


SET NOCOUNT ON
SET DATEFORMAT MDY
DECLARE @PURGE_DATE smalldatetime, @PURGE_DAYS INT, @SQL NVARCHAR(MAX), @ROW_COUNT BIGINT = 0


DECLARE  @C_TABLE_NAME NVARCHAR(128), @C_TIME_COLUMN NVARCHAR(128), @C_SERVER_FLAG BIT, @C_DATABASE_FLAG BIT, @C_PURGE_DAYS INT
DECLARE @DC_SERVER_NAME NVARCHAR(128), @DC_DATABASE_NAME NVARCHAR(128), @DC_HISTORY_MONTHS INT, @DC_HISTORY_DAYS INT, @DC_DETAILS_DAYS INT






/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''




DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT TABLE_NAME, TIME_COLUMN, SERVER_NAME_FLAG, DATABASE_NAME_FLAG, RETENTION_DAYS
FROM   DynamicsPerf..[DYNPERF_PURGETABLES] WHERE TIME_COLUMN > ''  ---REH Ignore tables without some form of time column.  The collection sproc will handle deletion of data in those tables
ORDER BY RETENTION_DAYS, TABLE_NAME    --REH this sort is to force QUERY_STATS to delete before QUERY_PLANS/QUERY_TEXT so we don't wait a day to delete records not attached to data



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TABLE_NAME, @C_TIME_COLUMN, @C_SERVER_FLAG, @C_DATABASE_FLAG, @C_PURGE_DAYS


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */



	SET @PURGE_DAYS = @C_PURGE_DAYS * -1  --set to negative so we go back in time not forward in time
	SET @PURGE_DATE = DATEADD(DD,@PURGE_DAYS,GETDATE())



	UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PURGING TABLE ' + ISNULL(@C_TABLE_NAME, 'TABLE ')
              + ' using PURGE_DAYS ' + CAST(@PURGE_DAYS AS VARCHAR(10)) + ' on DATE '
              + CONVERT(VARCHAR, @PURGE_DATE, 109) + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




IF @C_TABLE_NAME IN ('QUERY_PLANS', 'QUERY_TEXT')  --REH Use special handling for QUERY_PLANS and QUERY_TEXT TABLE delete based on no dependent records
BEGIN
--REH All associated records in other tables must be deleted first, QUERY_STATS, QUERY_HISTORY, ETC

		IF @C_TABLE_NAME = 'QUERY_PLANS'
		BEGIN

				SELECT DISTINCT QP.SERVER_NAME, QP.DATABASE_NAME, QP.QUERY_PLAN_HASH
				INTO #QP1
					 FROM QUERY_PLANS QP WHERE QP.SERVER_NAME = @SERVER_NAME AND
				 NOT EXISTS (SELECT QS.QUERY_PLAN_HASH FROM QUERY_STATS QS WHERE QS.DATABASE_NAME = QP.DATABASE_NAME AND QS.SERVER_NAME = QP.SERVER_NAME AND QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH) 
					AND NOT EXISTS (SELECT QUERY_PLAN_HASH FROM QUERY_HISTORY QH WHERE QH.DATABASE_NAME = QP.DATABASE_NAME AND QH.SERVER_NAME = QP.SERVER_NAME AND QP.QUERY_PLAN_HASH = QH.QUERY_PLAN_HASH) 
				
				DELETE QP FROM QUERY_PLANS QP INNER JOIN #QP1 ON  QP.SERVER_NAME = #QP1.SERVER_NAME 
					AND QP.DATABASE_NAME = #QP1.DATABASE_NAME AND QP.QUERY_PLAN_HASH = #QP1.QUERY_PLAN_HASH
		
				DROP TABLE #QP1


			--REH Delete any plans over the minimum number of plans to keep
				
				SELECT A.*
				INTO #DEL_PLANS
				FROM (
				SELECT DISTINCT QV.SERVER_NAME,
										QV.DATABASE_NAME,
										QUERY_HASH,
										QV.QUERY_PLAN_HASH,
										RN = ROW_NUMBER()
									  OVER (
										PARTITION BY QV.QUERY_HASH
										ORDER BY QV.QUERY_HASH DESC, QP.DATE_UPDATED DESC)
						FROM   QUERY_HISTORY_VW QV INNER JOIN QUERY_PLANS QP ON QV.SERVER_NAME=QP.SERVER_NAME
						AND QV.DATABASE_NAME = QP.DATABASE_NAME AND QV.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
						WHERE QV.DATE = DATEADD(MONTH, DATEDIFF(MONTH, 0, GETDATE()  ), 0) 

				   ) AS A 
				   INNER JOIN QUERY_PLANS QP ON QP.SERVER_NAME = A.SERVER_NAME AND QP.DATABASE_NAME = A.DATABASE_NAME AND QP.QUERY_PLAN_HASH = A.QUERY_PLAN_HASH
				   WHERE A.RN> (SELECT D2.NUM_PLANS_TO_KEEP FROM DATABASES_2_COLLECT D2 WHERE D2.LINKED_SERVER=A.SERVER_NAME AND D2.DATABASE_NAME = A.DATABASE_NAME)

					DELETE QP FROM QUERY_PLANS QP INNER JOIN #DEL_PLANS DP ON QP.SERVER_NAME = DP.SERVER_NAME
					AND QP.DATABASE_NAME = DP.DATABASE_NAME AND QP.QUERY_PLAN_HASH = DP.QUERY_PLAN_HASH

				   DROP TABLE #DEL_PLANS

			SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT


		END

				

	   IF @C_TABLE_NAME = 'QUERY_TEXT'
		BEGIN
			SELECT QT.SERVER_NAME, QT.DATABASE_NAME, QT.QUERY_HASH 
			INTO #QT 
			FROM QUERY_TEXT QT WHERE QT.SERVER_NAME = @SERVER_NAME AND
			 NOT EXISTS (SELECT QS.QUERY_HASH FROM QUERY_STATS QS WHERE QS.DATABASE_NAME = QT.DATABASE_NAME AND QS.SERVER_NAME = QT.SERVER_NAME AND QT.QUERY_HASH = QS.QUERY_HASH) 
				AND NOT EXISTS (SELECT QUERY_HASH FROM QUERY_HISTORY QH WHERE QH.DATABASE_NAME = QT.DATABASE_NAME AND QH.SERVER_NAME = QT.SERVER_NAME AND QT.QUERY_HASH = QH.QUERY_HASH) 

				DELETE QT FROM QUERY_TEXT QT INNER JOIN #QT TMP ON QT.SERVER_NAME = TMP.SERVER_NAME
				AND QT.DATABASE_NAME = TMP.DATABASE_NAME AND QT.QUERY_HASH = TMP.QUERY_HASH


				SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
		END
END
ELSE
IF @C_TABLE_NAME IN ('QUERY_STATS', 'INDEX_DETAIL')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE

		BEGIN

				IF @C_TABLE_NAME = 'QUERY_STATS'
					DELETE QS FROM QUERY_STATS QS WITH (ROWLOCK) INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE QS.SERVER_NAME = @SERVER_NAME AND QS.STATS_TIME < DATEADD(D,DC.RETAIN_DETAILS_DAYS * -1, GETDATE())

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

				IF @C_TABLE_NAME = 'INDEX_DETAIL'
					DELETE ID FROM INDEX_DETAIL ID WITH (ROWLOCK) INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.STATS_TIME < DATEADD(D,DC.RETAIN_DETAILS_DAYS * -1, GETDATE())

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
		
				
		END

ELSE
IF @C_TABLE_NAME IN ('CAPTURE_LOG')


	BEGIN

	
	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE  ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

	END
ELSE

IF @C_TABLE_NAME IN ('INDEX_HISTORY', 'QUERY_HISTORY')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE

		BEGIN

				IF @C_TABLE_NAME = 'QUERY_HISTORY'
				BEGIN
					--REH DELETE MONTHLY QUERY TOTALS 
					DELETE QS FROM QUERY_HISTORY QS INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE  QS.SERVER_NAME = @SERVER_NAME AND QS.DATE < DATEADD(MM,DC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) AND QS.FLAG = 'M'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



					--REH DELETE DAYS TOTALS FROM QUERY_HISTORY		
					DELETE QS FROM QUERY_HISTORY QS INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE  QS.SERVER_NAME = @SERVER_NAME AND QS.DATE < DATEADD(MM,DC.RETAIN_HISTORY_DAYS * -1, GETDATE()) AND QS.FLAG = 'D'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

		--REH STALE QUERY delete

							;WITH CTE_HIST (SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, MAX_DATE)
								 AS (SELECT SERVER_NAME,
											DATABASE_NAME,
											QUERY_HASH,
											QUERY_PLAN_HASH,
											MAX(DATE)
									 FROM   QUERY_HISTORY
									 GROUP  BY SERVER_NAME,
											   DATABASE_NAME,
											   QUERY_HASH,
											   QUERY_PLAN_HASH)
							DELETE QS
							FROM   QUERY_HISTORY QS
								   INNER JOIN DATABASES_2_COLLECT DC
										   ON QS.SERVER_NAME = DC.LINKED_SERVER
											  AND QS.DATABASE_NAME = DC.DATABASE_NAME
								   INNER JOIN CTE_HIST CTE
										   ON CTE.SERVER_NAME = QS.SERVER_NAME
											  AND CTE.DATABASE_NAME = QS.DATABASE_NAME
											  AND CTE.QUERY_HASH = QS.QUERY_HASH
											  AND CTE.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
							WHERE  QS.SERVER_NAME = @SERVER_NAME
								   AND CTE.MAX_DATE < DATEADD(MM, DC.PURGE_STALE_QUERIES_DAYS * -1, GETDATE()) 


						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

				END

				IF @C_TABLE_NAME = 'INDEX_HISTORY'
				BEGIN
					DELETE ID FROM INDEX_HISTORY ID INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.DATE < DATEADD(MM,DC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) AND ID.FLAG = 'M'

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

					DELETE ID FROM INDEX_HISTORY ID INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.DATE < DATEADD(MM,DC.RETAIN_HISTORY_DAYS * -1, GETDATE()) AND ID.FLAG = 'D'

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

				END	
			
		END

ELSE

IF @C_TABLE_NAME IN ('SSRS_EXECUTIONLOG', 'SSRS_HISTORY')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE
BEGIN
			IF @C_TABLE_NAME = 'SSRS_EXECUTIONLOG'
				BEGIN
					--REH DELETE MONTHLY QUERY TOTALS 
					DELETE EL FROM SSRS_EXECUTIONLOG EL 
					INNER JOIN SSRS_CONFIG SC ON EL.SERVER_NAME = SC.SERVER_NAME AND EL.DATABASE_NAME = SC.DATABASE_NAME
						WHERE  EL.TIMEEND < DATEADD(MM,SC.RETAIN_DETAILS_DAYS * -1, GETDATE()) 

					SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
				END
			IF @C_TABLE_NAME = 'SSRS_HISTORY'
				BEGIN
					--REH DELETE MONTHLY QUERY TOTALS 
					DELETE SH FROM SSRS_HISTORY SH 
						INNER JOIN SSRS_CONFIG SC ON SH.SERVER_NAME = SC.SERVER_NAME AND SH.DATABASE_NAME = SC.DATABASE_NAME
						WHERE   SH.REPORT_DATE < DATEADD(MM,SC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) AND SH.FLAG = 'M'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



					--REH DELETE DAYS TOTALS FROM QUERY_HISTORY	
					DELETE SH FROM SSRS_HISTORY SH 
						INNER JOIN SSRS_CONFIG SC ON SH.SERVER_NAME = SC.SERVER_NAME AND SH.DATABASE_NAME = SC.DATABASE_NAME
						WHERE   SH.REPORT_DATE < DATEADD(MM,SC.RETAIN_HISTORY_DAYS * -1, GETDATE()) AND SH.FLAG = 'M'
	
					SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
				END
				
END


ELSE


IF @C_TABLE_NAME IN ('QUERY_PLANS_PARSED')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE
BEGIN
	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SELECT QPP.SERVER_NAME, QPP.DATABASE_NAME, QPP.QUERY_PLAN_HASH 
	INTO #QPP FROM QUERY_PLANS_PARSED QPP 
	WHERE NOT EXISTS (SELECT 'X' FROM QUERY_HISTORY QH WHERE QPP.SERVER_NAME = QH.SERVER_NAME
	AND QPP.DATABASE_NAME = QH.DATABASE_NAME AND QPP.QUERY_PLAN_HASH = QH.QUERY_PLAN_HASH)

	DELETE QPP FROM QUERY_PLANS_PARSED QPP INNER JOIN #QPP TMP ON QPP.SERVER_NAME = TMP.SERVER_NAME
		AND QPP.DATABASE_NAME = TMP.DATABASE_NAME AND QPP.QUERY_PLAN_HASH = TMP.QUERY_PLAN_HASH

	DROP TABLE #QPP

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
END


ELSE


BEGIN



	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE SERVER_NAME =  ' + ''''+ @SERVER_NAME + '''' + ' AND ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

END




FETCH NEXT FROM TASK_CURSOR INTO @C_TABLE_NAME, @C_TIME_COLUMN, @C_SERVER_FLAG, @C_DATABASE_FLAG, @C_PURGE_DAYS


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
	


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Deleted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_REFRESH_QUERY_PLANS]...';


GO
ALTER PROCEDURE [dbo].DYNPERF_REFRESH_QUERY_PLANS
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @REFRESH_PLAN_DAYS INT
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_RQP_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_RQP_STATS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_RQP_STATS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.dm_exec_query_stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_RQP_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_query_stats'

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


  SELECT @REFRESH_PLAN_DAYS = REFRESH_PLAN_DAYS FROM DATABASES_2_COLLECT WHERE LINKED_SERVER = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @REMOTE_SERVER = 'N'
BEGIN
;WITH Query_Stats_CTE (SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH, PLAN_HANDLE )
     AS
     -- Define the CTE query.
     (SELECT  * FROM 
     (SELECT DISTINCT SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH,
                      PLAN_HANDLE
      FROM   QUERY_STATS AS QS WITH (NOLOCK)
      WHERE  STATS_TIME > DATEADD(D,-1,GETDATE())  --REH ANY QUERIES COLLECTED IN THE LAST DAY
             AND DATABASE_NAME = @DATABASE_NAME
             AND SERVER_NAME = @SERVER_NAME 
             AND QUERY_PLAN_HASH > 0x00000000
             AND  EXISTS (SELECT 'X'
                             FROM   QUERY_PLANS QP WITH (NOLOCK)
                             WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
                                    AND QS.DATABASE_NAME = QP.DATABASE_NAME
                                    AND QS.SERVER_NAME = QP.SERVER_NAME 
									AND QP.DATE_UPDATED <= DATEADD(D,-@REFRESH_PLAN_DAYS,GETDATE() ) --REH ANY PLANS THAT HAVEN'T BEEN UPDATED IN THE LAST 7 DAYS
									)) AS A)
									 
UPDATE QP 
SET QUERY_PLAN = COALESCE(RH.QUERY_PLAN,QP.QUERY_PLAN), DATE_UPDATED = GETDATE(), PARSED_FLAG = 0
FROM   QUERY_PLANS QP
INNER JOIN (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_PLAN_HASH
                        ORDER BY CTE.QUERY_PLAN_HASH DESC),
                        SERVER_NAME, 
                        DATABASE_NAME,
               CTE.QUERY_PLAN_HASH,
               query_plan AS QUERY_PLAN
        FROM   Query_Stats_CTE CTE
               OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH ON RH.SERVER_NAME = QP.SERVER_NAME AND RH.DATABASE_NAME = QP.DATABASE_NAME
               AND RH.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
WHERE  RN = 1 AND QP.SERVER_NAME = @SERVER_NAME AND QP.DATABASE_NAME = @DATABASE_NAME AND QP.QUERY_PLAN_HASH <> 0x0000000000000000


END

IF @REMOTE_SERVER = 'Y'
     BEGIN
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)


         SET @SQL = '
				CREATE TABLE [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH
				(
				QUERY_PLAN_HASH VARBINARY(64), 
				PLAN_HANDLE VARBINARY(64)
				)'

		IF @DEBUG = 'Y'
		BEGIN
         PRINT @SQL
		 END


         SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT [' + @SERVER_NAME
									 + ']'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

         SET @SQL = '

					;WITH Query_Stats_CTE ( QUERY_PLAN_HASH, PLAN_HANDLE)
						 AS (SELECT DISTINCT QUERY_PLAN_HASH,
										  PLAN_HANDLE
							 FROM   QUERY_STATS QS WITH (NOLOCK)
							 WHERE  QS.STATS_TIME >=  DATEADD(D,-1,GETDATE()) 
							  AND QUERY_PLAN_HASH > 0x00000000
									AND DATABASE_NAME = '
										+ '''' + @DATABASE_NAME + ''''
										+ '
									AND SERVER_NAME = ' + '''' +
										+ @SERVER_NAME + ''''
										+ ' 
									AND EXISTS (SELECT ''X''
													FROM   QUERY_PLANS QP WITH (NOLOCK)
												 WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
														AND QS.DATABASE_NAME = QP.DATABASE_NAME
														AND QS.SERVER_NAME = QP.SERVER_NAME 
															AND QP.DATE_UPDATED <= DATEADD(D,-' + CAST(@REFRESH_PLAN_DAYS AS VARCHAR(4)) +',GETDATE() ) 
													))
						INSERT INTO OPENQUERY([' + @SERVER_NAME
										+ '], ''SELECT QUERY_PLAN_HASH, PLAN_HANDLE FROM [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH'')
					                            
					  
					SELECT QUERY_PLAN_HASH, PLAN_HANDLE 
					FROM   (SELECT RN = ROW_NUMBER()
										  OVER (
											PARTITION BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE
											ORDER BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE DESC),
								   CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE 
					            
								FROM   Query_Stats_CTE CTE
							   ) AS RH
					WHERE  RN = 1 '

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END 


         EXEC(@SQL)



			SET @SQL = 'SELECT 
				   QUERY_PLAN_HASH,
				   cast(query_plan as nvarchar(max)) as QUERY_PLAN

			FROM   (SELECT RN = ROW_NUMBER()
								  OVER (
									PARTITION BY QUERY_PLAN_HASH
									ORDER BY QUERY_PLAN_HASH DESC),
						   QUERY_PLAN_HASH,
						   query_plan 
					FROM   [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH CTE
						   OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH
			WHERE  RN = 1 ' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  UPDATE DynamicsPerf.dbo.QUERY_PLANS
						 SET QUERY_PLAN =  COALESCE( RH.QUERY_PLAN, QUERY_PLANS.QUERY_PLAN), PARSED_FLAG = 0, DATE_UPDATED = ' + '''' + CAST(GETDATE() AS VARCHAR(20)) + '''' 
						 + 'FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') AS RH
						 WHERE SERVER_NAME = ' + '''' + @SERVER_NAME + '''' +
						  '   AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + 
						  '  AND RH.QUERY_PLAN_HASH = QUERY_PLANS.QUERY_PLAN_HASH' 

		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)
         

		 --REH Drop the table at the end of the process

         SET @SQL = '

				IF EXISTS (SELECT * FROM  [' + @DATABASE_NAME + '].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
				 DROP TABLE  [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)
     
     END 




UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)

	
         SET @SQL = '

				IF EXISTS (SELECT * FROM  [' + @DATABASE_NAME + '].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
				 DROP TABLE  [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 

				EXEC(@SQL2)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[SP_CAPTURESTATS]...';


GO



ALTER	PROCEDURE [dbo].[SP_CAPTURESTATS]
		@SERVER_NAME	NVARCHAR(128) = NULL,
		@DATABASE_NAME	NVARCHAR(128) = NULL ,
		@DYNAMICS_PRODUCT NVARCHAR(3)  = NULL,
		@TASK_TYPE		VARCHAR(50) = 'COLLECT',
		@AZURE_DB		BIT = 0,
		@TOP_ROWS		INT = 0,
		@TOP_COLUMN		NVARCHAR(128) = 'total_elapsed_time',
		@RUN_NAME		NVARCHAR(128) = NULL,
		@INDEX_PHYSICAL_STATS 	NCHAR(1)= 'N',
		@DEBUG			NVARCHAR(1)= 'N'

AS


SET NOCOUNT ON
SET DATEFORMAT MDY

SET ANSI_NULLS ON
SET ANSI_WARNINGS ON
SET ANSI_NULL_DFLT_ON ON
SET ANSI_PADDING ON


DECLARE @STATS_DATE		DATETIME, 
		@SQL_VERSION	NVARCHAR(1000), 
		@DYNAMICS_VERSION NVARCHAR(MAX),
		@DATABASE_ID	INT,
		@RETURN_CODE	INT,
		@SQL			NVARCHAR(MAX),
		@RUN_DESCRIPTION NVARCHAR(1000),
		@SQL_TOP_CLAUSE	NVARCHAR(128),
		@SQL_ORDERBY_CLAUSE	NVARCHAR(128),
		@PARM			NVARCHAR(500),
		@SQL_SERVER_STARTTIME DATETIME,
		@RC INT,
		@TASK_PROCEDURE NVARCHAR(128),
		@TASK_PARAMETERS NVARCHAR(1024),
		@TASK_DESCRIPTION NVARCHAR(256),
		@LAST_SERVER_NAME NVARCHAR(128) = 'ZZZ',  --REH This is used to trigger inserting a new STATS_COLLECTION_SUMMARY record
		@LAST_DATABASE_NAME NVARCHAR(128) = 'ZZZ',
		@LAST_STATS_DATE DATETIME,
		@REMOTE_SERVER NVARCHAR(1) = 'N',
		@TASK_STARTTIME DATETIME,
		@TASK_ENDTIME DATETIME,
		@TASK_TIME BIGINT,
		@SQL_STARTTIME DATETIME,
		@SQL_BUILD NVARCHAR(20),
		@SQL2 NVARCHAR(MAX),
		@MANUAL_CAPTURE NVARCHAR(1) = 'N',
		@SQL_TZ_OFFSET INT,
		@DPA_TZ_OFFSET INT,
		@RETRY_COUNT INT

		
		
DECLARE
	@C_SERVER_NAME NVARCHAR(128),
	@C_DATABASE_NAME NVARCHAR(128),
	@C_TASK_ID INT,
	@C_TASK_PROCEDURE NVARCHAR(128),
	@C_TASK_PARAMS NVARCHAR(1024),
	@C_TASK_DESC NVARCHAR(256),
	@C_SERVER_LEVEL_TASK BIT,
	@C_AZURE_DB  BIT,
	@C_LAST_RUN DATETIME
	
		
--REH Time zone off set for the DynamicsPerf database at time of collection
		SET @DPA_TZ_OFFSET = DATEDIFF(MI,GETUTCDATE(),GETDATE())

	IF @DATABASE_NAME IS NOT NULL SET @MANUAL_CAPTURE = 'Y'

	SET @STATS_DATE = GETDATE()
--REH  Verify database exists if being manually passed, skip check if Azure DB, no access to sys.databases catalogue

IF ( @AZURE_DB = 0 and ( @SERVER_NAME IS NOT NULL
      OR @DATABASE_NAME IS NOT NULL ))
     BEGIN

	 
	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_CS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_CS_QUERY_SYSDATABASES')

         IF @REMOTE_SERVER = 'Y'
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_CS_QUERY_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_CS_QUERY_SYSDATABASES
				FOR master.sys.databases'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END

         EXEC (@SQL) -- SELECT * FROM DYN_CS_QUERY_SYSDATABASES

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_CS_QUERY_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

         --REH Make sure there is a record in DATABASES_2_COLLECT or insert if new combination
         IF (SELECT COUNT(*)
             FROM   DATABASES_2_COLLECT
             WHERE  LINKED_SERVER = ISNULL(@SERVER_NAME, @@SERVERNAME)
                    AND DATABASE_NAME = @DATABASE_NAME) < 1
              BEGIN
                  INSERT DATABASES_2_COLLECT
                  VALUES(ISNULL(@SERVER_NAME,@@SERVERNAME),
                         @DATABASE_NAME,
                         ISNULL(@DYNAMICS_PRODUCT, 'ALL'),
                         1,
                         2,
                         24,
						 60,
						 2,
						 90,
						 7,
						 -1,
						 0,
						 100,
						 100)
              END
     END 


	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END



---------------------------------------------------------------------------------------------
--
--  Insert Capture_log entry with paramater values used for the run
--
----------------------------------------------------------------------------------------------

INSERT CAPTURE_LOG  SELECT @TASK_TYPE, @STATS_DATE, 'SP_CAPTURESTATS PARMS PASSED @SERVER_NAME = ' + ISNULL(@SERVER_NAME,'NOT PASSED') + ' @DATABASE_NAME = ' + ISNULL(@DATABASE_NAME,'NOT PASSED') +  ' @DEBUG = ' + @DEBUG + '  ' + CHAR(10) + CHAR(13)



SET @RETURN_CODE = 0

DELETE FROM  COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH Default is 'COLLECT' for this sproc.  CAN'T TRUNCATE MULTIPLE SPROCS USING THIS TABLE



IF @DATABASE_NAME IS NULL  --REH AKA, not a manual capture
  BEGIN
      INSERT COLLECTIONDATABASES
      SELECT ISNULL(LINKED_SERVER, @@SERVERNAME),
             [DATABASE_NAME],
             [DYNAMICS_PRODUCT],
             [AZURE_DB],
             [ENABLED],
			 @TASK_TYPE
      FROM   DATABASES_2_COLLECT
      WHERE  ENABLED = 1 -- db must be enabled for autostats collection to work with it
  END
ELSE
  BEGIN   --REH  Insert DBname of the manual capture
      INSERT COLLECTIONDATABASES
      VALUES(ISNULL(@SERVER_NAME, @@SERVERNAME),
             @DATABASE_NAME,
             @DYNAMICS_PRODUCT,
             @AZURE_DB,
             1,
			 @TASK_TYPE)
  END 


--REH Insert any missing task history records in case it's a new database being collected, so we don't fail to capture against the db because of no records
-- yes, this is a cartesian join between these 2 tables

INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE	--REH default is 'COLLECT' in parm definition of this sproc
       AND NOT EXISTS (SELECT 'X'
                       FROM   DYNPERF_TASK_HISTORY DTH
                       WHERE  DTS.TASK_ID = DTH.TASK_ID
                              AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                              AND CD.DATABASE_NAME = DTH.DATABASE_NAME)
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 0 --REH Ok, to put 1 record per database in for DB type tasks


	   
--REH Need to insert 1 bogus record for each server level task, or the join on the cursor will fail

INSERT COLLECTIONDATABASES 
 SELECT	DISTINCT [LINKED_SERVER],
             'N/A',
            'ALL',
             [AZURE_DB],
             [ENABLED],
			 [TASK_TYPE]
FROM COLLECTIONDATABASES CD
WHERE DATABASE_NAME <> 'N/A'
AND TASK_TYPE = @TASK_TYPE
AND NOT EXISTS (SELECT 'X' FROM COLLECTIONDATABASES CD2 WHERE CD2.LINKED_SERVER = CD.LINKED_SERVER AND CD2.DATABASE_NAME = 'N/A')



--REH now lets insert server level tasks with a blank DB name so we only do them once per server
INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       'N/A',
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE  --REH default is 'COLLECT' in parm definition of this sproc
		AND CD.DATABASE_NAME <> 'N/A'
       AND NOT EXISTS (SELECT 'X'
                   FROM   DYNPERF_TASK_HISTORY DTH
                   WHERE  DTS.TASK_ID = DTH.TASK_ID
                          AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                          AND DTH.DATABASE_NAME = 'N/A') --REH making the db name = 'N/A' for server level tasks
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 1 






	IF @DEBUG = 'Y'
	BEGIN
		PRINT 'MANUAL_CAPTURE = ' + @MANUAL_CAPTURE
	END

	--REH Create here and truncate table in each loop

	 --  CREATE TABLE #SQL_INFO
  --   (
  --      SQL_STARTTIME DATETIME,
  --      SQL_BUILD NVARCHAR(20),
		--TZ_OFFSET INT
  --   )


/********************************************************************************
Rod Hansen

Added a trigger to DATABASES_2_COLLECT so that we always have a 
DYNPERF_TASK_HISTORY record for this code 

********************************************************************************/

DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT DISTINCT DTS.TASK_ID,
       CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_PROCEDURE,
       DTS.TASK_PARAMETERS,
       DTS.TASK_DESCRIPTION,
       DTS.SERVER_LEVEL_TASK,
       CD.AZURE_DB,
       ISNULL(DTH.LAST_RUN, '1/1/1900')
FROM   DynamicsPerf..[DYNPERF_TASK_SCHEDULER] DTS
       LEFT OUTER JOIN DynamicsPerf..[DYNPERF_TASK_HISTORY] DTH
                    ON DTH.TASK_ID = DTS.TASK_ID
       INNER JOIN DynamicsPerf..COLLECTIONDATABASES CD
               ON CD.DATABASE_NAME = DTH.DATABASE_NAME
                  AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
WHERE
  --REH Task is enabled
  DTS.ENABLED = 1
  AND
  --REH It's the correct task type C = COLLECTOR, P = PROCESS, M = MONITOR, ETC
  DTS.TASK_TYPE = @TASK_TYPE
  AND
  --REH database is enabled
  CD.ENABLED = 1
  AND
  --REH Azure_db, if Azure db, then task must support it
  ( CD.AZURE_DB = DTS.AZURE_DB_SUPPORTED
     OR CD.AZURE_DB = 0 )
  --REH Either its an Azure Task, all Azure tasks will run locally, so if task supports AZ and we pass 0, run it anyways
  AND ( DTS.AZURE_DB_SUPPORTED = @AZURE_DB
         OR ( DTS.AZURE_DB_SUPPORTED = 1
              AND @AZURE_DB = 0 ) )
  AND
  --REH it's either All products or matches the Dynamics Product
  ( DTS.DYNAMICS_PRODUCT = 'ALL'
     OR DTS.DYNAMICS_PRODUCT = CD.DYNAMICS_PRODUCT )
  AND
  --REH Scheduling options now
(
  --REH In the case of minutes or hous, we ignore schedule time and just figure out if it's time to run again
  ( @MANUAL_CAPTURE = 'Y'
     OR ( @MANUAL_CAPTURE = 'N'
          AND ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                  WHEN 'MI' THEN DATEADD(MINUTE, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                END ) <= GETDATE()
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'HH' THEN DATEADD(HOUR, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                --REH and it is on the hour
                AND ( ABS(DATEDIFF(MI, DATEADD(Hour, DATEDIFF(Hour, 0, GETDATE()), 0), GETDATE())) <= 1 ) )
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'DD' THEN DATEADD(DAY, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'WK' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'MM' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'QQ' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'YY' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                AND ( --REH TIME IS NULL SO IGNORE IT
                    COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) IS NULL
                     OR --REH Current time = Scheduled time 
                    ( SUBSTRING((SELECT REPLACE(CONVERT(VARCHAR(10), GETDATE(), 108), ':', '')), 1, 4) = (SELECT REPLICATE('0', 4 - LEN( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME)))
                                                                                                                 + CAST( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) AS VARCHAR(4))) ) ) )
         --REH and last_run < current time
         )--AND CONVERT(VARCHAR(10), LAST_RUN, 108) <= CONVERT(VARCHAR(10), Getdate(), 108) ) 
   )
)
ORDER  BY CD.LINKED_SERVER,
          CD.DATABASE_NAME,
          DTS.TASK_ID 



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */


	          SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


--Insert new STATS_COLLECTION_SUMMARY RECORD, we want 1 RUN_NAME per server not per database
IF @C_SERVER_NAME <> @LAST_SERVER_NAME OR @C_DATABASE_NAME <> @LAST_DATABASE_NAME
BEGIN
    SET @RUN_NAME = ISNULL(@C_SERVER_NAME, @@SERVERNAME)+ ' '
                    + CAST(@STATS_DATE AS VARCHAR(30))

TRUNCATE TABLE WRK_CS_SQL_INFO   --REH clear out table to repopulate

 DELETE FROM COLLECTIONDATABASES WHERE LINKED_SERVER = @LAST_SERVER_NAME AND DATABASE_NAME = @LAST_DATABASE_NAME AND TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE


 
SELECT @SQL = 'SELECT create_date AS SQL_STARTTIME,
       CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))    AS SQL_BUILD,
	   DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
		FROM sys.databases WHERE name = ''TempDB'''

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


   
   SET NOCOUNT ON
 
IF @REMOTE_SERVER = 'N'
BEGIN
		   INSERT WRK_CS_SQL_INFO
		EXEC( @SQL)
END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
			IF @C_AZURE_DB = 0
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT create_date AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROM sys.databases WHERE name = ''TempDB''"	)'
			END
			IF @C_AZURE_DB = 1
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT DATEADD(ms,AVG(-wait_time_ms), GETDATE()) AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROMsys.dm_os_wait_stats w WHEREwait_type
IN(''DIRTY_PAGE_POLL'',''HADR_FILESTREAM_IOMGR_IOCOMPLETION'',''LAZYWRITER_SLEEP'',''LOGMGR_QUEUE'',''REQUEST_FOR_DEADLOCK_SEARCH'',''XE_DISPATCHER_WAIT'',''XE_TIMER_EVENT'') "	)'
			END


				IF @DEBUG = 'Y'
                  BEGIN
                      PRINT '@SQL= ' + @SQL2
                  END 
                
			INSERT WRK_CS_SQL_INFO
				EXEC (@SQL2) 
 
 END
 
 SELECT @SQL_STARTTIME = SQL_STARTTIME, @SQL_BUILD = SQL_BUILD, @SQL_TZ_OFFSET = TZ_OFFSET FROM WRK_CS_SQL_INFO
 TRUNCATE TABLE WRK_CS_SQL_INFO --REH Cleanout the table for next loop





		INSERT INTO [DynamicsPerf].[dbo].[STATS_COLLECTION_SUMMARY]
					([SERVER_NAME],
					 [STATS_TIME],
					 [RUN_NAME],
					 [DATABASE_NAME],
					 [SQL_VERSION],
					 [DYNAMICS_VERSION],
					 [RUN_DESCRIPTION],
					 [SQL_SERVER_STARTTIME],
					 [SQL_SERVER_TZ_OFFSET] ,
					 [DPA_TZ_OFFSET])
		VALUES      (@C_SERVER_NAME,
					 @STATS_DATE,
					 @RUN_NAME,
					 @C_DATABASE_NAME,
					 @SQL_BUILD,--<SQL_VERSION>
					 '',--<DYNAMICS_VERSION>
					 '',--<RUN_DESCRIPTION>
					 @SQL_STARTTIME, -- <SQL_SERVER_STARTTIME>
					 @SQL_TZ_OFFSET,  -- Time Zone offset in minutes of database collected
					 @DPA_TZ_OFFSET  -- Time Zone of the DynamicsPerf database
					) 
				
END 

SET @LAST_SERVER_NAME = @C_SERVER_NAME
SET @LAST_DATABASE_NAME = @C_DATABASE_NAME


SET @REMOTE_SERVER = CASE @C_SERVER_NAME
                       WHEN @@SERVERNAME THEN 'N'
                       ELSE 'Y'
                     END 



--Create synonyms for the sproc

--IF  EXISTS (SELECT * FROM sys.synonyms WHERE name = 'DYN_CS_CAPTURE_SPROC')
--DROP SYNONYM [dbo].[DYN_CS_CAPTURE_SPROC]
--SET @SQL = '
--CREATE SYNONYM DYN_CS_CAPTURE_SPROC
--FOR [DynamicsPerf].dbo.[' + @C_TASK_PROCEDURE + ']'

--IF @DEBUG = 'Y' 
--BEGIN
--PRINT '@SQL= ' + @SQL
--END

--EXEC(@SQL) 

IF @DEBUG = 'Y' 
BEGIN
PRINT 'TASK ID = ' + CAST(@C_TASK_ID AS VARCHAR(10))
PRINT 'SERVER NAME = ' + @C_SERVER_NAME 
PRINT 'DATABASE NAME = ' + @C_DATABASE_NAME
PRINT 'TASK PARMS = ' + ISNULL(@C_TASK_PARAMS, '')
PRINT 'TASK DESC = ' + ISNULL(@C_TASK_DESC,'')
PRINT 'LAST RUN = ' + ISNULL(CAST(@C_LAST_RUN AS VARCHAR(30)),'')
PRINT 'RUN NAME = ' + ISNULL(@RUN_NAME,'')
PRINT 'STATS DATE = ' + CAST(@STATS_DATE AS VARCHAR(30))
PRINT 'REMNOTE SERVER FLAG = ' + ISNULL(@REMOTE_SERVER,'')
PRINT 'AZURE DB = ' + CAST(@C_AZURE_DB AS CHAR(1))


END
			
	

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@C_TASK_DESC, '') + CONVERT(VARCHAR, GETDATE(), 109)
PRINT ''


SET @TASK_STARTTIME = GETDATE()
SET @C_TASK_PARAMS = ISNULL(@C_TASK_PARAMS,'')


IF @DEBUG = 'Y'
BEGIN

	PRINT 'SERVER TIME ZONE OFFSET = ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
	PRINT 'AT LAST RUN  = ' + CAST(@C_LAST_RUN AS VARCHAR(30))

END

--REH Adjust the last_run time to UTC Time, the called sproc's will adjust it to local time unless we've never collected
IF @C_LAST_RUN > '1/1/1901'
BEGIN
SET @C_LAST_RUN = DATEADD(MI,@DPA_TZ_OFFSET *-1 ,@C_LAST_RUN)
END


-- REH Adjusting last_run when its never be run to get things in last 5 mins
--   This is to prevent the massive data load on QUERY_STATS on 1st collection on large memory systems
IF @C_LAST_RUN < '1/1/2016'
BEGIN
SET @C_LAST_RUN = DATEADD(MI,@DPA_TZ_OFFSET *-1 ,DATEADD(MI,-5,GETDATE()))
END


IF @DEBUG = 'Y'
BEGIN
	PRINT 'AT LAST RUN TIME BEING PASSED TO SPROC ' + CAST(@C_LAST_RUN AS VARCHAR(30))
END

SELECT @SQL = 'EXEC ' + @C_TASK_PROCEDURE + '  @TASK_ID=' + CAST(@C_TASK_ID AS NVARCHAR(10)) + 
' ,@SERVER_NAME = ' + '''' +  @C_SERVER_NAME + '''' +
' ,@DATABASE_NAME = ' + '''' +  @C_DATABASE_NAME + '''' +
' ,@TASK_PARAMS = ' +  '''' +  @C_TASK_PARAMS + '''' +
' ,@TASK_DESC = ' + '''' +  @C_TASK_DESC + '''' +
' ,@LAST_RUN = ' + '''' + CONVERT(VARCHAR, @C_LAST_RUN, 109) + '''' +
' ,@RUN_NAME = ' + '''' +  @RUN_NAME + '''' +
' ,@STATS_DATE = ' + '''' + CONVERT(VARCHAR, @STATS_DATE, 109) + '''' +
' ,@REMOTE_SERVER = ' + '''' +  @REMOTE_SERVER + '''' +
' ,@AZURE_DB = ' + CAST(@C_AZURE_DB AS NVARCHAR(10)) + 
' ,@SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET AS NVARCHAR(10)) + 
' ,@DPA_TZ_OFFSET = ' + CAST(@DPA_TZ_OFFSET AS NVARCHAR(10)) + 


' ,@DEBUG = '  + '''' +  @DEBUG + ''''



UPDATE CAPTURE_LOG
SET    TEXT = TEXT  + CHAR(13) + CHAR(10) + '***** ' + @C_TASK_PROCEDURE
			+ CHAR(13) + CHAR(10)
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE



EXECUTE @RC = sp_executesql @SQL


	
   					  
SET @TASK_ENDTIME = GETDATE()

SET @TASK_TIME = DATEDIFF(ss,@TASK_STARTTIME, @TASK_ENDTIME)

 
 /*************** RETRY LOGIC ************************/
IF @RC = 1
   AND @TASK_TIME < 10 -- IT FAILED AND WAS LESS THEN 10 SECONDS
  BEGIN
      WAITFOR DELAY '00:00:02' -- REH Wait 2 seconds and try again if sproc trapped the error
      EXECUTE @RC = Sp_executesql
        @SQL

      SET @TASK_ENDTIME = GETDATE()
      SET @TASK_TIME = DATEDIFF(SS, @TASK_STARTTIME, @TASK_ENDTIME)
  END 

  
--REH update last  [DYNPERF_TASK_HISTORY] IF THE TASK WAS SUCCESSFUL


  
 IF @RC = 0
      BEGIN
          PRINT ''
 
          PRINT 'SUCCESSFULLY CAPTURED '
                + ISNULL(@C_TASK_DESC, '') +  ' for SERVER '
              + ISNULL(@C_SERVER_NAME, '') + ' on database '
              + ISNULL(@C_DATABASE_NAME, '') + ' in ' + cast(@TASK_TIME AS VARCHAR(20)) + ' SECONDS '
 
       --REH if a manual capture don't update last run so we don't mess up the scheduling engine
				 IF @MANUAL_CAPTURE = 'N'
				 BEGIN
						  MERGE DynamicsPerf..[DYNPERF_TASK_HISTORY] AS target
						  USING (SELECT @C_SERVER_NAME   AS SERVER_NAME,
										@C_DATABASE_NAME AS DATABASE_NAME,
										@C_TASK_ID       AS TASK_ID,
										@STATS_DATE      AS LAST_RUN,
										@TASK_TIME	AS LAST_EXECUTION_TIME_SECS 
												) AS source
						  ON ( source.SERVER_NAME = target.LINKEDSERVER_NAME
							   AND source.DATABASE_NAME = target.DATABASE_NAME
							   AND source.TASK_ID = target.TASK_ID )
						  WHEN MATCHED THEN
							UPDATE SET LAST_RUN = source.LAST_RUN, [LAST_EXECUTION_TIME_SECS] = source.[LAST_EXECUTION_TIME_SECS]
						  WHEN NOT MATCHED THEN
							INSERT ( [LINKEDSERVER_NAME],
									 [DATABASE_NAME],
									 [TASK_ID],
									 [LAST_RUN],
									 [LAST_EXECUTION_TIME_SECS])
							VALUES (source.SERVER_NAME,
									source.DATABASE_NAME,
									source.TASK_ID,
									source.LAST_RUN,
									source.LAST_EXECUTION_TIME_SECS );
				END
      END
 ELSE
	IF @RC = 1  --REH SPROC HANDLED THE ERROR
      BEGIN
          PRINT ''
 
          PRINT 'FAILED !!!!!! ' + ISNULL(@C_TASK_DESC, '')
 
          PRINT ''
      END 
 
  


           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_CS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_CS_QUERY_SYSDATABASES')



END TRY 

BEGIN CATCH


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PROCEDURE FAILED !!! '
              + ISNULL(@C_TASK_DESC, 'TASK') + ' for SERVER
	'
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) + ', '
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE

PRINT 'ERROR WHILE COLLECTING ' + ISNULL(@C_TASK_DESC, '') +' !!!!!!!!!!!!!!'




         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_CS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_CS_QUERY_SYSDATABASES')

END CATCH



FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
	  DELETE FROM COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
		

ENDPROC:
PRINT 'RUN NAME = '+ @RUN_NAME
GO
PRINT N'Altering [dbo].[SP_PROCESS_STATS]...';


GO
ALTER PROCEDURE [dbo].[SP_PROCESS_STATS]
		@SERVER_NAME	NVARCHAR(128) = NULL,
		@DATABASE_NAME	NVARCHAR(128) = NULL ,
		@DYNAMICS_PRODUCT NVARCHAR(3)  = NULL,
		@TASK_TYPE		VARCHAR(50) = 'PROCESS',
		@AZURE_DB		BIT = 0,
		@TOP_ROWS		INT = 0,
		@TOP_COLUMN		NVARCHAR(128) = 'total_elapsed_time',
		@RUN_NAME		NVARCHAR(128) = NULL,
		@INDEX_PHYSICAL_STATS 	NCHAR(1)= 'N',
		@DEBUG			NVARCHAR(1)= 'N'

AS


SET NOCOUNT ON
SET DATEFORMAT MDY

DECLARE @STATS_DATE		DATETIME, 
		@SQL_VERSION	NVARCHAR(1000), 
		@DYNAMICS_VERSION NVARCHAR(MAX),
		@DATABASE_ID	INT,
		@RETURN_CODE	INT,
		@SQL			NVARCHAR(MAX),
		@RUN_DESCRIPTION NVARCHAR(1000),
		@SQL_TOP_CLAUSE	NVARCHAR(128),
		@SQL_ORDERBY_CLAUSE	NVARCHAR(128),
		@PARM			NVARCHAR(500),
		@SQL_SERVER_STARTTIME DATETIME,
		@RC INT,
		@TASK_PROCEDURE NVARCHAR(128),
		@TASK_PARAMETERS NVARCHAR(1024),
		@TASK_DESCRIPTION NVARCHAR(256),
		@LAST_SERVER_NAME NVARCHAR(128) = 'ZZZ',  --REH This is used to trigger inserting a new STATS_COLLECTION_SUMMARY record
		@LAST_DATABASE_NAME NVARCHAR(128) = 'ZZZ',
		@LAST_STATS_DATE DATETIME,
		@REMOTE_SERVER NVARCHAR(1) = 'N',
		@TASK_STARTTIME DATETIME,
		@TASK_ENDTIME DATETIME,
		@TASK_TIME BIGINT,
		@SQL_STARTTIME DATETIME,
		@SQL_BUILD NVARCHAR(20),
		@SQL2 NVARCHAR(MAX),
		@MANUAL_CAPTURE NVARCHAR(1) = 'N',
		@SQL_TZ_OFFSET INT,
		@DPA_TZ_OFFSET INT 

		
		
DECLARE
	@C_SERVER_NAME NVARCHAR(128),
	@C_DATABASE_NAME NVARCHAR(128),
	@C_TASK_ID INT,
	@C_TASK_PROCEDURE NVARCHAR(128),
	@C_TASK_PARAMS NVARCHAR(1024),
	@C_TASK_DESC NVARCHAR(256),
	@C_SERVER_LEVEL_TASK BIT,
	@C_AZURE_DB  BIT,
	@C_LAST_RUN DATETIME
	
		
--REH Time zone off set for the DynamicsPerf database at time of collection
		SET @DPA_TZ_OFFSET = DATEDIFF(MI,GETUTCDATE(),GETDATE())

	IF @DATABASE_NAME IS NOT NULL SET @MANUAL_CAPTURE = 'Y'

	SET @STATS_DATE = GETDATE()
--REH  Verify database exists if being manually passed, skip check if Azure DB, no access to sys.databases catalogue

IF ( @AZURE_DB = 0 and ( @SERVER_NAME IS NOT NULL
      OR @DATABASE_NAME IS NOT NULL ))
     BEGIN

	 
	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_QUERY_SYSDATABASES')

         IF @REMOTE_SERVER = 'Y'
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_PS_QUERY_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_PS_QUERY_SYSDATABASES
				FOR master.sys.databases'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END

         EXEC (@SQL) -- SELECT * FROM DYN_PS_QUERY_SYSDATABASES

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_PS_QUERY_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

         --REH Make sure there is a record in DATABASES_2_COLLECT or insert if new combination
         IF (SELECT COUNT(*)
             FROM   DATABASES_2_COLLECT
             WHERE  LINKED_SERVER = ISNULL(@SERVER_NAME, @@SERVERNAME)
                    AND DATABASE_NAME = @DATABASE_NAME) < 1
              BEGIN
                  INSERT DATABASES_2_COLLECT
                  VALUES(ISNULL(@SERVER_NAME,@@SERVERNAME),
                         @DATABASE_NAME,
                         ISNULL(@DYNAMICS_PRODUCT, 'ALL'),
                         0,
                         2,
                         24,
						 60,
						 2,
						 90,
						 7,
						 -1,
						 0,
						 100,
						 100)
              END
     END 


	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END



---------------------------------------------------------------------------------------------
--
--  Insert Capture_log entry with paramater values used for the run
--
----------------------------------------------------------------------------------------------

INSERT CAPTURE_LOG  SELECT @TASK_TYPE, @STATS_DATE, 'SP_PROCESS_STATS PARMS PASSED @SERVER_NAME = ' + ISNULL(@SERVER_NAME,'NOT PASSED') + ' @DATABASE_NAME = ' + ISNULL(@DATABASE_NAME,'NOT PASSED') +  ' @DEBUG = ' + @DEBUG + '  ' + CHAR(10) + CHAR(13)



SET @RETURN_CODE = 0

DELETE FROM  COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH Default is 'COLLECT' for this sproc.  CAN'T TRUNCATE MULTIPLE SPROCS USING THIS TABLE




IF @DATABASE_NAME IS NULL  --REH AKA, not a manual capture
  BEGIN
      INSERT COLLECTIONDATABASES
      SELECT ISNULL(LINKED_SERVER, @@SERVERNAME),
             [DATABASE_NAME],
             [DYNAMICS_PRODUCT],
             [AZURE_DB],
             [ENABLED],
			 @TASK_TYPE
      FROM   DATABASES_2_COLLECT
      WHERE  ENABLED = 1 -- db must be enabled for autostats collection to work with it
  END
ELSE
  BEGIN   --REH  Insert DBname of the manual capture
      INSERT COLLECTIONDATABASES
      VALUES(ISNULL(@SERVER_NAME, @@SERVERNAME),
             @DATABASE_NAME,
             @DYNAMICS_PRODUCT,
             @AZURE_DB,
             1,
			 @TASK_TYPE)
  END 


--REH Insert any missing task history records in case it's a new database being collected, so we don't fail to capture against the db because of no records
-- yes, this is a cartesian join between these 2 tables

INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE	--REH default is 'PROCESS' in parm definition of this sproc
       AND NOT EXISTS (SELECT 'X'
                       FROM   DYNPERF_TASK_HISTORY DTH
                       WHERE  DTS.TASK_ID = DTH.TASK_ID
                              AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                              AND CD.DATABASE_NAME = DTH.DATABASE_NAME)
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 0 --REH Ok, to put 1 record per database in for DB type tasks


	   
--REH Need to insert 1 bogus record for each server level task, or the join on the cursor will fail

INSERT COLLECTIONDATABASES 
 SELECT	DISTINCT [LINKED_SERVER],
             'N/A',
            'ALL',
             [AZURE_DB],
             [ENABLED],
			 [TASK_TYPE]
FROM COLLECTIONDATABASES CD
WHERE DATABASE_NAME <> 'N/A'
AND TASK_TYPE = @TASK_TYPE
AND NOT EXISTS (SELECT 'X' FROM COLLECTIONDATABASES CD2 WHERE CD2.LINKED_SERVER = CD.LINKED_SERVER AND CD2.DATABASE_NAME = 'N/A')



--REH now lets insert server level tasks with a blank DB name so we only do them once per server
INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       'N/A',
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE  --REH default is 'COLLECT' in parm definition of this sproc
		AND CD.DATABASE_NAME <> 'N/A'
       AND NOT EXISTS (SELECT 'X'
                   FROM   DYNPERF_TASK_HISTORY DTH
                   WHERE  DTS.TASK_ID = DTH.TASK_ID
                          AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                          AND DTH.DATABASE_NAME = 'N/A') --REH making the db name = 'N/A' for server level tasks
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 1 





	IF @DEBUG = 'Y'
	BEGIN
		PRINT 'MANUAL_CAPTURE = ' + @MANUAL_CAPTURE
	END

	--REH Create here and truncate table in each loop
	 --  CREATE TABLE #SQL_INFO
  --   (
  --      SQL_STARTTIME DATETIME,
  --      SQL_BUILD NVARCHAR(20),
		--TZ_OFFSET INT
  --   )
   

/********************************************************************************
Rod Hansen

Added a trigger to DATABASES_2_COLLECT so that we always have a 
DYNPERF_TASK_HISTORY record for this code 

********************************************************************************/

DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT DISTINCT DTS.TASK_ID,
       CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_PROCEDURE,
       DTS.TASK_PARAMETERS,
       DTS.TASK_DESCRIPTION,
       DTS.SERVER_LEVEL_TASK,
       CD.AZURE_DB,
       ISNULL(DTH.LAST_RUN, '1/1/1900')
FROM   DynamicsPerf..[DYNPERF_TASK_SCHEDULER] DTS
       LEFT OUTER JOIN DynamicsPerf..[DYNPERF_TASK_HISTORY] DTH
                    ON DTH.TASK_ID = DTS.TASK_ID
       INNER JOIN DynamicsPerf..COLLECTIONDATABASES CD
               ON CD.DATABASE_NAME = DTH.DATABASE_NAME
                  AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
WHERE
  --REH Task is enabled
  DTS.ENABLED = 1
  AND
  --REH It's the correct task type C = COLLECTOR, P = PROCESS, M = MONITOR, ETC
  DTS.TASK_TYPE = @TASK_TYPE
  AND
  --REH database is enabled
  CD.ENABLED = 1
  AND
  --REH Azure_db, if Azure db, then task must support it
  ( CD.AZURE_DB = DTS.AZURE_DB_SUPPORTED
     OR CD.AZURE_DB = 0 )
  --REH Either its an Azure Task, all Azure tasks will run locally, so if task supports AZ and we pass 0, run it anyways
  AND ( DTS.AZURE_DB_SUPPORTED = @AZURE_DB
         OR ( DTS.AZURE_DB_SUPPORTED = 1
              AND @AZURE_DB = 0 ) )
  AND
  --REH it's either All products or matches the Dynamics Product
  ( DTS.DYNAMICS_PRODUCT = 'ALL'
     OR DTS.DYNAMICS_PRODUCT = CD.DYNAMICS_PRODUCT )
  AND
  --REH Scheduling options now
(
  --REH In the case of minutes or hous, we ignore schedule time and just figure out if it's time to run again
  ( @MANUAL_CAPTURE = 'Y'
     OR ( @MANUAL_CAPTURE = 'N'
          AND ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                  WHEN 'MI' THEN DATEADD(MINUTE, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                END ) <= GETDATE()
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'HH' THEN DATEADD(HOUR, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                --REH and it is on the hour
                AND ( ABS(DATEDIFF(MI, DATEADD(Hour, DATEDIFF(Hour, 0, GETDATE()), 0), GETDATE())) <= 1 ) )
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'DD' THEN DATEADD(DAY, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'WK' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'MM' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'QQ' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'YY' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                AND ( --REH TIME IS NULL SO IGNORE IT
                    COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) IS NULL
                     OR --REH Current time = Scheduled time 
                    ( SUBSTRING((SELECT REPLACE(CONVERT(VARCHAR(10), GETDATE(), 108), ':', '')), 1, 4) = (SELECT REPLICATE('0', 4 - LEN( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME)))
                                                                                                                 + CAST( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) AS VARCHAR(4))) ) ) )
         --REH and last_run < current time
         )--AND CONVERT(VARCHAR(10), LAST_RUN, 108) <= CONVERT(VARCHAR(10), Getdate(), 108) ) 
   )
)
ORDER  BY CD.LINKED_SERVER,
          CD.DATABASE_NAME,
          DTS.TASK_ID 



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

	SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                    WHEN @@SERVERNAME THEN 'N'
                    ELSE 'Y'
                    END

--Insert new STATS_COLLECTION_SUMMARY RECORD, we want 1 RUN_NAME per server not per database
IF @C_SERVER_NAME <> @LAST_SERVER_NAME OR @C_DATABASE_NAME <> @LAST_DATABASE_NAME
BEGIN
    SET @RUN_NAME = ISNULL(@C_SERVER_NAME, @@SERVERNAME)+ ' '
                    + CAST(@STATS_DATE AS VARCHAR(30))


TRUNCATE TABLE WRK_PS_SQL_INFO   

 DELETE FROM COLLECTIONDATABASES WHERE LINKED_SERVER = @LAST_SERVER_NAME AND DATABASE_NAME = @LAST_DATABASE_NAME AND TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
 
SELECT @SQL = 'SELECT create_date AS SQL_STARTTIME,
       CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))    AS SQL_BUILD,
	   DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
		FROM sys.databases WHERE name = ''TempDB'''

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


   SET NOCOUNT ON
 
IF @REMOTE_SERVER = 'N'
BEGIN
		   INSERT WRK_PS_SQL_INFO
		EXEC( @SQL)
END


 IF @REMOTE_SERVER = 'Y'
 BEGIN
			IF @C_AZURE_DB = 0
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT create_date AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROM sys.databases WHERE name = ''TempDB''"	)'
			END
			IF @C_AZURE_DB = 1
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT DATEADD(ms,AVG(-wait_time_ms), GETDATE()) AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROMsys.dm_os_wait_stats w WHEREwait_type
IN(''DIRTY_PAGE_POLL'',''HADR_FILESTREAM_IOMGR_IOCOMPLETION'',''LAZYWRITER_SLEEP'',''LOGMGR_QUEUE'',''REQUEST_FOR_DEADLOCK_SEARCH'',''XE_DISPATCHER_WAIT'',''XE_TIMER_EVENT'') "	)'
			END


				IF @DEBUG = 'Y'
                  BEGIN
                      PRINT '@SQL= ' + @SQL2
                  END 
                
			INSERT WRK_PS_SQL_INFO
				EXEC (@SQL2) 
 
 END
 
 SELECT @SQL_STARTTIME = SQL_STARTTIME, @SQL_BUILD = SQL_BUILD, @SQL_TZ_OFFSET = TZ_OFFSET FROM WRK_PS_SQL_INFO
 TRUNCATE TABLE WRK_PS_SQL_INFO  -- REH cleanout for next pass


  --REH NOT Collecting so don't need this code in this sproc


		--INSERT INTO [DynamicsPerf].[dbo].[STATS_COLLECTION_SUMMARY]
		--			([SERVER_NAME],
		--			 [STATS_TIME],
		--			 [RUN_NAME],
		--			 [DATABASE_NAME],
		--			 [SQL_VERSION],
		--			 [DYNAMICS_VERSION],
		--			 [RUN_DESCRIPTION],
		--			 [SQL_SERVER_STARTTIME],
		--			 [SQL_SERVER_TZ_OFFSET] ,
		--			 [DPA_TZ_OFFSET])
		--VALUES      (@C_SERVER_NAME,
		--			 @STATS_DATE,
		--			 @RUN_NAME,
		--			 @C_DATABASE_NAME,
		--			 @SQL_BUILD,--<SQL_VERSION>
		--			 '',--<DYNAMICS_VERSION>
		--			 '',--<RUN_DESCRIPTION>
		--			 @SQL_STARTTIME, -- <SQL_SERVER_STARTTIME>
		--			 @SQL_TZ_OFFSET,  -- Time Zone offset in minutes of database collected
		--			 @DPA_TZ_OFFSET  -- Time Zone of the DynamicsPerf database
		--			) 
				
END 

SET @LAST_SERVER_NAME = @C_SERVER_NAME
SET @LAST_DATABASE_NAME = @C_DATABASE_NAME


SET @REMOTE_SERVER = CASE @C_SERVER_NAME
                       WHEN @@SERVERNAME THEN 'N'
                       ELSE 'Y'
                     END 



--Create synonyms for the sproc

--IF  EXISTS (SELECT * FROM sys.synonyms WHERE name = 'DYN_PS_CAPTURE_SPROC')
--DROP SYNONYM [dbo].[DYN_PS_CAPTURE_SPROC]
--SET @SQL = '
--CREATE SYNONYM DYN_PS_CAPTURE_SPROC
--FOR [DynamicsPerf].dbo.[' + @C_TASK_PROCEDURE + ']'

--IF @DEBUG = 'Y' 
--BEGIN
--PRINT '@SQL= ' + @SQL
--END

--EXEC(@SQL) 

IF @DEBUG = 'Y' 
BEGIN
PRINT 'TASK ID = ' + CAST(@C_TASK_ID AS VARCHAR(10))
PRINT 'SERVER NAME = ' + @C_SERVER_NAME 
PRINT 'DATABASE NAME = ' + @C_DATABASE_NAME
PRINT 'TASK PARMS = ' + ISNULL(@C_TASK_PARAMS, '')
PRINT 'TASK DESC = ' + ISNULL(@C_TASK_DESC,'')
PRINT 'LAST RUN = ' + ISNULL(CAST(@C_LAST_RUN AS VARCHAR(30)),'')
PRINT 'RUN NAME = ' + ISNULL(@RUN_NAME,'')
PRINT 'STATS DATE = ' + CAST(@STATS_DATE AS VARCHAR(30))
PRINT 'REMNOTE SERVER FLAG = ' + ISNULL(@REMOTE_SERVER,'')
PRINT 'AZURE DB = ' + CAST(@C_AZURE_DB AS CHAR(1))


END
			
	

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@C_TASK_DESC, '') + CONVERT(VARCHAR, GETDATE(), 109)
PRINT ''


SET @TASK_STARTTIME = GETDATE()
SET @C_TASK_PARAMS = ISNULL(@C_TASK_PARAMS,'')


IF @DEBUG = 'Y'
BEGIN

	PRINT 'SERVER TIME ZONE OFFSET = ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
	PRINT 'AT LAST RUN  = ' + CAST(@C_LAST_RUN AS VARCHAR(30))

END

--REH Adjust the last_run time to UTC Time, the called sproc's will adjust it to local time unless we've never collected
IF @C_LAST_RUN > '1/1/1901'
BEGIN
SET @C_LAST_RUN = DATEADD(MI,@DPA_TZ_OFFSET *-1 ,@C_LAST_RUN)
END



IF @DEBUG = 'Y'
BEGIN
	PRINT 'AT LAST RUN TIME BEING PASSED TO SPROC ' + CAST(@C_LAST_RUN AS VARCHAR(30))
END

SELECT @SQL = 'EXEC ' + @C_TASK_PROCEDURE + '  @TASK_ID=' + CAST(@C_TASK_ID AS NVARCHAR(10)) + 
' ,@SERVER_NAME = ' + '''' +  @C_SERVER_NAME + '''' +
' ,@DATABASE_NAME = ' + '''' +  @C_DATABASE_NAME + '''' +
' ,@TASK_PARAMS = ' +  '''' +  @C_TASK_PARAMS + '''' +
' ,@TASK_DESC = ' + '''' +  @C_TASK_DESC + '''' +
' ,@LAST_RUN = ' + '''' + CONVERT(VARCHAR, @C_LAST_RUN, 109) + '''' +
' ,@RUN_NAME = ' + '''' +  @RUN_NAME + '''' +
' ,@STATS_DATE = ' + '''' + CONVERT(VARCHAR, @STATS_DATE, 109) + '''' +
' ,@REMOTE_SERVER = ' + '''' +  @REMOTE_SERVER + '''' +
' ,@AZURE_DB = ' + CAST(@C_AZURE_DB AS NVARCHAR(10)) + 
' ,@SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET AS NVARCHAR(10)) + 
' ,@DPA_TZ_OFFSET = ' + CAST(@DPA_TZ_OFFSET AS NVARCHAR(10)) + 


' ,@DEBUG = '  + '''' +  @DEBUG + ''''


UPDATE CAPTURE_LOG
SET    TEXT = TEXT  + CHAR(13) + CHAR(10) + '***** ' + @C_TASK_PROCEDURE
			+ CHAR(13) + CHAR(10)
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE



EXECUTE @RC = sp_executesql @SQL

   					  
SET @TASK_ENDTIME = GETDATE()

SET @TASK_TIME = DATEDIFF(ss,@TASK_STARTTIME, @TASK_ENDTIME)



 /*************** RETRY LOGIC ************************/ 
 IF @RC = 1
   AND @TASK_TIME < 10 -- IT FAILED AND WAS LESS THEN 10 SECONDS
  BEGIN
      WAITFOR DELAY '00:00:02' -- REH Wait 2 seconds and try again if sproc trapped the error
      EXECUTE @RC = Sp_executesql
        @SQL

      SET @TASK_ENDTIME = Getdate()
      SET @TASK_TIME = Datediff(ss, @TASK_STARTTIME, @TASK_ENDTIME)
  END 


--REH update last  [DYNPERF_TASK_HISTORY] IF THE TASK WAS SUCCESSFUL


  
 IF @RC = 0
      BEGIN
          PRINT ''
 
          PRINT 'SUCCESSFULLY CAPTURED '
                + ISNULL(@C_TASK_DESC, '') +  ' for SERVER
	'
              + ISNULL(@C_SERVER_NAME, '') + ' on database '
              + ISNULL(@C_DATABASE_NAME, '') + ' in ' + cast(@TASK_TIME AS VARCHAR(20)) + ' SECONDS '
 
       --REH if a manual capture don't update last run so we don't mess up the scheduling engine
				 IF @MANUAL_CAPTURE = 'N'
				 BEGIN
						  MERGE DynamicsPerf..[DYNPERF_TASK_HISTORY] AS target
						  USING (SELECT @C_SERVER_NAME   AS SERVER_NAME,
										@C_DATABASE_NAME AS DATABASE_NAME,
										@C_TASK_ID       AS TASK_ID,
										@STATS_DATE      AS LAST_RUN,
										@TASK_TIME	AS LAST_EXECUTION_TIME_SECS 
												) AS source
						  ON ( source.SERVER_NAME = target.LINKEDSERVER_NAME
							   AND source.DATABASE_NAME = target.DATABASE_NAME
							   AND source.TASK_ID = target.TASK_ID )
						  WHEN MATCHED THEN
							UPDATE SET LAST_RUN = source.LAST_RUN, [LAST_EXECUTION_TIME_SECS] = source.[LAST_EXECUTION_TIME_SECS]
						  WHEN NOT MATCHED THEN
							INSERT ( [LINKEDSERVER_NAME],
									 [DATABASE_NAME],
									 [TASK_ID],
									 [LAST_RUN],
									 [LAST_EXECUTION_TIME_SECS])
							VALUES (source.SERVER_NAME,
									source.DATABASE_NAME,
									source.TASK_ID,
									source.LAST_RUN,
									source.LAST_EXECUTION_TIME_SECS );
				END
      END
 ELSE
	IF @RC = 1  --REH SPROC HANDLED THE ERROR
      BEGIN
          PRINT ''
 
          PRINT 'FAILED !!!!!! ' + ISNULL(@C_TASK_DESC, '')
 
          PRINT ''
      END 
 

 
 

           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_QUERY_SYSDATABASES')

  
END TRY 

BEGIN CATCH


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PROCEDURE FAILED !!! '
              + ISNULL(@C_TASK_DESC, 'TASK') + ' for SERVER
	'
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) + ', '
WHERE  STATS_TIME = @STATS_DATE  AND TASK_TYPE = @TASK_TYPE

PRINT 'ERROR WHILE COLLECTING ' + ISNULL(@C_TASK_DESC, '') +' !!!!!!!!!!!!!!'


           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_QUERY_SYSDATABASES')


END CATCH



FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
 DELETE FROM COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
 
			

ENDPROC:
PRINT 'RUN NAME = '+ @RUN_NAME
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SSRS_EXECUTIONLOG]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SSRS_EXECUTIONLOG (
											  @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

DECLARE @SQL              NVARCHAR(MAX),
        @SQL2             NVARCHAR(MAX),
        @C_SERVER_NAME    NVARCHAR(128),
        @C_LAST_COLLECTED DATETIME,
        @UTC_TIME         DATETIME,
        @ROW_COUNT        BIGINT = 0,
        @C_DATABASE_NAME  NVARCHAR(128),
        @REMOTE_SERVER    NVARCHAR(1) = 'Y',
        @STATS_DATE       DATETIME = GETDATE(),
        @SQL_TZ_OFFSET    INT,
        @DPA_TZ_OFFSET    INT,
        @TASK_ID          INT,
        @SERVER_NAME      NVARCHAR(128),
        @DATABASE_NAME    NVARCHAR(128),
        @LAST_RUN         DATETIME 

		

    
 INSERT CAPTURE_LOG  SELECT 'SSRS', @STATS_DATE, 'STARTING to COLLECT SSRS ExecutionLog2  @DEBUG = ' + @DEBUG + '  ' + CHAR(10) + CHAR(13)

   
    
/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

SET @DPA_TZ_OFFSET = DATEDIFF(MI,GETUTCDATE(),GETDATE())

SET @UTC_TIME = DATEADD(MI,@DPA_TZ_OFFSET,@STATS_DATE)




BEGIN TRY
PRINT 'STARTING to COLLECT SSRS Data'
PRINT ''


DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT SERVER_NAME,
       Isnull(LAST_COLLECTED, '1/1/1900'), 
	   DATABASE_NAME
FROM   DynamicsPerf..SSRS_CONFIG SSRS
WHERE LAST_COLLECTED < @UTC_TIME



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_SERVER_NAME, @C_LAST_COLLECTED, @C_DATABASE_NAME



/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

	          SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


  -- CREATE TABLE #SQL_INFO
  --   (
  --      SQL_STARTTIME DATETIME,
  --      SQL_BUILD NVARCHAR(20),
		--SQL_TZ_OFFSET INT
  --   )
   
   SET NOCOUNT ON
   

   
TRUNCATE TABLE WRK_TZ_SQL_INFO   --REH clear out table to repopulate

 
SELECT @SQL = 'SELECT create_date AS SQL_STARTTIME,
       CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))    AS SQL_BUILD,
	   DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
		FROM sys.databases WHERE name = ''TempDB'''

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

SET @REMOTE_SERVER = 'N'
IF @C_SERVER_NAME <> @@SERVERNAME  SET @REMOTE_SERVER = 'Y'
   
   SET NOCOUNT ON
 
IF @REMOTE_SERVER = 'N'
BEGIN
		   INSERT WRK_TZ_SQL_INFO
		EXEC( @SQL)
END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT DATEADD(ms,AVG(-wait_time_ms), GETDATE()) AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROMsys.dm_os_wait_stats w WHEREwait_type
IN(''DIRTY_PAGE_POLL'',''HADR_FILESTREAM_IOMGR_IOCOMPLETION'',''LAZYWRITER_SLEEP'',''LOGMGR_QUEUE'',''REQUEST_FOR_DEADLOCK_SEARCH'',''XE_DISPATCHER_WAIT'',''XE_TIMER_EVENT'') "	)'
		


				IF @DEBUG = 'Y'
                  BEGIN
                      PRINT '@SQL= ' + @SQL2
                  END 
                
			INSERT WRK_TZ_SQL_INFO
				EXEC (@SQL2) 
 
 END
 
 --INSERT @SQL_INFO SELECT SQL_STARTTIME,  SQL_BUILD,TZ_OFFSET FROM WRK_TZ_SQL_INFO


 SET @SQL_TZ_OFFSET = (SELECT TZ_OFFSET FROM WRK_TZ_SQL_INFO)


   --INSERT #SQL_INFO
   --EXECUTE SP_TZOFFSET
   --  @SERVER_NAME = @C_SERVER_NAME,
   --  @DATABASE_NAME = @C_DATABASE_NAME--, @DEBUG = 'N'





--REH LAST_COLLECTED IS STORE IN UTC TIME, NEED TO CONVERT BACK TO LOCAL TIME AS TIMEEND IN EXECUTIONLOG2 IS LOCAL SQL TIME

IF @C_LAST_COLLECTED > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @C_LAST_COLLECTED = DATEADD(MI, @DPA_TZ_OFFSET*-1, @C_LAST_COLLECTED) --REH STORED AS UTC TIME, NEED TO CONVERT TO LOCAL TIME
        END
      ELSE
        BEGIN
            SET @C_LAST_COLLECTED = DATEADD(MI, @SQL_TZ_OFFSET*-1, @C_LAST_COLLECTED)  --REH STORED AS UTC TIME, NEED TO CONVERT TO LOCAL TIME
        END
  END 

  --PRINT '@C_LAST_COLLECTED ' + CAST(@C_LAST_COLLECTED AS VARCHAR(50))



IF @REMOTE_SERVER = 'N'
BEGIN

	
		SET @SQL = 'SET DATEFORMAT MDY 
		INSERT INTO DynamicsPerf.dbo.SSRS_EXECUTIONLOG

	SELECT '
	+ '''' + @C_SERVER_NAME + '''' + ', '
	+ '''' +  CONVERT(NVARCHAR(24), @STATS_DATE, 121) + '''' + ', '
	+ '''' + @C_DATABASE_NAME + '''' + ', ' 
	+'InstanceName, 
	REPLACE(COALESCE(C.Path, ''Unknown''),C.Name,'+'''' + ''''+') AS ReportPath, 
	C.Name,
	''Removed for security reason'', --UserName,
	ExecutionId, 
	CASE(RequestType)
		WHEN 0 THEN ''Interactive''
		WHEN 1 THEN ''Subscription''
		ELSE ''Unknown''
		END AS RequestType, 
	-- SubscriptionId, 
	Format, 
	Parameters, 
	CASE(ReportAction)		
		WHEN 1 THEN ''Render''
		WHEN 2 THEN ''BookmarkNavigation''
		WHEN 3 THEN ''DocumentMapNavigation''
		WHEN 4 THEN ''DrillThrough''
		WHEN 5 THEN ''FindString''
		WHEN 6 THEN ''GetDocumentMap''
		WHEN 7 THEN ''Toggle''
		WHEN 8 THEN ''Sort''
		ELSE ''Unknown''
		END AS ReportAction,
	TimeStart, 
	TimeEnd, 
	TimeDataRetrieval, 
	TimeProcessing, 
	TimeRendering,
	CASE(Source)
		WHEN 1 THEN ''Live''
		WHEN 2 THEN ''Cache''
		WHEN 3 THEN ''Snapshot'' 
		WHEN 4 THEN ''History''
		WHEN 5 THEN ''AdHoc''
		WHEN 6 THEN ''Session''
		WHEN 7 THEN ''Rdce''
		ELSE ''Unknown''
		END AS Source,
	Status,
	ByteCount,
	[RowCount]
FROM ['+@C_DATABASE_NAME + '].dbo.ExecutionLogStorage EL WITH(NOLOCK)
LEFT OUTER JOIN ['+@C_DATABASE_NAME + '].dbo.Catalog C WITH(NOLOCK) ON (EL.ReportID = C.ItemID)
WHERE TimeEnd >= ' +'''' + CONVERT(NVARCHAR(24), @C_LAST_COLLECTED, 121) +''''

	
	
	
END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
 
 
		SET @SQL = 'SET DATEFORMAT MDY 
	SELECT '
		+ '''' + @C_SERVER_NAME + '''' + ', '
	+ '''' +  CONVERT(NVARCHAR(24), @STATS_DATE, 121) + '''' + ', '
	+ '''' + @C_DATABASE_NAME + '''' + ', ' +
	'InstanceName, 
	REPLACE(COALESCE(C.Path, ''Unknown''),C.Name,'+'''' + ''''+') AS ReportPath, 
	C.Name,
	''Removed for security reason'', --UserName,
	ExecutionId, 
	CASE(RequestType)
		WHEN 0 THEN ''Interactive''
		WHEN 1 THEN ''Subscription''
		ELSE ''Unknown''
		END AS RequestType, 
	-- SubscriptionId, 
	Format, 
	Parameters, 
	CASE(ReportAction)		
		WHEN 1 THEN ''Render''
		WHEN 2 THEN ''BookmarkNavigation''
		WHEN 3 THEN ''DocumentMapNavigation''
		WHEN 4 THEN ''DrillThrough''
		WHEN 5 THEN ''FindString''
		WHEN 6 THEN ''GetDocumentMap''
		WHEN 7 THEN ''Toggle''
		WHEN 8 THEN ''Sort''
		ELSE ''Unknown''
		END AS ReportAction,
	TimeStart, 
	TimeEnd, 
	TimeDataRetrieval, 
	TimeProcessing, 
	TimeRendering,
	CASE(Source)
		WHEN 1 THEN ''Live''
		WHEN 2 THEN ''Cache''
		WHEN 3 THEN ''Snapshot'' 
		WHEN 4 THEN ''History''
		WHEN 5 THEN ''AdHoc''
		WHEN 6 THEN ''Session''
		WHEN 7 THEN ''Rdce''
		ELSE ''Unknown''
		END AS Source,
	Status,
	ByteCount,
	[RowCount]
FROM ['+@C_DATABASE_NAME + '].dbo.ExecutionLogStorage EL WITH(NOLOCK)
LEFT OUTER JOIN ['+@C_DATABASE_NAME + '].dbo.Catalog C WITH(NOLOCK) ON (EL.ReportID = C.ItemID)
WHERE TimeEnd >= ' +'''' + CONVERT(NVARCHAR(24), @C_LAST_COLLECTED, 121) +''''



		                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  INSERT INTO DynamicsPerf.dbo.SSRS_EXECUTIONLOG
				 SELECT * FROM OPENQUERY([' + @C_SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '
                    
                    EXEC (@SQL2)
           
               
 
 
 END
 
 SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT


 UPDATE SSRS_CONFIG SET LAST_COLLECTED = @UTC_TIME WHERE SERVER_NAME = @C_SERVER_NAME

 --PRINT '@DPA_TZ_OFFSET ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(50))
 --PRINT '@STATS_DATE ' + CAST(@STATS_DATE AS VARCHAR(50))
 --PRINT '@UTC_TIME ' + CAST(@UTC_TIME AS VARCHAR(50))

 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY collected SSRS data for SERVER ' + @C_SERVER_NAME 
              + ' on database ' + @C_DATABASE_NAME
             +  CHAR(10) + CHAR(13)
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = 'SSRS'


 TRUNCATE TABLE WRK_TZ_SQL_INFO --REH Cleanout the table for next loop

FETCH NEXT FROM TASK_CURSOR INTO @C_SERVER_NAME, @C_LAST_COLLECTED, @C_DATABASE_NAME



END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
 


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY collected SSRS Data'
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = 'SSRS'


PRINT ''
PRINT 'SUCCESSFULLY COLLECTED SSRS DATA'
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to collect SSRS Data '
				  + ' TRYING TO PROCESS REPORT SERVER ' + ISNULL(@C_SERVER_NAME,'') + '  '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE ='SSRS'



    PRINT 'ERROR WHILE COLLECTING SSRS DATA'
          

   -- RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_UPDATE_SSRS_HISTORY]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_UPDATE_SSRS_HISTORY]
				(    @DEBUG         NVARCHAR(1) = 'N')
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

     
    
	DECLARE @SQL              NVARCHAR(MAX),
        @SQL2             NVARCHAR(MAX),
        @C_SERVER_NAME    NVARCHAR(128),
        @C_LAST_COLLECTED DATETIME,
        @UTC_TIME         DATETIME,
        @ROW_COUNT        BIGINT = 0,
        @C_DATABASE_NAME  NVARCHAR(128),
        @REMOTE_SERVER    NVARCHAR(1) = 'Y',
        @STATS_DATE       DATETIME = GETDATE(),
        @SQL_TZ_OFFSET    INT,
        @DPA_TZ_OFFSET    INT,
        @TASK_ID          INT,
        @SERVER_NAME      NVARCHAR(128),
        @DATABASE_NAME    NVARCHAR(128),
        @LAST_RUN         DATETIME 


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/


 INSERT CAPTURE_LOG  SELECT 'SSRS', @STATS_DATE, 'STARTING to ROLLUP SSRS HISTORY  @DEBUG = ' + @DEBUG + '  ' + CHAR(10) + CHAR(13)






--REH  Time Zone code for all procedures

-- @LAST_RUN is UTC time


--IF @LAST_RUN > '1/1/1901'
--  BEGIN
--      IF @REMOTE_SERVER = 'N'
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
--        END
--      ELSE
--        BEGIN
--            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
--        END
--  END 

  --SET @UTC_TIME = DATEADD(MI,@DPA_TZ_OFFSET,@STATS_DATE)

BEGIN TRY
PRINT 'STARTING SSRS HISTORY ROLLUP'
PRINT ''

--REH Deal with default instance

/******************************************************************************
NEED TO SUBTRACT OUT PREVIOUS DAYS AMOUNTS IF COMPILE_TIME WAS BEFORE TODAY

SUBTRACT THE LAST QUERY_STATS RECORD FROM PREVIOUS DAY WITH SAME COMPILE_TIME


*******************************************************************************/
--REH This sums up to the totals of the day

MERGE SSRS_HISTORY AS target
		USING (
		SELECT SERVER_NAME, DATABASE_NAME, INSTANCE_NAME,
       REPORTPATH,
       REPORTNAME                                      AS REPORT_NAME,
       MAX(DATEADD(DAY, DATEDIFF(DAY, 0, TIMEEND), 0)) AS REPORT_DATE,
       SUM([TIME_DATARETRIEVAL])                       AS TOTAL_TIME_DATA,
       SUM([TIME_PROCESSING])                          AS TOTAL_TIME_PROCESSING,
       SUM([TIME_RENDERING])                           AS TOTAL_TIME_RENDERING,
       MAX(TIME_DATARETRIEVAL + TIME_PROCESSING
           + TIME_RENDERING)                           AS MAX_REPORT_TIME_MS,
       MIN(TIME_DATARETRIEVAL + TIME_PROCESSING
           + TIME_RENDERING)                           AS MIN_REPORT_TIME_MS,
       COUNT(REPORTPATH)                               AS EXECUTION_COUNT,
       MAX(BYTECOUNT)                                  AS MAX_SIZE_BYTES,
       MAX([ROWCOUNT])                                 AS MAX_ROW_COUNT,
       MAX('D')                                        AS FLAG
FROM   SSRS_EXECUTIONLOG SSRS
WHERE 
	--SERVER_NAME = @SERVER_NAME 
 --     AND DATABASE_NAME = @DATABASE_NAME  AND
	  
	   DATEADD(DAY, DATEDIFF(DAY, 0, TIMEEND), 0) >= iSNULL((SELECT MAX(DATEADD(DAY, DATEDIFF(DAY, 0, TIMEEND), 0)) 
			FROM SSRS_EXECUTIONLOG S2
				 WHERE SSRS.SERVER_NAME = S2.SERVER_NAME AND SSRS.DATABASE_NAME = S2.DATABASE_NAME) ,GETDATE())  -- DATEADD(DAY, DATEDIFF(DAY, 0, @STATS_DATE), 0)
GROUP  BY SERVER_NAME, DATABASE_NAME, INSTANCE_NAME,
DATEADD(DAY, DATEDIFF(DAY, 0, TIMEEND), 0) ,
          REPORTPATH,
          REPORTNAME ) AS source
ON ( source.SERVER_NAME = target.SERVER_NAME
			 AND source.DATABASE_NAME = target.DATABASE_NAME
			 AND source.INSTANCE_name = target.INSTANCE_NAME
			 AND source.REPORTPATH = target.REPORTPATH
			 AND source.REPORT_NAME = target.REPORT_NAME
			 AND source.REPORT_DATE = target.REPORT_DATE
			 AND source.FLAG = target.FLAG )
		WHEN MATCHED THEN
		 UPDATE SET TOTAL_TIME_DATA = source.TOTAL_TIME_DATA,
					 TOTAL_TIME_PROCESSING = source.TOTAL_TIME_PROCESSING,
					 TOTAL_TIME_RENDERING = source.TOTAL_TIME_RENDERING,
					 MAX_REPORT_TIME_MS = source.MAX_REPORT_TIME_MS,
					 MIN_REPORT_TIME_MS = source.MIN_REPORT_TIME_MS,
					 EXECUTION_COUNT = source.EXECUTION_COUNT,
					 MAX_SIZE_BYTES = source.MAX_SIZE_BYTES,
					 MAX_ROW_COUNT = source.MAX_ROW_COUNT


		WHEN NOT MATCHED THEN
		  INSERT ([SERVER_NAME]
		   ,[DATABASE_NAME]
		   ,[INSTANCE_NAME]
           ,[REPORTPATH]
           ,[REPORT_NAME]
           ,[REPORT_DATE]
           ,[TOTAL_TIME_DATA]
           ,[TOTAL_TIME_PROCESSING]
           ,[TOTAL_TIME_RENDERING]
           ,[MAX_REPORT_TIME_MS]
           ,[MIN_REPORT_TIME_MS]
           ,[EXECUTION_COUNT]
           ,[MAX_SIZE_BYTES]
           ,[MAX_ROW_COUNT]
           ,[FLAG])
		  VALUES (source.[SERVER_NAME]
		   ,source.[DATABASE_NAME]
		   ,source.[INSTANCE_NAME]
           ,source.[REPORTPATH]
           ,source.[REPORT_NAME]
           ,source.[REPORT_DATE]
           ,source.[TOTAL_TIME_DATA]
           ,source.[TOTAL_TIME_PROCESSING]
           ,source.[TOTAL_TIME_RENDERING]
           ,source.[MAX_REPORT_TIME_MS]
           ,source.[MIN_REPORT_TIME_MS]
           ,source.[EXECUTION_COUNT]
           ,source.[MAX_SIZE_BYTES]
           ,source.[MAX_ROW_COUNT]
           ,source.[FLAG]);


		   SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

 --REH Rollup the daily total into the Monthly total


MERGE SSRS_HISTORY AS target
		USING (
		SELECT SERVER_NAME, DATABASE_NAME, INSTANCE_NAME
           ,[REPORTPATH]
           ,[REPORT_NAME]
           ,DATEADD(MONTH, DATEDIFF(MONTH, 0, REPORT_DATE), 0) AS REPORT_DATE --REH floor the date to the month level
           ,SUM([TOTAL_TIME_DATA]) AS TOTAL_TIME_DATA
           ,SUM([TOTAL_TIME_PROCESSING]) AS TOTAL_TIME_PROCESSING
           ,SUM([TOTAL_TIME_RENDERING]) AS TOTAL_TIME_RENDERING
           ,MAX([MAX_REPORT_TIME_MS]) AS MAX_REPORT_TIME_MS
           ,MIN([MIN_REPORT_TIME_MS]) AS MIN_REPORT_TIME_MS
           ,SUM([EXECUTION_COUNT]) AS EXECUTION_COUNT
           ,MAX([MAX_SIZE_BYTES]) AS MAX_SIZE_BYTES
           ,MAX([MAX_ROW_COUNT]) AS MAX_ROW_COUNT
           ,'M' AS FLAG
FROM   SSRS_HISTORY SSRS
WHERE 
--SERVER_NAME = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME AND 
	FLAG = 'D' -- ONLY sum up the Daily totals into the monthly totals
	 AND  DATEADD(MONTH, DATEDIFF(MONTH, 0, REPORT_DATE), 0) >= iSNULL((SELECT MAX(DATEADD(MONTH, DATEDIFF(MONTH, 0, REPORT_DATE), 0)) 
			FROM SSRS_HISTORY S2
				 WHERE SSRS.SERVER_NAME = S2.SERVER_NAME AND SSRS.DATABASE_NAME = S2.DATABASE_NAME) ,GETDATE())
GROUP  BY SERVER_NAME, DATABASE_NAME,INSTANCE_NAME,
DATEADD(MONTH, DATEDIFF(MONTH, 0, REPORT_DATE), 0) ,
          REPORTPATH,
          REPORT_NAME ) AS source
ON ( source.SERVER_NAME = target.SERVER_NAME
			 AND source.DATABASE_NAME = target.DATABASE_NAME
			 AND source.INSTANCE_name = target.INSTANCE_NAME
			 AND source.REPORTPATH = target.REPORTPATH
			 AND source.REPORT_NAME = target.REPORT_NAME
			 AND source.REPORT_DATE = target.REPORT_DATE
			 AND source.FLAG = target.FLAG )
		WHEN MATCHED THEN
		 UPDATE SET TOTAL_TIME_DATA = source.TOTAL_TIME_DATA,
					 TOTAL_TIME_PROCESSING = source.TOTAL_TIME_PROCESSING,
					 TOTAL_TIME_RENDERING = source.TOTAL_TIME_RENDERING,
					 MAX_REPORT_TIME_MS = source.MAX_REPORT_TIME_MS,
					 MIN_REPORT_TIME_MS = source.MIN_REPORT_TIME_MS,
					 EXECUTION_COUNT = source.EXECUTION_COUNT,
					 MAX_SIZE_BYTES = source.MAX_SIZE_BYTES,
					 MAX_ROW_COUNT = source.MAX_ROW_COUNT


		WHEN NOT MATCHED THEN
		  INSERT ([SERVER_NAME]
		   ,[DATABASE_NAME]
		   ,[INSTANCE_NAME]
           ,[REPORTPATH]
           ,[REPORT_NAME]
           ,[REPORT_DATE]
           ,[TOTAL_TIME_DATA]
           ,[TOTAL_TIME_PROCESSING]
           ,[TOTAL_TIME_RENDERING]
           ,[MAX_REPORT_TIME_MS]
           ,[MIN_REPORT_TIME_MS]
           ,[EXECUTION_COUNT]
           ,[MAX_SIZE_BYTES]
           ,[MAX_ROW_COUNT]
           ,[FLAG])
		  VALUES (source.[SERVER_NAME]
		   ,source.[DATABASE_NAME]
		   ,source.[INSTANCE_NAME]
           ,source.[REPORTPATH]
           ,source.[REPORT_NAME]
           ,source.[REPORT_DATE]
           ,source.[TOTAL_TIME_DATA]
           ,source.[TOTAL_TIME_PROCESSING]
           ,source.[TOTAL_TIME_RENDERING]
           ,source.[MAX_REPORT_TIME_MS]
           ,source.[MIN_REPORT_TIME_MS]
           ,source.[EXECUTION_COUNT]
           ,source.[MAX_SIZE_BYTES]
           ,source.[MAX_ROW_COUNT]
           ,source.[FLAG]);

		   SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY ROLLED UP SSRS HISTORY'
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = 'SSRS'


PRINT ''
PRINT 'SUCCESSFULLY ROLLED UP SSRS HISOTRY '
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'FAILED TO ROLL UP SSRS HISTORY'
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = 'SSRS'


    PRINT 'ERROR WHILE ROLLING UP SSRS HISTORY !!!!!!!!!!!!!!'

    --RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_AX_NUMBERSEQUENCE]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_AX_NUMBERSEQUENCE (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @ROW_COUNT BIGINT
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/


--REH All versions have this table so it's here in the code
-- version specific synonyms are in the appropriate AX version below


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCETABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCETABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCETABLE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCETABLE
				FOR [' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCETABLE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 











/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


--REH Get AX version

DECLARE @AX_SERVER_NAME   NVARCHAR(128) = NULL,
        @AX_DATABASE_NAME NVARCHAR(128),
        @AX_APP_BUILD     NVARCHAR(120),
        @KERNEL_BUILD     NVARCHAR(20)
   
   CREATE TABLE #AX_VERSION_NUM
     (
        AX_APP_BUILD NVARCHAR(120),
        KERNEL_BUILD NVARCHAR(20)
     )
   
   SET NOCOUNT ON
   
   INSERT #AX_VERSION_NUM
   EXECUTE DYNPERF_AX_VERSION_INFO
     @AX_SERVER_NAME = @SERVER_NAME,
     @AX_DATABASE_NAME = @DATABASE_NAME--, @DEBUG = 'N'
   SELECT @AX_APP_BUILD = AX_APP_BUILD,
          @KERNEL_BUILD = KERNEL_BUILD
   FROM   #AX_VERSION_NUM
   
   --PRINT 'AX BUILD = ' + ISNULL(@AX_APP_BUILD, '')
   
   --PRINT 'KERNEL BUILD = '+ ISNULL(@KERNEL_BUILD, '')
   
   IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = '#AX_VERSION_NUM') 
	BEGIN
	  DROP TABLE #AX_VERSION_NUM 
	END
   
   
  
IF Substring(@AX_APP_BUILD, 1, 1) BETWEEN N'4' AND N'5'
BEGIN



--REH  Have to check if the NUMBERSEQUENCETABLE is shared or not, aka. does DATAAREAID exist in the table

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSTABLES')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSTABLES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSTABLES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.tables'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSTABLES
				FOR [' + @DATABASE_NAME + '].sys.tables'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSCOLUMNS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSCOLUMNS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.columns'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSCOLUMNS
				FOR [' + @DATABASE_NAME + '].sys.columns'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


		--REH store data by company, most common scenario
		IF EXISTS (SELECT * FROM DYN_AXNUM_SYSTABLES t INNER JOIN DYN_AXNUM_SYSCOLUMNS c
		ON t.object_id=c.object_id
		WHERE t.name = 'NUMBERSEQUENCETABLE' AND c.name = 'DATAAREAID') 
		BEGIN
			INSERT INTO AX_NUM_SEQUENCES
			SELECT @SERVER_NAME,
				   @STATS_DATE,
				   @DATABASE_NAME,
				   0,
				   NUMBERSEQUENCE,
				   TXT,
				   LOWEST,
				   HIGHEST,
				   NEXTREC,
				   0,
				   0,
				   CASE CONTINUOUS
					 WHEN 0 THEN 'No'
					 WHEN 1 THEN 'Yes'
				   END,
				   FETCHAHEAD,
				   FETCHAHEADQTY,
				   0,
				   0,
				   NULL,
				   NULL,
				   DATAAREAID,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   FORMAT
			FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE 


		END
		ELSE
		BEGIN
		
			INSERT INTO AX_NUM_SEQUENCES
			SELECT @SERVER_NAME,
				   @STATS_DATE,
				   @DATABASE_NAME,
				   0,
				   NUMBERSEQUENCE,
				   TXT,
				   LOWEST,
				   HIGHEST,
				   NEXTREC,
				   0,
				   0,
				   CASE CONTINUOUS
					 WHEN 0 THEN 'No'
					 WHEN 1 THEN 'Yes'
				   END,
				   FETCHAHEAD,
				   FETCHAHEADQTY,
				   0,
				   0,
				   NULL,
				   NULL,
				   '',			--blank out dataareid, field doesn't exist
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   FORMAT
			FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE 


		
		END

		SET @ROW_COUNT = @@ROWCOUNT
	
END

--REH Synonyms for all version of AX2012 --------------------------------------------------

IF Substring(@AX_APP_BUILD, 1, 1) = '6'
BEGIN
	

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
 EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.DATAAREA'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @DATABASE_NAME + '].dbo.DATAAREA'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)
	
END



IF Substring(@AX_APP_BUILD, 1, 1) = '7'
BEGIN
	

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.DATAAREA'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @DATABASE_NAME + '].dbo.DATAAREA'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)
	
		
	
	
PRINT ''	
END

-------------------------------------------End of AX2012 common synonyms -------------------


IF Substring(@AX_APP_BUILD, 1, 3) = '6.0'
BEGIN




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_COMPANYINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_COMPANYINFO')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_COMPANYINFO
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.COMPANYINFO'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_COMPANYINFO
				FOR [' + @DATABASE_NAME + '].dbo.COMPANYINFO'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_OMOPERATINGUNIT')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_OMOPERATINGUNIT')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_OMOPERATINGUNIT
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.OMOPERATINGUNIT'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_OMOPERATINGUNIT
				FOR [' + @DATABASE_NAME + '].dbo.OMOPERATINGUNIT'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

INSERT INTO AX_NUM_SEQUENCES
SELECT @SERVER_NAME,
       @STATS_DATE,
       @DATABASE_NAME,
       NST.RECID,
       NST.NUMBERSEQUENCE                                                                                                                                 AS [NumberSequence],
       NST.TXT                                                                                                                                            AS [Text],
       NST.LOWEST,
       NST.HIGHEST,
       NST.NEXTREC,
       CAST (( CAST(( NST.HIGHEST - NST.NEXTREC ) AS DECIMAL(20, 2)) / ( CAST(( NST.HIGHEST - NST.LOWEST ) AS DECIMAL(20, 2)) ) * 100 ) AS DECIMAL(6, 2)) AS [PercentRemaining],
       NST.HIGHEST - NST.NEXTREC                                                                                                                          AS [NumbersRemaining],
       CASE NST.CONTINUOUS
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Continuous],
       NST.FETCHAHEAD                                                                                                                                     AS FetchAhead,
       NST.FETCHAHEADQTY                                                                                                                                  AS FetchAheadQty,
       NST.CLEANINTERVAL                                                                                                                                  AS CleanInterval,
       NST.CLEANATACCESS                                                                                                                                  AS CleanAtAccess,
       'N/A'                                                                                                                                              AS [PartitionName],
       NST.NUMBERSEQUENCESCOPE,
       DA.ID                                                                                                                                              [CompanyId],
       DA.NAME                                                                                                                                            [CompanyName],
       CASE DA.ISVIRTUAL
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Shared],
       CI.DATAAREA                                                                                                                                        [LegalEntityName],
       CASE OU.OMOPERATINGUNITTYPE
         WHEN 0 THEN 'None'
         WHEN 1 THEN 'Department'
         WHEN 2 THEN 'Cost center'
         WHEN 3 THEN 'Value stream'
         WHEN 4 THEN 'Business unit'
         WHEN 5 THEN 'All operating units'
         WHEN 6 THEN 'Retail channel'
       END                                                                                                                                                [OperatingUnitType],
       OU.OMOPERATINGUNITNUMBER                                                                                                                           [OperatingUnitNumber],
       FC.CALENDARID                                                                                                                                      [FiscalCalendar],
       FCY.NAME                                                                                                                                           [FiscalCalendarYear],
       FCP.NAME                                                                                                                                           [Period],
       NST.FORMAT
FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE NST
       JOIN DYN_AXNUM_AX_NUMBERSEQUENCESCOPE NSS
         ON NSS.RECID = NST.NUMBERSEQUENCESCOPE
       LEFT JOIN DYN_AXNUM_AX_DATAAREA DA
              ON NSS.DATAAREA = DA.ID
       LEFT JOIN DYN_AXNUM_AX_COMPANYINFO CI
              ON NSS.LEGALENTITY = CI.RECID
       LEFT JOIN DYN_AXNUM_AX_OMOPERATINGUNIT OU
              ON NSS.OPERATINGUNIT = OU.RECID
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARPERIOD FCP
              ON NSS.FISCALCALENDARPERIOD = FCP.RECID
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDAR FC
              ON FC.RECID = FCP.FISCALCALENDAR
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARYEAR FCY
              ON FCY.RECID = FCP.FISCALCALENDARYEAR

	
	SET @ROW_COUNT = @@ROWCOUNT
END
	
IF Substring(@AX_APP_BUILD, 1, 3) IN ( '6.2', '6.3', '7.0')
BEGIN
	


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_PARTITIONS')
  EXEC('DROP SYNONYM [dbo].DYN_AXNUM_AX_PARTITIONS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_PARTITIONS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.PARTITIONS'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_PARTITIONS
				FOR [' + @DATABASE_NAME + '].dbo.PARTITIONS'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DIRPARTYTABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DIRPARTYTABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DIRPARTYTABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.DIRPARTYTABLE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DIRPARTYTABLE
				FOR [' + @DATABASE_NAME + '].dbo.DIRPARTYTABLE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

INSERT INTO AX_NUM_SEQUENCES
SELECT @SERVER_NAME,
       @STATS_DATE,
       @DATABASE_NAME,
       NST.RECID,
       NST.NUMBERSEQUENCE                                                                                                                                 AS [NumberSequence],
       NST.TXT                                                                                                                                            AS [Text],
       NST.LOWEST,
       NST.HIGHEST,
       NST.NEXTREC,
       CAST (( CAST(( NST.HIGHEST - NST.NEXTREC ) AS DECIMAL(20, 2)) / ( CAST(( NST.HIGHEST - NST.LOWEST ) AS DECIMAL(20, 2)) ) * 100 ) AS DECIMAL(6, 2)) AS [PercentRemaining],
       NST.HIGHEST - NST.NEXTREC                                                                                                                          AS [NumbersRemaining],
       CASE NST.CONTINUOUS
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Continuous],
       NST.FETCHAHEAD                                                                                                                                     AS FetchAhead,
       NST.FETCHAHEADQTY                                                                                                                                  AS FetchAheadQty,
       NST.CLEANINTERVAL                                                                                                                                  AS CleanInterval,
       NST.CLEANATACCESS                                                                                                                                  AS CleanAtAccess,
       P.NAME                                                                                                                                             AS [PartitionName],
       NST.NUMBERSEQUENCESCOPE,
       DA.ID                                                                                                                                              [CompanyId],
       DA.NAME                                                                                                                                            [CompanyName],
       CASE DA.ISVIRTUAL
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Shared],
       DI.DATAAREA                                                                                                                                        [LegalEntityName],
       CASE DI.OMOPERATINGUNITTYPE
         WHEN 0 THEN 'None'
         WHEN 1 THEN 'Department'
         WHEN 2 THEN 'Cost center'
         WHEN 3 THEN 'Value stream'
         WHEN 4 THEN 'Business unit'
         WHEN 5 THEN 'All operating units'
         WHEN 6 THEN 'Retail channel'
       END                                                                                                                                                [OperatingUnitType],
       DI.OMOPERATINGUNITNUMBER                                                                                                                           [OperatingUnitNumber],
       FC.CALENDARID                                                                                                                                      [FiscalCalendar],
       FCY.NAME                                                                                                                                           [FiscalCalendarYear],
       FCP.NAME                                                                                                                                           [Period],
       NST.FORMAT
FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE NST
       JOIN DYN_AXNUM_AX_PARTITIONS P
         ON NST.PARTITION = P.RECID
       JOIN DYN_AXNUM_AX_NUMBERSEQUENCESCOPE NSS
         ON NSS.RECID = NST.NUMBERSEQUENCESCOPE
       LEFT JOIN DYN_AXNUM_AX_DATAAREA DA
              ON NSS.DATAAREA = DA.ID
       LEFT JOIN DYN_AXNUM_AX_DIRPARTYTABLE DI
              ON ( NSS.LEGALENTITY = DI.RECID )
                  OR ( NSS.OPERATINGUNIT = DI.RECID )
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARPERIOD FCP
              ON NSS.FISCALCALENDARPERIOD = FCP.RECID
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDAR FC
              ON FC.RECID = FCP.FISCALCALENDAR
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARYEAR FCY
              ON FCY.RECID = FCP.FISCALCALENDARYEAR


	SET @ROW_COUNT = @@ROWCOUNT

END
    


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@ROW_COUNT as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


--REH Drop all synonyms

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCETABLE')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSTABLES')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSTABLES')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSCOLUMNS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
 EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_COMPANYINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_COMPANYINFO')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_OMOPERATINGUNIT')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_OMOPERATINGUNIT')



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_PARTITIONS')
  EXEC('DROP SYNONYM [dbo].DYN_AXNUM_AX_PARTITIONS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DIRPARTYTABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DIRPARTYTABLE')




RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/




BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

--REH Drop all synonyms

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCETABLE')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSTABLES')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSTABLES')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSCOLUMNS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
 EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_COMPANYINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_COMPANYINFO')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_OMOPERATINGUNIT')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_OMOPERATINGUNIT')



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_PARTITIONS')
  EXEC('DROP SYNONYM [dbo].DYN_AXNUM_AX_PARTITIONS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DIRPARTYTABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DIRPARTYTABLE')





    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_CRM_ORGANIZATION]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_CRM_ORGANIZATION (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMO_CRMORGANIZATION')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMO_CRMORGANIZATION')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMO_CRMORGANIZATION
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.Organization'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMO_CRMORGANIZATION
				FOR [' + @DATABASE_NAME + '].dbo.Organization'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


INSERT INTO [DynamicsPerf].dbo.CRM_ORGANIZATION
SELECT @SERVER_NAME,
       CONVERT(NVARCHAR(50), @STATS_DATE, 121),
       @DATABASE_NAME,
       sharetopreviousowneronassign,
       minoutlooksyncinterval,
       tagpollingperiod,
       MinAddressBookSyncInterval,
       AllowAddressBookSyncs,
       emailsendpollingperiod,
       ispresenceenabled,
       GetStartedPaneContentEnabled,
       orgdborgsettings
FROM   DYN_CRMO_CRMORGANIZATION 


    


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_CRM_PLUGINS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_CRM_PLUGINS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_PLUGINTYPE')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_PLUGINTYPE')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINTYPE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.PluginType'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINTYPE
				FOR [' + @DATABASE_NAME + '].dbo.PluginType'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_PLUGINASSEMBLY')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_PLUGINASSEMBLY')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINASSEMBLY
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.PluginAssembly'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINASSEMBLY
				FOR [' + @DATABASE_NAME + '].dbo.PluginAssembly'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_PLUGINTYPESTATISTIC')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_PLUGINTYPESTATISTIC')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINTYPESTATISTIC
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.PluginTypeStatistic'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_PLUGINTYPESTATISTIC
				FOR [' + @DATABASE_NAME + '].dbo.PluginTypeStatistic'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_SDKMESSAGEPROCESSINGSTEP')
 EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_SDKMESSAGEPROCESSINGSTEP')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGEPROCESSINGSTEP
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SdkMessageProcessingStep'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGEPROCESSINGSTEP
				FOR [' + @DATABASE_NAME + '].dbo.SdkMessageProcessingStep'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_SDKMESSAGEFILTER')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_SDKMESSAGEFILTER')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGEFILTER
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SdkMessageFilter'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGEFILTER
				FOR [' + @DATABASE_NAME + '].dbo.SdkMessageFilter'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_SDKMESSAGE')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_SDKMESSAGE')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.SdkMessage'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_SDKMESSAGE
				FOR [' + @DATABASE_NAME + '].dbo.SdkMessage'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPLUG_CRM_ENTITYLOGICALVIEW')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPLUG_CRM_ENTITYLOGICALVIEW')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_ENTITYLOGICALVIEW
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.EntityLogicalView'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPLUG_CRM_ENTITYLOGICALVIEW
				FOR [' + @DATABASE_NAME + '].dbo.EntityLogicalView'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

INSERT INTO [DynamicsPerf].dbo.CRM_PLUGINS
SELECT @SERVER_NAME,
       CONVERT(NVARCHAR(50), @STATS_DATE, 121),
       @DATABASE_NAME,
       CASE sdkmessageprocessingstep0.StateCode
         WHEN 0 THEN 'Enabled'
         WHEN 1 THEN 'Disabled'
         ELSE 'n/a'
       END                                                        AS 'StatusName',
       ISNULL(e.NAME, 'None')                                     AS 'EntityName',
       CASE sdkmessageprocessingstep0.Stage
         WHEN 10 THEN 'Pre-Out Of Trx'
         WHEN 20 THEN 'Pre in Trx'
         WHEN 40 THEN 'Post in Trx'
         WHEN 50 THEN 'Post-Out of Trx'
         ELSE 'Workflow Activity'
       END                                                        AS 'StageName',
       CASE PluginAssembly.IsolationMode
         WHEN 1 THEN 'Full'
         WHEN 2 THEN 'Isolated-SandBox'
         ELSE 'Unknown'
       END                                                        AS 'IsolationModeName',
       PluginAssembly.IsolationMode,
       PluginAssembly.Version,
       PluginAssembly.IsManaged,
       ISNULL(sm.Name, 'None')                                    AS 'MessageName',
       PluginType0.componentstate                                 AS 'Assembly',
       PluginType0.typename                                       AS 'Plugin',
       CASE sdkmessageprocessingstep0.Mode
         WHEN 1 THEN 'Asynchronous'
         WHEN 0 THEN 'Synchronous'
         ELSE 'None'
       END                                                        AS 'ModeName',
       CASE ( ( COALESCE(sdkmessageprocessingstep0.AsyncAutoDelete, 0) * sdkmessageprocessingstep0.Mode ) + sdkmessageprocessingstep0.Mode )
         WHEN 1 THEN 'No'
         WHEN 2 THEN 'Yes'
         ELSE '-'
       END                                                        AS 'AsyncAutoDeleteName',
       ISNULL(sdkmessageprocessingstep0.Rank, '')                 AS 'Rank',
       --CASE sdkmessageprocessingstep0.InvocationSource WHEN 0 Then 'Parent' WHEN 1 Then 'Child' END as 'PipelineName',
       ISNULL(sdkmessageprocessingstep0.FilteringAttributes, '-') AS 'FilteringAttributes',
       ISNULL(sdkmessageprocessingstep0.Description, '-')         AS 'StepName',
       ISNULL(sdkmessageprocessingstep0.AsyncAutoDelete, '')      AS 'AsyncAutoDelete',
       ISNULL(sdkmessageprocessingstep0.Mode, '')                 'Mode',
       ISNULL(sdkmessageprocessingstep0.Stage, '')                'Stage',
       COALESCE(pts.AverageExecuteTimeInMilliseconds, -1)         'AvgExecTimeMs',
       COALESCE(pts.ExecuteCount, -1)                             'Executes',
       COALESCE(pts.FailureCount, -1)                             'Failures'
FROM   DYN_CRMPLUG_CRM_PLUGINTYPE PluginType0
       INNER JOIN DYN_CRMPLUG_CRM_PLUGINASSEMBLY PluginAssembly
               ON PluginType0.PluginAssemblyId = PluginAssembly.PluginAssemblyId
       INNER JOIN DYN_CRMPLUG_CRM_PLUGINTYPESTATISTIC pts
               ON pts.PluginTypeId = PluginType0.PluginTypeId
       LEFT JOIN DYN_CRMPLUG_CRM_SDKMESSAGEPROCESSINGSTEP AS sdkmessageprocessingstep0
              ON PluginType0.PluginTypeId = sdkmessageprocessingstep0.PluginTypeId
       LEFT JOIN DYN_CRMPLUG_CRM_SDKMESSAGEFILTER filter
              ON filter.SdkMessageFilterId = sdkmessageprocessingstep0.SdkMessageFilterId
       LEFT JOIN DYN_CRMPLUG_CRM_SDKMESSAGE sm
              ON sm.SdkMessageId = filter.SdkMessageId
       LEFT JOIN DYN_CRMPLUG_CRM_ENTITYLOGICALVIEW e
              ON filter.PrimaryObjectTypeCode = e.ObjectTypeCode
WHERE  ( ( sdkmessageprocessingstep0.CustomizationLevel != 2
            OR sdkmessageprocessingstep0.CustomizationLevel IS NULL )
         AND ( sdkmessageprocessingstep0.Stage IS NULL
                OR ( sdkmessageprocessingstep0.Stage IN ( 10, 20, 40, 50 ) ) ) )
       AND FriendlyName NOT IN ( 'InternalOperation' )
       AND IsolationMode = 2 


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_CRM_POA_TOTALS]...';


GO


ALTER PROCEDURE DYNPERF_COLLECT_CRM_POA_TOTALS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPOA_CRM_POA')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPOA_CRM_POA')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPOA_CRM_POA
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.PrincipalObjectAccess'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPOA_CRM_POA
				FOR [' + @DATABASE_NAME + '].dbo.PrincipalObjectAccess'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CRMPOA_CRM_EV')
  EXEC ('DROP SYNONYM [dbo].DYN_CRMPOA_CRM_EV')



IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CRMPOA_CRM_EV
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.EntityAsIfPublishedLogicalView'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_CRMPOA_CRM_EV
				FOR [' + @DATABASE_NAME + '].dbo.EntityAsIfPublishedLogicalView'


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


INSERT INTO [DynamicsPerf].dbo.CRM_POA_TOTALS
SELECT @SERVER_NAME,
       CONVERT(NVARCHAR(50), @STATS_DATE, 121),
       @DATABASE_NAME,
       e.NAME   AS [EntityName],
       Sum(CASE
             WHEN p.AccessRightsMask > 0 THEN 1
             ELSE 0
           END) AS [DirectShares],
       Sum(CASE
             WHEN p.InheritedAccessRightsMask > 0 THEN 1
             ELSE 0
           END) AS [InheritedShares],
       Sum(CASE
             WHEN p.AccessRightsMask = 0
                  AND p.InheritedAccessRightsMask = 0 THEN 1
             ELSE 0
           END) AS[QueuedForDeletion],
       Sum(CASE
             WHEN p.AccessRightsMask > 0
                  AND p.InheritedAccessRightsMask > 0 THEN 1
             ELSE 0
           END) AS[InheritedAndDirect],
       Count(*) AS TotalShares
FROM   DYN_CRMPOA_CRM_POA p
       JOIN DYN_CRMPOA_CRM_EV e
         ON p.ObjectTypeCode = e.ObjectTypeCode
GROUP  BY e.Name
ORDER  BY TotalShares DESC 

    


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@@rowcount as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_INDEXSTATS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_INDEXSTATS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @PREV_STATS_TIME DATETIME
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_INDEX_COLS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_INDEX_COLS')


IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_INDEX_COLS
				FOR [' + @DATABASE_NAME + '].sys.index_columns'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_SYS_COLS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_SYS_COLS')


IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_SYS_COLS
				FOR [' + @DATABASE_NAME + '].sys.columns'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_INDEXES')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_INDEXES')


IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_INDEXES
				FOR [' + @DATABASE_NAME + '].sys.indexes'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_SYS_INDEXES')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_SYS_INDEXES')


IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_SYS_INDEXES
				FOR [' + @DATABASE_NAME + '].sys.sysindexes'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_OBJECTS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_OBJECTS')


IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_OBJECTS
				FOR [' + @DATABASE_NAME + '].sys.objects'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_SCHEMAS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_SCHEMAS')

IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_SCHEMAS
				FOR [' + @DATABASE_NAME + '].sys.schemas'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_PARTITIONS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_PARTITIONS')

IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_PARTITIONS
				FOR [' + @DATABASE_NAME + '].sys.partitions'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_CI_PARTITION_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_CI_PARTITION_STATS')

IF @REMOTE_SERVER = 'N'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_CI_PARTITION_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_db_partition_stats'
     END


IF @DEBUG = 'Y'
     BEGIN
         PRINT '@SQL= ' + @SQL
     END

EXEC(@SQL) 



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


IF @REMOTE_SERVER = 'N'
BEGIN
INSERT INTO INDEX_DETAIL
SELECT @SERVER_NAME,
       CONVERT(NVARCHAR(50), @STATS_DATE, 121),
       @DATABASE_NAME,
       si.object_id,
       si.index_id,
       CASE
         WHEN ss.NAME IN ( 'sys', 'dbo' ) THEN so.NAME
         ELSE ss.NAME + '.' + so.NAME
       END,
       si.NAME,
       si.type_desc + CASE WHEN is_unique = 1 THEN ', UNIQUE' ELSE '' END + CASE WHEN is_primary_key = 1 THEN ', PRIMARY KEY' ELSE '' END + CASE WHEN has_filter = 1 THEN ', FILTERED' ELSE '' END,
       Stuff ((SELECT ', ' + sc.NAME
               FROM   DYN_CI_INDEX_COLS sic
                      JOIN DYN_CI_SYS_COLS sc
                        ON sc.column_id = sic.column_id
               WHERE  so.object_id = sic.object_id
                      AND sic.index_id = si.index_id
                      AND sc.object_id = so.object_id
                      AND sic.is_included_column = 0
               ORDER  BY sic.key_ordinal
               FOR xml path('')), 1, 1, '') AS key_columns,
       Stuff ((SELECT ', ' + sc.NAME
               FROM   DYN_CI_INDEX_COLS sic
                      JOIN DYN_CI_SYS_COLS sc
                        ON sc.column_id = sic.column_id
               WHERE  so.object_id = sic.object_id
                      AND sic.index_id = si.index_id
                      AND sc.object_id = so.object_id
                      AND sic.is_included_column = 1
               ORDER  BY sic.key_ordinal
               FOR XML path('')), 1, 1, '') AS included_columns,
       PS.DATA_SIZE                         AS PAGE_COUNT,
       PS.ROW_COUNT                         AS ROW_COUNT,
       sp.data_compression
FROM   DYN_CI_INDEXES si
       JOIN DYN_CI_SYS_INDEXES ii
         ON si.object_id = ii.id
            AND si.index_id = ii.indid
       JOIN DYN_CI_OBJECTS so
         ON so.object_id = si.object_id
       JOIN DYN_CI_SCHEMAS ss
         ON ss.schema_id = so.schema_id
       JOIN DYN_CI_PARTITIONS sp
         ON so.object_id = sp.object_id
            AND sp.index_id = ii.indid
       INNER JOIN (SELECT object_id,
                          index_id,
                          Sum(row_count)                      AS ROW_COUNT,
                          Sum(in_row_data_page_count
                              + lob_used_page_count
                              + row_overflow_used_page_count) AS DATA_SIZE
                   FROM   DYN_CI_PARTITION_STATS
                   GROUP  BY object_id,
                             index_id) AS PS
               ON PS.index_id = si.index_id
                  AND PS.object_id = si.object_id
WHERE  so.type = 'U'
       AND si.type > 0 --other than heap tables
       AND sp.partition_number = 1 -- fix issue with partiioned tables multiplying the number or records we return

	UNION ALL
    
    SELECT @SERVER_NAME,
           CONVERT(NVARCHAR(50), @STATS_DATE, 121),
           @DATABASE_NAME,
           si.object_id,
           si.index_id,
		   CASE
			 WHEN ss.NAME IN ( 'sys', 'dbo' ) THEN so.NAME
			 ELSE ss.NAME + '.' + so.NAME
		   END,
           so.NAME,
           'HEAP',
           'N/A',
           'N/A',
           PS.DATA_SIZE AS PAGE_COUNT,
           PS.ROW_COUNT AS ROW_COUNT,
           sp.data_compression
    FROM   DYN_CI_INDEXES si
           JOIN DYN_CI_SYS_INDEXES ii
             ON si.object_id = ii.id
                AND si.index_id = ii.indid
           JOIN DYN_CI_OBJECTS so
             ON so.object_id = si.object_id
           JOIN DYN_CI_SCHEMAS ss
             ON ss.schema_id = so.schema_id
           JOIN DYN_CI_PARTITIONS sp
             ON so.object_id = sp.object_id
                AND sp.index_id = ii.indid
           INNER JOIN (SELECT object_id,
                              index_id,
                              Sum(row_count)                      AS ROW_COUNT,
                              Sum(in_row_data_page_count
                                  + lob_used_page_count
                                  + row_overflow_used_page_count) AS DATA_SIZE
                       FROM   DYN_CI_PARTITION_STATS
                       GROUP  BY object_id,
                                 index_id) AS PS
                   ON PS.index_id = si.index_id
                      AND PS.object_id = si.object_id
    WHERE  so.type = 'U'
           AND si.type = 0 --only heap tables
           AND sp.partition_number = 1 -- fix issue with partiioned tables multiplying the number or records we return
    
    
 END
 
 IF @REMOTE_SERVER = 'Y'
 BEGIN
 
 
    		SET @SQL = '	
			
			
			SELECT	
 			si.object_id,
			si.index_id,
			CASE 
			WHEN ss.name in (''sys'', ''dbo'') THEN so.name
			ELSE 
				ss.name + ''.'' + so.name
			END, 
			si.name,  
			si.type_desc+
			CASE
				WHEN is_unique = 1 THEN '', UNIQUE''
				ELSE ''''
			END
			+	
			CASE
				WHEN is_primary_key = 1 THEN '', PRIMARY KEY''
				ELSE ''''
			END
			+
			CASE
				WHEN has_filter = 1 THEN '', FILTERED''
				ELSE ''''
			END,
			

    	stuff
    		(
    				
    			(
    			SELECT '', '' + sc.name FROM	['+ @DATABASE_NAME+ '].sys.index_columns sic
    			JOIN	['+ @DATABASE_NAME+ '].sys.columns sc ON sc.column_id = sic.column_id
    			WHERE	so.object_id = sic.object_id
    			AND		sic.index_id = si.index_id
    			AND		sc.object_id = so.object_id
    			AND		sic.is_included_column=0
    			ORDER	BY sic.key_ordinal
    			FOR		xml path('''')
    			)
    		,1,1,''''
    		)  AS key_columns,
    	stuff
    		(
    			(
    			SELECT	'', '' + sc.name FROM ['+ @DATABASE_NAME+ '].sys.index_columns sic
    			JOIN	['+ @DATABASE_NAME+ '].sys.columns sc ON sc.column_id = sic.column_id
    			WHERE	so.object_id = sic.object_id
    			AND		sic.index_id = si.index_id
    			AND		sc.object_id = so.object_id
    			AND		sic.is_included_column=1
    			ORDER BY sic.key_ordinal
    			FOR XML path('''')
    			)
    		,1,1,''''
    		)  AS included_columns,
    	PS.DATA_SIZE AS PAGE_COUNT,
    	PS.ROW_COUNT AS ROW_COUNT,
    	sp.data_compression
    	FROM	 ['+ @DATABASE_NAME+ '].sys.indexes si
    	JOIN 	['+ @DATABASE_NAME+ '].sys.sysindexes ii ON si.object_id = ii.id AND si.index_id = ii.indid
    	JOIN 	['+ @DATABASE_NAME+ '].sys.objects so ON so.object_id = si.object_id
    	JOIN	 ['+ @DATABASE_NAME+ '].sys.schemas ss ON ss.schema_id = so.schema_id
    	JOIN	 ['+ @DATABASE_NAME+ '].sys.partitions sp ON so.object_id = sp.object_id AND sp.index_id = ii.indid
    	INNER JOIN  (SELECT object_id, index_id,SUM(row_count) AS ROW_COUNT,SUM(in_row_data_page_count + lob_used_page_count + row_overflow_used_page_count) AS DATA_SIZE
    	FROM ['+ @DATABASE_NAME+ '].sys.dm_db_partition_stats GROUP BY  object_id, index_id) AS PS ON PS.index_id = si.index_id AND PS.object_id = si.object_id
    	
     WHERE	so.type = ''U''
    	AND		si.type > 0 
    	AND     sp.partition_number = 1 
    
	
	UNION ALL
    
    
SELECT	
    
			si.object_id,
			si.index_id,
			so.name, 
			CASE 
			WHEN ss.name in (''sys'', ''dbo'') THEN so.name
			ELSE 
				ss.name + ''.'' + so.name
			END, 
			''HEAP'',

			''N/A'', 
			''N/A'',
	PS.DATA_SIZE AS PAGE_COUNT,
	PS.ROW_COUNT AS ROW_COUNT,
	sp.data_compression 
    	FROM ['+ @DATABASE_NAME+ '].sys.indexes si
	JOIN ['+ @DATABASE_NAME+ '].sys.sysindexes ii ON si.object_id = ii.id AND si.index_id = ii.indid
	JOIN ['+ @DATABASE_NAME+ '].sys.objects so ON so.object_id = si.object_id
	JOIN	 ['+ @DATABASE_NAME+ '].sys.schemas ss ON ss.schema_id = so.schema_id
	JOIN ['+ @DATABASE_NAME+ '].sys.partitions sp ON so.object_id = sp.object_id AND sp.index_id = ii.indid
	
    INNER JOIN  (SELECT object_id, index_id,SUM(row_count) AS ROW_COUNT,SUM(in_row_data_page_count + lob_used_page_count + row_overflow_used_page_count) AS DATA_SIZE
	FROM ['+ @DATABASE_NAME+ '].sys.dm_db_partition_stats GROUP BY  object_id, index_id) AS PS ON PS.index_id = si.index_id AND PS.object_id = si.object_id
	
 WHERE	so.type = ''U''
	AND		si.type = 0  --only heap tables
	AND     sp.partition_number = 1 ' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  INSERT INTO DynamicsPerf.dbo.INDEX_DETAIL
						 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + ','
				  + '''' + @DATABASE_NAME + '''' + ',*
		                   FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ')'


		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)

 END
 
    
    
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO



GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SQL_TEXT]...';
GO


ALTER PROCEDURE DYNPERF_COLLECT_SQL_TEXT (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    
/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



IF @REMOTE_SERVER = 'N'
     BEGIN ;
         WITH Query_Stats_CTE ( QUERY_HASH, PLAN_HANDLE)
              AS (SELECT DISTINCT QUERY_HASH, PLAN_HANDLE
                  FROM   QUERY_STATS QS
                  WHERE  QS.STATS_TIME >= @LAST_RUN
                         AND DATABASE_NAME = @DATABASE_NAME
                         AND SERVER_NAME = @SERVER_NAME 
						-- AND DATEADD(MS,LAST_ELAPSED_TIME/1000,LAST_EXECUTION_TIME) >= @LAST_RUN
                         AND NOT EXISTS (SELECT 'X'
                                         FROM   QUERY_TEXT QT
                                         WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                                AND QS.SERVER_NAME = QT.SERVER_NAME ))
         INSERT QUERY_TEXT
         SELECT @SERVER_NAME,
                @DATABASE_NAME,
                QUERY_HASH,
                SQL_TEXT,
				@STATS_DATE
         FROM   (SELECT RN = ROW_NUMBER()
                               OVER (
                                 PARTITION BY CTE.QUERY_HASH
                                 ORDER BY CTE.QUERY_HASH DESC),
                        qs.query_hash                                                                                              AS QUERY_HASH,
                        SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                        WHEN -1 THEN DATALENGTH(st.text)
                                                                                        ELSE qs.statement_end_offset
                                                                                      END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
                 FROM   Query_Stats_CTE CTE
                        INNER JOIN sys.dm_exec_query_stats AS qs
                                ON CTE.QUERY_HASH = qs.query_hash and CTE.PLAN_HANDLE = qs.plan_handle
                        OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                        CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
                 WHERE  attribute = N'dbid'
                        AND DB_NAME(CONVERT(INT, value)) = @DATABASE_NAME
                        AND last_execution_time >= @LAST_RUN
						) AS RH
         WHERE  RN = 1
     END 


 IF @REMOTE_SERVER = 'Y'
 BEGIN
 


				 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)



 SET @SQL = '
CREATE TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH
(
QUERY_HASH VARBINARY(64),
PLAN_HANDLE VARBINARY(64)
)' 



 SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  EXEC ('+'"' + @SQL +'"' + ') AT [' + @SERVER_NAME + ']'
  
 IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END

EXEC (@SQL2)


SET @SQL = '

;WITH Query_Stats_CTE ( QUERY_HASH, PLAN_HANDLE)
     AS (SELECT DISTINCT QUERY_HASH,PLAN_HANDLE
         FROM   QUERY_STATS QS
         WHERE  QS.STATS_TIME >= '  +'''' + CONVERT(NVARCHAR(24), @LAST_RUN, 121) +'''' +  '
                AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + '
                AND SERVER_NAME = ' + '''' + +@SERVER_NAME + '''' 
				--+ ' AND DATEADD(MS,LAST_ELAPSED_TIME/1000,LAST_EXECUTION_TIME) >= ' + '''' +CONVERT(NVARCHAR(24), @LAST_RUN, 121) + '''' 
				+ ' AND NOT EXISTS (SELECT ''X''
                                FROM   QUERY_TEXT QT
                                WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                AND QS.SERVER_NAME = QT.SERVER_NAME 
                                ))
INSERT INTO OPENQUERY([' + @SERVER_NAME + '], ''SELECT QUERY_HASH, PLAN_HANDLE FROM  [tempdb].dbo.DYNPERF_QUERY_HASH'')

SELECT QUERY_HASH, PLAN_HANDLE
FROM   (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_HASH, CTE.PLAN_HANDLE
                        ORDER BY CTE.QUERY_HASH ,  CTE.PLAN_HANDLE DESC),
               QUERY_HASH,
			   PLAN_HANDLE
            
            FROM   Query_Stats_CTE CTE
           ) AS RH
WHERE  RN = 1 '

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


EXEC (@SQL)


        
 SET @SQL = '
         SELECT QUERY_HASH, SQL_TEXT
         FROM (
         SELECT RN = ROW_NUMBER() OVER (PARTITION BY CTE.QUERY_HASH ORDER BY CTE.QUERY_HASH DESC),
          qs.query_hash AS QUERY_HASH,
                         SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                         WHEN -1 THEN DATALENGTH(st.text)
                                                                                         ELSE qs.statement_end_offset
                                                                                       END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
         FROM    [tempdb].dbo.DYNPERF_QUERY_HASH CTE
                INNER JOIN sys.dm_exec_query_stats AS qs
                        ON CTE.QUERY_HASH = qs.query_hash AND CTE.PLAN_HANDLE = qs.plan_handle
                OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
         WHERE  attribute = N''dbid''
                AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
				AND last_execution_time >= ' +'''' + CONVERT(NVARCHAR(24), @LAST_RUN, 121) +'''' + '
                ) AS RH  
                WHERE RN = 1 '
PRINT ''
PRINT ''
                  
IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  INSERT INTO DynamicsPerf.dbo.QUERY_TEXT
				 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + '''' + @DATABASE_NAME + '''' + ',
                    
                    RH.*, ' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + ' FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END
				 
				 EXECUTE (@SQL2)
				 
 --REH  Delete the table back out
 
 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

 
 END
 
    

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH 




GO

PRINT N'Altering [dbo].[DYNPERF_COLLECT_QUERY_PLANS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_QUERY_PLANS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @TOPPLANPCT INT


		SELECT   @TOPPLANPCT = COLLECT_TOP_X_PLANS
	FROM   DATABASES_2_COLLECT
	WHERE  LINKED_SERVER = @SERVER_NAME
		   AND DATABASE_NAME = @DATABASE_NAME 


    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_QP_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_QP_STATS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_QP_STATS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.dm_exec_query_stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_QP_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_query_stats'

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @REMOTE_SERVER = 'N'
BEGIN
--;WITH Query_Stats_CTE ( QUERY_PLAN_HASH, PLAN_HANDLE )
--     AS
--     -- Define the CTE query.
--     (SELECT DISTINCT QUERY_PLAN_HASH,
--                      PLAN_HANDLE
--      FROM   QUERY_STATS AS QS
--      WHERE  STATS_TIME >= @LAST_RUN
--             AND DATABASE_NAME = @DATABASE_NAME
--             AND SERVER_NAME = @SERVER_NAME 
--             AND QUERY_PLAN_HASH > 0x00000000
--             AND NOT EXISTS (SELECT 'X'
--                             FROM   QUERY_PLANS QP
--                             WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
--                                    AND QS.DATABASE_NAME = QP.DATABASE_NAME
--                                    AND QS.SERVER_NAME = QP.SERVER_NAME ))
--INSERT INTO QUERY_PLANS
--SELECT @SERVER_NAME,
--       @DATABASE_NAME,
--       QUERY_PLAN_HASH,
--       QUERY_PLAN,
--       '',
--       0,
--       0,
--       GETDATE()
--FROM   (SELECT RN = ROW_NUMBER()
--                      OVER (
--                        PARTITION BY CTE.QUERY_PLAN_HASH
--                        ORDER BY CTE.QUERY_PLAN_HASH DESC),
--               CTE.QUERY_PLAN_HASH,
--               query_plan AS QUERY_PLAN
--        FROM   Query_Stats_CTE CTE
--               OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH
--WHERE  RN = 1 

SET @SQL = '

;WITH Query_Stats_CTE (  QUERY_PLAN_HASH, PLAN_HANDLE )
     AS
     (SELECT DISTINCT  QUERY_PLAN_HASH, PLAN_HANDLE FROM 
     (SELECT TOP ' + CAST(@TOPPLANPCT AS VARCHAR(4)) + ' PERCENT SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH,
                      PLAN_HANDLE
      FROM   QUERY_STATS AS QS
      WHERE  STATS_TIME >= ' + '''' + CONVERT(NVARCHAR(24), @LAST_RUN, 121) + '''' + '
             AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + ''''+ '
             AND SERVER_NAME = ' + '''' + @SERVER_NAME  + ''''
			 --+ ' AND DATEADD(MS,LAST_ELAPSED_TIME/1000,LAST_EXECUTION_TIME) >= ' + '''' +CONVERT(NVARCHAR(24), @LAST_RUN, 121) + '''' 
            + ' AND QUERY_PLAN_HASH > 0x00000000
             
         ORDER BY TOTAL_ELAPSED_TIME DESC 
                                   ) AS A
					WHERE  NOT EXISTS (SELECT ''X''
                             FROM   QUERY_PLANS QP
                             WHERE  QP.QUERY_PLAN_HASH = A.QUERY_PLAN_HASH
                                    AND QP.DATABASE_NAME = A.DATABASE_NAME
                                    AND QP.SERVER_NAME = A.SERVER_NAME )	   
								   
								   
								   )
INSERT INTO QUERY_PLANS
SELECT ' + '''' +@SERVER_NAME+ ''''+',
       '+ '''' +@DATABASE_NAME+ ''''+',
       QUERY_PLAN_HASH,
       QUERY_PLAN,
       '''',
       0,
       0,
       GETDATE()
FROM   (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_PLAN_HASH
                        ORDER BY CTE.QUERY_PLAN_HASH DESC),
               CTE.QUERY_PLAN_HASH,
               query_plan AS QUERY_PLAN
        FROM   Query_Stats_CTE CTE
               OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH
WHERE  RN = 1 AND query_plan IS NOT NULL'

IF @DEBUG = 'Y'
BEGIN
	PRINT @SQL
END


EXEC (@SQL)



END

IF @REMOTE_SERVER = 'Y'
     BEGIN
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)


         SET @SQL = '
				CREATE TABLE [tempdb].dbo.DYNPERF_QUERY_HASH
				(
				QUERY_PLAN_HASH VARBINARY(64), 
				PLAN_HANDLE VARBINARY(64)
				)'


         SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT [' + @SERVER_NAME
									 + ']'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

         SET @SQL = '

					;WITH Query_Stats_CTE ( QUERY_PLAN_HASH, PLAN_HANDLE)
						 AS (SELECT DISTINCT  QUERY_PLAN_HASH, PLAN_HANDLE FROM 
						(SELECT TOP ' + CAST(@TOPPLANPCT AS VARCHAR(4)) + ' PERCENT SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH,
							PLAN_HANDLE
							 FROM   QUERY_STATS QS
							 WHERE  QS.STATS_TIME >= ' + ''''
										+ CONVERT(NVARCHAR(24), @LAST_RUN, 121)
										+ ''''
										+ '
									AND DATABASE_NAME = '
										+ '''' + @DATABASE_NAME + ''''
										+ '
									AND SERVER_NAME = ' + '''' +
										+ @SERVER_NAME + ''''
										-- + ' AND DATEADD(MS,LAST_ELAPSED_TIME/1000,LAST_EXECUTION_TIME) >= ' + '''' +CONVERT(NVARCHAR(24), @LAST_RUN, 121) + '''' 
            + ' AND QUERY_PLAN_HASH > 0x00000000
					ORDER BY TOTAL_ELAPSED_TIME DESC 
                                   ) AS A
								   WHERE  NOT EXISTS (SELECT ''X''
													FROM   QUERY_PLANS QP
												 WHERE  QP.QUERY_PLAN_HASH = A.QUERY_PLAN_HASH
														AND QP.DATABASE_NAME = A.DATABASE_NAME
														AND QP.SERVER_NAME = A.SERVER_NAME)
								   
								   )

						INSERT INTO OPENQUERY([' + @SERVER_NAME
										+ '], ''SELECT QUERY_PLAN_HASH, PLAN_HANDLE FROM '
										+ '[tempdb].dbo.DYNPERF_QUERY_HASH'')
					                            
					  
					SELECT QUERY_PLAN_HASH, PLAN_HANDLE 
					FROM   (SELECT RN = ROW_NUMBER()
										  OVER (
											PARTITION BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE
											ORDER BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE DESC),
								   CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE 
					            
								FROM   Query_Stats_CTE CTE
							   ) AS RH
					WHERE  RN = 1  '

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END 


         EXEC(@SQL)

			SET @SQL = 'SELECT 
				   QUERY_PLAN_HASH,
				   cast(query_plan as nvarchar(max)) as QUERY_PLAN

			FROM   (SELECT RN = ROW_NUMBER()
								  OVER (
									PARTITION BY QUERY_PLAN_HASH
									ORDER BY QUERY_PLAN_HASH DESC),
						   QUERY_PLAN_HASH,
						   query_plan 
					FROM   [tempdb].dbo.DYNPERF_QUERY_HASH CTE
						   OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH
			WHERE  RN = 1 AND query_plan IS NOT NULL' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  INSERT INTO DynamicsPerf.dbo.QUERY_PLANS
						 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + ''''
					+ @DATABASE_NAME + ''''
					+ ',
		                    QUERY_PLAN_HASH, CAST(QUERY_PLAN AS XML), ' + QUOTENAME('','''') + ',0,0,GETDATE() FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ')' --RH '
					--		RH.QUERY_PLAN_HASH, RH.QUERY_PLAN, '''', 0, 0, GETDATE() FROM OPENQUERY(['
					--+ @SERVER_NAME + '], ' + ''' + @SQL + ''' + ') RH ' 

		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)
         

		 --REH Drop the table at the end of the process

         SET @SQL = '

				IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH'') 
				 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)
     
     END 





UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH 










GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_QUERY_STATS]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_QUERY_STATS (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQL_BUILD NVARCHAR(128), @MIN_TIME INT, @TOPQUERYPCT INT

	--REH Get the build so we can add the new columns to the query_stats table from SQL2016 and above
    SELECT @SQL_BUILD = SQL_VERSION  FROM STATS_COLLECTION_SUMMARY SCS WHERE SERVER_NAME = @SERVER_NAME AND DATABASE_NAME=@DATABASE_NAME AND STATS_TIME = @STATS_DATE
    

	--REH Get the Minimum time for queries to collect
	SELECT @MIN_TIME = [IGNORE_QUERIES_UNDER_MS],
		   @TOPQUERYPCT = COLLECT_TOP_X_QUERIES
	FROM   DATABASES_2_COLLECT
	WHERE  LINKED_SERVER = @SERVER_NAME
		   AND DATABASE_NAME = @DATABASE_NAME 



/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_QS_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_QS_STATS') 
  
IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_PLAN_ATTRIBUTES')
  EXEC ('DROP SYNONYM [dbo].DYN_PLAN_ATTRIBUTES')



         SET @SQL = '
				CREATE SYNONYM DYN_QS_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_query_stats'

EXEC (@SQL)


         SET @SQL = '
				CREATE SYNONYM DYN_PLAN_ATTRIBUTES
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_plan_attributes'

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 





PRINT 'TIME ZONE OFFSET AT TASK ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
PRINT 'LAST RUN AT TASK ' + CAST(@LAST_RUN AS VARCHAR(20))


PRINT 'LAST RUN WITH OFFSET ' + CAST(@LAST_RUN AS VARCHAR(20))
 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, ' TASK')
PRINT ''




IF @DEBUG = 'Y'
  BEGIN
      PRINT '@LAST_RUN = '

      PRINT @LAST_RUN
  END 
  
  
  IF @REMOTE_SERVER = 'N'
       BEGIN
			--IF @SQL_BUILD >= '13.' --REH  SQL2016 or above
		          
 SET @SQL =  ' INSERT INTO DynamicsPerf.dbo.QUERY_STATS

          SELECT TOP ' + CAST(@TOPQUERYPCT AS VARCHAR(4)) + ' PERCENT   MIN(' + '''' + @SERVER_NAME + '''' + '), MAX(' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + '),MIN('
				  + '''' + @DATABASE_NAME + '''' + '), 
                  MIN(plan_handle),
                  MAX(plan_generation_num),
                  creation_time,
                  MAX(last_execution_time),
                  SUM(execution_count),
                  SUM(total_worker_time),
                  AVG(last_worker_time),
                  MIN(min_worker_time),
                  MAX(max_worker_time),
                  SUM(total_physical_reads),
                  AVG(last_physical_reads),
                  MIN(min_physical_reads),
                  MAX(max_physical_reads),
                  SUM(total_logical_writes),
                  AVG(last_logical_writes),
                  MIN(min_logical_writes),
                  MAX(max_logical_writes),
                  SUM(total_logical_reads),
                  AVG(last_logical_reads),
                  MIN(min_logical_reads),
                  MAX(max_logical_reads),
                  SUM(total_clr_time),
                  AVG(last_clr_time),
                  MIN(min_clr_time),
                  MAX(max_clr_time),
                  SUM(total_elapsed_time),
                  AVG(last_elapsed_time),
                  MIN(min_elapsed_time),
                  MAX(max_elapsed_time),
                  query_hash,
                  query_plan_hash,
                  SUM ( total_rows),
                  SUM ( last_rows),
                  MAX ( max_rows),
                  MIN ( min_rows),'

				  IF @SQL_BUILD >= '13.' or (@SQL_BUILD >= '11.0.6020' and @SQL_BUILD < '12.') --REH correct build per version
				  BEGIN
					  SELECT @SQL = @SQL + 'SUM(total_dop), AVG(last_dop), MIN(min_dop), MAX(max_dop) '

				  END
				  ELSE
				  BEGIN
					SELECT @SQL = @SQL + 'SUM(-1), SUM(-1), SUM(-1), SUM(-1) '


				  END
SELECT @SQL = @SQL + '

           FROM   sys.dm_exec_query_stats
                  OUTER APPLY sys.dm_exec_plan_attributes (plan_handle)
           WHERE  attribute = N''dbid'' AND query_hash > 0x00000000000000000000000000000
                  AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
                  AND dateadd(ms,last_elapsed_time/1000,last_execution_time) >= ''' +CONVERT(NVARCHAR(24), @LAST_RUN, 121) + '''
           GROUP  BY query_hash,
                     query_plan_hash,
					 creation_time
			HAVING SUM(total_elapsed_time) / CASE SUM(execution_count) WHEN 0 THEN 1 ELSE SUM(execution_count) end / 1000.000 > ' + CAST(@MIN_TIME AS VARCHAR(4))
			+ ' ORDER BY SUM(total_elapsed_time)  DESC '
					 


					 
			IF @DEBUG = 'Y'
			  BEGIN
				  PRINT @SQL
			  END 
  
			  EXEC (@SQL)

		END

  IF @REMOTE_SERVER = 'Y'
       BEGIN
       
    

           --INSERT INTO QUERY_STATS
           
 SET @SQL = ' SET DATEFORMAT MDY 
           SELECT TOP ' + CAST(@TOPQUERYPCT AS VARCHAR(4)) + ' PERCENT 
                  MIN(plan_handle),
                  MAX(plan_generation_num),
                  creation_time,
                  MAX(last_execution_time),
                  SUM(execution_count),
                  SUM(total_worker_time),
                  AVG(last_worker_time),
                  MIN(min_worker_time),
                  MAX(max_worker_time),
                  SUM(total_physical_reads),
                  AVG(last_physical_reads),
                  MIN(min_physical_reads),
                  MAX(max_physical_reads),
                  SUM(total_logical_writes),
                  AVG(last_logical_writes),
                  MIN(min_logical_writes),
                  MAX(max_logical_writes),
                  SUM(total_logical_reads),
                  AVG(last_logical_reads),
                  MIN(min_logical_reads),
                  MAX(max_logical_reads),
                  SUM(total_clr_time),
                  AVG(last_clr_time),
                  MIN(min_clr_time),
                  MAX(max_clr_time),
                  SUM(total_elapsed_time),
                  AVG(last_elapsed_time),
                  MIN(min_elapsed_time),
                  MAX(max_elapsed_time),
                  query_hash,
                  query_plan_hash,
                  SUM ( total_rows),
                  SUM ( last_rows),
                  MAX ( max_rows),
                  MIN ( min_rows),'

				   IF @SQL_BUILD >= '13.' or (@SQL_BUILD >= '11.0.6020' and @SQL_BUILD < '12.') --REH correct build per version
				  BEGIN
					  SELECT @SQL = @SQL + 'SUM(total_dop), AVG(last_dop), MIN(min_dop), MAX(max_dop) '

				  END
				  ELSE
				  BEGIN
					SELECT @SQL = @SQL + 'SUM(-1), SUM(-1), SUM(-1), SUM(-1) '


				  END
SELECT @SQL = @SQL + '

           FROM   sys.dm_exec_query_stats
                  OUTER APPLY sys.dm_exec_plan_attributes (plan_handle)
           WHERE  attribute = N''dbid'' AND query_hash > 0x00000000000000000000000000000
                  AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
                  AND dateadd(ms,last_elapsed_time/1000,last_execution_time) >= ''' +CONVERT(NVARCHAR(24), @LAST_RUN, 121) + '''
           GROUP  BY query_hash,
                     query_plan_hash,
					 creation_time
					 HAVING SUM(total_elapsed_time) / CASE SUM(execution_count) WHEN 0 THEN 1 ELSE SUM(execution_count) end / 1000.000 > ' + CAST(@MIN_TIME AS VARCHAR(4))
                    + ' ORDER BY SUM(total_elapsed_time)  DESC '



                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  INSERT INTO DynamicsPerf.dbo.QUERY_STATS
				 SELECT ' + '''' + @SERVER_NAME + '''' + ',' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' + ','
				  + '''' + @DATABASE_NAME + '''' + ',
                    
                    RH.* FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '

				 
				 EXECUTE (@SQL2)
				 
       END 
  




UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH




GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SERVERINFO]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SERVERINFO (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @SQLVERSION NVARCHAR(30)
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF @AZURE_DB = 0
BEGIN

		IF EXISTS (SELECT *
				   FROM   sys.synonyms
				   WHERE  name = 'DYN_SI_SQLVERSION')
		 EXEC ('DROP SYNONYM [dbo].DYN_SI_SQLVERSION')


		IF @REMOTE_SERVER = 'Y'
			 BEGIN
				 SET @SQL = '
						CREATE SYNONYM DYN_SI_SQLVERSION
						FOR [' + @SERVER_NAME + '].master.sys.xp_msver'
			 END
		ELSE

				 SET @SQL = '
						CREATE SYNONYM DYN_SI_SQLVERSION
						FOR master.sys.xp_msver'

		IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL
		END

		EXEC (@SQL) 


		CREATE  table #SQLVERSION(
		[INDEX] INT,
		NAME NVARCHAR(128),
		INTERNAL_VALUE NVARCHAR(128),
		VALUE NVARCHAR(128)
		);

		INSERT #SQLVERSION
		exec DYN_SI_SQLVERSION  --[master].sys.[xp_msver]

		SELECT @SQLVERSION = VALUE FROM #SQLVERSION WHERE NAME = 'ProductVersion'

END
ELSE
BEGIN 
	SET @SQLVERSION = '12.0' 
END



SELECT @SQL = 'SELECT '+QUOTENAME(@SERVER_NAME,'''')+ ',
       '+ QUOTENAME(CONVERT(NVARCHAR(50), @STATS_DATE, 121),'''') +',sqlserver_start_time,
       Serverproperty(''ComputerNamePhysicalNetBIOS'') AS PhysicalComputerName,
       Serverproperty(''IsClustered'')                 AS IsClustered,
       Serverproperty(''MachineName'')                 AS MachineName,
       Serverproperty(''InstanceName'')                AS InstanceName,
       Serverproperty(''ProductVersion'')              AS ProductVersion,
       Serverproperty(''ProductLevel'')                AS ProductLevel,
       Serverproperty(''Edition'')                     AS Edition,
       Serverproperty(''EngineEdition'')               AS EngineEdition,
       Serverproperty(''SqlCharSet'')                  AS SqlCharSet,
       Serverproperty(''SqlCharSetName'')              AS SqlCharSetName,
       Serverproperty(''SqlSortOrder'')                AS SqlSortOrder,
       Serverproperty(''SqlSortOrderName'')            AS SqlSortOrderName,
       cpu_count,
       hyperthread_ratio,'

	   IF @SQLVERSION >= '11.0'
	   BEGIN
	   SELECT @SQL = @SQL +'
       committed_kb / 1024                     AS Bpool_Committed_MB,
       committed_target_kb / 1024                 AS Bpool_Commit_Target_MB,
       visible_target_kb / 1024                       AS Bpool_Visible_MB,
       (select count(*) from sys.dm_os_schedulers where status like ''VISIBLE ONLINE'' )  AS SQL_SCHEDULER_COUNT
	   '
		END
		ELSE
		BEGIN
		SELECT  @SQL = @SQL + 'bpool_committed / 1024 * 8                    AS Bpool_Committed_MB,
       bpool_commit_target / 1024 * 8                AS Bpool_Commit_Target_MB,
       bpool_visible / 1024 * 8                      AS Bpool_Visible_MB,
       (select count(*) from sys.dm_os_schedulers where status like ''VISIBLE ONLINE'' )  AS SQL_SCHEDULER_COUNT
	   '
		END

SELECT @SQL = @SQL + '
FROM   sys.dm_os_sys_info
       '



IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END




/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @REMOTE_SERVER = 'N'
BEGIN


INSERT INTO SERVERINFO 
EXEC( @SQL)

END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
 
		SET @SQL2 = ' 
						  SET QUOTED_IDENTIFIER OFF
						  	INSERT DynamicsPerf.dbo.SERVERINFO

								SELECT ' + '''' + @SERVER_NAME + '''' + ',' + ''''
					+ CONVERT(NVARCHAR(50), @STATS_DATE, 121) + ''''
					+ ', * FROM OPENQUERY(['+@SERVER_NAME+ '],"
	
	SELECT sqlserver_start_time ,
       Serverproperty(''ComputerNamePhysicalNetBIOS'') AS PhysicalComputerName,
       Serverproperty(''IsClustered'')                 AS IsClustered,
       Serverproperty(''MachineName'')                 AS MachineName,
       Serverproperty(''InstanceName'')                AS InstanceName,
       Serverproperty(''ProductVersion'')              AS ProductVersion,
       Serverproperty(''ProductLevel'')                AS ProductLevel,
       Serverproperty(''Edition'')                     AS Edition,
       Serverproperty(''EngineEdition'')               AS EngineEdition,
       Serverproperty(''SqlCharSet'')                  AS SqlCharSet,
       Serverproperty(''SqlCharSetName'')              AS SqlCharSetName,
       Serverproperty(''SqlSortOrder'')                AS SqlSortOrder,
       Serverproperty(''SqlSortOrderName'')            AS SqlSortOrderName,
       cpu_count,
       hyperthread_ratio,'

	   	   IF @SQLVERSION >= '11.0'
	   BEGIN
	   SELECT @SQL2 = @SQL2 +'
		   committed_kb / 1024                     AS Bpool_Committed_MB,
		   committed_target_kb / 1024                 AS Bpool_Commit_Target_MB,
		   visible_target_kb / 1024                       AS Bpool_Visible_MB,
		   (select count(*) from sys.dm_os_schedulers where status like ''VISIBLE ONLINE'' )  AS SQL_SCHEDULER_COUNT
		   '
		END
		ELSE
		BEGIN
			SELECT  @SQL2 = @SQL2 + 'bpool_committed / 1024 * 8                    AS Bpool_Committed_MB,
		   bpool_commit_target / 1024 * 8                AS Bpool_Commit_Target_MB,
		   bpool_visible / 1024 * 8                      AS Bpool_Visible_MB,
		   (select count(*) from sys.dm_os_schedulers where status like ''VISIBLE ONLINE'' )  AS SQL_SCHEDULER_COUNT
	   '
		END

SELECT @SQL2 = @SQL2 + '
FROM   sys.dm_os_sys_info
     
	"
	)'

	
		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL2
			 END

		EXEC (@SQL2) 

 
 
 END
 
    

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_PROCESS_QUERY_PLANS]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PROCESS_QUERY_PLANS]
       (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
                                                                             @AZURE_DB           BIT,
                                                                             @SQL_TZ_OFFSET INT,
                                                                             @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @CPU INT
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH Need to delete any old data in case QUERY_PLAN refresh updates the flag.  We need to delete old parsed plans

DELETE QPP
FROM   QUERY_PLANS_PARSED QPP
       INNER JOIN QUERY_PLANS QP WITH (NOLOCK)
               ON QPP.SERVER_NAME = QP.SERVER_NAME
                  AND QPP.DATABASE_NAME = QP.DATABASE_NAME
                  AND QPP.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
WHERE  QP.PARSED_FLAG = 0 and QP.SERVER_NAME = @SERVER_NAME and QP.DATABASE_NAME = @DATABASE_NAME

IF EXISTS (SELECT * FROM [tempdb].sys.objects WHERE name = '#PARSE_PLANS')
DROP TABLE #PARSE_PLANS

;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT	TOP 10000	QT.SERVER_NAME, QT.DATABASE_NAME, QT.[QUERY_PLAN_HASH],
 CONVERT (NVARCHAR(MAX), index_node.query('for $qplan in //sp:QueryPlan, $plist in $qplan/sp:ParameterList, $colref in $plist/sp:ColumnReference  return concat(string($colref/@Column),":",string($colref/@ParameterCompiledValue),",   "),"  "')) as SQL_PARAMS
  
INTO #PARSE_PLANS

  FROM [QUERY_PLANS] QT WITH (NOLOCK)
  	INNER LOOP JOIN QUERY_STATS QS ON QT.SERVER_NAME = QS.SERVER_NAME AND QT.DATABASE_NAME = QS.DATABASE_NAME
		AND QT.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
      OUTER APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node)
    
WHERE PARSED_FLAG = 0 AND QT.SERVER_NAME = @SERVER_NAME AND QT.DATABASE_NAME = @DATABASE_NAME
	AND QT.QUERY_PLAN_HASH > 0X000000000000000  --REH Don't process the 0 hash values
	ORDER BY QS.TOTAL_ELAPSED_TIME DESC  --REH do the top execution times first, most likely to show up in query views


--REH Parse out the QUERY_PLANS table into it's vital statistics

SET QUOTED_IDENTIFIER OFF
SELECT @CPU = cpu_count * .25 FROM sys.dm_os_sys_info

IF @CPU < 2 SET @CPU = 2

SET @SQL = '
 ;WITH XMLNAMESPACES (''http://schemas.microsoft.com/sqlserver/2004/07/showplan'' AS sp)

 INSERT QUERY_PLANS_PARSED
 SELECT DISTINCT *
FROM   (SELECT QUERY_PLANS.SERVER_NAME, QUERY_PLANS.DATABASE_NAME, QUERY_PLANS.QUERY_PLAN_HASH,
			   CAST(isnull(index_node.value(''(..//@NodeId)[1]'', ''nvarchar(128)''),''0'') AS INT) AS NodeID,
               CAST(Replace(Replace(index_node.value(''(.//@Table)[1]'', ''NVARCHAR(128)''), ''['', ''''), '']'', '''') AS NVARCHAR(128))  AS TABLE_NAME,
               CAST(Replace(Replace(index_node.value(''(.//@Index)[1]'', ''NVARCHAR(128)''), ''['', ''''), '']'', '''') AS NVARCHAR(128)) AS INDEX_NAME,
			   CAST(isnull(index_node.value(''(.//@Lookup)[1]'', ''nvarchar(128)''),''0'') AS INT) AS LOOKUP,
			   CAST(isnull(index_node.value(''(..//@Parallel)[1]'', ''nvarchar(128)''),''0'') AS INT) AS PARALLEL,
			   CAST(index_node.value(''(..//@PhysicalOp)[1]'', ''nvarchar(128)'') AS NVARCHAR(128)) AS PHYSICALOP,
			   CAST(index_node.value(''(..//@LogicalOp)[1]'', ''nvarchar(128)'') AS NVARCHAR(128)) AS LOGICALOP,
			   CAST(str(ISNULL(index_node.value(''(..//@EstimateRows)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(14,0)) AS ESTIMATEROWS,
			   CAST(str(ISNULL(index_node.value(''(..//@EstimateIO)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(20,7)) AS EstimateIO,
			   CAST(str(ISNULL(index_node.value(''(..//@EstimateCPU)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(20,7)) AS ESTIMATECPU,
			   CAST(str(ISNULL(index_node.value(''(..//@AvgRowSize)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(14,0)) AS AVGROWSIZE,
			   CAST(str(isnull(index_node.value(''(..//@EstimatedTotalSubtreeCost)[1]'', ''nvarchar(128)'') ,''0.0''),30,17) AS DECIMAL (20,7)) AS ESTIMATEDTOTALSUBTREECOST,
               CONVERT(NVARCHAR(MAX), index_node.query(''for $seekpredicate in ./sp:SeekPredicates,
                                                            $rangecolumns in $seekpredicate//sp:RangeColumns,
                                                            $columnreference in $rangecolumns/sp:ColumnReference
                                        return string($columnreference/@Column)''))        AS SEEK_COLUMNS,

              CONVERT(NVARCHAR(MAX), index_node.query(''for $predicate2 in ./sp:Predicate,
                                                           $Ident in  $predicate2//sp:Identifier,
														   $COLREF2 in  $Ident/sp:ColumnReference
                                                            
                                        return string($COLREF2/@Column)'')) AS PREDICATES,

		    REPLACE( REPLACE( CONVERT(NVARCHAR(MAX), index_node.query(''for $predicate in ./sp:Predicate,
                                                $rangecolumn in $predicate//sp:ScalarOperator
                                                            
                            return string($rangecolumn/@ScalarString)''))
							,''&lt;'', ''<'')   ,''&gt;'', ''>'')         AS PREDICATE_TEXT
        FROM   QUERY_PLANS WITH (NOLOCK)
			INNER JOIN #PARSE_PLANS ON QUERY_PLANS.SERVER_NAME = #PARSE_PLANS.SERVER_NAME
					AND QUERY_PLANS.DATABASE_NAME = #PARSE_PLANS.DATABASE_NAME
					AND QUERY_PLANS.QUERY_PLAN_HASH = #PARSE_PLANS.QUERY_PLAN_HASH
			OUTER APPLY QUERY_PLAN.nodes(''//sp:RelOp/sp:IndexScan'') AS SeekPredicates(index_node)
               --CROSS APPLY QUERY_PLAN.nodes(''//sp:Batch'') AS Batch(index_node2)
			WHERE QUERY_PLANS.SERVER_NAME = ' + '''' + @SERVER_NAME + '''' +'  AND QUERY_PLANS.DATABASE_NAME = '+ '''' +  @DATABASE_NAME +'''' + ' 
			   AND QUERY_PLANS.PARSED_FLAG = 0

			   ) A
			   OPTION(MAXDOP ' + CAST(@CPU AS VARCHAR(4)) + ')'

			   IF @DEBUG = 'Y'
			   BEGIN
				 PRINT @SQL
			   END


			   EXEC (@SQL)



UPDATE QP SET SQL_PARMS = PP.SQL_PARAMS
, PARSED_FLAG = 1

FROM QUERY_PLANS QP
INNER JOIN #PARSE_PLANS PP ON QP.SERVER_NAME = PP.SERVER_NAME
			AND QP.DATABASE_NAME = PP.DATABASE_NAME
			AND QP.QUERY_PLAN_HASH = PP.QUERY_PLAN_HASH

 WHERE QP.SERVER_NAME = @SERVER_NAME AND QP.DATABASE_NAME = @DATABASE_NAME AND QP.PARSED_FLAG = 0 
 OPTION(MAXDOP 1)
 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[SP_INDEX_CHANGES]...';


GO
ALTER PROCEDURE [dbo].[SP_INDEX_CHANGES] @START_DATE AS VARCHAR(128),
                                          @START_FLAG VARCHAR(1),
                                          @END_DATE   AS VARCHAR(128),
                                          @END_FLAG   VARCHAR(1)
AS
    SELECT *
    FROM   (SELECT LAST.DATABASE_NAME,
                   LAST.TABLE_NAME,
                   LAST.INDEX_NAME,
                   'INDEX CHANGED' AS DIFFERENCE
            FROM   INDEX_HISTORY LAST
                   INNER JOIN INDEX_HISTORY START
                           ON LAST.SERVER_NAME = START.SERVER_NAME
                              AND LAST.DATABASE_NAME = START.DATABASE_NAME
                              AND LAST.TABLE_NAME = START.TABLE_NAME
                              AND LAST.INDEX_NAME = START.INDEX_NAME
                              AND LAST.INDEX_KEYS <> START.INDEX_KEYS
            WHERE  LAST.DATE = @END_DATE
                   AND LAST.FLAG = @END_FLAG
                   AND START.DATE = @START_DATE
                   AND START.FLAG = @START_FLAG
            UNION
            SELECT START.DATABASE_NAME,
                   START.TABLE_NAME,
                   START.INDEX_NAME,
                   'INDEX DELETED' AS DIFFERENCE
            FROM   INDEX_HISTORY START
            WHERE  NOT EXISTS (SELECT INDEX_NAME
                               FROM   INDEX_HISTORY LAST
                               WHERE  LAST.SERVER_NAME = START.SERVER_NAME
                                      AND LAST.DATABASE_NAME = START.DATABASE_NAME
                                      AND LAST.TABLE_NAME = START.TABLE_NAME
                                      AND LAST.INDEX_NAME = START.INDEX_NAME
                                      AND LAST.DATE = @END_DATE
                                      AND LAST.FLAG = @END_FLAG)
                   AND START.DATE = @START_DATE
                   AND START.FLAG = @START_FLAG
            UNION
            SELECT LAST.DATABASE_NAME,
                   LAST.TABLE_NAME,
                   LAST.INDEX_NAME,
                   'INDEX ADDED' AS DIFFERENCE
            FROM   INDEX_HISTORY LAST
            WHERE  NOT EXISTS (SELECT INDEX_NAME
                               FROM   INDEX_HISTORY START
                               WHERE  LAST.SERVER_NAME = START.SERVER_NAME
                                      AND LAST.DATABASE_NAME = START.DATABASE_NAME
                                      AND LAST.TABLE_NAME = START.TABLE_NAME
                                      AND LAST.INDEX_NAME = START.INDEX_NAME
                                      AND START.DATE = @START_DATE
                                      AND START.FLAG = @START_FLAG)
                   AND LAST.DATE = @END_DATE
                   AND LAST.FLAG = @END_FLAG) AS A
    ORDER  BY A.DATABASE_NAME,
              A.TABLE_NAME
GO
PRINT N'Creating [dbo].[DYNPERF_PROCESS_MISSING_INDEXES]...';


GO

/****** Object:  StoredProcedure [dbo].[DYNPERF_PROCESS_MISSING_INDEXES]    Script Date: 06/23/2016 22:21:20 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[DYNPERF_PROCESS_MISSING_INDEXES]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[DYNPERF_PROCESS_MISSING_INDEXES]
GO


GO
CREATE PROCEDURE [dbo].[DYNPERF_PROCESS_MISSING_INDEXES]

       (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
                                                                             @AZURE_DB           BIT,
                                                                             @SQL_TZ_OFFSET INT,
                                                                             @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @CPU INT
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH Need to delete any old data in case QUERY_PLAN refresh updates the flag.  We need to delete old parsed plans


IF EXISTS (SELECT * FROM [tempdb].sys.objects WHERE name = '#PARSE_PLANS')
DROP TABLE #PARSE_PLANS

	
;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)


SELECT SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH,
ISNULL(STUFF((SELECT                                                                                                  
       --QUERY_PLAN,
       ' [IMPACT]= ' +cast(index_nodeS.value('(../@Impact)[1]', 'float')   as varchar(10))                                                            --  AS INDEX_IMPACT,
       + CHAR(9) + '[TABLE]= ' +replace(replace(index_nodeS.value('(./@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                      --  AS TABLE_NAME,
       + CHAR(10) + CHAR(9) + '[EQUALITY_COLUMNS]= ' +replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in ./sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "EQUALITY"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') 
       + CHAR(10) + CHAR(9) + '[INEQUALITY_COLUMNS]= ' +replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in ./sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "INEQUALITY"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') 
       + CHAR(10) + CHAR(9) + '[INCLUDED_COLUMNS]= ' +replace(replace(replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in .//sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "INCLUDE"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '') 
		+CHAR(10) + CHAR(10)


FROM   QUERY_PLANS QP 
       CROSS APPLY QP.QUERY_PLAN.nodes('//sp:MissingIndexes/sp:MissingIndexGroup/sp:MissingIndex') AS missing_indexes(index_nodeS)
   WHERE 
   cast(index_nodeS.value('(../@Impact)[1]', 'float')   as varchar(10)) IS NOT NULL AND
   QP.SERVER_NAME = QP2.SERVER_NAME AND QP.DATABASE_NAME = QP2.DATABASE_NAME AND QP.QUERY_PLAN_HASH = QP2.QUERY_PLAN_HASH
   
   FOR xml path('')),1,1, ''),'') AS MISSING_INDEX_INFO

   INTO #PARSE_PLANS
   FROM QUERY_PLANS QP2
   WHERE MI_FLAG = 0 AND QP2.SERVER_NAME = @SERVER_NAME AND QP2.DATABASE_NAME = @DATABASE_NAME
	AND QP2.QUERY_PLAN_HASH > 0X000000000000000 
	AND QP2.DATE_UPDATED >= @LAST_RUN --REH This keeps us from continually trying to process plans that don't have missing indexes
	 OPTION(MAXDOP 1)

	 --REH Remove the xml tags out of the data
	 	 UPDATE #PARSE_PLANS SET MISSING_INDEX_INFO = REPLACE(REPLACE( MISSING_INDEX_INFO,'MISSING_INDEX_INFO>', ''), '</MISSING_INDEX_INFO>', '')


MERGE MISSING_INDEXES AS target
USING (SELECT SERVER_NAME,
              DATABASE_NAME,
              QUERY_PLAN_HASH,
              Getdate() AS DATE_UPDATED,
              MISSING_INDEX_INFO
       FROM   #PARSE_PLANS WHERE MISSING_INDEX_INFO > '') AS source
ON ( source.SERVER_NAME = target.SERVER_NAME
     AND source.DATABASE_NAME = target.DATABASE_NAME
     AND source.QUERY_PLAN_HASH = target.QUERY_PLAN_HASH )
WHEN MATCHED THEN
  UPDATE SET MISSING_INDEX_INFO = source.MISSING_INDEX_INFO,
             DATE_UPDATED = source.DATE_UPDATED
WHEN NOT MATCHED THEN
  INSERT (SERVER_NAME,
          DATABASE_NAME,
          QUERY_PLAN_HASH,
          DATE_UPDATED,
          MISSING_INDEX_INFO)
  VALUES (source.SERVER_NAME,
          source.DATABASE_NAME,
          source.QUERY_PLAN_HASH,
          source.DATE_UPDATED,
          source.MISSING_INDEX_INFO); 



UPDATE QP
SET    MI_FLAG = 1
FROM   QUERY_PLANS QP
       INNER JOIN #PARSE_PLANS PP
               ON QP.SERVER_NAME = PP.SERVER_NAME
                  AND QP.DATABASE_NAME = PP.DATABASE_NAME
                  AND QP.QUERY_PLAN_HASH = PP.QUERY_PLAN_HASH
WHERE  QP.SERVER_NAME = @SERVER_NAME
       AND QP.DATABASE_NAME = @DATABASE_NAME
       AND QP.MI_FLAG = 0
OPTION(MAXDOP 1) 

 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Creating [dbo].[SP_PROCESS_STATS_LOW_PRIORITY]...';

GO

/****** Object:  StoredProcedure [dbo].[SP_PROCESS_STATS_LOW_PRIORITY]    Script Date: 06/23/2016 22:21:46 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SP_PROCESS_STATS_LOW_PRIORITY]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SP_PROCESS_STATS_LOW_PRIORITY]
GO



GO
CREATE PROCEDURE [dbo].[SP_PROCESS_STATS_LOW_PRIORITY]
	@SERVER_NAME	NVARCHAR(128) = NULL,
		@DATABASE_NAME	NVARCHAR(128) = NULL ,
		@DYNAMICS_PRODUCT NVARCHAR(3)  = NULL,
		@TASK_TYPE		VARCHAR(50) = 'PROCESS_LP',
		@AZURE_DB		BIT = 0,
		@TOP_ROWS		INT = 0,
		@TOP_COLUMN		NVARCHAR(128) = 'total_elapsed_time',
		@RUN_NAME		NVARCHAR(128) = NULL,
		@INDEX_PHYSICAL_STATS 	NCHAR(1)= 'N',
		@DEBUG			NVARCHAR(1)= 'N'

AS


SET NOCOUNT ON
SET DATEFORMAT MDY

DECLARE @STATS_DATE		DATETIME, 
		@SQL_VERSION	NVARCHAR(1000), 
		@DYNAMICS_VERSION NVARCHAR(MAX),
		@DATABASE_ID	INT,
		@RETURN_CODE	INT,
		@SQL			NVARCHAR(MAX),
		@RUN_DESCRIPTION NVARCHAR(1000),
		@SQL_TOP_CLAUSE	NVARCHAR(128),
		@SQL_ORDERBY_CLAUSE	NVARCHAR(128),
		@PARM			NVARCHAR(500),
		@SQL_SERVER_STARTTIME DATETIME,
		@RC INT,
		@TASK_PROCEDURE NVARCHAR(128),
		@TASK_PARAMETERS NVARCHAR(1024),
		@TASK_DESCRIPTION NVARCHAR(256),
		@LAST_SERVER_NAME NVARCHAR(128) = 'ZZZ',  --REH This is used to trigger inserting a new STATS_COLLECTION_SUMMARY record
		@LAST_DATABASE_NAME NVARCHAR(128) = 'ZZZ',
		@LAST_STATS_DATE DATETIME,
		@REMOTE_SERVER NVARCHAR(1) = 'N',
		@TASK_STARTTIME DATETIME,
		@TASK_ENDTIME DATETIME,
		@TASK_TIME BIGINT,
		@SQL_STARTTIME DATETIME,
		@SQL_BUILD NVARCHAR(20),
		@SQL2 NVARCHAR(MAX),
		@MANUAL_CAPTURE NVARCHAR(1) = 'N',
		@SQL_TZ_OFFSET INT,
		@DPA_TZ_OFFSET INT 

		
		
DECLARE
	@C_SERVER_NAME NVARCHAR(128),
	@C_DATABASE_NAME NVARCHAR(128),
	@C_TASK_ID INT,
	@C_TASK_PROCEDURE NVARCHAR(128),
	@C_TASK_PARAMS NVARCHAR(1024),
	@C_TASK_DESC NVARCHAR(256),
	@C_SERVER_LEVEL_TASK BIT,
	@C_AZURE_DB  BIT,
	@C_LAST_RUN DATETIME
	
		
--REH Time zone off set for the DynamicsPerf database at time of collection
		SET @DPA_TZ_OFFSET = DATEDIFF(MI,GETUTCDATE(),GETDATE())

	IF @DATABASE_NAME IS NOT NULL SET @MANUAL_CAPTURE = 'Y'

	SET @STATS_DATE = GETDATE()
--REH  Verify database exists if being manually passed, skip check if Azure DB, no access to sys.databases catalogue

IF ( @AZURE_DB = 0 and ( @SERVER_NAME IS NOT NULL
      OR @DATABASE_NAME IS NOT NULL ))
     BEGIN

	 
	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_LP_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_LP_QUERY_SYSDATABASES')

         IF @REMOTE_SERVER = 'Y'
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_PS_LP_QUERY_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_PS_LP_QUERY_SYSDATABASES
				FOR master.sys.databases'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END

         EXEC (@SQL) -- SELECT * FROM DYN_PS_LP_QUERY_SYSDATABASES

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_PS_LP_QUERY_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

         --REH Make sure there is a record in DATABASES_2_COLLECT or insert if new combination
         IF (SELECT COUNT(*)
             FROM   DATABASES_2_COLLECT
             WHERE  LINKED_SERVER = ISNULL(@SERVER_NAME, @@SERVERNAME)
                    AND DATABASE_NAME = @DATABASE_NAME) < 1
              BEGIN
                  INSERT DATABASES_2_COLLECT
                  VALUES(ISNULL(@SERVER_NAME,@@SERVERNAME),
                         @DATABASE_NAME,
                         ISNULL(@DYNAMICS_PRODUCT, 'ALL'),
                         0,
                         2,
                         24,
						 60,
						 2,
						 90,
						 7,
						 -1,
						 0,
						 100,
						 100)
              END
     END 


	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END



---------------------------------------------------------------------------------------------
--
--  Insert Capture_log entry with paramater values used for the run
--
----------------------------------------------------------------------------------------------

INSERT CAPTURE_LOG  SELECT @TASK_TYPE, @STATS_DATE, 'SP_PROCESS_STATS PARMS PASSED @SERVER_NAME = ' + ISNULL(@SERVER_NAME,'NOT PASSED') + ' @DATABASE_NAME = ' + ISNULL(@DATABASE_NAME,'NOT PASSED') +  ' @DEBUG = ' + @DEBUG + '  ' + CHAR(10) + CHAR(13)



SET @RETURN_CODE = 0

DELETE FROM  COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH Default is 'COLLECT' for this sproc.  CAN'T TRUNCATE MULTIPLE SPROCS USING THIS TABLE




IF @DATABASE_NAME IS NULL  --REH AKA, not a manual capture
  BEGIN
      INSERT COLLECTIONDATABASES
      SELECT ISNULL(LINKED_SERVER, @@SERVERNAME),
             [DATABASE_NAME],
             [DYNAMICS_PRODUCT],
             [AZURE_DB],
             [ENABLED],
			 @TASK_TYPE
      FROM   DATABASES_2_COLLECT
      WHERE  ENABLED = 1 -- db must be enabled for autostats collection to work with it
  END
ELSE
  BEGIN   --REH  Insert DBname of the manual capture
      INSERT COLLECTIONDATABASES
      VALUES(ISNULL(@SERVER_NAME, @@SERVERNAME),
             @DATABASE_NAME,
             @DYNAMICS_PRODUCT,
             @AZURE_DB,
             1,
			 @TASK_TYPE)
  END 


--REH Insert any missing task history records in case it's a new database being collected, so we don't fail to capture against the db because of no records
-- yes, this is a cartesian join between these 2 tables

INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE	--REH default is 'PROCESS' in parm definition of this sproc
       AND NOT EXISTS (SELECT 'X'
                       FROM   DYNPERF_TASK_HISTORY DTH
                       WHERE  DTS.TASK_ID = DTH.TASK_ID
                              AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                              AND CD.DATABASE_NAME = DTH.DATABASE_NAME)
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 0 --REH Ok, to put 1 record per database in for DB type tasks


	   
--REH Need to insert 1 bogus record for each server level task, or the join on the cursor will fail

INSERT COLLECTIONDATABASES 
 SELECT	DISTINCT [LINKED_SERVER],
             'N/A',
            'ALL',
             [AZURE_DB],
             [ENABLED],
			 [TASK_TYPE]
FROM COLLECTIONDATABASES CD
WHERE DATABASE_NAME <> 'N/A'
AND TASK_TYPE = @TASK_TYPE
AND NOT EXISTS (SELECT 'X' FROM COLLECTIONDATABASES CD2 WHERE CD2.LINKED_SERVER = CD.LINKED_SERVER AND CD2.DATABASE_NAME = 'N/A')



--REH now lets insert server level tasks with a blank DB name so we only do them once per server
INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       'N/A',
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE  --REH default is 'COLLECT' in parm definition of this sproc
		AND CD.DATABASE_NAME <> 'N/A'
       AND NOT EXISTS (SELECT 'X'
                   FROM   DYNPERF_TASK_HISTORY DTH
                   WHERE  DTS.TASK_ID = DTH.TASK_ID
                          AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                          AND DTH.DATABASE_NAME = 'N/A') --REH making the db name = 'N/A' for server level tasks
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 1 





	IF @DEBUG = 'Y'
	BEGIN
		PRINT 'MANUAL_CAPTURE = ' + @MANUAL_CAPTURE
	END

	--REH Create here and truncate table in each loop
	 --  CREATE TABLE #SQL_INFO
  --   (
  --      SQL_STARTTIME DATETIME,
  --      SQL_BUILD NVARCHAR(20),
		--TZ_OFFSET INT
  --   )
   

/********************************************************************************
Rod Hansen

Added a trigger to DATABASES_2_COLLECT so that we always have a 
DYNPERF_TASK_HISTORY record for this code 

********************************************************************************/

DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT DISTINCT DTS.TASK_ID,
       CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_PROCEDURE,
       DTS.TASK_PARAMETERS,
       DTS.TASK_DESCRIPTION,
       DTS.SERVER_LEVEL_TASK,
       CD.AZURE_DB,
       ISNULL(DTH.LAST_RUN, '1/1/1900')
FROM   DynamicsPerf..[DYNPERF_TASK_SCHEDULER] DTS
       LEFT OUTER JOIN DynamicsPerf..[DYNPERF_TASK_HISTORY] DTH
                    ON DTH.TASK_ID = DTS.TASK_ID
       INNER JOIN DynamicsPerf..COLLECTIONDATABASES CD
               ON CD.DATABASE_NAME = DTH.DATABASE_NAME
                  AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
WHERE
  --REH Task is enabled
  DTS.ENABLED = 1
  AND
  --REH It's the correct task type C = COLLECTOR, P = PROCESS, M = MONITOR, ETC
  DTS.TASK_TYPE = @TASK_TYPE
  AND
  --REH database is enabled
  CD.ENABLED = 1
  AND
  --REH Azure_db, if Azure db, then task must support it
  ( CD.AZURE_DB = DTS.AZURE_DB_SUPPORTED
     OR CD.AZURE_DB = 0 )
  --REH Either its an Azure Task, all Azure tasks will run locally, so if task supports AZ and we pass 0, run it anyways
  AND ( DTS.AZURE_DB_SUPPORTED = @AZURE_DB
         OR ( DTS.AZURE_DB_SUPPORTED = 1
              AND @AZURE_DB = 0 ) )
  AND
  --REH it's either All products or matches the Dynamics Product
  ( DTS.DYNAMICS_PRODUCT = 'ALL'
     OR DTS.DYNAMICS_PRODUCT = CD.DYNAMICS_PRODUCT )
  AND
  --REH Scheduling options now
(
  --REH In the case of minutes or hous, we ignore schedule time and just figure out if it's time to run again
  ( @MANUAL_CAPTURE = 'Y'
     OR ( @MANUAL_CAPTURE = 'N'
          AND ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                  WHEN 'MI' THEN DATEADD(MINUTE, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                END ) <= GETDATE()
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'HH' THEN DATEADD(HOUR, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                --REH and it is on the hour
                AND ( ABS(DATEDIFF(MI, DATEADD(Hour, DATEDIFF(Hour, 0, GETDATE()), 0), GETDATE())) <= 1 ) )
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'DD' THEN DATEADD(DAY, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'WK' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'MM' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'QQ' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'YY' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                AND ( --REH TIME IS NULL SO IGNORE IT
                    COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) IS NULL
                     OR --REH Current time = Scheduled time 
                    ( SUBSTRING((SELECT REPLACE(CONVERT(VARCHAR(10), GETDATE(), 108), ':', '')), 1, 4) = (SELECT REPLICATE('0', 4 - LEN( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME)))
                                                                                                                 + CAST( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) AS VARCHAR(4))) ) ) )
         --REH and last_run < current time
         )--AND CONVERT(VARCHAR(10), LAST_RUN, 108) <= CONVERT(VARCHAR(10), Getdate(), 108) ) 
   )
)
ORDER  BY CD.LINKED_SERVER,
          CD.DATABASE_NAME,
          DTS.TASK_ID 



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

	SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                    WHEN @@SERVERNAME THEN 'N'
                    ELSE 'Y'
                    END

--Insert new STATS_COLLECTION_SUMMARY RECORD, we want 1 RUN_NAME per server not per database
IF @C_SERVER_NAME <> @LAST_SERVER_NAME OR @C_DATABASE_NAME <> @LAST_DATABASE_NAME
BEGIN
    SET @RUN_NAME = ISNULL(@C_SERVER_NAME, @@SERVERNAME)+ ' '
                    + CAST(@STATS_DATE AS VARCHAR(30))


TRUNCATE TABLE WRK_LP_SQL_INFO   

 DELETE FROM COLLECTIONDATABASES WHERE LINKED_SERVER = @LAST_SERVER_NAME AND DATABASE_NAME = @LAST_DATABASE_NAME AND TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
 
SELECT @SQL = 'SELECT create_date AS SQL_STARTTIME,
       CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))    AS SQL_BUILD,
	   DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
		FROM sys.databases WHERE name = ''TempDB'''

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


   SET NOCOUNT ON
 
IF @REMOTE_SERVER = 'N'
BEGIN
		   INSERT WRK_LP_SQL_INFO
		EXEC( @SQL)
END


 IF @REMOTE_SERVER = 'Y'
 BEGIN
			IF @C_AZURE_DB = 0
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT create_date AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROM sys.databases WHERE name = ''TempDB''"	)'
			END
			IF @C_AZURE_DB = 1
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT DATEADD(ms,AVG(-wait_time_ms), GETDATE()) AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROMsys.dm_os_wait_stats w WHEREwait_type
IN(''DIRTY_PAGE_POLL'',''HADR_FILESTREAM_IOMGR_IOCOMPLETION'',''LAZYWRITER_SLEEP'',''LOGMGR_QUEUE'',''REQUEST_FOR_DEADLOCK_SEARCH'',''XE_DISPATCHER_WAIT'',''XE_TIMER_EVENT'') "	)'
			END


				IF @DEBUG = 'Y'
                  BEGIN
                      PRINT '@SQL= ' + @SQL2
                  END 
                
			INSERT WRK_LP_SQL_INFO
				EXEC (@SQL2) 
 
 END
 
 SELECT @SQL_STARTTIME = SQL_STARTTIME, @SQL_BUILD = SQL_BUILD, @SQL_TZ_OFFSET = TZ_OFFSET FROM WRK_LP_SQL_INFO
 TRUNCATE TABLE WRK_LP_SQL_INFO  -- REH cleanout for next pass


  --REH NOT Collecting so don't need this code in this sproc


		--INSERT INTO [DynamicsPerf].[dbo].[STATS_COLLECTION_SUMMARY]
		--			([SERVER_NAME],
		--			 [STATS_TIME],
		--			 [RUN_NAME],
		--			 [DATABASE_NAME],
		--			 [SQL_VERSION],
		--			 [DYNAMICS_VERSION],
		--			 [RUN_DESCRIPTION],
		--			 [SQL_SERVER_STARTTIME],
		--			 [SQL_SERVER_TZ_OFFSET] ,
		--			 [DPA_TZ_OFFSET])
		--VALUES      (@C_SERVER_NAME,
		--			 @STATS_DATE,
		--			 @RUN_NAME,
		--			 @C_DATABASE_NAME,
		--			 @SQL_BUILD,--<SQL_VERSION>
		--			 '',--<DYNAMICS_VERSION>
		--			 '',--<RUN_DESCRIPTION>
		--			 @SQL_STARTTIME, -- <SQL_SERVER_STARTTIME>
		--			 @SQL_TZ_OFFSET,  -- Time Zone offset in minutes of database collected
		--			 @DPA_TZ_OFFSET  -- Time Zone of the DynamicsPerf database
		--			) 
				
END 

SET @LAST_SERVER_NAME = @C_SERVER_NAME
SET @LAST_DATABASE_NAME = @C_DATABASE_NAME


SET @REMOTE_SERVER = CASE @C_SERVER_NAME
                       WHEN @@SERVERNAME THEN 'N'
                       ELSE 'Y'
                     END 



--Create synonyms for the sproc

--IF  EXISTS (SELECT * FROM sys.synonyms WHERE name = 'DYN_PS_LP_CAPTURE_SPROC')
--DROP SYNONYM [dbo].[DYN_PS_LP_CAPTURE_SPROC]
--SET @SQL = '
--CREATE SYNONYM DYN_PS_LP_CAPTURE_SPROC
--FOR [DynamicsPerf].dbo.[' + @C_TASK_PROCEDURE + ']'

--IF @DEBUG = 'Y' 
--BEGIN
--PRINT '@SQL= ' + @SQL
--END

--EXEC(@SQL) 

IF @DEBUG = 'Y' 
BEGIN
PRINT 'TASK ID = ' + CAST(@C_TASK_ID AS VARCHAR(10))
PRINT 'SERVER NAME = ' + @C_SERVER_NAME 
PRINT 'DATABASE NAME = ' + @C_DATABASE_NAME
PRINT 'TASK PARMS = ' + ISNULL(@C_TASK_PARAMS, '')
PRINT 'TASK DESC = ' + ISNULL(@C_TASK_DESC,'')
PRINT 'LAST RUN = ' + ISNULL(CAST(@C_LAST_RUN AS VARCHAR(30)),'')
PRINT 'RUN NAME = ' + ISNULL(@RUN_NAME,'')
PRINT 'STATS DATE = ' + CAST(@STATS_DATE AS VARCHAR(30))
PRINT 'REMNOTE SERVER FLAG = ' + ISNULL(@REMOTE_SERVER,'')
PRINT 'AZURE DB = ' + CAST(@C_AZURE_DB AS CHAR(1))


END
			
	

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@C_TASK_DESC, '') + CONVERT(VARCHAR, GETDATE(), 109)
PRINT ''


SET @TASK_STARTTIME = GETDATE()
SET @C_TASK_PARAMS = ISNULL(@C_TASK_PARAMS,'')


IF @DEBUG = 'Y'
BEGIN

	PRINT 'SERVER TIME ZONE OFFSET = ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
	PRINT 'AT LAST RUN  = ' + CAST(@C_LAST_RUN AS VARCHAR(30))

END

--REH Adjust the last_run time to UTC Time, the called sproc's will adjust it to local time unless we've never collected
IF @C_LAST_RUN > '1/1/1901'
BEGIN
SET @C_LAST_RUN = DATEADD(MI,@DPA_TZ_OFFSET *-1 ,@C_LAST_RUN)
END



IF @DEBUG = 'Y'
BEGIN
	PRINT 'AT LAST RUN TIME BEING PASSED TO SPROC ' + CAST(@C_LAST_RUN AS VARCHAR(30))
END

SELECT @SQL = 'EXEC ' + @C_TASK_PROCEDURE + '  @TASK_ID=' + CAST(@C_TASK_ID AS NVARCHAR(10)) + 
' ,@SERVER_NAME = ' + '''' +  @C_SERVER_NAME + '''' +
' ,@DATABASE_NAME = ' + '''' +  @C_DATABASE_NAME + '''' +
' ,@TASK_PARAMS = ' +  '''' +  @C_TASK_PARAMS + '''' +
' ,@TASK_DESC = ' + '''' +  @C_TASK_DESC + '''' +
' ,@LAST_RUN = ' + '''' + CONVERT(VARCHAR, @C_LAST_RUN, 109) + '''' +
' ,@RUN_NAME = ' + '''' +  @RUN_NAME + '''' +
' ,@STATS_DATE = ' + '''' + CONVERT(VARCHAR, @STATS_DATE, 109) + '''' +
' ,@REMOTE_SERVER = ' + '''' +  @REMOTE_SERVER + '''' +
' ,@AZURE_DB = ' + CAST(@C_AZURE_DB AS NVARCHAR(10)) + 
' ,@SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET AS NVARCHAR(10)) + 
' ,@DPA_TZ_OFFSET = ' + CAST(@DPA_TZ_OFFSET AS NVARCHAR(10)) + 


' ,@DEBUG = '  + '''' +  @DEBUG + ''''


UPDATE CAPTURE_LOG
SET    TEXT = TEXT  + CHAR(13) + CHAR(10) + '***** ' + @C_TASK_PROCEDURE
			+ CHAR(13) + CHAR(10)
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE



EXECUTE @RC = sp_executesql @SQL

   					  
SET @TASK_ENDTIME = GETDATE()

SET @TASK_TIME = DATEDIFF(ss,@TASK_STARTTIME, @TASK_ENDTIME)



 /*************** RETRY LOGIC ************************/ 
 IF @RC = 1
   AND @TASK_TIME < 10 -- IT FAILED AND WAS LESS THEN 10 SECONDS
  BEGIN
      WAITFOR DELAY '00:00:02' -- REH Wait 2 seconds and try again if sproc trapped the error
      EXECUTE @RC = Sp_executesql
        @SQL

      SET @TASK_ENDTIME = Getdate()
      SET @TASK_TIME = Datediff(ss, @TASK_STARTTIME, @TASK_ENDTIME)
  END 


--REH update last  [DYNPERF_TASK_HISTORY] IF THE TASK WAS SUCCESSFUL


  
 IF @RC = 0
      BEGIN
          PRINT ''
 
          PRINT 'SUCCESSFULLY CAPTURED '
                + ISNULL(@C_TASK_DESC, '') +  ' for SERVER
	'
              + ISNULL(@C_SERVER_NAME, '') + ' on database '
              + ISNULL(@C_DATABASE_NAME, '') + ' in ' + cast(@TASK_TIME AS VARCHAR(20)) + ' SECONDS '
 
       --REH if a manual capture don't update last run so we don't mess up the scheduling engine
				 IF @MANUAL_CAPTURE = 'N'
				 BEGIN
						  MERGE DynamicsPerf..[DYNPERF_TASK_HISTORY] AS target
						  USING (SELECT @C_SERVER_NAME   AS SERVER_NAME,
										@C_DATABASE_NAME AS DATABASE_NAME,
										@C_TASK_ID       AS TASK_ID,
										@STATS_DATE      AS LAST_RUN,
										@TASK_TIME	AS LAST_EXECUTION_TIME_SECS 
												) AS source
						  ON ( source.SERVER_NAME = target.LINKEDSERVER_NAME
							   AND source.DATABASE_NAME = target.DATABASE_NAME
							   AND source.TASK_ID = target.TASK_ID )
						  WHEN MATCHED THEN
							UPDATE SET LAST_RUN = source.LAST_RUN, [LAST_EXECUTION_TIME_SECS] = source.[LAST_EXECUTION_TIME_SECS]
						  WHEN NOT MATCHED THEN
							INSERT ( [LINKEDSERVER_NAME],
									 [DATABASE_NAME],
									 [TASK_ID],
									 [LAST_RUN],
									 [LAST_EXECUTION_TIME_SECS])
							VALUES (source.SERVER_NAME,
									source.DATABASE_NAME,
									source.TASK_ID,
									source.LAST_RUN,
									source.LAST_EXECUTION_TIME_SECS );
				END
      END
 ELSE
	IF @RC = 1  --REH SPROC HANDLED THE ERROR
      BEGIN
          PRINT ''
 
          PRINT 'FAILED !!!!!! ' + ISNULL(@C_TASK_DESC, '')
 
          PRINT ''
      END 
 

 
 

           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_LP_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_LP_QUERY_SYSDATABASES')

  
END TRY 

BEGIN CATCH


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PROCEDURE FAILED !!! '
              + ISNULL(@C_TASK_DESC, 'TASK') + ' for SERVER
	'
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) + ', '
WHERE  STATS_TIME = @STATS_DATE  AND TASK_TYPE = @TASK_TYPE

PRINT 'ERROR WHILE COLLECTING ' + ISNULL(@C_TASK_DESC, '') +' !!!!!!!!!!!!!!'


           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_LP_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_LP_QUERY_SYSDATABASES')


END CATCH



FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
 DELETE FROM COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
 
			

ENDPROC:
PRINT 'RUN NAME = '+ @RUN_NAME
GO
PRINT N'Creating [dbo].[SP_TZOFFSET]...';

GO

/****** Object:  StoredProcedure [dbo].[SP_TZOFFSET]    Script Date: 06/23/2016 22:22:19 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SP_TZOFFSET]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SP_TZOFFSET]
GO



GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE PROCEDURE [dbo].[SP_TZOFFSET]

                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
											  @DEBUG NVARCHAR(1) = 'N'
AS


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @C_SERVER_NAME NVARCHAR(128), @C_LAST_COLLECTED DATETIME, @UTC_TIME DATETIME, @ROW_COUNT BIGINT = 0
	DECLARE @C_DATABASE_NAME NVARCHAR(128),@REMOTE_SERVER NVARCHAR(1) ,@SQL_STARTTIME DATETIME,
		@SQL_BUILD NVARCHAR(20),		@SQL_TZ_OFFSET INT


TRUNCATE TABLE WRK_TZ_SQL_INFO   --REH clear out table to repopulate

 
SELECT @SQL = 'SELECT create_date AS SQL_STARTTIME,
       CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))    AS SQL_BUILD,
	   DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
		FROM sys.databases WHERE name = ''TempDB'''

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

SET @REMOTE_SERVER = 'N'
IF @SERVER_NAME <> @@SERVERNAME  SET @REMOTE_SERVER = 'Y'
   
   SET NOCOUNT ON
 
IF @REMOTE_SERVER = 'N'
BEGIN
		   INSERT WRK_TZ_SQL_INFO
		EXEC( @SQL)
END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT DATEADD(ms,AVG(-wait_time_ms), GETDATE()) AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROMsys.dm_os_wait_stats w WHEREwait_type
IN(''DIRTY_PAGE_POLL'',''HADR_FILESTREAM_IOMGR_IOCOMPLETION'',''LAZYWRITER_SLEEP'',''LOGMGR_QUEUE'',''REQUEST_FOR_DEADLOCK_SEARCH'',''XE_DISPATCHER_WAIT'',''XE_TIMER_EVENT'') "	)'
		


				IF @DEBUG = 'Y'
                  BEGIN
                      PRINT '@SQL= ' + @SQL2
                  END 
                
			INSERT WRK_TZ_SQL_INFO
				EXEC (@SQL2) 
 
 END
 
 SELECT @SQL_STARTTIME = SQL_STARTTIME, @SQL_BUILD = SQL_BUILD, @SQL_TZ_OFFSET = TZ_OFFSET FROM WRK_TZ_SQL_INFO
 TRUNCATE TABLE WRK_TZ_SQL_INFO --REH Cleanout the table for next loop
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Refreshing [dbo].[DYNPERF_COLLECT_AX_SQLTRACE]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[DYNPERF_COLLECT_AX_SQLTRACE]';


GO
PRINT N'Refreshing [dbo].[DYNPERF_REFRESH_QUERY_TEXT]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[DYNPERF_REFRESH_QUERY_TEXT]';

go



TRUNCATE TABLE DYNPERF_TASK_SCHEDULER
TRUNCATE TABLE DYNPERF_TASK_HISTORY

GO



TRUNCATE TABLE DYNPERF_TASK_SCHEDULER

-- Enabled, Dynamics Product, Sproc Name, Sproc Parms, Task Desc, Sched Units, Sched qty, Sched time, Azure, Linked Server , Server level task, Task group


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_QUERY_STATS', NULL, 'Collect QUERY_STATS for database','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_INDEXSTATS', NULL, 'Collect INDEX STATS for database','HH',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_TEXT', NULL, 'Collect SQL TEXT for database','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_QUERY_PLANS', NULL, 'Collect QUERY PLANS for database','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SYSOBJECTS', NULL, 'Collect SYSTEM OBJECT DEFINITIONS for database','DD',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_WAITSTATS', NULL, 'Collect SERVER WAIT STATS for server','HH',1,NULL,1,1,1,'COLLECT');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_VIRTIALIO_DISKSTATS', NULL, 'Collect VIRTUAL I/O DISK STATS for database','HH',1,NULL,1,1,0,'COLLECT');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_CHANGE_DATA_CONTROL', NULL, 'Collect CHANGE DATA CONTROL for database','DD',1,NULL,0,1,0,'COLLECT');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_CHANGE_TRACKING', NULL, 'Collect CHANGE TRACKING for database','DD',1,NULL,1,1,0,'COLLECT')


--INSERT DYNPERF_TASK_SCHEDULER
--VALUES (1,'ALL', 'DYNPERF_COLLECT_SSRS_EXECUTIONLOG', NULL, 'Collect SSRS for database','MI',5,NULL,1,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_DATA_BUFFER_CACHE', NULL, 'Collect SQL DATA BUFFER CACHE for server','DD',1,NULL,1,1,1,'COLLECT')


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_DATABASES', NULL, 'Collect SQL DATABASES INFORMATION for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_DATABASE_REPLICATION_INFO', NULL, 'Collect REPLICATION CONFIGURATION for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_CONFIGURATION', NULL, 'Collect SQL CONFIGURATION INFORMATION for server','DD',1,NULL,0,1,1,'COLLECT')


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_DATABASE_FILES', NULL, 'Collect SQL DATABASE FILE INFORMATION for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_DATABASE_VLFS', NULL, 'Collect SQL TLOG VLFS for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_INDEX_USAGE_STATS', NULL, 'Collect INDEX USAGE STATS for database','HH',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_INDEX_OPERATIONAL_STATS', NULL, 'Collect INDEX OPERATIONAL STATS for database','HH',1,NULL,1,1,0,'COLLECT');
	

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_JOBS', NULL, 'Collect SQL JOBS for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVERINFO', NULL, 'Collect SQL INSTANCE CONFIGURATION for server','DD',1,NULL,1,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVER_REGISTRY', NULL, 'Collect SQL STARTUP PARMS IN THE REGISTRY for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVER_DISKVOLUMES', NULL, 'Collect DISKVOLUMES USED BY SQL for server','WK',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SERVER_OS_INFO', NULL, 'Collect WINDOW OS VERSION INFO for server','WK',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_TRIGGER_INFO', NULL, 'Collect DATABASE TRIGGER INFO for database','DD',1,NULL,1,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_TRACEFLAGS_RUNNING', NULL, 'Collect RUNNING TRACE FLAGS for server','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_ERRORLOG', NULL, 'Collect SQL SERVER ERROR LOG for server','MI',5,NULL,1,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_DATABASE_STATISTICS', NULL, 'Collect DATABASE STATISTICS for database','WK',1,NULL,0,1,0,'PROCESS_LP')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_SQL_PLAN_GUIDES', NULL, 'Collect PLAN GUIDES for database','DD',1,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_PERF_COUNTERS', NULL, 'Collect SQL Performance Counters ','MI',5,NULL,0,1,1,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_PERF_COUNTERS_AZURE', NULL, 'Collect SQL Performance Counters for AZURE db ','MI',5,NULL,1,1,0,'COLLECT');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_COLLECT_AZURE_EVENTLOG', NULL, 'Collect sys.event_log  for AZURE db ','MI',5,NULL,1,1,0,'COLLECT');






-----------------------------------------Process Tasks -----------------------------------------------------------------------------






INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_UPDATE_QUERY_HISTORY', NULL, 'Rollup QUERY data into history tables','MI',5,NULL,1,1,1,'PROCESS');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_UPDATE_INDEX_HISTORY', NULL, 'Rollup INDEX data into history tables','HH',1,NULL,1,1,1,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PROCESS_QUERY_ALERTS', NULL, 'Query Alerts Processing','MI',5,NULL,1,1,0,'PROCESS');

--INSERT DYNPERF_TASK_SCHEDULER
--VALUES (1,'ALL', 'DYNPERF_UPDATE_SSRS_HISTORY', NULL, 'Rollup SSRS EXECUTIONLOG into History table','MI',5,NULL,1,1,1,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PROCESS_MISSING_INDEXES', NULL, 'Parse MISSING INDEXES from Query Plans','MI',5,NULL,1,1,0,'PROCESS');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PROCESS_AXSQLTRACE', '7' , 'Update QUERY_HASH in AX_SQLTRACE table','MI',5,NULL,1,1,0,'PROCESS_LP');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_REFRESH_QUERY_PLANS', NULL, 'Refresh old QUERY PLANS','DD',1,NULL,1,1,0,'PROCESS_LP');

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_REFRESH_QUERY_TEXT', NULL, 'Refresh old QUERY TEXT','DD',1,NULL,1,1,0,'PROCESS_LP');

--reh do this task last so everything else happens in case this task takes a long time
INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PROCESS_QUERY_PLANS', NULL, 'Parse all XML Query Plans','MI',5,NULL,1,1,0,'PROCESS_LP');


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'ALL', 'DYNPERF_PURGE_DATA', NULL, 'Purge data from DynamicsPerf','DD',1,NULL,1,1,1,'PROCESS_LP');


/****************************************

AX_SCHEDULE

These are the  tasks for Dynamics AX
*****************************************/

----------------------------------------------AX ---------------------------------------

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_SQLTRACE', NULL, 'Collect SYSTRACETABLESQL for database','MI',5,NULL,0,1,0,'COLLECT')

--REH replaced by AOTEXPORT, better data
--INSERT DYNPERF_TASK_SCHEDULER
--VALUES (1,'AX', 'DYNPERF_COLLECT_AX_BATCHSERVER', NULL, 'Collect AX BATCH TABLES for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_SQLSTORAGE', NULL, 'Collect AX SQLSTORAGE TABLE for database','WK',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_USERINFO', NULL, 'Collect AX USERINFO TABLE for database','DD',1,NULL,0,1,0,'COLLECT')


INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_NUMBERSEQUENCE', NULL, 'Collect AX NUMBER SEQUENCES for database','HH',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_SYSGLOBALCONFIG', NULL, 'Collect AX SYSGLOBALCONFIG for database','DD',1,NULL,0,1,0,'COLLECT')

--REH AOTEXPORT class goes direct to DynamicsPerf now
--INSERT DYNPERF_TASK_SCHEDULER
--VALUES (1,'AX', 'DYNPERF_COLLECT_AX_AOTEXPORT_DATA', NULL, 'Collect AX AOTEXPORT DATA for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_SET_AX_SQLTRACE', NULL, 'Set AX_SQLTRACE for database','DD',1,NULL,0,1,1,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'AX', 'DYNPERF_COLLECT_AX_USERINFO', NULL, 'Collect USERINFO for database','DD',1,NULL,0,1,0,'COLLECT')





/****************************************

CRM_SCHEDULE

These are the  tasks for Dynamics CRM
*****************************************/

----------------------------------------------CRM ---------------------------------------

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'CRM', 'DYNPERF_COLLECT_CRM_ORGANIZATION', NULL, 'Collect CRM ORGANIZATION INFO for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'CRM', 'DYNPERF_COLLECT_CRM_PLUGINS', NULL, 'Collect CRM PLUGINS INFO for database','DD',1,NULL,0,1,0,'COLLECT')

INSERT DYNPERF_TASK_SCHEDULER
VALUES (1,'CRM', 'DYNPERF_COLLECT_CRM_POA_TOTALS', NULL, 'Collect CRM Primary Object Access INFO for database','HH',1,NULL,0,1,0,'COLLECT')


GO


/****************************************************************************************************************************
INSERT PUGETABLE STUFF
*****************************************************************************************************************************/

TRUNCATE TABLE [DYNPERF_PURGETABLES]


INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_BATCHJOB_DETAIL' ,'STATS_TIME', 1, 1,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_BATCHSERVERGROUP_CONFIG' ,'STATS_TIME', 1, 1,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_INDEX_DETAIL' ,'STATS_TIME', 1, 1,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_LICENSEKEY_DETAIL' ,'STATS_TIME', 1, 1,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_NUM_SEQUENCES' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_SERVER_CONFIG' ,'STATS_TIME', 1, 1,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_SQLTRACE' ,'STATS_TIME', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_TABLE_DETAIL' ,'STATS_TIME', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AZURE_EVENTS' ,'STATS_TIME', 1, 1,90) 


-- HANDLED BY SPROC  INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('AX_SYSGLOBALCONFIGURATION' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('BLOCKS' ,'BLOCKED_DTTM', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('BUFFER_DETAIL' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('CAPTURE_LOG' ,'STATS_TIME', 0, 0,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('CDC' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('CRM_ORGANIZATION' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('CRM_PLUGINS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('CRM_POA_TOTALS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('DISKSTATS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_DENSITY_VECTOR' ,'', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_DETAIL' ,'STATS_TIME', 1, 1,2) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_HISTOGRAM' ,'', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_HISTORY' ,'DATE', 1, 1,999) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_OPERATIONAL_STATS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_PHYSICAL_STATS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_STAT_HEADER' ,'', 1, 1,14)
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('INDEX_USAGE_STATS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('LOGINFO' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('PERF_COUNTER_DATA' ,'STATS_TIME', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_ALERTS' ,'STATS_TIME', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_ALERTS_CONFIG' ,'', 1, 1,7) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_HISTORY' ,'DATE', 1, 1,999) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_PLANS' ,'DATE_UPDATED', 1, 1,999) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_PLANS_PARSED' ,'', 1, 1,999) 

INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_STATS' ,'STATS_TIME', 1, 1,2) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('QUERY_TEXT' ,' ', 1, 1,999) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SERVERINFO' ,'STATS_TIME', 1, 0,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_AZURE_EVENTS' ,'END_TIME', 1, 1,14) 

INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_CONFIGURATION' ,'STATS_TIME', 1, 0,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_DATABASEFILES' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_DATABASES' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_JOBS' ,'STATS_TIME', 1, 0,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_PLAN_GUIDES' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQL_REPLICATION' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SQLERRORLOG' ,'LOGDATE', 1, 0,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SSRS_EXECUTIONLOG' ,'TIMEEND', 1, 0,30) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('STATS_COLLECTION_SUMMARY' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('TRACEFLAGS' ,'STATS_TIME', 1, 1,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('TRIGGER_TABLE' ,'', 1, 1,14) 

INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('WAIT_STATS' ,'STATS_TIME', 1, 0,14) 
INSERT INTO [dbo].[DYNPERF_PURGETABLES]([TABLE_NAME],[TIME_COLUMN],[SERVER_NAME_FLAG],[DATABASE_NAME_FLAG],[RETENTION_DAYS])  VALUES ('SSRS_HISTORY' ,'REPORT_DATE', 1, 0,730) 





GO


/****************************************************************************************************************************
INSERT sys.dm_os_performance_counters STUFF
*****************************************************************************************************************************/
TRUNCATE TABLE PERF_COUNTER_2_COLLECT
									--OBJECT NAME        COUNTER_NAME         INSTANCE
INSERT PERF_COUNTER_2_COLLECT VALUES('Buffer Manager', 'Page life expectancy', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Access Methods', 'Page Splits/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Access Methods', 'Table Lock Escalations/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Availability Replica', 'Bytes Sent to Replica/sec', '_Total')
INSERT PERF_COUNTER_2_COLLECT VALUES('Buffer Manager', 'Page reads/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Buffer Manager', 'Page writes/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Cursor Manager by Type', 'Active cursors', '_Total')
INSERT PERF_COUNTER_2_COLLECT VALUES('Cursor Manager by Type', 'Cursor memory usage', '_Total')
INSERT PERF_COUNTER_2_COLLECT VALUES('Databases', 'Transactions/sec', '_Total')
INSERT PERF_COUNTER_2_COLLECT VALUES('General Statistics', 'Processes blocked', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('General Statistics', 'User Connections', '')


INSERT PERF_COUNTER_2_COLLECT VALUES('Locks', 'Average Wait Time (ms)', '_Total')
INSERT PERF_COUNTER_2_COLLECT VALUES('Locks', 'Average Wait Time Base', '_Total')

INSERT PERF_COUNTER_2_COLLECT VALUES('Locks', 'Number of Deadlocks/sec', '_Total')
INSERT PERF_COUNTER_2_COLLECT VALUES('Memory Manager', 'Free Memory (KB)', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Memory Manager', 'Lock Memory (KB)', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Memory Manager', 'Target Server Memory (KB)', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Memory Manager', 'Total Server Memory (KB)', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Plan Cache', 'Cache Pages', '_Total')
INSERT PERF_COUNTER_2_COLLECT VALUES('SQL Statistics', 'Batch Requests/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('SQL Statistics', 'Guided plan executions/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('SQL Statistics', 'SQL Compilations/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('SQL Statistics', 'SQL Re-Compilations/sec', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Transactions', 'Free Space in tempdb (KB)', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Transactions', 'Version Store Size (KB)', '')

                                                                                                         



INSERT PERF_COUNTER_2_COLLECT VALUES('Wait Statistics', 'Network IO waits', 'Average wait time (ms)')
INSERT PERF_COUNTER_2_COLLECT VALUES('Wait Statistics', 'Page IO latch waits', 'Average wait time (ms)')
INSERT PERF_COUNTER_2_COLLECT VALUES('Wait Statistics', 'Page latch waits', 'Average wait time (ms)')
INSERT PERF_COUNTER_2_COLLECT VALUES('Wait Statistics', 'Network IO waits', 'Cumulative wait time (ms) per second')
INSERT PERF_COUNTER_2_COLLECT VALUES('Wait Statistics', 'Page IO latch waits', '')
INSERT PERF_COUNTER_2_COLLECT VALUES('Wait Statistics', 'Page latch waits', 'Cumulative wait time (ms) per second')



GO

UPDATE DYNAMICSPERF_SETUP
SET VERSION = '2.00 RC0'


--INSERT PERF_COUNTER_2_COLLECT VALUES('', '', '')



/*************************** START OF SQL JOBS ******************************************/

USE [msdb]
GO
--REH  Delete old jobs that we renamed

/****** Object:  Job [DYNPERF_Log_Blocks_Option1_Tracing]    Script Date: 10/10/2010 14:34:59 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Log_Blocks_Option1_Tracing_Start')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Log_Blocks_Option1_Tracing_Start', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option1_Tracing_Stop]    Script Date: 10/10/2010 15:24:21 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Log_Blocks_Option1_Tracing_Stop')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Log_Blocks_Option1_Tracing_Stop', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option1_Load_Blocked_Data]    Script Date: 12/16/2010 11:22:48 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Log_Blocks_Option1_Load_Blocked_Data')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Log_Blocks_Option1_Load_Blocked_Data', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option2_Polling]    Script Date: 10/10/2010 14:36:42 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Log_Blocks_Option2_Polling')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Log_Blocks_Option2_Polling', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Option1_Tracing_Start]    Script Date: 10/19/2011 15:23:06 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Option1_Tracing_Start')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Option1_Tracing_Start', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option1_Tracing_Stop]    Script Date: 10/10/2010 15:24:21 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Option1_Tracing_Stop')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Option1_Tracing_Stop', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option1_Load_Blocked_Data]    Script Date: 12/16/2010 11:22:48 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Option1_Load_Blocked_Data')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Option1_Load_Blocked_Data', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option2_Polling]    Script Date: 10/10/2010 14:36:42 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Option2_Polling_for_Blocking')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Option2_Polling_for_Blocking', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option2_Polling]    Script Date: 10/10/2010 14:36:42 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Option2_Polling_for_Blocking')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Option2_Polling_for_Blocking', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_PerfStats_Hourly]    Script Date: 03/13/2011 13:38:20 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_PerfStats_Hourly')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_PerfStats_Hourly', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Capture_Stats_Purge]    Script Date: 02/18/2010 11:38:53 ******/
IF EXISTS (SELECT job_id FROM   msdb.dbo.sysjobs_view WHERE  name = N'DYNPERF_Capture_Stats_Purge')
EXEC msdb.dbo.sp_delete_job  @job_name=N'DYNPERF_Capture_Stats_Purge',  @delete_unused_schedule=1 
GO
IF EXISTS (SELECT job_id FROM   msdb.dbo.sysjobs_view WHERE  name = N'DYNPERF_Compression_Analyzer')
  EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Compression_Analyzer', @delete_unused_schedule=1
GO

/****** Object:  Job [DYNPERF_Purge_Stats]    Script Date: 10/10/2010 14:36:42 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Purge_Stats')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Purge_Stats', @delete_unused_schedule=1
GO

/****** Object:  Job [DYNPERF_Default_Trace_Start]    Script Date: 04/26/2012 19:26:53 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Detailed_Trace')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Detailed_Trace', @delete_unused_schedule=1
GO

IF EXISTS (SELECT job_id FROM   msdb.dbo.sysjobs_view  WHERE  name = N'DYNPERF_Purge_Blocks')
  EXEC msdb.dbo.sp_delete_job @job_name = N'DYNPERF_Purge_Blocks', @delete_unused_schedule=1
GO
IF EXISTS (SELECT job_id FROM   msdb.dbo.sysjobs_view WHERE  name = N'DYNPERF_Capture_Stats_Purge')
  EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Capture_Stats_Purge', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Capture_Stats_Baseline]    Script Date: 03/18/2014 21:27:20 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Capture_Stats_Baseline')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Capture_Stats_Baseline', @delete_unused_schedule=1
GO


--REH deleting lowercased named ones on Case Sensitive systems
/****** Object:  Job [DYNPERF_Capture_Stats]    Script Date: 02/18/2010 11:38:20 ******/ --REH converted to UPPERCASE
IF EXISTS (SELECT job_id FROM   msdb.dbo.sysjobs_view   WHERE  name = N'DYNPERF_Capture_Stats')
EXEC msdb.dbo.sp_delete_job  @job_name=N'DYNPERF_Capture_Stats',  @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Default_Trace_Start]    Script Date: 10/19/2011 15:23:06 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Default_Trace_Start')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Default_Trace_Start', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Default_Trace_Stop]    Script Date: 10/10/2010 15:24:21 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Default_Trace_Stop')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Default_Trace_Stop', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_LONG_DURATION_TRACE]    Script Date: 04/26/2012 19:26:53 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Long_Duration_Trace')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Long_Duration_Trace', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option2_Polling]    Script Date: 10/10/2010 14:36:42 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Optional_Polling_for_Blocking')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Optional_Polling_for_Blocking', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Purge_SYSTRACETABLESQL_AX]    Script Date: 10/19/2011 16:21:00 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Purge_SYSTRACETABLESQL_AX')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Purge_SYSTRACETABLESQL_AX', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Set_AX_User_Trace_on]    Script Date: 04/01/2014 08:20:00 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Set_AX_User_Trace_on')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Set_AX_User_Trace_on', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Set_AX_User_Trace_off]    Script Date: 04/01/2014 08:21:23 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_Set_AX_User_Trace_off')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_Set_AX_User_Trace_off', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_SET_AX_USER_TRACE_ON]    Script Date: 04/01/2014 08:20:00 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_SET_AX_USER_TRACE_ON')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_SET_AX_USER_TRACE_ON', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_SET_AX_USER_TRACE_OFF]    Script Date: 04/01/2014 08:21:23 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_SET_AX_USER_TRACE_OFF')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_SET_AX_USER_TRACE_OFF', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_PURGE_SYSTRACETABLESQL_AX]    Script Date: 10/19/2011 16:21:00 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_PURGE_SYSTRACETABLESQL_AX')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_PURGE_SYSTRACETABLESQL_AX', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_DEFAULT_TRACE_START]    Script Date: 10/19/2011 15:23:06 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_DEFAULT_TRACE_START')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_DEFAULT_TRACE_START', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_DEFAULT_TRACE_STOP]    Script Date: 10/10/2010 15:24:21 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_DEFAULT_TRACE_STOP')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_DEFAULT_TRACE_STOP', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_LONG_DURATION_TRACE]    Script Date: 04/26/2012 19:26:53 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_LONG_DURATION_TRACE')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_LONG_DURATION_TRACE', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_Log_Blocks_Option2_Polling]    Script Date: 10/10/2010 14:36:42 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_OPTIONAL_POLLING_FOR_BLOCKING')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_OPTIONAL_POLLING_FOR_BLOCKING', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_COLLECT_AOS_CONFIG]    Script Date: 09/19/2015 07:23:26 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_CAPTURE_SRS')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_CAPTURE_SRS', @delete_unused_schedule=1
GO
/****** Object:  Job [DYNPERF_COLLECT_AOS_CONFIG]    Script Date: 09/19/2015 07:23:26 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_CAPTURE_SSRS')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_CAPTURE_SSRS', @delete_unused_schedule=1
GO



USE [msdb]
GO
/****** Object:  Job [DYNPERF_CAPTURE_STATS]    Script Date: 02/18/2010 11:38:20 ******/
IF EXISTS (SELECT job_id FROM   msdb.dbo.sysjobs_view  WHERE  name = N'DYNPERF_CAPTURE_STATS')
  EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_CAPTURE_STATS',  @delete_unused_schedule=1
GO

USE [msdb]
GO

/****** Object:  Job [DYNPERF_CAPTURE_STATS]    Script Date: 09/20/2015 19:31:09 ******/
BEGIN TRANSACTION
DECLARE @ReturnCode INT
SELECT @ReturnCode = 0
/****** Object:  JobCategory [[Uncategorized (Local)]]]    Script Date: 09/20/2015 19:31:09 ******/
IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
BEGIN
EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'[Uncategorized (Local)]'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

END

DECLARE @jobId BINARY(16)
EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'DYNPERF_CAPTURE_STATS', 
		@enabled=1, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'Capture DMV Data for performance analysis, daily', 
		@category_name=N'[Uncategorized (Local)]', 
		@owner_login_name=N'sa', @job_id = @jobId OUTPUT
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
/****** Object:  Step [sp_capturestats]    Script Date: 09/20/2015 19:31:10 ******/
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'sp_capturestats', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'EXEC  SP_CAPTURESTATS', 
		@database_name=N'DynamicsPerf', 
		@flags=0
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'5 MINUTES', 
		@enabled=1, 
		@freq_type=4, 
		@freq_interval=1, 
		@freq_subday_type=4, 
		@freq_subday_interval=5, 
		@freq_relative_interval=0, 
		@freq_recurrence_factor=0, 
		@active_start_date=20101008, 
		@active_end_date=99991231, 
		@active_start_time=0, 
		@active_end_time=235959
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
COMMIT TRANSACTION
GOTO EndSave
QuitWithRollback:
    IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
EndSave:
GO






USE [msdb]
GO
/****** Object:  Job [DYNPERF_PROCESS_TASKS]    Script Date: 02/18/2010 11:38:20 ******/
IF EXISTS (SELECT job_id
           FROM   msdb.dbo.sysjobs_view
           WHERE  name = N'DYNPERF_PROCESS_TASKS')
  EXEC msdb.dbo.sp_delete_job
    @job_name=N'DYNPERF_PROCESS_TASKS',
    @delete_unused_schedule=1

GO

USE [msdb]
GO

/****** Object:  Job [DYNPERF_PROCESS_TASKS]    Script Date: 10/10/2010 14:25:48 ******/
BEGIN TRANSACTION
DECLARE @ReturnCode INT
SELECT @ReturnCode = 0
/****** Object:  JobCategory [[Uncategorized (Local)]]]    Script Date: 10/10/2010 14:25:48 ******/
IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
BEGIN
EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'[Uncategorized (Local)]'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

END

DECLARE @jobId BINARY(16)
EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'DYNPERF_PROCESS_TASKS', 
		@enabled=1, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'Run Processing tasks in DynamicsPerf Database', 
		@category_name=N'[Uncategorized (Local)]', 
		@owner_login_name=N'sa', @job_id = @jobId OUTPUT
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
/****** Object:  Step [sp_capturestats]    Script Date: 10/10/2010 14:25:48 ******/
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'SP_PROCESS_STATS', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'EXEC SP_PROCESS_STATS	 ', 
		@database_name=N'DynamicsPerf', 
		@flags=0
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'EVERY 5 MINUTES', 
		@enabled=1, 
		@freq_type=4, 
		@freq_interval=1, 
		@freq_subday_type=4, 
		@freq_subday_interval=5, 
		@freq_relative_interval=0, 
		@freq_recurrence_factor=0, 
		@active_start_date=20101008, 
		@active_end_date=99991231, 
		@active_start_time=100, 
		@active_end_time=235959

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
COMMIT TRANSACTION
GOTO EndSave
QuitWithRollback:
    IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
EndSave:

GO




USE [msdb]
GO
/****** Object:  Job [DYNPERF_PROCESS_TASKS_LOW_PRIORITY]    Script Date: 02/18/2010 11:38:20 ******/
IF EXISTS (SELECT job_id
           FROM   msdb.dbo.sysjobs_view
           WHERE  name = N'DYNPERF_PROCESS_TASKS_LOW_PRIORITY')
  EXEC msdb.dbo.sp_delete_job
    @job_name=N'DYNPERF_PROCESS_TASKS_LOW_PRIORITY',
    @delete_unused_schedule=1

GO

USE [msdb]
GO

/****** Object:  Job [DYNPERF_PROCESS_TASKS_LOW_PRIORITY]    Script Date: 10/10/2010 14:25:48 ******/
BEGIN TRANSACTION
DECLARE @ReturnCode INT
SELECT @ReturnCode = 0
/****** Object:  JobCategory [[Uncategorized (Local)]]]    Script Date: 10/10/2010 14:25:48 ******/
IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
BEGIN
EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'[Uncategorized (Local)]'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

END

DECLARE @jobId BINARY(16)
EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'DYNPERF_PROCESS_TASKS_LOW_PRIORITY', 
		@enabled=1, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'Run Processing tasks in DynamicsPerf Database', 
		@category_name=N'[Uncategorized (Local)]', 
		@owner_login_name=N'sa', @job_id = @jobId OUTPUT
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
/****** Object:  Step [sp_capturestats]    Script Date: 10/10/2010 14:25:48 ******/
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'SP_PROCESS_STATS_LOW_PRIORITY', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'EXEC SP_PROCESS_STATS_LOW_PRIORITY	 ', 
		@database_name=N'DynamicsPerf', 
		@flags=0
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'EVERY 5 MINUTES', 
		@enabled=1, 
		@freq_type=4, 
		@freq_interval=1, 
		@freq_subday_type=4, 
		@freq_subday_interval=5, 
		@freq_relative_interval=0, 
		@freq_recurrence_factor=0, 
		@active_start_date=20101008, 
		@active_end_date=99991231, 
		@active_start_time=100, 
		@active_end_time=235959

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
COMMIT TRANSACTION
GOTO EndSave
QuitWithRollback:
    IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
EndSave:

GO





USE [msdb]
GO

/****** Object:  Job [DYNPERF_COLLECT_AOS_CONFIG]    Script Date: 09/19/2015 07:23:26 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_COLLECT_AOS_CONFIG')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_COLLECT_AOS_CONFIG', @delete_unused_schedule=1
GO

USE [msdb]
GO

/****** Object:  Job [DYNPERF_COLLECT_AOS_CONFIG]    Script Date: 09/19/2015 07:23:26 ******/
BEGIN TRANSACTION
DECLARE @ReturnCode INT
SELECT @ReturnCode = 0
/****** Object:  JobCategory [[Uncategorized (Local)]]]    Script Date: 09/19/2015 07:23:26 ******/
IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
BEGIN
EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'[Uncategorized (Local)]'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

END

DECLARE @jobId BINARY(16)
EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'DYNPERF_COLLECT_AOS_CONFIG', 
		@enabled=0, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'No description available.', 
		@category_name=N'[Uncategorized (Local)]', 
		@owner_login_name=N'sa', @job_id = @jobId OUTPUT
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
/****** Object:  Step [COLLECT AOS CONFIG]    Script Date: 09/19/2015 07:23:26 ******/
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'COLLECT AOS CONFIG', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'ActiveScripting', 
	@command=N'strSQLInstance = "PROD_SQL"
strAXDataBase = "PROD_DB"

strSQLInstanceDPA = "DP_SQL"
strDataBaseDPA = "DynamicsPerf"


Const HKLM          = &H80000002
Const adInteger     = 3
Const adVarWChar    = 202
Const adlongVarWChar= 203
Const adParamInput  = &H0001
Const adCmdText     = &H0001
const REG_SZ        = 1
const REG_EXPAND_SZ = 2
const REG_BINARY    = 3
const REG_DWORD     = 4
const REG_MULTI_SZ  = 7

Dim objConnection
Dim objRecordset
Dim objCommandEvt
Dim objCommandReg


Dim objConnectionDPA
Dim objRecordsetDPA
Dim objCommandEvtDPA
Dim objCommandRegDPA



Dim prmEvt1
Dim prmEvt2
Dim prmEvt3
Dim prmEvt4
Dim prmEvt5
Dim prmEvt6

Dim prmReg1
Dim prmReg2
Dim prmReg3
Dim prmReg4
Dim prmReg5
Dim prmReg6
Dim prmReg7
Dim prmReg8


Dim strAOS
Dim strRecordset

strRecordset = "SELECT SUBSTRING(SERVERID,(CHARINDEX(''@'',SERVERID)+1), (LEN(SERVERID)-CHARINDEX(''@'',SERVERID)))FROM SYSSERVERCONFIG"

Set objConnection=CreateObject("ADODB.Connection") 
Set objRecordset=CreateObject("ADODB.Recordset")
set objCommandEvt=CreateObject("ADODB.command")
set objCommandReg=CreateObject("ADODB.command")


Set objConnectionDPA=CreateObject("ADODB.Connection") 
Set objRecordsetDPA=CreateObject("ADODB.Recordset")
set objCommandEvtDPA=CreateObject("ADODB.command")
set objCommandRegDPA=CreateObject("ADODB.command")




objConnection.Provider="SQLOLEDB"
objConnection.Properties("Data Source").Value = strSQLInstance
objConnection.Properties("Initial Catalog").Value = strAXDatabase
objConnection.Properties("Integrated Security").Value = "SSPI"

objConnection.Open


objConnectionDPA.Provider="SQLOLEDB"
objConnectionDPA.Properties("Data Source").Value = strSQLInstanceDPA
objConnectionDPA.Properties("Initial Catalog").Value = strDatabaseDPA
objConnectionDPA.Properties("Integrated Security").Value = "SSPI"

objConnectionDPA.Open



objCommandEvtDPA.ActiveConnection=objConnectionDPA
objCommandEvtDPA.CommandType=adCmdText
objCommandEvtDPA.CommandText="INSERT INTO DynamicsPerf..AOS_EVENTLOG VALUES (?,?,?,?,?,?)"

Set prmEvt1=objCommandEvtDPA.CreateParameter ("", adVarWChar,adParamInput,23)
Set prmEvt2=objCommandEvtDPA.CreateParameter ("", adVarWChar,adParamInput,255)
Set prmEvt3=objCommandEvtDPA.CreateParameter ("", adInteger,adParamInput)
Set prmEvt4=objCommandEvtDPA.CreateParameter ("", adVarWChar,adParamInput,255)
Set prmEvt5=objCommandEvtDPA.CreateParameter ("", adlongVarWChar,adParamInput,32768)
Set prmEvt6=objCommandEvtDPA.CreateParameter ("", adVarWChar,adParamInput,255)

objCommandEvtDPA.Parameters.Append prmEvt1
objCommandEvtDPA.Parameters.Append prmEvt2
objCommandEvtDPA.Parameters.Append prmEvt3
objCommandEvtDPA.Parameters.Append prmEvt4
objCommandEvtDPA.Parameters.Append prmEvt5
objCommandEvtDPA.Parameters.Append prmEvt6

objCommandRegDPA.ActiveConnection=objConnectionDPA
objCommandRegDPA.CommandType=adCmdText
objCommandRegDPA.CommandText="INSERT INTO DynamicsPerf..AOS_REGISTRY VALUES (?,?,?,?,?,?,?,?)"

Set prmReg1=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,255)
Set prmReg2=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,5)
Set prmReg3=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,255)
Set prmReg4=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,25)
Set prmReg5=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,255)
Set prmReg6=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,1)
Set prmReg7=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,255)
Set prmReg8=objCommandRegDPA.CreateParameter ("", adVarWChar,adParamInput,8000)

objCommandRegDPA.Parameters.Append prmReg1
objCommandRegDPA.Parameters.Append prmReg2
objCommandRegDPA.Parameters.Append prmReg3
objCommandRegDPA.Parameters.Append prmReg4
objCommandRegDPA.Parameters.Append prmReg5
objCommandRegDPA.Parameters.Append prmReg6
objCommandRegDPA.Parameters.Append prmReg7
objCommandRegDPA.Parameters.Append prmReg8

objConnectionDPA.Execute "SET DATEFORMAT MDY"
objConnectionDPA.Execute "TRUNCATE TABLE DynamicsPerf..AOS_EVENTLOG"
objConnectionDPA.Execute "TRUNCATE TABLE DynamicsPerf..AOS_REGISTRY"

objRecordset.Open strRecordset, objConnection


Do While Not objRecordset.EOF


				strAOS =  objRecordset.Fields(0) 


				On Error Resume Next

				Set objWMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!\\" & strAOS & "\root\cimv2")
				if Err.Number <> 0 then
							set objWMIService = nothing
							err.clear
				Else
				Set objWMIService = Nothing


				AOSevt(strAOS)
				AOSreg(strAOS)

		end IF
		on error goto 0
		objRecordset.MoveNext 
Loop

Set objConnection=nothing
Set objRecordset=nothing
set objCommandEvt=nothing
set objCommandReg=nothing


Set objConnectionDPA=nothing
Set objRecordsetDPA=nothing
set objCommandEvtDPA=nothing
set objCommandRegDPA=nothing



Sub AOSevt(strAOS)
  
    Const CONVERT_TO_LOCAL_TIME = True
    Set dtmStartDate = CreateObject("WbemScripting.SWbemDateTime")
    DateToCheck = CDate(DATE - 14)
    dtmStartDate.SetVarDate DateToCheck, CONVERT_TO_LOCAL_TIME
    Set objWMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!\\" & strAOS & "\root\cimv2")
    Set colLoggedEvents = objWMIService.ExecQuery _
	    ("Select * from Win32_NTLogEvent Where Logfile = ''Application'' and (eventtype = 1 or eventtype = 2 or (eventtype = 3 and eventcode = 149)) and  TimeWritten >= ''" & dtmStartDate & "''")
    For Each objEvent in colLoggedEvents
        prmEvt1.value=cUTC2Lt(objEvent.TimeWritten)
        prmEvt2.value=objEvent.ComputerName
        prmEvt3.value=objEvent.EventCode
        prmEvt4.value=objEvent.Type
        prmEvt5.value=left(objEvent.Message, 256)
        prmEvt6.value=objEvent.SourceName
        objCommandEvtDPA.Execute
    Next	
End Sub

Sub AOSreg(strAOS)
    Const HKLM = &H80000002
    Set ObjReg=GetObject("winmgmts:{impersonationLevel=impersonate}!\\" & StrAOS & "\root\default:StdRegProv")
    StrKeyPath = "System\CurrentControlSet\Services\Dynamics Server"
    ObjReg.EnumKey HKLM, StrKeyPath, ArrVersions
    For Each StrVersion In ArrVersions
        ObjReg.EnumKey HKLM, StrKeyPath & "\" & StrVersion, ArrInstances
        If IsArray(ArrInstances) Then
            For Each StrInstance In ArrInstances 
                objReg.GetStringValue HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance, "InstanceName", strInstanceName 
                objReg.GetStringValue HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance, "Current", strCurrentConfig 
                objReg.GetStringValue HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance, "ProductVersion", strProductVersion 
                ObjReg.EnumKey HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance, ArrConfigs
                    For Each StrConfig In ArrConfigs
                        If StrConfig = StrCurrentConfig Then
                            strActive = "Y"
                        Else
                            strActive = "N"
                        End if
                        ObjReg.EnumValues HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance & "\" & StrConfig, ArrValueNames,  ArrValueTypes
                        For I=0 To UBound(arrValueNames) 
                            StrValueName = arrValueNames(I)           
                            Select Case arrValueTypes(I)
                                Case REG_SZ
                                    objReg.GetStringValue HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance & "\" & StrConfig, strValueName, strValue
                                Case REG_EXPAND_SZ
                                    objReg.GetExpandedStringValue HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance & "\" & StrConfig, strValueName, strValue
                                Case REG_BINARY
                                     objReg.GetBinaryValue  HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance & "\" & StrConfig, strValueName, strValue
                                Case REG_DWORD
                                     objReg.GetDWORDValue HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance & "\" & StrConfig, strValueName, strValue
                                Case REG_MULTI_SZ
                                     objReg.GetMultiStringValue  HKLM, StrKeyPath & "\" & StrVersion & "\" & StrInstance & "\" & StrConfig, strValueName, strValue
                            End Select        
                            prmReg1.value=StrAOS
                            prmReg2.value=StrVersion
                            prmReg3.value=strInstanceName
                            prmReg4.value=StrProductVersion
                            prmReg5.value=StrConfig
                            prmReg6.value=strActive
                            prmReg7.value=StrValueName
                            prmReg8.value=StrValue
                            objCommandRegDPA.Execute
                        Next
                    Next
            Next
        End If
    Next
End Sub

Function cUTC2Lt(WMITime)
''   Convert UTC Time from Event Log to DateTime format compatible with SQL Server DateTime data type
   	Dim strDate, strTime
   	Dim yyyy : yyyy = left(WMITime,4) ''year
   	Dim mm   : mm = mid(WMITime,5,2)  ''month
   	Dim dd   : dd = mid(WMITime,7,2)  ''day
   	Dim hh   : hh = mid(WMITime,9,2)  ''hour
   	Dim mn   : mn = mid(WMITime,11,2) ''minutes
   	Dim ss   : ss = mid(WMITime,13,2) ''seconds
   	Dim ms   : ms = mid(WMITime,16,6) ''microseconds
 ''  	strDate = mm & "-" & dd & "-" & yyyy
	strDate = yyyy & "-" & mm & "-" & dd
      	strTime = hh & ":" & mn & ":" & ss
      	cUTC2Lt = strDate & " " & strTime
End Function


', 
		@database_name=N'VBScript', 
		@flags=0
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'DAILY', 
		@enabled=1, 
		@freq_type=4, 
		@freq_interval=1, 
		@freq_subday_type=1, 
		@freq_subday_interval=0, 
		@freq_relative_interval=0, 
		@freq_recurrence_factor=0, 
		@active_start_date=20150919, 
		@active_end_date=99991231, 
		@active_start_time=60000, 
		@active_end_time=235959

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
COMMIT TRANSACTION
GOTO EndSave
QuitWithRollback:
    IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
EndSave:

GO


/****** Object:  Job [DYNPERF_COLLECT_AOS_CONFIG]    Script Date: 09/19/2015 07:23:26 ******/
IF  EXISTS (SELECT job_id FROM msdb.dbo.sysjobs_view WHERE name = N'DYNPERF_CAPTURE_SSRS')
EXEC msdb.dbo.sp_delete_job @job_name=N'DYNPERF_CAPTURE_SSRS', @delete_unused_schedule=1
GO

USE [msdb]
GO

/****** Object:  Job [DYNPERF_CAPTURE_SSRS]    Script Date: 06/22/2016 07:07:55 ******/
BEGIN TRANSACTION
DECLARE @ReturnCode INT
SELECT @ReturnCode = 0
/****** Object:  JobCategory [[Uncategorized (Local)]]]    Script Date: 06/22/2016 07:07:55 ******/
IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)
BEGIN
EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'[Uncategorized (Local)]'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback

END

DECLARE @jobId BINARY(16)
EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'DYNPERF_CAPTURE_SSRS', 
		@enabled=1, 
		@notify_level_eventlog=0, 
		@notify_level_email=0, 
		@notify_level_netsend=0, 
		@notify_level_page=0, 
		@delete_level=0, 
		@description=N'Capture SSRS EXECUTIONLOG2 for performance analysis', 
		@category_name=N'[Uncategorized (Local)]', 
		@owner_login_name=N'sa', @job_id = @jobId OUTPUT
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
/****** Object:  Step [DYNPERF_COLLECT_SSRS_EXECUTIONLOG]    Script Date: 06/22/2016 07:07:55 ******/
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'DYNPERF_COLLECT_SSRS_EXECUTIONLOG', 
		@step_id=1, 
		@cmdexec_success_code=0, 
		@on_success_action=4, 
		@on_success_step_id=2, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'EXEC  DYNPERF_COLLECT_SSRS_EXECUTIONLOG @DEBUG = ''N''', 
		@database_name=N'DynamicsPerf', 
		@flags=0
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
/****** Object:  Step [DYNPERF_ROLLUP_SSRS_HISTORY]    Script Date: 06/22/2016 07:07:55 ******/
EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'DYNPERF_ROLLUP_SSRS_HISTORY', 
		@step_id=2, 
		@cmdexec_success_code=0, 
		@on_success_action=1, 
		@on_success_step_id=0, 
		@on_fail_action=2, 
		@on_fail_step_id=0, 
		@retry_attempts=0, 
		@retry_interval=0, 
		@os_run_priority=0, @subsystem=N'TSQL', 
		@command=N'exec DYNPERF_UPDATE_SSRS_HISTORY @DEBUG = ''N''', 
		@database_name=N'DynamicsPerf', 
		@flags=0
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobschedule @job_id=@jobId, @name=N'5 MINUTES', 
		@enabled=1, 
		@freq_type=4, 
		@freq_interval=1, 
		@freq_subday_type=4, 
		@freq_subday_interval=5, 
		@freq_relative_interval=0, 
		@freq_recurrence_factor=0, 
		@active_start_date=20101008, 
		@active_end_date=99991231, 
		@active_start_time=0, 
		@active_end_time=235959

IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'
IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback
COMMIT TRANSACTION
GOTO EndSave
QuitWithRollback:
    IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION
EndSave:

GO





/********************** END OF SQL JOBS ***********************************/



GO
PRINT N'Update complete.';


GO
