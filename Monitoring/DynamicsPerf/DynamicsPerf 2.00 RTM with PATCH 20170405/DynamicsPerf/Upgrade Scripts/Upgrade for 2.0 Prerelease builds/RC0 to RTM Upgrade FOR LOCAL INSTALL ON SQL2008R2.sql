/*
Deployment script for DynamicsPerfRC0

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

--USE DynamicsPerf

GO


IF EXISTS(SELECT 1
          FROM   msdb.dbo.sysjobs J
                 JOIN msdb.dbo.sysjobactivity A
                   ON A.job_id = J.job_id
          WHERE  J.NAME = N'DYNPERF_CAPTURE_SSRS'
                 AND A.run_requested_date IS NOT NULL
                 AND A.stop_execution_date IS NULL)
  EXEC msdb.dbo.Sp_stop_job
    N'DYNPERF_CAPTURE_SSRS' 
 

IF EXISTS(SELECT 1
          FROM   msdb.dbo.sysjobs J
                 JOIN msdb.dbo.sysjobactivity A
                   ON A.job_id = J.job_id
          WHERE  J.NAME = N'DYNPERF_CAPTURE_STATS'
                 AND A.run_requested_date IS NOT NULL
                 AND A.stop_execution_date IS NULL)
  EXEC msdb.dbo.Sp_stop_job
    N'DYNPERF_CAPTURE_STATS' 
    
    
 IF EXISTS(SELECT 1
          
          FROM   msdb.dbo.sysjobs J
                 JOIN msdb.dbo.sysjobactivity A
                   ON A.job_id = J.job_id
          WHERE  J.NAME = N'DYNPERF_COLLECT_AOS_CONFIG'
                 AND A.run_requested_date IS NOT NULL
                 AND A.stop_execution_date IS NULL)
  EXEC msdb.dbo.Sp_stop_job
    N'DYNPERF_COLLECT_AOS_CONFIG' 
    
    IF EXISTS(SELECT 1
          FROM   msdb.dbo.sysjobs J
                 JOIN msdb.dbo.sysjobactivity A
                   ON A.job_id = J.job_id
          WHERE  J.NAME = N'DYNPERF_PROCESS_TASKS'
                 AND A.run_requested_date IS NOT NULL
                 AND A.stop_execution_date IS NULL)
  EXEC msdb.dbo.Sp_stop_job
    N'DYNPERF_PROCESS_TASKS' 
    
    IF EXISTS(SELECT 1
          FROM   msdb.dbo.sysjobs J
                 JOIN msdb.dbo.sysjobactivity A
                   ON A.job_id = J.job_id
          WHERE  J.NAME = N'DYNPERF_PROCESS_TASKS_LOW_PRIORITY'
                 AND A.run_requested_date IS NOT NULL
                 AND A.stop_execution_date IS NULL)
  EXEC msdb.dbo.Sp_stop_job
    N'DYNPERF_PROCESS_TASKS_LOW_PRIORITY' 
       
    GO
  
      
    EXEC msdb.dbo.sp_update_job  @job_name = N'DYNPERF_CAPTURE_SSRS', @enabled = 0 ; 
    EXEC msdb.dbo.sp_update_job  @job_name = N'DYNPERF_CAPTURE_STATS', @enabled = 0 ; 
    EXEC msdb.dbo.sp_update_job  @job_name = N'DYNPERF_COLLECT_AOS_CONFIG', @enabled = 0 ; 
    EXEC msdb.dbo.sp_update_job  @job_name = N'DYNPERF_PROCESS_TASKS', @enabled = 0 ; 
    EXEC msdb.dbo.sp_update_job  @job_name = N'DYNPERF_PROCESS_TASKS_LOW_PRIORITY', @enabled = 0 ; 
        
   
   
GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
--USE [DynamicsPerf];


GO


GO
PRINT N'Dropping [dbo].[AX_SQLTRACE].[IX_AX_SQLTRACE_CANPROCESS]...';


GO
DROP INDEX [IX_AX_SQLTRACE_CANPROCESS]
    ON [dbo].[AX_SQLTRACE];


GO
PRINT N'Altering [dbo].[AX_NUM_SEQUENCES]...';


GO
ALTER TABLE [dbo].[AX_NUM_SEQUENCES] ALTER COLUMN [COMPANYNAME] NVARCHAR (100) NULL;

ALTER TABLE [dbo].[AX_NUM_SEQUENCES] ALTER COLUMN [PARTITIONNAME] NVARCHAR (100) NULL;


GO
PRINT N'Altering [dbo].[DATABASES_2_COLLECT]...';


GO

if not exists (select
                     column_name
               from
                     INFORMATION_SCHEMA.columns
               where
                     table_name = 'DATABASES_2_COLLECT'
                     and column_name = 'PURGE_PLANS_AFTER_X_DAYS')
BEGIN
ALTER TABLE [dbo].[DATABASES_2_COLLECT]
    ADD [KEEP_TOP_X_QUERIES_BY_MONTH] INT DEFAULT ((100)) NULL,
        [KEEP_TOP_X_PLANS_BY_MONTH]   INT DEFAULT ((100)) NULL,
        [PURGE_PLANS_AFTER_X_DAYS]    INT DEFAULT ((60)) NULL;
END

GO
PRINT N'Creating [dbo].[AX_SQLTRACE].[IX_AX_SQLTRACE_CANPROCESS]...';


GO
CREATE NONCLUSTERED INDEX [IX_AX_SQLTRACE_CANPROCESS]
    ON [dbo].[AX_SQLTRACE]([QUERY_HASH] ASC, [CANPROCESS] ASC, [DATABASE_NAME] ASC, [SERVER_NAME] ASC) WITH (DATA_COMPRESSION = ROW);


GO
PRINT N'Creating [dbo].[QUERY_HISTORY].[IX_INDEX_HISTORY1]...';


GO
/****** Object:  Index [IX_INDEX_HISTORY1]    Script Date: 01/11/2017 13:49:02 ******/
IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[QUERY_HISTORY]') AND name = N'IX_INDEX_HISTORY1')
DROP INDEX [IX_INDEX_HISTORY1] ON [dbo].[QUERY_HISTORY] WITH ( ONLINE = OFF )
GO
CREATE NONCLUSTERED INDEX [IX_INDEX_HISTORY1]
    ON [dbo].[QUERY_HISTORY]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [QUERY_HASH] ASC, [DATE] ASC, [FLAG] ASC, [EXECUTION_COUNT_TODAY] ASC, [QUERY_PLAN_HASH] ASC) WITH (DATA_COMPRESSION = ROW);


GO
PRINT N'Creating [dbo].[QUERY_HISTORY].[IX_INDEX_HISTORY2]...';


GO

/****** Object:  Index [IX_INDEX_HISTORY2]    Script Date: 01/11/2017 13:49:16 ******/
IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[QUERY_HISTORY]') AND name = N'IX_INDEX_HISTORY2')
DROP INDEX [IX_INDEX_HISTORY2] ON [dbo].[QUERY_HISTORY] WITH ( ONLINE = OFF )
GO

CREATE NONCLUSTERED INDEX [IX_INDEX_HISTORY2]
    ON [dbo].[QUERY_HISTORY]([SERVER_NAME] ASC, [DATABASE_NAME] ASC, [QUERY_HASH] ASC, [QUERY_PLAN_HASH] ASC, [DATE] ASC, [FLAG] ASC, [EXECUTION_COUNT_TODAY] ASC) WITH (DATA_COMPRESSION = ROW);


GO
PRINT N'Refreshing [dbo].[AX_NUM_SEQUENCES_CURR_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[AX_NUM_SEQUENCES_CURR_VW]';


GO
PRINT N'Refreshing [dbo].[AX_NUM_SEQUENCES_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[AX_NUM_SEQUENCES_VW]';


GO
PRINT N'Altering [dbo].[INDEX_STATS_CURR_VW]...';


GO


ALTER VIEW [dbo].[INDEX_STATS_CURR_VW]
AS

WITH CTE_SERVER(SERVER_NAME, DATABASE_NAME)
     AS (SELECT LINKED_SERVER,
                DATABASE_NAME
         FROM   [dbo].[DATABASES_2_COLLECT]),


     MAX_STATS_CTE (SERVER_NAME, DATABASE_NAME, STATS_TIME)
     AS (
       
        SELECT SERVER_NAME,
                     DATABASE_NAME,
                     MAX(STATS_TIME)
         FROM   INDEX_DETAIL --STATS_COLLECTION_SUMMARY
		 GROUP BY SERVER_NAME, 
				  DATABASE_NAME
)


SELECT D.SERVER_NAME,
       S.SQL_SERVER_STARTTIME,
       D.DATABASE_NAME,
       D.TABLE_NAME,
       D.INDEX_NAME,
       INDEX_DESCRIPTION,
       D.DATA_COMPRESSION,
       INDEX_KEYS,
       INCLUDED_COLUMNS,
       USER_SEEKS,
       USER_SCANS,
       USER_LOOKUPS,
       USER_UPDATES,
       RANGE_SCAN_COUNT,
       PAGE_COUNT,
       ROW_COUNT,
       SINGLETON_LOOKUP_COUNT,
       FORWARDED_FETCH_COUNT,
       INDEX_DEPTH,
       AVG_FRAGMENTATION_IN_PERCENT,
       FRAGMENT_COUNT,
       ROW_LOCK_WAIT_IN_MS,
       PAGE_LOCK_WAIT_IN_MS,
       INDEX_LOCK_PROMOTION_ATTEMPT_COUNT,
       INDEX_LOCK_PROMOTION_COUNT,
       PAGE_LATCH_WAIT_IN_MS,
       PAGE_IO_LATCH_WAIT_IN_MS,
       LEAF_INSERT_COUNT,
       LEAF_DELETE_COUNT,
       LEAF_UPDATE_COUNT,
       LEAF_GHOST_COUNT,
       NONLEAF_INSERT_COUNT,
       NONLEAF_DELETE_COUNT,
       NONLEAF_UPDATE_COUNT,
       LEAF_ALLOCATION_COUNT,
       NONLEAF_ALLOCATION_COUNT,
       LEAF_PAGE_MERGE_COUNT,
       NONLEAF_PAGE_MERGE_COUNT,
       LOB_FETCH_IN_PAGES,
       LOB_FETCH_IN_BYTES,
       LOB_ORPHAN_CREATE_COUNT,
       LOB_ORPHAN_INSERT_COUNT,
       ROW_OVERFLOW_FETCH_IN_PAGES,
       ROW_OVERFLOW_FETCH_IN_BYTES,
       COLUMN_VALUE_PUSH_OFF_ROW_COUNT,
       COLUMN_VALUE_PULL_IN_ROW_COUNT,
       ROW_LOCK_COUNT,
       ROW_LOCK_WAIT_COUNT,
       PAGE_LOCK_COUNT,
       PAGE_LOCK_WAIT_COUNT,
       PAGE_LATCH_WAIT_COUNT,
       PAGE_IO_LATCH_WAIT_COUNT,
       D.STATS_TIME,
       D.INDEX_ID
FROM   CTE_SERVER -- FOR EVERY SERVER & DATABASE
       CROSS APPLY(SELECT *
                   FROM   MAX_STATS_CTE CTE WITH (NOLOCK)
                   WHERE  CTE.SERVER_NAME = CTE_SERVER.SERVER_NAME
                          AND CTE.DATABASE_NAME = CTE_SERVER.DATABASE_NAME) AS CTE -- GET MAX OF STATS_DATE
       OUTER APPLY(SELECT ID.*
                   FROM   INDEX_DETAIL ID WITH (NOLOCK)
                   WHERE  ID.STATS_TIME = CTE.STATS_TIME
                          AND ID.DATABASE_NAME = CTE.DATABASE_NAME
                          AND ID.SERVER_NAME = CTE.SERVER_NAME) AS D --AND GET ALL THE INDEX_DETAILS
       JOIN STATS_COLLECTION_SUMMARY S
         ON S.SERVER_NAME = D.SERVER_NAME
            AND S.STATS_TIME = D.STATS_TIME
            AND S.DATABASE_NAME = D.DATABASE_NAME
       LEFT JOIN INDEX_USAGE_STATS U WITH (NOLOCK)
              ON U.SERVER_NAME = D.SERVER_NAME
                 AND U.STATS_TIME = D.STATS_TIME
                 AND U.DATABASE_NAME = D.DATABASE_NAME
                 AND U.OBJECT_ID = D.OBJECT_ID
                 AND U.INDEX_ID = D.INDEX_ID
       LEFT JOIN INDEX_PHYSICAL_STATS P WITH (NOLOCK)
              ON D.SERVER_NAME = P.SERVER_NAME
                 AND D.STATS_TIME = P.STATS_TIME
                 AND D.DATABASE_NAME = P.DATABASE_NAME
                 AND D.OBJECT_ID = P.OBJECT_ID
                 AND D.INDEX_ID = P.INDEX_ID
       LEFT JOIN INDEX_OPERATIONAL_STATS O WITH (NOLOCK)
              ON D.SERVER_NAME = O.SERVER_NAME
                 AND D.STATS_TIME = O.STATS_TIME
                 AND D.DATABASE_NAME = O.DATABASE_NAME
                 AND D.OBJECT_ID = O.OBJECT_ID
                 AND D.INDEX_ID = O.INDEX_ID
GO
PRINT N'Altering [dbo].[QUERY_PLANS_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
ALTER VIEW [dbo].[QUERY_PLANS_VW]
	AS 
	
SELECT SERVER_NAME,DATABASE_NAME,QUERY_PLAN_HASH,QUERY_PLAN,SQL_PARMS, MI_FLAG,
ISNULL(STUFF(( 

		select '| TABLE= ' + PP.TABLE_NAME + '  NODE_ID=' + cast(PP.NODE_ID AS VARCHAR(5)) + char(10) + char(9)
		+ ' ||| INDEX= ' + PP.INDEX_NAME 
		+ ' ||| INDEX_KEYS= ' + ISNULL((SELECT TOP 1 INDEX_KEYS FROM INDEX_STATS_CURR_VW IV WHERE IV.SERVER_NAME = PP.SERVER_NAME AND IV.DATABASE_NAME = PP.DATABASE_NAME AND IV.TABLE_NAME = PP.TABLE_NAME AND IV.INDEX_NAME = PP.INDEX_NAME),'')
		+ ' ||| PHYSICAL_OP= ' + PP.PHYSICALOP 
		+ ' ||| LOGICAL_OP= ' + PP.LOGICALOP 
		+ char(10) + char(9)
		+ ' ||| SEEK_COLUMNS= ' + replace(PP.SEEK_COLUMNS, ' ', ',')
		+ char(10) + char(9)
		+ ' ||| PREDICATE_COLUMNS= ' + PREDICATES 
		+ ' ||| PREDICATE_TEXT= ' + PREDICATE_TEXT 
		+ char(10) + char(9)
		+ ' ||| LOOKUP= ' + CAST(PP.LOOKUP AS VARCHAR(1))
		+ ' ||| ESTIMATED_ROWS = ' + CAST(PP.ESTIMATEROWS AS VARCHAR(30))
		+ ' ||| AVG_ROW_SIZE = ' + CAST(PP.AVGROWSIZE  AS VARCHAR(30))
		+ ' ||| ESTIMATED_TOTAL_COST ' + CAST(PP.ESTIMATEDTOTALSUBTREECOST AS VARCHAR(30))
		+ ' ||| ESTIMATED_IO = ' + CAST(PP.ESTIMATEIO AS VARCHAR(30))
		+ ' ||| ESTIMATED_CPU = ' + CAST(PP.ESTIMATECPU AS VARCHAR(30))

		+ CASE ATV.TABLE_NAME WHEN NULL THEN '' ELSE CHAR(10) + CHAR(10) + CHAR(9) 
		+ '||| AX TABLE DETAILS |||' + CHAR(10) + CHAR(10)
		+ CHAR(9) + CHAR(9) + 'LAYER - ' + ATV.APPLAYER + '  CACHE - ' + ATV.CACHE_LOOKUP + '  TABLE GROUP - ' + ATV.TABLE_GROUP + ' OCC ENABLED - ' + CAST(ATV.OCC_ENABLED AS VARCHAR(2))
		END
		 
		 + CASE ATV.INSERT_METHOD_OVERRIDDEN WHEN NULL THEN '' ELSE CHAR(10) + CHAR(9) + CHAR(9)
		 + 'OVERWRITTEN METHODS - ' + 'INSERT = ' + CAST(ATV.INSERT_METHOD_OVERRIDDEN AS VARCHAR(1)) + ' UPDATE = ' + CAST(ATV.UPDATE_METHOD_OVERRIDDEN AS VARCHAR(1)) + ' DELETE = ' + CAST(ATV.DELETE_METHOD_OVERRIDDEN AS VARCHAR(1)) END 
		  
		  + CASE ATV.DATABASELOG_INSERT WHEN NULL THEN '' ELSE CHAR(10) + CHAR(9) + CHAR(9)
		  + 'DATABASE LOGGING SETTINGS - ' + 'DELETE = ' + CAST(ATV.DATABASELOG_DELETE AS VARCHAR(1)) + ' UPDATE = ' + CAST(ATV.DATABASELOG_UPDATE AS VARCHAR(1)) + ' INSERT = ' + CAST(ATV.DATABASELOG_INSERT AS VARCHAR(1)) END

		  + CASE ATV.EVENT_UPDATE WHEN NULL THEN '' ELSE CHAR(10) + CHAR(9) + CHAR(9)
		  + 'ALERTS SETTINGS - ' + 'DELETE = ' + CAST(ATV.EVENT_DELETE AS VARCHAR(1)) + ' UPDATE = ' + CAST(ATV.EVENT_UPDATE AS VARCHAR(1)) + ' INSERT = ' + CAST(ATV.EVENT_INSERT AS VARCHAR(1)) END

		+char(10) +char(10) + ' ||| INDEXES FOR THIS TABLE |||' + char(10) + CHAR(10) 
		+ char(9) + 'TABLE ROWS = ' + (SELECT TOP 1 CAST(ROW_COUNT AS VARCHAR(20))  FROM INDEX_STATS_CURR_VW IV 
			WHERE IV.SERVER_NAME = PP.SERVER_NAME AND IV.DATABASE_NAME = PP.DATABASE_NAME AND IV.TABLE_NAME = PP.TABLE_NAME ) 
			+ CHAR(10)+CHAR(9)
			+CASE PP.LOOKUP WHEN 0 THEN STUFF((SELECT CHAR(9) + CHAR(9) + 'NAME=['+ INDEX_NAME + ']  KEYS=['+  INDEX_KEYS + ']' + CHAR(9) + INDEX_DESCRIPTION +CHAR(10)  FROM INDEX_STATS_CURR_VW IV 
			WHERE IV.SERVER_NAME = PP.SERVER_NAME AND IV.DATABASE_NAME = PP.DATABASE_NAME AND IV.TABLE_NAME = PP.TABLE_NAME 
			FOR xml path('')),1,1, '') ELSE ' ' END + CHAR(10) + CHAR(10)

			from QUERY_PLANS_PARSED PP
			LEFT JOIN AX_TABLE_DETAIL_VW ATV 
				ON PP.SERVER_NAME = ATV.SERVER_NAME AND PP.DATABASE_NAME = ATV.DATABASE_NAME AND PP.TABLE_NAME = ATV.TABLE_NAME
			where QP.SERVER_NAME = PP.SERVER_NAME
				AND QP.DATABASE_NAME = PP.DATABASE_NAME
			AND QP.QUERY_PLAN_HASH = PP.QUERY_PLAN_HASH
			ORDER BY PP.ESTIMATEROWS DESC
			FOR xml path('')),1,1, ''),'')  AS QUERY_NODES

FROM QUERY_PLANS QP
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Refreshing [dbo].[QUERY_ALERTS_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[QUERY_ALERTS_VW]';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[QUERY_HISTORY_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
ALTER VIEW [dbo].[QUERY_HISTORY_VW]
AS
  SELECT QH.SERVER_NAME,
         QH.DATABASE_NAME,
         QH.FLAG                                                                                                                                                                                 AS FLAG,
         DATE,
         EXECUTION_COUNT_TODAY                                                                                                                                                                   AS EXECUTION_COUNT,
         Cast(ELAPSED_TIME_TODAY / 1000.000 AS DECIMAL(29, 3))                                                                                                                                   AS TOTAL_ELAPSED_TIME,
         QH.AVG_TIME_TODAY_MS                                                                                                                                                                    AS AVG_ELAPSED_TIME,
         Cast(MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                                                                                                     AS MAX_ELAPSED_TIME,
         AVG_LOGICAL_READS = CASE EXECUTION_COUNT_TODAY
                               WHEN 0 THEN 0
                               ELSE TOTAL_LOGICAL_READS_TODAY / EXECUTION_COUNT_TODAY
                             END,
         AVG_LOGICAL_READS_MB = CASE EXECUTION_COUNT_TODAY
                                  WHEN 0 THEN 0
                                  ELSE ( TOTAL_LOGICAL_READS_TODAY / EXECUTION_COUNT_TODAY ) * 8 / 1024
                                END,
         Cast(ELAPSED_TIME_TODAY / 1000.000 AS DECIMAL(29, 3)) - Cast(TOTAL_WORKER_TIME_TODAY / 1000.000 AS DECIMAL(29, 3))                                                                      AS TOTAL_WAIT_TIME,
         AVG_ROWS_RETURNED = CASE EXECUTION_COUNT_TODAY
                               WHEN 0 THEN 0
                               ELSE TOTAL_ROWS_TODAY / EXECUTION_COUNT_TODAY
                             END,
          REPLACE(REPLACE(REPLACE(QT.SQL_TEXT, 'SELECT ', CHAR(10)+'SELECT '), ' FROM', CHAR(10)+' FROM'), ' WHERE', CHAR(10)+ ' WHERE')
         + Char(10) + Char(10) + Replicate('-', 50)
         + 'QUERY PARAMETERS' + Replicate('-', 61)
         + Char(10) + QP.SQL_PARMS + Char(10) + Char(10)
         + Replicate('-', 50)
         + 'TABLE NODES FROM QUERY PLAN'
         + Replicate('-', 50) + Char(10)
         + Isnull((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE QH.SERVER_NAME = QPV.SERVER_NAME AND QH.DATABASE_NAME = QPV.DATABASE_NAME AND QH.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '') AS QUERY_PLAN_PARSED,
         Isnull((SELECT MISSING_INDEX_INFO
                 FROM   QUERY_PLANS_MISSING_INDEX_VW QPV
                 WHERE  QH.SERVER_NAME = QPV.SERVER_NAME
                        AND QH.DATABASE_NAME = QPV.DATABASE_NAME
                        AND QH.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '')                                                                                                                       AS MISSING_INDEXES,
         QP.SQL_PARMS                                                                                                                                                                            AS QUERY_PARAMETER_VALUES,
         QP.QUERY_PLAN,
         QH.QUERY_PLAN_HASH,
         QH.QUERY_HASH,
         QT.SQL_TEXT                                                                                                                                                                             AS SQL_TEXT,
         TOTAL_ROWS_TODAY                                                                                                                                                                        AS TOTAL_ROWS,
         LAST_EXECUTION_TIME                                                                                                                                                                     AS LAST_EXECUTION_TIME,
         TOTAL_LOGICAL_READS_TODAY                                                                                                                                                               AS TOTAL_LOGICAL_READS,
         QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN),
		 QP.DATE_UPDATED
  FROM   QUERY_HISTORY QH WITH (NOLOCK)
         LEFT OUTER LOOP JOIN QUERY_PLANS QP WITH (NOLOCK)
                      ON QP.QUERY_PLAN_HASH = QH.QUERY_PLAN_HASH
                         AND QP.SERVER_NAME = QH.SERVER_NAME
                         AND QP.DATABASE_NAME = QH.DATABASE_NAME
         LEFT OUTER LOOP JOIN QUERY_TEXT AS QT
                           ON QH.QUERY_HASH = QT.QUERY_HASH
                              AND QH.SERVER_NAME = QT.SERVER_NAME
                              AND QH.DATABASE_NAME = QT.DATABASE_NAME
         LEFT OUTER LOOP JOIN COMMENTS C
                           ON QH.QUERY_HASH = C.QUERY_HASH
                              AND QH.SERVER_NAME = C.SERVER_NAME
                              AND QH.DATABASE_NAME = C.DATABASE_NAME
  WHERE  EXECUTION_COUNT_TODAY > 0
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[QUERY_STATS_CURR_VW]...';


GO

ALTER VIEW [dbo].[QUERY_STATS_CURR_VW]
AS

WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT Q.SERVER_NAME,
       Q.DATABASE_NAME,
       CREATION_TIME                                                                                                AS COMPILED_TIME,
       EXECUTION_COUNT,
       EXECUTION_COUNT / CASE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                           WHEN 0 THEN 1
                           ELSE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                         END                                                                                        AS EXECUTION_PER_HOUR,
       cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                        AS TOTAL_ELAPSED_TIME,
       Q.AVG_TIME_MS                                                                                                AS AVG_ELAPSED_TIME,
       cast(MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS MAX_ELAPSED_TIME,
       AVG_LOGICAL_READS = TOTAL_LOGICAL_READS / EXECUTION_COUNT,
       AVG_LOGICAL_READS_MB = (TOTAL_LOGICAL_READS / EXECUTION_COUNT)*8/1024,
	   cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3)) - cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3)) AS TOTAL_WAIT_TIME,
       AVG_ROWS_RETURNED = TOTAL_ROWS / EXECUTION_COUNT,
       REPLACE(REPLACE(REPLACE(QT.SQL_TEXT, 'SELECT ', CHAR(10)+'SELECT '), ' FROM', CHAR(10)+' FROM'), ' WHERE', CHAR(10)+ ' WHERE')+
	   REPLICATE('-',50)+'TABLE NODES FROM QUERY PLAN' + REPLICATE('-',50) + CHAR(10) + ISNULL((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE Q.SERVER_NAME = QPV.SERVER_NAME AND Q.DATABASE_NAME = QPV.DATABASE_NAME AND Q.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS QUERY_PLAN_PARSED,
        ISNULL((SELECT MISSING_INDEX_INFO FROM QUERY_PLANS_MISSING_INDEX_VW QPV WHERE Q.SERVER_NAME = QPV.SERVER_NAME AND Q.DATABASE_NAME = QPV.DATABASE_NAME AND Q.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS MISSING_INDEXES,
	   QP.SQL_PARMS                                                                                                 AS QUERY_PARAMETER_VALUES,
       QUERY_PLAN,
       Q.ROW_NUM,
       Q.QUERY_HASH,
       QT.SQL_TEXT AS SQL_TEXT,
	   TOTAL_ROWS,
       MAX_ROWS,
       MIN_ROWS,
       PLAN_GENERATION_NUM,
       Q.LAST_EXECUTION_TIME,
       cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                         AS TOTAL_WORKER_TIME,
       AVG_PHYSICAL_READS = TOTAL_PHYSICAL_READS / EXECUTION_COUNT,
       AVG_LOGICAL_WRITES = TOTAL_LOGICAL_WRITES / EXECUTION_COUNT,
       cast(LAST_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                         AS LAST_ELAPSED_TIME,
       cast(MIN_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS MIN_ELAPSED_TIME,
       TOTAL_PHYSICAL_READS,
       LAST_PHYSICAL_READS,
       MIN_PHYSICAL_READS,
       MAX_PHYSICAL_READS,
       TOTAL_LOGICAL_READS,
       LAST_LOGICAL_READS,
       MIN_LOGICAL_READS,
       MAX_LOGICAL_READS,
       TOTAL_LOGICAL_WRITES,
       LAST_LOGICAL_WRITES,
       MIN_LOGICAL_WRITES,
       MAX_LOGICAL_WRITES,
       cast(LAST_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS LAST_WORKER_TIME,
       cast(MIN_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS MIN_WORKER_TIME,
       cast(MAX_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS MAX_WORKER_TIME,
       QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN),
       S.STATS_TIME,
       SQL_VERSION,
       S.SQL_SERVER_STARTTIME,
       Q.QUERY_PLAN_HASH,
       C.COMMENT
FROM   (SELECT QS2.SERVER_NAME,
               QS2.DATABASE_NAME,
               QUERY_HASH,
               max(QS2.STATS_TIME)      AS STATS_TIME,
               max(LAST_EXECUTION_TIME) AS LAST_EXECUTION_TIME
        FROM   QUERY_STATS QS2
               INNER JOIN STATS_COLLECTION_SUMMARY S2 WITH (NOLOCK)
                       ON QS2.STATS_TIME = S2.STATS_TIME
                          AND QS2.DATABASE_NAME = S2.DATABASE_NAME
                          AND QS2.SERVER_NAME = S2.SERVER_NAME
                          
        GROUP  BY QS2.SERVER_NAME,
                  QS2.DATABASE_NAME,
                  QUERY_HASH,
				  QUERY_PLAN_HASH) AS A
       INNER LOOP JOIN QUERY_STATS Q WITH (NOLOCK)
                    ON A.SERVER_NAME = Q.SERVER_NAME
                       AND A.DATABASE_NAME = Q.DATABASE_NAME
                       AND A.QUERY_HASH = Q.QUERY_HASH
                       AND A.LAST_EXECUTION_TIME = Q.LAST_EXECUTION_TIME
                       AND A.STATS_TIME = Q.STATS_TIME
       LEFT OUTER JOIN QUERY_PLANS QP WITH (NOLOCK)
               ON QP.QUERY_PLAN_HASH = Q.QUERY_PLAN_HASH
                  AND QP.SERVER_NAME = Q.SERVER_NAME
                  AND QP.DATABASE_NAME = Q.DATABASE_NAME
       INNER JOIN STATS_COLLECTION_SUMMARY S WITH (NOLOCK)
               ON Q.STATS_TIME = S.STATS_TIME
                  AND Q.DATABASE_NAME = S.DATABASE_NAME
                  AND Q.SERVER_NAME = S.SERVER_NAME
       LEFT OUTER JOIN QUERY_TEXT AS QT
                    ON Q.QUERY_HASH = QT.QUERY_HASH
                       AND Q.DATABASE_NAME = QT.DATABASE_NAME
                       AND Q.SERVER_NAME = QT.SERVER_NAME
       LEFT OUTER JOIN COMMENTS C
                    ON Q.QUERY_HASH = C.QUERY_HASH
                       AND Q.SERVER_NAME = C.SERVER_NAME
                       AND Q.DATABASE_NAME = C.DATABASE_NAME
GO
PRINT N'Altering [dbo].[QUERY_STATS_VW]...';


GO

ALTER VIEW [dbo].[QUERY_STATS_VW]
AS


WITH STATS_CTE ( SERVER_NAME, DATABASE_NAME, STATS_TIME, COMPILED_TIME, EXECUTION_COUNT, TOTAL_ELAPSED_TIME, AVG_ELAPSED_TIME, MAX_ELAPSED_TIME, AVG_LOGICAL_READS, AVG_LOGICAL_READS_MB, TOTAL_WAIT_TIME, AVG_ROWS_RETURNED, QUERY_PLAN_HASH, QUERY_HASH, TOTAL_ROWS, MAX_ROWS, MIN_ROWS, PLAN_GENERATION_NUM, LAST_EXECUTION_TIME, TOTAL_WORKER_TIME, AVG_PHYSICAL_READS, AVG_LOGICAL_WRITES, LAST_ELAPSED_TIME, MIN_ELAPSED_TIME, TOTAL_PHYSICAL_READS, LAST_PHYSICAL_READS, MIN_PHYSICAL_READS, MAX_PHYSICAL_READS, TOTAL_LOGICAL_READS, LAST_LOGICAL_READS, MIN_LOGICAL_READS, MAX_LOGICAL_READS, TOTAL_LOGICAL_WRITES, LAST_LOGICAL_WRITES, MIN_LOGICAL_WRITES, MAX_LOGICAL_WRITES, LAST_WORKER_TIME, MIN_WORKER_TIME, MAX_WORKER_TIME )
     AS (SELECT QS.SERVER_NAME,
                QS.DATABASE_NAME,
                STATS_TIME,
                MIN(CREATION_TIME)                                                                                                     AS COMPILED_TIME,
                SUM(EXECUTION_COUNT)                                                                                                   AS EXECUTION_COUNT,
                CAST(SUM(TOTAL_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                             AS TOTAL_ELAPSED_TIME,
                AVG(QS.AVG_TIME_MS)                                                                                                    AS AVG_ELAPSED_TIME,
                CAST(SUM(MAX_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                               AS MAX_ELAPSED_TIME,
                AVG_LOGICAL_READS = SUM(TOTAL_LOGICAL_READS) / SUM(EXECUTION_COUNT),
                AVG_LOGICAL_READS_MB = (SUM(TOTAL_LOGICAL_READS) / SUM(EXECUTION_COUNT)) * 8 / 1024,
				CAST(SUM(TOTAL_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3)) - CAST(SUM(TOTAL_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3)) AS TOTAL_WAIT_TIME,
                AVG_ROWS_RETURNED = SUM(TOTAL_ROWS) / SUM(EXECUTION_COUNT),
                QS.QUERY_PLAN_HASH,
                QS.QUERY_HASH,
                SUM(TOTAL_ROWS)                                                                                                        AS TOTAL_ROWS,
                MAX(MAX_ROWS)                                                                                                          AS MAX_ROWS,
                MIN(MIN_ROWS)                                                                                                          AS MIN_ROWS,
                MAX(PLAN_GENERATION_NUM)                                                                                               AS PLAN_GENERATION_NUM,
                MAX(LAST_EXECUTION_TIME)                                                                                               AS LAST_EXECUTION_TIME,
                CAST(SUM(TOTAL_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                              AS TOTAL_WORKER_TIME,
                AVG_PHYSICAL_READS = SUM(TOTAL_PHYSICAL_READS) / SUM(EXECUTION_COUNT),
                AVG_LOGICAL_WRITES = SUM(TOTAL_LOGICAL_WRITES) / SUM(EXECUTION_COUNT),
                CAST(AVG(LAST_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                              AS LAST_ELAPSED_TIME,
                CAST(MIN(MIN_ELAPSED_TIME) / 1000.000 AS DECIMAL(29, 3))                                                               AS MIN_ELAPSED_TIME,
                SUM(TOTAL_PHYSICAL_READS)                                                                                              AS TOTAL_PHYSICAL_READS,
                AVG(LAST_PHYSICAL_READS)                                                                                               AS LAST_PHYSICAL_READS,
                MIN(MIN_PHYSICAL_READS)                                                                                                AS MIN_PHYSICAL_READS,
                MAX(MAX_PHYSICAL_READS)                                                                                                AS MAX_PHYSICAL_READS,
                SUM(TOTAL_LOGICAL_READS)                                                                                               AS TOTAL_LOGICAL_READS,
                AVG(LAST_LOGICAL_READS)                                                                                                AS LAST_LOGICAL_READS,
                MIN(MIN_LOGICAL_READS)                                                                                                 AS MIN_LOGICAL_READS,
                MAX(MAX_LOGICAL_READS)                                                                                                 AS MAX_LOGICAL_READS,
                SUM(TOTAL_LOGICAL_WRITES)                                                                                              AS TOTAL_LOGICAL_WRITES,
                AVG(LAST_LOGICAL_WRITES)                                                                                               AS LAST_LOGICAL_WRITES,
                MIN(MIN_LOGICAL_WRITES)                                                                                                AS MIN_LOGICAL_WRITES,
                MAX(MAX_LOGICAL_WRITES)                                                                                                AS MAX_LOGICAL_WRITES,
                CAST(AVG(LAST_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                               AS LAST_WORKER_TIME,
                CAST(MIN(MIN_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                                AS MIN_WORKER_TIME,
                CAST(MAX(MAX_WORKER_TIME) / 1000.000 AS DECIMAL(29, 3))                                                                AS MAX_WORKER_TIME
         FROM   QUERY_STATS QS WITH (NOLOCK)
         GROUP  BY QS.SERVER_NAME,
                   QS.DATABASE_NAME,
                   QS.STATS_TIME,
                   QS.QUERY_HASH,
                   QS.QUERY_PLAN_HASH)
-------------------------------------------------
SELECT CTE.SERVER_NAME,
       CTE.DATABASE_NAME,
       CTE.COMPILED_TIME,
       CTE.EXECUTION_COUNT,
       CTE.EXECUTION_COUNT / CASE ( Datediff(HOUR, CTE.COMPILED_TIME, CTE.STATS_TIME) )
                               WHEN 0 THEN 1
                               ELSE ( Datediff(HOUR, CTE.COMPILED_TIME, CTE.STATS_TIME) )
                             END                                                                                                                                                            AS EXECUTION_PER_HOUR,
       CTE.TOTAL_ELAPSED_TIME,
       CTE.AVG_ELAPSED_TIME,
       CTE.MAX_ELAPSED_TIME,
       CTE.AVG_LOGICAL_READS,
	   CTE.AVG_LOGICAL_READS_MB,
       CTE.TOTAL_WAIT_TIME,
       AVG_ROWS_RETURNED,
       REPLACE(REPLACE(REPLACE(QT.SQL_TEXT, 'SELECT ', CHAR(10)+'SELECT '), ' FROM', CHAR(10)+' FROM'), ' WHERE', CHAR(10)+ ' WHERE')
       + Char(10) + Char(10) + REPLICATE('-',50) + 'QUERY PARAMETERS'+ REPLICATE('-',61)+CHAR(10)  +QP.SQL_PARMS + CHAR(10)+ CHAR(10)+ 
	   REPLICATE('-',50)+'TABLE NODES FROM QUERY PLAN' + REPLICATE('-',50) + Char(10) + Isnull((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE CTE.SERVER_NAME = QPV.SERVER_NAME AND CTE.DATABASE_NAME = QPV.DATABASE_NAME AND CTE.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '') AS QUERY_PLAN_PARSED,
	    ISNULL((SELECT MISSING_INDEX_INFO FROM QUERY_PLANS_MISSING_INDEX_VW QPV WHERE CTE.SERVER_NAME = QPV.SERVER_NAME AND CTE.DATABASE_NAME = QPV.DATABASE_NAME AND CTE.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS MISSING_INDEXES,
       QP.SQL_PARMS                                                                                                                                                                         AS QUERY_PARAMETER_VALUES,
       QP.QUERY_PLAN,
       CTE.QUERY_HASH,
       CTE.QUERY_PLAN_HASH,
       QT.SQL_TEXT                                                                                                                                                                          AS SQL_TEXT,
       CTE.TOTAL_ROWS,
       CTE.MAX_ROWS,
       CTE.MIN_ROWS,
       CTE.PLAN_GENERATION_NUM,
       CTE.LAST_EXECUTION_TIME,
       CTE.TOTAL_WORKER_TIME,
       CTE.AVG_PHYSICAL_READS,
       CTE.AVG_LOGICAL_WRITES,
       CTE.LAST_ELAPSED_TIME,
       CTE.MIN_ELAPSED_TIME,
       CTE.TOTAL_PHYSICAL_READS,
       CTE.LAST_PHYSICAL_READS,
       CTE.MIN_PHYSICAL_READS,
       CTE.MAX_PHYSICAL_READS,
       CTE.TOTAL_LOGICAL_READS,
       CTE.LAST_LOGICAL_READS,
       CTE.MIN_LOGICAL_READS,
       CTE.MAX_LOGICAL_READS,
       CTE.TOTAL_LOGICAL_WRITES,
       CTE.LAST_LOGICAL_WRITES,
       CTE.MIN_LOGICAL_WRITES,
       CTE.MAX_LOGICAL_WRITES,
       CTE.LAST_WORKER_TIME,
       CTE.MIN_WORKER_TIME,
       CTE.MAX_WORKER_TIME,
       QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN),
	   CTE.STATS_TIME,
       C.COMMENT
FROM   STATS_CTE CTE
       LEFT OUTER LOOP JOIN QUERY_PLANS QP WITH (NOLOCK)
                    ON QP.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH
                       AND QP.SERVER_NAME = CTE.SERVER_NAME
                       AND QP.DATABASE_NAME = CTE.DATABASE_NAME
       LEFT OUTER LOOP JOIN QUERY_TEXT AS QT
                         ON CTE.QUERY_HASH = QT.QUERY_HASH
                            AND CTE.SERVER_NAME = QT.SERVER_NAME
                            AND CTE.DATABASE_NAME = QT.DATABASE_NAME
       LEFT OUTER LOOP JOIN COMMENTS C
                         ON CTE.QUERY_HASH = C.QUERY_HASH
                            AND CTE.SERVER_NAME = C.SERVER_NAME
                            AND CTE.DATABASE_NAME = C.DATABASE_NAME
GO
PRINT N'Refreshing [dbo].[HIDDEN_SCANS_CURR_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[HIDDEN_SCANS_CURR_VW]';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Refreshing [dbo].[USER_SCANS_CURR_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[USER_SCANS_CURR_VW]';


GO
PRINT N'Altering [dbo].[SERVERINFO_VW]...';


GO

ALTER VIEW [dbo].[SERVERINFO_VW]
AS

SELECT [SERVER_NAME],
       [STATS_TIME],
       [SQL_SERVER_STARTTIME],
       [PHYSICALCOMPUTERNAME],
       CASE [ISCLUSTERED]
         WHEN 0 THEN 'N0'
         ELSE 'YES'
       END                             AS CLUSTERED_SERVER,
       [MACHINENAME],
       [INSTANCENAME],
       [PRODUCTVERSION],
       [PRODUCTLEVEL],
       [EDITION],
       [ENGINEEDITION],
       [SQLCHARSET],
       [SQLCHARSETNAME],
       [SQLSORTORDER],
       [SQLSORTORDERNAME],
       [SQL_SCHEDULER_COUNT],
       [CPU_COUNT]                     AS TOTAL_CORES,
       [HYPERTHREAD_RATIO]             AS CORES_PER_SOCKET,
       [CPU_COUNT] / HYPERTHREAD_RATIO AS TOTAL_SOCKETS,
       [BPOOL_COMMITTED_MB],
       [BPOOL_COMMIT_TARGET_MB],
       [BPOOL_VISIBLE_MB]
FROM   [SERVERINFO] S
GO
PRINT N'Creating [dbo].[INDEX_HISTOGRAM_SUMMARY_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;

/****** Object:  View [dbo].[INDEX_HISTOGRAM_SUMMARY_VW]    Script Date: 01/11/2017 13:51:10 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[INDEX_HISTOGRAM_SUMMARY_VW]'))
DROP VIEW [dbo].[INDEX_HISTOGRAM_SUMMARY_VW]
GO


/****** Object:  View [dbo].[MISSING_INDEXES_HISTORY_VW]    Script Date: 01/11/2017 13:53:21 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[MISSING_INDEXES_HISTORY_VW]'))
DROP VIEW [dbo].[MISSING_INDEXES_HISTORY_VW]
GO

GO
CREATE VIEW [dbo].[INDEX_HISTOGRAM_SUMMARY_VW]
	AS 

	SELECT SERVER_NAME,
       DATABASE_NAME,
       TABLE_NAME,
       COLUMN_NAME,
       MIN(EQ_ROWS)   AS MIN_ROWS,
       AVG(EQ_ROWS)   AS AVG_ROWS,
       MAX(EQ_ROWS)   AS MAX_ROWS

FROM   INDEX_HISTOGRAM
WHERE  INDEX_NAME LIKE '_WA%'
GROUP  BY SERVER_NAME,
          DATABASE_NAME,
          TABLE_NAME,
          COLUMN_NAME
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[INDEX_KEY_ORDER_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;



/****** Object:  View [dbo].[INDEX_KEY_ORDER_VW]    Script Date: 01/19/2017 09:12:20 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[INDEX_KEY_ORDER_VW]'))
DROP VIEW [dbo].[INDEX_KEY_ORDER_VW]
GO


GO
CREATE VIEW [dbo].[INDEX_KEY_ORDER_VW]
AS
	 WITH CTE (SERVER_NAME, DATABASE_NAME, TABLENAME, INDEXNAME, ROWS, KEYCOLUMN, COLUMNS, PREV_COL)
       AS (SELECT IDV.SERVER_NAME,
                  IDV.DATABASE_NAME,
                  TABLENAME,
                  INDEXNAME,
                  Cast(1 / DENSITY AS BIGINT)                                        AS ROWS,
                  Replace(Replace(COLUMNS, Lag(COLUMNS, 1, '')
                                             OVER (
                                               PARTITION BY TABLENAME, INDEXNAME
                                               ORDER BY Len(COLUMNS)), ''), ',', '') AS KEYCOLUMN,
                  COLUMNS,
                  Lag(COLUMNS, 1, '')
                    OVER (
                      PARTITION BY TABLENAME, INDEXNAME
                      ORDER BY Len(COLUMNS))                                         AS PREV_COL
           FROM   INDEX_DENSITY_VECTOR IDV
                  INNER JOIN INDEX_STATS_CURR_VW CV
                          ON IDV.DATABASE_NAME = CV.DATABASE_NAME
                             AND IDV.TABLENAME = CV.TABLE_NAME
                             AND IDV.INDEXNAME = CV.INDEX_NAME
                             --WHERE  IDV.TABLENAME = 'INVENTTRANS'
                             AND Len(IDV.COLUMNS) <= Len(CV.INDEX_KEYS) --REH for places where SQL has added the clustered index columns to the density vector
                             AND INDEXNAME NOT LIKE '_wa%') --REH Auto Stats indexes
  SELECT SERVER_NAME,
         DATABASE_NAME,
         TABLENAME,
         INDEXNAME,
         ROWS,
         KEYCOLUMN,
         COLUMNS,
         CASE KEYCOLUMN
           WHEN 'PARTITION' THEN -2
           WHEN 'DATAAREAID' THEN -1
           ELSE Cast (ROWS - Lag(ROWS, 1, 0)
                               OVER (
                                 PARTITION BY TABLENAME, INDEXNAME
                                 ORDER BY Len(COLUMNS)) AS BIGINT)
         END AS TOTAL_ROWS
  FROM   CTE
--ORDER BY TABLENAME,INDEXNAME, TOTAL_ROWS DESC
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[MISSING_INDEXES_HISTORY_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
CREATE VIEW [dbo].[MISSING_INDEXES_HISTORY_VW]
	AS 

WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)

SELECT QH.SERVER_NAME,
       QH.DATABASE_NAME,
       QH.FLAG,
       QH.DATE,
       QH.EXECUTION_COUNT_TODAY                                                                                                                                                                AS EXECUTION_COUNT,
       Cast(QH.ELAPSED_TIME_TODAY / 1000.000 AS DECIMAL(29, 3))                                                                                                                                AS TOTAL_ELAPSED_TIME,
       QH.AVG_TIME_TODAY_MS                                                                                                                                                                    AS AVG_ELAPSED_TIME,
       Cast(MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                                                                                                     AS MAX_ELAPSED_TIME,
       AVG_LOGICAL_READS = QH.TOTAL_LOGICAL_READS_TODAY / QH.EXECUTION_COUNT_TODAY,
       AVG_ROWS_RETURNED = qh.TOTAL_ROWS_TODAY / EXECUTION_COUNT_TODAY,
       index_nodeS.value('(../@Impact)[1]', 'float')                                                                                                                                           AS INDEX_IMPACT,
       Replace(Replace(index_nodeS.value('(./@Table)[1]', 'NVARCHAR(128)'), '[', ''), ']', '')                                                                                                 AS TABLE_NAME,
       Replace(Replace(Replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in ./sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "EQUALITY"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '')                                                                          AS EQUALITY_COLUMNS,
       Replace(Replace(Replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in ./sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "INEQUALITY"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '')                                                                          AS INEQUALITY_COLUMNS,
       Replace(Replace(Replace(CONVERT(NVARCHAR(max), index_nodeS.query('for $colgroup in .//sp:ColumnGroup,
                                                $col in $colgroup/sp:Column
                                                where $colgroup/@Usage = "INCLUDE"
                                                return string($col/@Name)')), '] [', ', '), '[', ''), ']', '')                                                                          AS INCLUDED_COLUMNS,
       QP.SQL_PARMS                                                                                                                                                                            AS QUERY_PARAMETER_VALUES,
       Replace(Replace(QT.SQL_TEXT, 'SELECT ', Char(10)+'SELECT '), ' FROM', Char(10)+' FROM')
       + Char(10) + Char(10) + Replicate('-', 50)
       + 'QUERY PARAMETERS' + Replicate('-', 61)
       + Char(10) + QP.SQL_PARMS + Char(10) + Char(10)
       + Replicate('-', 50)
       + 'TABLE NODES FROM QUERY PLAN'
       + Replicate('-', 50) + Char(10)
       + Isnull((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE QH.SERVER_NAME = QPV.SERVER_NAME AND QH.DATABASE_NAME = QPV.DATABASE_NAME AND QH.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '') AS QUERY_PLAN_PARSED,
       QUERY_PLAN,
       QT.SQL_TEXT                                                                                                                                                                             AS SQL_TEXT,
       QH.QUERY_HASH,
       QH.QUERY_PLAN_HASH
FROM   QUERY_HISTORY QH
       INNER JOIN QUERY_PLANS QP
               ON QH.SERVER_NAME = QP.SERVER_NAME
                  AND QH.DATABASE_NAME = QP.DATABASE_NAME
                  AND QH.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
                  AND QP.MI_FLAG = 1
       CROSS APPLY QP.QUERY_PLAN.nodes('//sp:MissingIndexes/sp:MissingIndexGroup/sp:MissingIndex') AS missing_indexes(index_nodeS)
       LEFT OUTER JOIN QUERY_TEXT AS QT
                    ON QH.QUERY_HASH = QT.QUERY_HASH
                       AND QH.DATABASE_NAME = QT.DATABASE_NAME
                       AND QH.SERVER_NAME = QT.SERVER_NAME
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[QUERY_STATS_CTE_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;



/****** Object:  View [dbo].[QUERY_STATS_CTE_VW]    Script Date: 01/19/2017 09:12:45 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[QUERY_STATS_CTE_VW]'))
DROP VIEW [dbo].[QUERY_STATS_CTE_VW]
GO



GO
CREATE VIEW [dbo].[QUERY_STATS_CTE_VW]
	AS 
	
	
WITH CTE_STATS (SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME, STATS_TIME, PREV_STATS_TIME, PREV_CREATION_TIME, PREV_ELAPSED_TIME, PREV_EXECUTION_COUNT, EXECUTION_COUNT, TOTAL_WORKER_TIME, TOTAL_ELAPSED_TIME, PREV_TOTAL_WORKER_TIME, TIME_THIS_PERIOD, WORKER_TIME_THIS_PERIOD, EXECUTIONS_THIS_PERIOD)
     AS (SELECT DISTINCT SERVER_NAME,
                         DATABASE_NAME,
                         QUERY_HASH,
                         QUERY_PLAN_HASH,

                         CREATION_TIME,
                         [STATS_TIME],
                         LAG(STATS_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_STATS_TIME,
                         LAG(CREATION_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_CREATION_TIME,
                         
                         LAG(TOTAL_ELAPSED_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_ELAPSED_TIME,
                         LAG(EXECUTION_COUNT, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_EXECUTION_COUNT,
                         EXECUTION_COUNT,
                         TOTAL_WORKER_TIME,
                         TOTAL_ELAPSED_TIME,
                         LAG(TOTAL_WORKER_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_TOTAL_WORKER_TIME,
                         TOTAL_ELAPSED_TIME - LAG(TOTAL_ELAPSED_TIME, 1, 0)
                                                OVER (
                                                  PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                                                  ORDER BY STATS_TIME ) AS TIME_THIS_PERIOD,
                         TOTAL_WORKER_TIME - LAG(TOTAL_WORKER_TIME, 1, 0)
                                               OVER (
                                                 PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                                                 ORDER BY STATS_TIME )  AS WORKER_TIME_THIS_PERIOD,
                         EXECUTION_COUNT - LAG(EXECUTION_COUNT, 1, 0)
                                             OVER (
                                               PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                                               ORDER BY STATS_TIME )    AS EXECUTIONS_THIS_PERIOD
         FROM   QUERY_STATS

         WHERE  QUERY_HASH <> 0x0000000000000000)


   SELECT CTE.SERVER_NAME,
          CTE.DATABASE_NAME,
          CTE.QUERY_HASH,
          CTE.QUERY_PLAN_HASH,
          QT.SQL_TEXT,
          QP.QUERY_PLAN,
          REPLACE(REPLACE(REPLACE(QT.SQL_TEXT, 'SELECT ', CHAR(10)+'SELECT '), ' FROM', CHAR(10)+' FROM'), ' WHERE', CHAR(10)+ ' WHERE')
          + CHAR(10) + CHAR(10) + REPLICATE('-', 50)
          + 'QUERY PARAMETERS' + REPLICATE('-', 61)
          + CHAR(10) + QP.SQL_PARMS + CHAR(10) + CHAR(10)
          + REPLICATE('-', 50)
          + 'TABLE NODES FROM QUERY PLAN'
          + REPLICATE('-', 50) + CHAR(10)
          + ISNULL((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE CTE.SERVER_NAME = QPV.SERVER_NAME AND CTE.DATABASE_NAME = QPV.DATABASE_NAME AND CTE.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '') AS QUERY_PLAN_PARSED,
          ISNULL((SELECT MISSING_INDEX_INFO
                  FROM   QUERY_PLANS_MISSING_INDEX_VW QPV
                  WHERE  CTE.SERVER_NAME = QPV.SERVER_NAME
                         AND CTE.DATABASE_NAME = QPV.DATABASE_NAME
                         AND CTE.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '')                                                                                                                         AS MISSING_INDEXES,
          QP.SQL_PARMS                                                                                                                                                                               AS QUERY_PARAMETER_VALUES,
          CREATION_TIME,
          STATS_TIME,
          PREV_STATS_TIME,
          PREV_CREATION_TIME,
          PREV_ELAPSED_TIME,
          PREV_EXECUTION_COUNT,
          EXECUTION_COUNT,
          TOTAL_WORKER_TIME,
          TOTAL_ELAPSED_TIME,
          PREV_TOTAL_WORKER_TIME,
          TIME_THIS_PERIOD,
          WORKER_TIME_THIS_PERIOD,
          EXECUTIONS_THIS_PERIOD
   FROM   CTE_STATS CTE
          LEFT OUTER LOOP JOIN QUERY_TEXT QT
                            ON QT.QUERY_HASH = CTE.QUERY_HASH
                               AND QT.SERVER_NAME = CTE.SERVER_NAME
          LEFT OUTER LOOP JOIN QUERY_PLANS QP WITH (NOLOCK)
                            ON QP.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH
                               AND QP.SERVER_NAME = CTE.SERVER_NAME
                               AND QP.DATABASE_NAME = CTE.DATABASE_NAME
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_AX_NUMBERSEQUENCE]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_AX_NUMBERSEQUENCE (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @ROW_COUNT BIGINT
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/


--REH All versions have this table so it's here in the code
-- version specific synonyms are in the appropriate AX version below


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCETABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCETABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCETABLE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCETABLE
				FOR [' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCETABLE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 











/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 




BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


--REH Get AX version

DECLARE @AX_SERVER_NAME   NVARCHAR(128) = NULL,
        @AX_DATABASE_NAME NVARCHAR(128),
        @AX_APP_BUILD     NVARCHAR(120),
        @KERNEL_BUILD     NVARCHAR(20)
   
   CREATE TABLE #AX_VERSION_NUM
     (
        AX_APP_BUILD NVARCHAR(120),
        KERNEL_BUILD NVARCHAR(20)
     )
   
   SET NOCOUNT ON
   
   INSERT #AX_VERSION_NUM
   EXECUTE DYNPERF_AX_VERSION_INFO
     @AX_SERVER_NAME = @SERVER_NAME,
     @AX_DATABASE_NAME = @DATABASE_NAME--, @DEBUG = 'N'
   SELECT @AX_APP_BUILD = AX_APP_BUILD,
          @KERNEL_BUILD = KERNEL_BUILD
   FROM   #AX_VERSION_NUM
   
   --PRINT 'AX BUILD = ' + ISNULL(@AX_APP_BUILD, '')
   
   --PRINT 'KERNEL BUILD = '+ ISNULL(@KERNEL_BUILD, '')
   
   IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = '#AX_VERSION_NUM') 
	BEGIN
	  DROP TABLE #AX_VERSION_NUM 
	END
   
   
  
IF Substring(@AX_APP_BUILD, 1, 1) BETWEEN N'4' AND N'5'
BEGIN



--REH  Have to check if the NUMBERSEQUENCETABLE is shared or not, aka. does DATAAREAID exist in the table

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSTABLES')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSTABLES')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSTABLES
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.tables'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSTABLES
				FOR [' + @DATABASE_NAME + '].sys.tables'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSCOLUMNS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSCOLUMNS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.columns'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_SYSCOLUMNS
				FOR [' + @DATABASE_NAME + '].sys.columns'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL) 


		--REH store data by company, most common scenario
		IF EXISTS (SELECT * FROM DYN_AXNUM_SYSTABLES t INNER JOIN DYN_AXNUM_SYSCOLUMNS c
		ON t.object_id=c.object_id
		WHERE t.name = 'NUMBERSEQUENCETABLE' AND c.name = 'DATAAREAID') 
		BEGIN
			INSERT INTO AX_NUM_SEQUENCES
			SELECT @SERVER_NAME,
				   @STATS_DATE,
				   @DATABASE_NAME,
				   0,
				   NUMBERSEQUENCE,
				   TXT,
				   LOWEST,
				   HIGHEST,
				   NEXTREC,
				   0,
				   0,
				   CASE CONTINUOUS
					 WHEN 0 THEN 'No'
					 WHEN 1 THEN 'Yes'
				   END,
				   FETCHAHEAD,
				   FETCHAHEADQTY,
				   0,
				   0,
				   NULL,
				   NULL,
				   DATAAREAID,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   FORMAT
			FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE 


		END
		ELSE
		BEGIN
		
			INSERT INTO AX_NUM_SEQUENCES
			SELECT @SERVER_NAME,
				   @STATS_DATE,
				   @DATABASE_NAME,
				   0,
				   NUMBERSEQUENCE,
				   TXT,
				   LOWEST,
				   HIGHEST,
				   NEXTREC,
				   0,
				   0,
				   CASE CONTINUOUS
					 WHEN 0 THEN 'No'
					 WHEN 1 THEN 'Yes'
				   END,
				   FETCHAHEAD,
				   FETCHAHEADQTY,
				   0,
				   0,
				   NULL,
				   NULL,
				   '',			--blank out dataareid, field doesn't exist
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   NULL,
				   FORMAT
			FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE 


		
		END

		SET @ROW_COUNT = @@ROWCOUNT
	
END

--REH Synonyms for all version of AX2012 --------------------------------------------------

IF Substring(@AX_APP_BUILD, 1, 1) = '6'
BEGIN
	

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
 EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.DATAAREA'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @DATABASE_NAME + '].dbo.DATAAREA'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)
	
END



IF Substring(@AX_APP_BUILD, 1, 1) = '7'
BEGIN
	

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_NUMBERSEQUENCESCOPE
				FOR [' + @DATABASE_NAME + '].dbo.NUMBERSEQUENCESCOPE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.DATAAREA'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DATAAREA
				FOR [' + @DATABASE_NAME + '].dbo.DATAAREA'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARPERIOD
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARPERIOD'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_FISCALCALENDARYEAR
				FOR [' + @DATABASE_NAME + '].dbo.FISCALCALENDARYEAR'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)
	
		
	
	
PRINT ''	
END

-------------------------------------------End of AX2012 common synonyms -------------------


IF Substring(@AX_APP_BUILD, 1, 3) = '6.0'
BEGIN




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_COMPANYINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_COMPANYINFO')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_COMPANYINFO
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.COMPANYINFO'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_COMPANYINFO
				FOR [' + @DATABASE_NAME + '].dbo.COMPANYINFO'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)




IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_OMOPERATINGUNIT')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_OMOPERATINGUNIT')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_OMOPERATINGUNIT
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.OMOPERATINGUNIT'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_OMOPERATINGUNIT
				FOR [' + @DATABASE_NAME + '].dbo.OMOPERATINGUNIT'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

INSERT INTO AX_NUM_SEQUENCES
SELECT @SERVER_NAME,
       @STATS_DATE,
       @DATABASE_NAME,
       NST.RECID,
       NST.NUMBERSEQUENCE                                                                                                                                 AS [NumberSequence],
       NST.TXT                                                                                                                                            AS [Text],
       NST.LOWEST,
       NST.HIGHEST,
       NST.NEXTREC,
       CAST (( CAST(( NST.HIGHEST - NST.NEXTREC ) AS DECIMAL(20, 2)) / ( CAST(( NST.HIGHEST - NST.LOWEST ) AS DECIMAL(20, 2)) ) * 100 ) AS DECIMAL(6, 2)) AS [PercentRemaining],
       NST.HIGHEST - NST.NEXTREC                                                                                                                          AS [NumbersRemaining],
       CASE NST.CONTINUOUS
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Continuous],
       NST.FETCHAHEAD                                                                                                                                     AS FetchAhead,
       NST.FETCHAHEADQTY                                                                                                                                  AS FetchAheadQty,
       NST.CLEANINTERVAL                                                                                                                                  AS CleanInterval,
       NST.CLEANATACCESS                                                                                                                                  AS CleanAtAccess,
       'N/A'                                                                                                                                              AS [PartitionName],
       NST.NUMBERSEQUENCESCOPE,
       DA.ID                                                                                                                                              [CompanyId],
       DA.NAME                                                                                                                                            [CompanyName],
       CASE DA.ISVIRTUAL
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Shared],
       CI.DATAAREA                                                                                                                                        [LegalEntityName],
       CASE OU.OMOPERATINGUNITTYPE
         WHEN 0 THEN 'None'
         WHEN 1 THEN 'Department'
         WHEN 2 THEN 'Cost center'
         WHEN 3 THEN 'Value stream'
         WHEN 4 THEN 'Business unit'
         WHEN 5 THEN 'All operating units'
         WHEN 6 THEN 'Retail channel'
       END                                                                                                                                                [OperatingUnitType],
       OU.OMOPERATINGUNITNUMBER                                                                                                                           [OperatingUnitNumber],
       FC.CALENDARID                                                                                                                                      [FiscalCalendar],
       FCY.NAME                                                                                                                                           [FiscalCalendarYear],
       FCP.NAME                                                                                                                                           [Period],
       NST.FORMAT
FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE NST
       JOIN DYN_AXNUM_AX_NUMBERSEQUENCESCOPE NSS
         ON NSS.RECID = NST.NUMBERSEQUENCESCOPE
       LEFT JOIN DYN_AXNUM_AX_DATAAREA DA
              ON NSS.DATAAREA = DA.ID
       LEFT JOIN DYN_AXNUM_AX_COMPANYINFO CI
              ON NSS.LEGALENTITY = CI.RECID
       LEFT JOIN DYN_AXNUM_AX_OMOPERATINGUNIT OU
              ON NSS.OPERATINGUNIT = OU.RECID
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARPERIOD FCP
              ON NSS.FISCALCALENDARPERIOD = FCP.RECID
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDAR FC
              ON FC.RECID = FCP.FISCALCALENDAR
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARYEAR FCY
              ON FCY.RECID = FCP.FISCALCALENDARYEAR

	
	SET @ROW_COUNT = @@ROWCOUNT
END
	
IF Substring(@AX_APP_BUILD, 1, 3) IN ( '6.2', '6.3', '7.0')
BEGIN
	


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_PARTITIONS')
  EXEC('DROP SYNONYM [dbo].DYN_AXNUM_AX_PARTITIONS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_PARTITIONS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.PARTITIONS'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_PARTITIONS
				FOR [' + @DATABASE_NAME + '].dbo.PARTITIONS'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DIRPARTYTABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DIRPARTYTABLE')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DIRPARTYTABLE
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.DIRPARTYTABLE'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_AXNUM_AX_DIRPARTYTABLE
				FOR [' + @DATABASE_NAME + '].dbo.DIRPARTYTABLE'

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

EXEC (@SQL)

INSERT INTO AX_NUM_SEQUENCES
SELECT @SERVER_NAME,
       @STATS_DATE,
       @DATABASE_NAME,
       NST.RECID,
       NST.NUMBERSEQUENCE                                                                                                                                 AS [NumberSequence],
       NST.TXT                                                                                                                                            AS [Text],
       NST.LOWEST,
       NST.HIGHEST,
       NST.NEXTREC,
       CAST (( CAST(( NST.HIGHEST - NST.NEXTREC ) AS DECIMAL(20, 2)) / ( CAST(( NST.HIGHEST - NST.LOWEST ) AS DECIMAL(20, 2)) ) * 100 ) AS DECIMAL(6, 2)) AS [PercentRemaining],
       NST.HIGHEST - NST.NEXTREC                                                                                                                          AS [NumbersRemaining],
       CASE NST.CONTINUOUS
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Continuous],
       NST.FETCHAHEAD                                                                                                                                     AS FetchAhead,
       NST.FETCHAHEADQTY                                                                                                                                  AS FetchAheadQty,
       NST.CLEANINTERVAL                                                                                                                                  AS CleanInterval,
       NST.CLEANATACCESS                                                                                                                                  AS CleanAtAccess,
       P.NAME                                                                                                                                             AS [PartitionName],
       NST.NUMBERSEQUENCESCOPE,
       DA.ID                                                                                                                                              [CompanyId],
       DA.NAME                                                                                                                                            [CompanyName],
       CASE DA.ISVIRTUAL
         WHEN 0 THEN 'No'
         WHEN 1 THEN 'Yes'
       END                                                                                                                                                [Shared],
       DI.DATAAREA                                                                                                                                        [LegalEntityName],
       CASE DI.OMOPERATINGUNITTYPE
         WHEN 0 THEN 'None'
         WHEN 1 THEN 'Department'
         WHEN 2 THEN 'Cost center'
         WHEN 3 THEN 'Value stream'
         WHEN 4 THEN 'Business unit'
         WHEN 5 THEN 'All operating units'
         WHEN 6 THEN 'Retail channel'
       END                                                                                                                                                [OperatingUnitType],
       DI.OMOPERATINGUNITNUMBER                                                                                                                           [OperatingUnitNumber],
       FC.CALENDARID                                                                                                                                      [FiscalCalendar],
       FCY.NAME                                                                                                                                           [FiscalCalendarYear],
       FCP.NAME                                                                                                                                           [Period],
       NST.FORMAT
FROM   DYN_AXNUM_AX_NUMBERSEQUENCETABLE NST
       JOIN DYN_AXNUM_AX_PARTITIONS P
         ON NST.PARTITION = P.RECID
       JOIN DYN_AXNUM_AX_NUMBERSEQUENCESCOPE NSS
         ON NSS.RECID = NST.NUMBERSEQUENCESCOPE
       LEFT JOIN DYN_AXNUM_AX_DATAAREA DA
              ON NSS.DATAAREA = DA.ID
			  and NST.PARTITION = DA.PARTITION
       LEFT JOIN DYN_AXNUM_AX_DIRPARTYTABLE DI
              ON ( NSS.LEGALENTITY = DI.RECID )
                  OR ( NSS.OPERATINGUNIT = DI.RECID )
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARPERIOD FCP
              ON NSS.FISCALCALENDARPERIOD = FCP.RECID
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDAR FC
              ON FC.RECID = FCP.FISCALCALENDAR
       LEFT JOIN DYN_AXNUM_AX_FISCALCALENDARYEAR FCY
              ON FCY.RECID = FCP.FISCALCALENDARYEAR


	SET @ROW_COUNT = @@ROWCOUNT

END
    


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + cast(@ROW_COUNT as varchar(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)


PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


--REH Drop all synonyms

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCETABLE')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSTABLES')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSTABLES')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSCOLUMNS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
 EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_COMPANYINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_COMPANYINFO')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_OMOPERATINGUNIT')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_OMOPERATINGUNIT')



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_PARTITIONS')
  EXEC('DROP SYNONYM [dbo].DYN_AXNUM_AX_PARTITIONS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DIRPARTYTABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DIRPARTYTABLE')




RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/




BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

--REH Drop all synonyms

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCETABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCETABLE')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSTABLES')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSTABLES')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_SYSCOLUMNS')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_SYSCOLUMNS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
 EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_NUMBERSEQUENCESCOPE')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DATAAREA')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DATAAREA')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARPERIOD')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARPERIOD')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDAR')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_FISCALCALENDARYEAR')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_FISCALCALENDARYEAR')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_COMPANYINFO')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_COMPANYINFO')


IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_OMOPERATINGUNIT')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_OMOPERATINGUNIT')



IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_PARTITIONS')
  EXEC('DROP SYNONYM [dbo].DYN_AXNUM_AX_PARTITIONS')

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_AXNUM_AX_DIRPARTYTABLE')
  EXEC ('DROP SYNONYM [dbo].DYN_AXNUM_AX_DIRPARTYTABLE')





    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_PURGE_DATA]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PURGE_DATA]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


SET NOCOUNT ON
SET DATEFORMAT MDY
DECLARE @PURGE_DATE smalldatetime, @PURGE_DAYS INT, @SQL NVARCHAR(MAX), @ROW_COUNT BIGINT = 0


DECLARE  @C_TABLE_NAME NVARCHAR(128), @C_TIME_COLUMN NVARCHAR(128), @C_SERVER_FLAG BIT, @C_DATABASE_FLAG BIT, @C_PURGE_DAYS INT
DECLARE @DC_SERVER_NAME NVARCHAR(128), @DC_DATABASE_NAME NVARCHAR(128), @DC_HISTORY_MONTHS INT, @DC_HISTORY_DAYS INT, @DC_DETAILS_DAYS INT






/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''




DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT TABLE_NAME, TIME_COLUMN, SERVER_NAME_FLAG, DATABASE_NAME_FLAG, RETENTION_DAYS
FROM   DynamicsPerf..[DYNPERF_PURGETABLES] WHERE TIME_COLUMN > ''  ---REH Ignore tables without some form of time column.  The collection sproc will handle deletion of data in those tables
ORDER BY RETENTION_DAYS, TABLE_NAME    --REH this sort is to force QUERY_STATS to delete before QUERY_PLANS/QUERY_TEXT so we don't wait a day to delete records not attached to data



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TABLE_NAME, @C_TIME_COLUMN, @C_SERVER_FLAG, @C_DATABASE_FLAG, @C_PURGE_DAYS


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */



	SET @PURGE_DAYS = @C_PURGE_DAYS * -1  --set to negative so we go back in time not forward in time
	SET @PURGE_DATE = DATEADD(DD,@PURGE_DAYS,GETDATE())



	UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PURGING TABLE ' + ISNULL(@C_TABLE_NAME, 'TABLE ')
              + ' using PURGE_DAYS ' + CAST(@PURGE_DAYS AS VARCHAR(10)) + ' on DATE '
              + CONVERT(VARCHAR, @PURGE_DATE, 109) + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




IF @C_TABLE_NAME IN ('QUERY_PLANS', 'QUERY_TEXT')  --REH Use special handling for QUERY_PLANS and QUERY_TEXT TABLE delete based on no dependent records
BEGIN
--REH All associated records in other tables must be deleted first, QUERY_STATS, QUERY_HISTORY, ETC

		IF @C_TABLE_NAME = 'QUERY_PLANS'
		BEGIN

				SELECT DISTINCT QP.SERVER_NAME, QP.DATABASE_NAME, QP.QUERY_PLAN_HASH
				INTO #QP1
					 FROM QUERY_PLANS QP WHERE QP.SERVER_NAME = @SERVER_NAME AND
				 NOT EXISTS (SELECT QS.QUERY_PLAN_HASH FROM QUERY_STATS QS WHERE QS.DATABASE_NAME = QP.DATABASE_NAME AND QS.SERVER_NAME = QP.SERVER_NAME AND QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH) 
					AND NOT EXISTS (SELECT QUERY_PLAN_HASH FROM QUERY_HISTORY QH WHERE QH.DATABASE_NAME = QP.DATABASE_NAME AND QH.SERVER_NAME = QP.SERVER_NAME AND QP.QUERY_PLAN_HASH = QH.QUERY_PLAN_HASH) 
				
				DELETE QP FROM QUERY_PLANS QP INNER JOIN #QP1 ON  QP.SERVER_NAME = #QP1.SERVER_NAME 
					AND QP.DATABASE_NAME = #QP1.DATABASE_NAME AND QP.QUERY_PLAN_HASH = #QP1.QUERY_PLAN_HASH
		
				DROP TABLE #QP1


			--REH Delete any plans over the minimum number of plans to keep
				
				SELECT A.*
				INTO #DEL_PLANS
				FROM (
				SELECT DISTINCT QV.SERVER_NAME,
										QV.DATABASE_NAME,
										QUERY_HASH,
										QV.QUERY_PLAN_HASH,
										RN = ROW_NUMBER()
									  OVER (
										PARTITION BY QV.QUERY_HASH
										ORDER BY QV.QUERY_HASH DESC, QP.DATE_UPDATED DESC)
						FROM   QUERY_HISTORY_VW QV INNER JOIN QUERY_PLANS QP ON QV.SERVER_NAME=QP.SERVER_NAME
						AND QV.DATABASE_NAME = QP.DATABASE_NAME AND QV.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
						WHERE QV.DATE = DATEADD(MONTH, DATEDIFF(MONTH, 0, GETDATE()  ), 0) 

				   ) AS A 
				   INNER JOIN QUERY_PLANS QP ON QP.SERVER_NAME = A.SERVER_NAME AND QP.DATABASE_NAME = A.DATABASE_NAME AND QP.QUERY_PLAN_HASH = A.QUERY_PLAN_HASH
				   WHERE A.RN> (SELECT D2.NUM_PLANS_TO_KEEP FROM DATABASES_2_COLLECT D2 WHERE D2.LINKED_SERVER=A.SERVER_NAME AND D2.DATABASE_NAME = A.DATABASE_NAME)

					DELETE QP FROM QUERY_PLANS QP INNER JOIN #DEL_PLANS DP ON QP.SERVER_NAME = DP.SERVER_NAME
					AND QP.DATABASE_NAME = DP.DATABASE_NAME AND QP.QUERY_PLAN_HASH = DP.QUERY_PLAN_HASH

				   DROP TABLE #DEL_PLANS

			SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT


			--REH Delete any plans over the retention data

			DELETE QP FROM QUERY_PLANS QP INNER JOIN DATABASES_2_COLLECT DC ON QP.SERVER_NAME = DC.LINKED_SERVER AND DC.DATABASE_NAME = QP.DATABASE_NAME
			WHERE QP.DATE_UPDATED < DATEADD(DD, DC.PURGE_PLANS_AFTER_X_DAYS, GETDATE() )
			
			--REH Delete the bottom % of query_plans  RUN this task on the first day of the month
			

			--IF DATEPART(D,GETDATE()) = 1 --REH Only run this part on first day of month
			--BEGIN 
			--	WITH CTE_STATS (SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH, PctRank)
			--		 AS (
	 	--				SELECT TOP 100 PERCENT QH.SERVER_NAME, QH.DATABASE_NAME, QH.QUERY_PLAN_HASH,
			--		   PERCENT_RANK() OVER (PARTITION BY QH.SERVER_NAME, QH.DATABASE_NAME ORDER BY QH.ELAPSED_TIME_TODAY  ) * 100.00 AS PctRank
			--	FROM QUERY_HISTORY QH INNER JOIN DATABASES_2_COLLECT D2 ON QH.SERVER_NAME = D2.LINKED_SERVER AND QH.DATABASE_NAME = D2.DATABASE_NAME
			--	WHERE FLAG = 'M' and DATE =  DATEADD(MM,-1,DATEDIFF(MONTH, 0, GETDATE()))  --REH Previous Month
			--	--AND < 100 - D2.KEEP_TOP_X_PLANS_BY_MONTH  --REH The rank is less than the rank we want to keep (based on total time)
			--	ORDER BY QH.SERVER_NAME, QH.DATABASE_NAME, QH.ELAPSED_TIME_TODAY DESC)

			--	DELETE QP FROM QUERY_PLANS QP 
			--	INNER JOIN CTE_STATS CTE ON QP.SERVER_NAME = CTE.SERVER_NAME AND CTE.DATABASE_NAME = QP.DATABASE_NAME AND CTE.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
			--	INNER JOIN DATABASES_2_COLLECT D2  ON D2.LINKED_SERVER = CTE.SERVER_NAME AND CTE.DATABASE_NAME = D2.DATABASE_NAME 
			--	WHERE CTE.PCTRANK < 100 - D2.KEEP_TOP_X_QUERIES_BY_MONTH  --REH The rank is less than the rank we want to keep (based on total time)
			
			
			--END

		END

				

	   IF @C_TABLE_NAME = 'QUERY_TEXT'
		BEGIN
			SELECT QT.SERVER_NAME, QT.DATABASE_NAME, QT.QUERY_HASH 
			INTO #QT 
			FROM QUERY_TEXT QT WHERE QT.SERVER_NAME = @SERVER_NAME AND
			 NOT EXISTS (SELECT QS.QUERY_HASH FROM QUERY_STATS QS WHERE QS.DATABASE_NAME = QT.DATABASE_NAME AND QS.SERVER_NAME = QT.SERVER_NAME AND QT.QUERY_HASH = QS.QUERY_HASH) 
				AND NOT EXISTS (SELECT QUERY_HASH FROM QUERY_HISTORY QH WHERE QH.DATABASE_NAME = QT.DATABASE_NAME AND QH.SERVER_NAME = QT.SERVER_NAME AND QT.QUERY_HASH = QH.QUERY_HASH) 

				DELETE QT FROM QUERY_TEXT QT INNER JOIN #QT TMP ON QT.SERVER_NAME = TMP.SERVER_NAME
				AND QT.DATABASE_NAME = TMP.DATABASE_NAME AND QT.QUERY_HASH = TMP.QUERY_HASH


				SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
		END
END
ELSE
IF @C_TABLE_NAME IN ('QUERY_STATS', 'INDEX_DETAIL')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE

		BEGIN

				IF @C_TABLE_NAME = 'QUERY_STATS'
					DELETE QS FROM QUERY_STATS QS WITH (ROWLOCK) INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE QS.SERVER_NAME = @SERVER_NAME AND QS.STATS_TIME < DATEADD(D,DC.RETAIN_DETAILS_DAYS * -1, GETDATE())

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

				IF @C_TABLE_NAME = 'INDEX_DETAIL'
					DELETE ID FROM INDEX_DETAIL ID WITH (ROWLOCK) INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.STATS_TIME < DATEADD(D,DC.RETAIN_DETAILS_DAYS * -1, GETDATE())

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
		
				
		END

ELSE
IF @C_TABLE_NAME IN ('CAPTURE_LOG')


	BEGIN

	
	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE  ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

	END
ELSE

IF @C_TABLE_NAME IN ('INDEX_HISTORY', 'QUERY_HISTORY')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE

		BEGIN

				IF @C_TABLE_NAME = 'QUERY_HISTORY'
				BEGIN
					--REH DELETE MONTHLY QUERY TOTALS 
					DELETE QS FROM QUERY_HISTORY QS INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE  QS.SERVER_NAME = @SERVER_NAME AND QS.DATE < DATEADD(MM,DC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) AND QS.FLAG = 'M'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



					--REH DELETE DAYS TOTALS FROM QUERY_HISTORY		
					DELETE QS FROM QUERY_HISTORY QS INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE  QS.SERVER_NAME = @SERVER_NAME AND QS.DATE < DATEADD(MM,DC.RETAIN_HISTORY_DAYS * -1, GETDATE()) AND QS.FLAG = 'D'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

		--REH STALE QUERY delete

							;WITH CTE_HIST (SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, MAX_DATE)
								 AS (SELECT SERVER_NAME,
											DATABASE_NAME,
											QUERY_HASH,
											QUERY_PLAN_HASH,
											MAX(DATE)
									 FROM   QUERY_HISTORY
									 GROUP  BY SERVER_NAME,
											   DATABASE_NAME,
											   QUERY_HASH,
											   QUERY_PLAN_HASH)
							DELETE QS
							FROM   QUERY_HISTORY QS
								   INNER JOIN DATABASES_2_COLLECT DC
										   ON QS.SERVER_NAME = DC.LINKED_SERVER
											  AND QS.DATABASE_NAME = DC.DATABASE_NAME
								   INNER JOIN CTE_HIST CTE
										   ON CTE.SERVER_NAME = QS.SERVER_NAME
											  AND CTE.DATABASE_NAME = QS.DATABASE_NAME
											  AND CTE.QUERY_HASH = QS.QUERY_HASH
											  AND CTE.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
							WHERE  QS.SERVER_NAME = @SERVER_NAME
								   AND CTE.MAX_DATE < DATEADD(MM, DC.PURGE_STALE_QUERIES_DAYS * -1, GETDATE()) 


						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



						IF DATEPART(D,GETDATE()) = 1 --REH Only run this part on first day of month
							BEGIN 
								WITH CTE_STATS (SERVER_NAME, DATABASE_NAME, QUERY_HASH, PctRank)
									 AS (
	 									SELECT TOP 100 PERCENT QH.SERVER_NAME, QH.DATABASE_NAME, QH.QUERY_HASH,
									   PERCENT_RANK() OVER (PARTITION BY QH.SERVER_NAME, QH.DATABASE_NAME ORDER BY QH.ELAPSED_TIME_TODAY  ) * 100.00 AS PctRank
								FROM QUERY_HISTORY QH INNER JOIN DATABASES_2_COLLECT D2 ON QH.SERVER_NAME = D2.LINKED_SERVER AND QH.DATABASE_NAME = D2.DATABASE_NAME
								WHERE FLAG = 'M' and DATE =  DATEADD(MM,-1,DATEDIFF(MONTH, 0, GETDATE()))  --REH Previous Month
								--AND < 100 - D2.KEEP_TOP_X_PLANS_BY_MONTH  --REH The rank is less than the rank we want to keep (based on total time)
								ORDER BY QH.SERVER_NAME, QH.DATABASE_NAME, QH.ELAPSED_TIME_TODAY DESC)

								DELETE QP FROM QUERY_HISTORY QH
								INNER JOIN CTE_STATS CTE ON QH.SERVER_NAME = CTE.SERVER_NAME AND CTE.DATABASE_NAME = QH.DATABASE_NAME AND CTE.QUERY_HASH = QH.QUERY_HASH
								INNER JOIN DATABASES_2_COLLECT D2  ON D2.LINKED_SERVER = CTE.SERVER_NAME AND CTE.DATABASE_NAME = D2.DATABASE_NAME 
								WHERE CTE.PCTRANK < 100 - D2.KEEP_TOP_X_QUERIES_BY_MONTH  --REH The rank is less than the rank we want to keep (based on total time)
			
							END







				END

				IF @C_TABLE_NAME = 'INDEX_HISTORY'
				BEGIN
					DELETE ID FROM INDEX_HISTORY ID INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.DATE < DATEADD(MM,DC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) AND ID.FLAG = 'M'

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

					DELETE ID FROM INDEX_HISTORY ID INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.DATE < DATEADD(MM,DC.RETAIN_HISTORY_DAYS * -1, GETDATE()) AND ID.FLAG = 'D'

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

				END	
			
		END

ELSE

IF @C_TABLE_NAME IN ('SSRS_EXECUTIONLOG', 'SSRS_HISTORY')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE
BEGIN
			IF @C_TABLE_NAME = 'SSRS_EXECUTIONLOG'
				BEGIN
					--REH DELETE MONTHLY QUERY TOTALS 
					DELETE EL FROM SSRS_EXECUTIONLOG EL 
					INNER JOIN SSRS_CONFIG SC ON EL.SERVER_NAME = SC.SERVER_NAME AND EL.DATABASE_NAME = SC.DATABASE_NAME
						WHERE  EL.TIMEEND < DATEADD(MM,SC.RETAIN_DETAILS_DAYS * -1, GETDATE()) 

					SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
				END
			IF @C_TABLE_NAME = 'SSRS_HISTORY'
				BEGIN
					--REH DELETE MONTHLY QUERY TOTALS 
					DELETE SH FROM SSRS_HISTORY SH 
						INNER JOIN SSRS_CONFIG SC ON SH.SERVER_NAME = SC.SERVER_NAME AND SH.DATABASE_NAME = SC.DATABASE_NAME
						WHERE   SH.REPORT_DATE < DATEADD(MM,SC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) AND SH.FLAG = 'M'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



					--REH DELETE DAYS TOTALS FROM QUERY_HISTORY	
					DELETE SH FROM SSRS_HISTORY SH 
						INNER JOIN SSRS_CONFIG SC ON SH.SERVER_NAME = SC.SERVER_NAME AND SH.DATABASE_NAME = SC.DATABASE_NAME
						WHERE   SH.REPORT_DATE < DATEADD(MM,SC.RETAIN_HISTORY_DAYS * -1, GETDATE()) AND SH.FLAG = 'M'
	
					SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
				END
				
END


ELSE


IF @C_TABLE_NAME IN ('QUERY_PLANS_PARSED')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE
BEGIN
	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SELECT QPP.SERVER_NAME, QPP.DATABASE_NAME, QPP.QUERY_PLAN_HASH 
	INTO #QPP FROM QUERY_PLANS_PARSED QPP 
	WHERE NOT EXISTS (SELECT 'X' FROM QUERY_HISTORY QH WHERE QPP.SERVER_NAME = QH.SERVER_NAME
	AND QPP.DATABASE_NAME = QH.DATABASE_NAME AND QPP.QUERY_PLAN_HASH = QH.QUERY_PLAN_HASH)

	DELETE QPP FROM QUERY_PLANS_PARSED QPP INNER JOIN #QPP TMP ON QPP.SERVER_NAME = TMP.SERVER_NAME
		AND QPP.DATABASE_NAME = TMP.DATABASE_NAME AND QPP.QUERY_PLAN_HASH = TMP.QUERY_PLAN_HASH

	DROP TABLE #QPP

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
END


ELSE


BEGIN



	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE SERVER_NAME =  ' + ''''+ @SERVER_NAME + '''' + ' AND ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

END




FETCH NEXT FROM TASK_CURSOR INTO @C_TABLE_NAME, @C_TIME_COLUMN, @C_SERVER_FLAG, @C_DATABASE_FLAG, @C_PURGE_DAYS


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
	


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Deleted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[SP_CAPTURESTATS]...';


GO



ALTER	PROCEDURE [dbo].[SP_CAPTURESTATS]
		@SERVER_NAME	NVARCHAR(128) = NULL,
		@DATABASE_NAME	NVARCHAR(128) = NULL ,
		@DYNAMICS_PRODUCT NVARCHAR(3)  = NULL,
		@TASK_TYPE		VARCHAR(50) = 'COLLECT',
		@AZURE_DB		BIT = 0,
		@TOP_ROWS		INT = 0,
		@TOP_COLUMN		NVARCHAR(128) = 'total_elapsed_time',
		@RUN_NAME		NVARCHAR(128) = NULL,
		@INDEX_PHYSICAL_STATS 	NCHAR(1)= 'N',
		@DEBUG			NVARCHAR(1)= 'N'

AS


SET NOCOUNT ON
SET DATEFORMAT MDY

SET ANSI_NULLS ON
SET ANSI_WARNINGS ON
SET ANSI_NULL_DFLT_ON ON
SET ANSI_PADDING ON


DECLARE @STATS_DATE		DATETIME, 
		@STATS_DATE_HOLD DATETIME,
		@C_SCHED_UNITS CHAR(2),
		@SQL_VERSION	NVARCHAR(1000), 
		@DYNAMICS_VERSION NVARCHAR(MAX),
		@DATABASE_ID	INT,
		@RETURN_CODE	INT,
		@SQL			NVARCHAR(MAX),
		@RUN_DESCRIPTION NVARCHAR(1000),
		@SQL_TOP_CLAUSE	NVARCHAR(128),
		@SQL_ORDERBY_CLAUSE	NVARCHAR(128),
		@PARM			NVARCHAR(500),
		@SQL_SERVER_STARTTIME DATETIME,
		@RC INT,
		@TASK_PROCEDURE NVARCHAR(128),
		@TASK_PARAMETERS NVARCHAR(1024),
		@TASK_DESCRIPTION NVARCHAR(256),
		@LAST_SERVER_NAME NVARCHAR(128) = 'ZZZ',  --REH This is used to trigger inserting a new STATS_COLLECTION_SUMMARY record
		@LAST_DATABASE_NAME NVARCHAR(128) = 'ZZZ',
		@LAST_STATS_DATE DATETIME,
		@REMOTE_SERVER NVARCHAR(1) = 'N',
		@TASK_STARTTIME DATETIME,
		@TASK_ENDTIME DATETIME,
		@TASK_TIME BIGINT,
		@SQL_STARTTIME DATETIME,
		@SQL_BUILD NVARCHAR(20),
		@SQL2 NVARCHAR(MAX),
		@MANUAL_CAPTURE NVARCHAR(1) = 'N',
		@SQL_TZ_OFFSET INT,
		@DPA_TZ_OFFSET INT,
		@RETRY_COUNT INT

		
		
DECLARE
	@C_SERVER_NAME NVARCHAR(128),
	@C_DATABASE_NAME NVARCHAR(128),
	@C_TASK_ID INT,
	@C_TASK_PROCEDURE NVARCHAR(128),
	@C_TASK_PARAMS NVARCHAR(1024),
	@C_TASK_DESC NVARCHAR(256),
	@C_SERVER_LEVEL_TASK BIT,
	@C_AZURE_DB  BIT,
	@C_LAST_RUN DATETIME
	
		
--REH Time zone off set for the DynamicsPerf database at time of collection
		SET @DPA_TZ_OFFSET = DATEDIFF(MI,GETUTCDATE(),GETDATE())

	IF @DATABASE_NAME IS NOT NULL SET @MANUAL_CAPTURE = 'Y'

	SET @STATS_DATE = GETDATE()
--REH  Verify database exists if being manually passed, skip check if Azure DB, no access to sys.databases catalogue

IF ( @AZURE_DB = 0 and ( @SERVER_NAME IS NOT NULL
      OR @DATABASE_NAME IS NOT NULL ))
     BEGIN

	 
	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_CS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_CS_QUERY_SYSDATABASES')

         IF @REMOTE_SERVER = 'Y'
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_CS_QUERY_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_CS_QUERY_SYSDATABASES
				FOR master.sys.databases'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END

         EXEC (@SQL) -- SELECT * FROM DYN_CS_QUERY_SYSDATABASES

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_CS_QUERY_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

         --REH Make sure there is a record in DATABASES_2_COLLECT or insert if new combination
         IF (SELECT COUNT(*)
             FROM   DATABASES_2_COLLECT
             WHERE  LINKED_SERVER = ISNULL(@SERVER_NAME, @@SERVERNAME)
                    AND DATABASE_NAME = @DATABASE_NAME) < 1
              BEGIN
                  INSERT DATABASES_2_COLLECT
                  VALUES(ISNULL(@SERVER_NAME,@@SERVERNAME),
                         @DATABASE_NAME,
                         ISNULL(@DYNAMICS_PRODUCT, 'ALL'),
                         1,
                         2,
                         24,
						 60,
						 2,
						 90,
						 7,
						 -1,
						 0,
						 100,
						 100,
						 100,
						 100,
						 60)
              END
     END 


	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END



---------------------------------------------------------------------------------------------
--
--  Insert Capture_log entry with paramater values used for the run
--
----------------------------------------------------------------------------------------------

INSERT CAPTURE_LOG  SELECT @TASK_TYPE, @STATS_DATE, 'SP_CAPTURESTATS PARMS PASSED @SERVER_NAME = ' + ISNULL(@SERVER_NAME,'NOT PASSED') + ' @DATABASE_NAME = ' + ISNULL(@DATABASE_NAME,'NOT PASSED') +  ' @DEBUG = ' + @DEBUG + '  ' + CHAR(10) + CHAR(13)



SET @RETURN_CODE = 0

DELETE FROM  COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH Default is 'COLLECT' for this sproc.  CAN'T TRUNCATE MULTIPLE SPROCS USING THIS TABLE



IF @DATABASE_NAME IS NULL  --REH AKA, not a manual capture
  BEGIN
      INSERT COLLECTIONDATABASES
      SELECT ISNULL(LINKED_SERVER, @@SERVERNAME),
             [DATABASE_NAME],
             [DYNAMICS_PRODUCT],
             [AZURE_DB],
             [ENABLED],
			 @TASK_TYPE
      FROM   DATABASES_2_COLLECT
      WHERE  ENABLED = 1 -- db must be enabled for autostats collection to work with it
  END
ELSE
  BEGIN   --REH  Insert DBname of the manual capture
      INSERT COLLECTIONDATABASES
      VALUES(ISNULL(@SERVER_NAME, @@SERVERNAME),
             @DATABASE_NAME,
             @DYNAMICS_PRODUCT,
             @AZURE_DB,
             1,
			 @TASK_TYPE)
  END 


--REH Insert any missing task history records in case it's a new database being collected, so we don't fail to capture against the db because of no records
-- yes, this is a cartesian join between these 2 tables

INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE	--REH default is 'COLLECT' in parm definition of this sproc
       AND NOT EXISTS (SELECT 'X'
                       FROM   DYNPERF_TASK_HISTORY DTH
                       WHERE  DTS.TASK_ID = DTH.TASK_ID
                              AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                              AND CD.DATABASE_NAME = DTH.DATABASE_NAME)
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 0 --REH Ok, to put 1 record per database in for DB type tasks


	   
--REH Need to insert 1 bogus record for each server level task, or the join on the cursor will fail

INSERT COLLECTIONDATABASES 
 SELECT	DISTINCT [LINKED_SERVER],
             'N/A',
            'ALL',
             [AZURE_DB],
             [ENABLED],
			 [TASK_TYPE]
FROM COLLECTIONDATABASES CD
WHERE DATABASE_NAME <> 'N/A'
AND TASK_TYPE = @TASK_TYPE
AND NOT EXISTS (SELECT 'X' FROM COLLECTIONDATABASES CD2 WHERE CD2.LINKED_SERVER = CD.LINKED_SERVER AND CD2.DATABASE_NAME = 'N/A')



--REH now lets insert server level tasks with a blank DB name so we only do them once per server
INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       'N/A',
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE  --REH default is 'COLLECT' in parm definition of this sproc
		AND CD.DATABASE_NAME <> 'N/A'
       AND NOT EXISTS (SELECT 'X'
                   FROM   DYNPERF_TASK_HISTORY DTH
                   WHERE  DTS.TASK_ID = DTH.TASK_ID
                          AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                          AND DTH.DATABASE_NAME = 'N/A') --REH making the db name = 'N/A' for server level tasks
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 1 






	IF @DEBUG = 'Y'
	BEGIN
		PRINT 'MANUAL_CAPTURE = ' + @MANUAL_CAPTURE
	END

	--REH Create here and truncate table in each loop

	 --  CREATE TABLE #SQL_INFO
  --   (
  --      SQL_STARTTIME DATETIME,
  --      SQL_BUILD NVARCHAR(20),
		--TZ_OFFSET INT
  --   )


/********************************************************************************
Rod Hansen

Added a trigger to DATABASES_2_COLLECT so that we always have a 
DYNPERF_TASK_HISTORY record for this code 

********************************************************************************/

DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT DISTINCT DTS.TASK_ID,
       CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_PROCEDURE,
       DTS.TASK_PARAMETERS,
       DTS.TASK_DESCRIPTION,
       DTS.SERVER_LEVEL_TASK,
       CD.AZURE_DB,
       ISNULL(DTH.LAST_RUN, '1/1/1900'),
	   COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)  -- Need this to do calculations after task is run

FROM   DynamicsPerf..[DYNPERF_TASK_SCHEDULER] DTS
       LEFT OUTER JOIN DynamicsPerf..[DYNPERF_TASK_HISTORY] DTH
                    ON DTH.TASK_ID = DTS.TASK_ID
       INNER JOIN DynamicsPerf..COLLECTIONDATABASES CD
               ON CD.DATABASE_NAME = DTH.DATABASE_NAME
                  AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
WHERE
  --REH Task is enabled
  DTS.ENABLED = 1
  AND
  --REH It's the correct task type C = COLLECTOR, P = PROCESS, M = MONITOR, ETC
  DTS.TASK_TYPE = @TASK_TYPE
  AND
  --REH database is enabled
  CD.ENABLED = 1
  AND
  --REH Azure_db, if Azure db, then task must support it
  ( CD.AZURE_DB = DTS.AZURE_DB_SUPPORTED
     OR CD.AZURE_DB = 0 )
  --REH Either its an Azure Task, all Azure tasks will run locally, so if task supports AZ and we pass 0, run it anyways
  AND ( DTS.AZURE_DB_SUPPORTED = @AZURE_DB
         OR ( DTS.AZURE_DB_SUPPORTED = 1
              AND @AZURE_DB = 0 ) )
  AND
  --REH it's either All products or matches the Dynamics Product
  ( DTS.DYNAMICS_PRODUCT = 'ALL'
     OR DTS.DYNAMICS_PRODUCT = CD.DYNAMICS_PRODUCT )
  AND
  --REH Scheduling options now
(
  --REH In the case of minutes or hours, we ignore schedule time and just figure out if it's time to run again
  ( @MANUAL_CAPTURE = 'Y'
     OR ( @MANUAL_CAPTURE = 'N'
          AND ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                  WHEN 'MI' THEN DATEADD(MINUTE, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                END ) <= GETDATE()
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'HH' THEN DATEADD(HOUR, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                --REH and it is on the hour
                AND ( ABS(DATEDIFF(MI, DATEADD(Hour, DATEDIFF(Hour, 0, GETDATE()), 0), GETDATE())) <= 1 ) )
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'DD' THEN DATEADD(DAY, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'WK' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'MM' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'QQ' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'YY' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                AND ( --REH TIME IS NULL SO IGNORE IT
                    COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) IS NULL
                     OR --REH Current time = Scheduled time 
                    ( SUBSTRING((SELECT REPLACE(CONVERT(VARCHAR(10), GETDATE(), 108), ':', '')), 1, 4) = (SELECT REPLICATE('0', 4 - LEN( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME)))
                                                                                                                 + CAST( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) AS VARCHAR(4))) ) ) )
         --REH and last_run < current time
         )--AND CONVERT(VARCHAR(10), LAST_RUN, 108) <= CONVERT(VARCHAR(10), Getdate(), 108) ) 
   )
)
ORDER  BY CD.LINKED_SERVER,
          CD.DATABASE_NAME,
          DTS.TASK_ID 



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN, @C_SCHED_UNITS


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */


	          SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


--Insert new STATS_COLLECTION_SUMMARY RECORD, we want 1 RUN_NAME per server not per database
IF @C_SERVER_NAME <> @LAST_SERVER_NAME OR @C_DATABASE_NAME <> @LAST_DATABASE_NAME
BEGIN
    SET @RUN_NAME = ISNULL(@C_SERVER_NAME, @@SERVERNAME)+ ' '
                    + CAST(@STATS_DATE AS VARCHAR(30))

TRUNCATE TABLE WRK_CS_SQL_INFO   --REH clear out table to repopulate

 DELETE FROM COLLECTIONDATABASES WHERE LINKED_SERVER = @LAST_SERVER_NAME AND DATABASE_NAME = @LAST_DATABASE_NAME AND TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE


 
SELECT @SQL = 'SELECT create_date AS SQL_STARTTIME,
       CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))    AS SQL_BUILD,
	   DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
		FROM sys.databases WHERE name = ''TempDB'''

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


   
   SET NOCOUNT ON
 
IF @REMOTE_SERVER = 'N'
BEGIN
		   INSERT WRK_CS_SQL_INFO
		EXEC( @SQL)
END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
			IF @C_AZURE_DB = 0
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT create_date AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROM sys.databases WHERE name = ''TempDB''"	)'
			END
			IF @C_AZURE_DB = 1
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT DATEADD(ms,AVG(-wait_time_ms), GETDATE()) AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROMsys.dm_os_wait_stats w WHEREwait_type
IN(''DIRTY_PAGE_POLL'',''HADR_FILESTREAM_IOMGR_IOCOMPLETION'',''LAZYWRITER_SLEEP'',''LOGMGR_QUEUE'',''REQUEST_FOR_DEADLOCK_SEARCH'',''XE_DISPATCHER_WAIT'',''XE_TIMER_EVENT'') "	)'
			END


				IF @DEBUG = 'Y'
                  BEGIN
                      PRINT '@SQL= ' + @SQL2
                  END 
                
			INSERT WRK_CS_SQL_INFO
				EXEC (@SQL2) 
 
 END
 
 SELECT @SQL_STARTTIME = SQL_STARTTIME, @SQL_BUILD = SQL_BUILD, @SQL_TZ_OFFSET = TZ_OFFSET FROM WRK_CS_SQL_INFO
 TRUNCATE TABLE WRK_CS_SQL_INFO --REH Cleanout the table for next loop





		INSERT INTO [DynamicsPerf].[dbo].[STATS_COLLECTION_SUMMARY]
					([SERVER_NAME],
					 [STATS_TIME],
					 [RUN_NAME],
					 [DATABASE_NAME],
					 [SQL_VERSION],
					 [DYNAMICS_VERSION],
					 [RUN_DESCRIPTION],
					 [SQL_SERVER_STARTTIME],
					 [SQL_SERVER_TZ_OFFSET] ,
					 [DPA_TZ_OFFSET])
		VALUES      (@C_SERVER_NAME,
					 @STATS_DATE,
					 @RUN_NAME,
					 @C_DATABASE_NAME,
					 @SQL_BUILD,--<SQL_VERSION>
					 '',--<DYNAMICS_VERSION>
					 '',--<RUN_DESCRIPTION>
					 @SQL_STARTTIME, -- <SQL_SERVER_STARTTIME>
					 @SQL_TZ_OFFSET,  -- Time Zone offset in minutes of database collected
					 @DPA_TZ_OFFSET  -- Time Zone of the DynamicsPerf database
					) 
				
END 

SET @LAST_SERVER_NAME = @C_SERVER_NAME
SET @LAST_DATABASE_NAME = @C_DATABASE_NAME


SET @REMOTE_SERVER = CASE @C_SERVER_NAME
                       WHEN @@SERVERNAME THEN 'N'
                       ELSE 'Y'
                     END 



--Create synonyms for the sproc

--IF  EXISTS (SELECT * FROM sys.synonyms WHERE name = 'DYN_CS_CAPTURE_SPROC')
--DROP SYNONYM [dbo].[DYN_CS_CAPTURE_SPROC]
--SET @SQL = '
--CREATE SYNONYM DYN_CS_CAPTURE_SPROC
--FOR [DynamicsPerf].dbo.[' + @C_TASK_PROCEDURE + ']'

--IF @DEBUG = 'Y' 
--BEGIN
--PRINT '@SQL= ' + @SQL
--END

--EXEC(@SQL) 

IF @DEBUG = 'Y' 
BEGIN
PRINT 'TASK ID = ' + CAST(@C_TASK_ID AS VARCHAR(10))
PRINT 'SERVER NAME = ' + @C_SERVER_NAME 
PRINT 'DATABASE NAME = ' + @C_DATABASE_NAME
PRINT 'TASK PARMS = ' + ISNULL(@C_TASK_PARAMS, '')
PRINT 'TASK DESC = ' + ISNULL(@C_TASK_DESC,'')
PRINT 'LAST RUN = ' + ISNULL(CAST(@C_LAST_RUN AS VARCHAR(30)),'')
PRINT 'RUN NAME = ' + ISNULL(@RUN_NAME,'')
PRINT 'STATS DATE = ' + CAST(@STATS_DATE AS VARCHAR(30))
PRINT 'REMNOTE SERVER FLAG = ' + ISNULL(@REMOTE_SERVER,'')
PRINT 'AZURE DB = ' + CAST(@C_AZURE_DB AS CHAR(1))


END
			
	

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@C_TASK_DESC, '') + CONVERT(VARCHAR, GETDATE(), 109)
PRINT ''


SET @TASK_STARTTIME = GETDATE()
SET @C_TASK_PARAMS = ISNULL(@C_TASK_PARAMS,'')


IF @DEBUG = 'Y'
BEGIN

	PRINT 'SERVER TIME ZONE OFFSET = ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
	PRINT 'AT LAST RUN  = ' + CAST(@C_LAST_RUN AS VARCHAR(30))

END

--REH Adjust the last_run time to UTC Time, the called sproc's will adjust it to local time unless we've never collected
IF @C_LAST_RUN > '1/1/1901'
BEGIN
SET @C_LAST_RUN = DATEADD(MI,@DPA_TZ_OFFSET *-1 ,@C_LAST_RUN)
END


-- REH Adjusting last_run when its never be run to get things in last 5 mins
--   This is to prevent the massive data load on QUERY_STATS on 1st collection on large memory systems
IF @C_LAST_RUN < '1/1/2016'
BEGIN
SET @C_LAST_RUN = DATEADD(MI,@DPA_TZ_OFFSET *-1 ,DATEADD(MI,-5,GETDATE()))
END


IF @DEBUG = 'Y'
BEGIN
	PRINT 'AT LAST RUN TIME BEING PASSED TO SPROC ' + CAST(@C_LAST_RUN AS VARCHAR(30))
END

SELECT @SQL = 'EXEC ' + @C_TASK_PROCEDURE + '  @TASK_ID=' + CAST(@C_TASK_ID AS NVARCHAR(10)) + 
' ,@SERVER_NAME = ' + '''' +  @C_SERVER_NAME + '''' +
' ,@DATABASE_NAME = ' + '''' +  @C_DATABASE_NAME + '''' +
' ,@TASK_PARAMS = ' +  '''' +  @C_TASK_PARAMS + '''' +
' ,@TASK_DESC = ' + '''' +  @C_TASK_DESC + '''' +
' ,@LAST_RUN = ' + '''' + CONVERT(VARCHAR, @C_LAST_RUN, 109) + '''' +
' ,@RUN_NAME = ' + '''' +  @RUN_NAME + '''' +
' ,@STATS_DATE = ' + '''' + CONVERT(VARCHAR, @STATS_DATE, 109) + '''' +
' ,@REMOTE_SERVER = ' + '''' +  @REMOTE_SERVER + '''' +
' ,@AZURE_DB = ' + CAST(@C_AZURE_DB AS NVARCHAR(10)) + 
' ,@SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET AS NVARCHAR(10)) + 
' ,@DPA_TZ_OFFSET = ' + CAST(@DPA_TZ_OFFSET AS NVARCHAR(10)) + 


' ,@DEBUG = '  + '''' +  @DEBUG + ''''



UPDATE CAPTURE_LOG
SET    TEXT = TEXT  + CHAR(13) + CHAR(10) + '***** ' + @C_TASK_PROCEDURE
			+ CHAR(13) + CHAR(10)
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE



EXECUTE @RC = sp_executesql @SQL


	
   					  
SET @TASK_ENDTIME = GETDATE()

SET @TASK_TIME = DATEDIFF(ss,@TASK_STARTTIME, @TASK_ENDTIME)

 
 /*************** RETRY LOGIC ************************/
IF @RC = 1
   AND @TASK_TIME < 10 -- IT FAILED AND WAS LESS THEN 10 SECONDS
  BEGIN
      WAITFOR DELAY '00:00:02' -- REH Wait 2 seconds and try again if sproc trapped the error
      EXECUTE @RC = Sp_executesql
        @SQL

      SET @TASK_ENDTIME = GETDATE()
      SET @TASK_TIME = DATEDIFF(SS, @TASK_STARTTIME, @TASK_ENDTIME)
  END 

  
--REH update last  [DYNPERF_TASK_HISTORY] IF THE TASK WAS SUCCESSFUL


  
 IF @RC = 0
      BEGIN
          PRINT ''
 
          PRINT 'SUCCESSFULLY CAPTURED '
                + ISNULL(@C_TASK_DESC, '') +  ' for SERVER '
              + ISNULL(@C_SERVER_NAME, '') + ' on database '
              + ISNULL(@C_DATABASE_NAME, '') + ' in ' + cast(@TASK_TIME AS VARCHAR(20)) + ' SECONDS '
 
 -- REH set last run for daily tasks to previous day so that they will run at midnight from here forward
 SET @STATS_DATE_HOLD = @STATS_DATE
 IF @C_SCHED_UNITS IN ('DD','WK','MM','QQ', 'YY') 

 BEGIN
	--REH Adjust to midnight the previous night if last run was 1/1/1900 so that all daily tasks will then run at midnight

		--REH floor it to today then subtract 2 mins so that its before midnight so that daily tasks will run at 
		-- midnight from now on and not run when we installed DynamicsPerf

	 SET @STATS_DATE_HOLD = DATEADD(MI,-2,dateadd(DAY,datediff(DAY,0,@STATS_DATE),0))


 END

       --REH if a manual capture don't update last run so we don't mess up the scheduling engine
				 IF @MANUAL_CAPTURE = 'N'
				 BEGIN
						  MERGE DynamicsPerf..[DYNPERF_TASK_HISTORY] AS target
						  USING (SELECT @C_SERVER_NAME   AS SERVER_NAME,
										@C_DATABASE_NAME AS DATABASE_NAME,
										@C_TASK_ID       AS TASK_ID,
										@STATS_DATE_HOLD AS LAST_RUN,
										@TASK_TIME	AS LAST_EXECUTION_TIME_SECS 
												) AS source
						  ON ( source.SERVER_NAME = target.LINKEDSERVER_NAME
							   AND source.DATABASE_NAME = target.DATABASE_NAME
							   AND source.TASK_ID = target.TASK_ID )
						  WHEN MATCHED THEN
							UPDATE SET LAST_RUN = source.LAST_RUN, [LAST_EXECUTION_TIME_SECS] = source.[LAST_EXECUTION_TIME_SECS]
						  WHEN NOT MATCHED THEN
							INSERT ( [LINKEDSERVER_NAME],
									 [DATABASE_NAME],
									 [TASK_ID],
									 [LAST_RUN],
									 [LAST_EXECUTION_TIME_SECS])
							VALUES (source.SERVER_NAME,
									source.DATABASE_NAME,
									source.TASK_ID,
									source.LAST_RUN,
									source.LAST_EXECUTION_TIME_SECS );
				END
      END
 ELSE
	IF @RC = 1  --REH SPROC HANDLED THE ERROR
      BEGIN
          PRINT ''
 
          PRINT 'FAILED !!!!!! ' + ISNULL(@C_TASK_DESC, '')
 
          PRINT ''
      END 
 
  


           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_CS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_CS_QUERY_SYSDATABASES')



END TRY 

BEGIN CATCH


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PROCEDURE FAILED !!! '
              + ISNULL(@C_TASK_DESC, 'TASK') + ' for SERVER
        '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) + ', '
                          + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX)) 
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE


PRINT 'ERROR WHILE COLLECTING ' + ISNULL(@C_TASK_DESC, '') +' !!!!!!!!!!!!!!'




         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_CS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_CS_QUERY_SYSDATABASES')

END CATCH



FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN, @C_SCHED_UNITS


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
	  DELETE FROM COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
		

ENDPROC:
PRINT 'RUN NAME = '+ @RUN_NAME
GO
PRINT N'Altering [dbo].[SP_PROCESS_STATS]...';


GO
ALTER PROCEDURE [dbo].[SP_PROCESS_STATS]
		@SERVER_NAME	NVARCHAR(128) = NULL,
		@DATABASE_NAME	NVARCHAR(128) = NULL ,
		@DYNAMICS_PRODUCT NVARCHAR(3)  = NULL,
		@TASK_TYPE		VARCHAR(50) = 'PROCESS',
		@AZURE_DB		BIT = 0,
		@TOP_ROWS		INT = 0,
		@TOP_COLUMN		NVARCHAR(128) = 'total_elapsed_time',
		@RUN_NAME		NVARCHAR(128) = NULL,
		@INDEX_PHYSICAL_STATS 	NCHAR(1)= 'N',
		@DEBUG			NVARCHAR(1)= 'N'

AS


SET NOCOUNT ON
SET DATEFORMAT MDY

DECLARE @STATS_DATE		DATETIME, 
		@STATS_DATE_HOLD DATETIME,
		@C_SCHED_UNITS CHAR(2),
		@SQL_VERSION	NVARCHAR(1000), 
		@DYNAMICS_VERSION NVARCHAR(MAX),
		@DATABASE_ID	INT,
		@RETURN_CODE	INT,
		@SQL			NVARCHAR(MAX),
		@RUN_DESCRIPTION NVARCHAR(1000),
		@SQL_TOP_CLAUSE	NVARCHAR(128),
		@SQL_ORDERBY_CLAUSE	NVARCHAR(128),
		@PARM			NVARCHAR(500),
		@SQL_SERVER_STARTTIME DATETIME,
		@RC INT,
		@TASK_PROCEDURE NVARCHAR(128),
		@TASK_PARAMETERS NVARCHAR(1024),
		@TASK_DESCRIPTION NVARCHAR(256),
		@LAST_SERVER_NAME NVARCHAR(128) = 'ZZZ',  --REH This is used to trigger inserting a new STATS_COLLECTION_SUMMARY record
		@LAST_DATABASE_NAME NVARCHAR(128) = 'ZZZ',
		@LAST_STATS_DATE DATETIME,
		@REMOTE_SERVER NVARCHAR(1) = 'N',
		@TASK_STARTTIME DATETIME,
		@TASK_ENDTIME DATETIME,
		@TASK_TIME BIGINT,
		@SQL_STARTTIME DATETIME,
		@SQL_BUILD NVARCHAR(20),
		@SQL2 NVARCHAR(MAX),
		@MANUAL_CAPTURE NVARCHAR(1) = 'N',
		@SQL_TZ_OFFSET INT,
		@DPA_TZ_OFFSET INT 

		
		
DECLARE
	@C_SERVER_NAME NVARCHAR(128),
	@C_DATABASE_NAME NVARCHAR(128),
	@C_TASK_ID INT,
	@C_TASK_PROCEDURE NVARCHAR(128),
	@C_TASK_PARAMS NVARCHAR(1024),
	@C_TASK_DESC NVARCHAR(256),
	@C_SERVER_LEVEL_TASK BIT,
	@C_AZURE_DB  BIT,
	@C_LAST_RUN DATETIME
	
		
--REH Time zone off set for the DynamicsPerf database at time of collection
		SET @DPA_TZ_OFFSET = DATEDIFF(MI,GETUTCDATE(),GETDATE())

	IF @DATABASE_NAME IS NOT NULL SET @MANUAL_CAPTURE = 'Y'

	SET @STATS_DATE = GETDATE()
--REH  Verify database exists if being manually passed, skip check if Azure DB, no access to sys.databases catalogue

IF ( @AZURE_DB = 0 and ( @SERVER_NAME IS NOT NULL
      OR @DATABASE_NAME IS NOT NULL ))
     BEGIN

	 
	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_QUERY_SYSDATABASES')

         IF @REMOTE_SERVER = 'Y'
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_PS_QUERY_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_PS_QUERY_SYSDATABASES
				FOR master.sys.databases'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END

         EXEC (@SQL) -- SELECT * FROM DYN_PS_QUERY_SYSDATABASES

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_PS_QUERY_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

         --REH Make sure there is a record in DATABASES_2_COLLECT or insert if new combination
         IF (SELECT COUNT(*)
             FROM   DATABASES_2_COLLECT
             WHERE  LINKED_SERVER = ISNULL(@SERVER_NAME, @@SERVERNAME)
                    AND DATABASE_NAME = @DATABASE_NAME) < 1
              BEGIN
                  INSERT DATABASES_2_COLLECT
                  VALUES(ISNULL(@SERVER_NAME,@@SERVERNAME),
                         @DATABASE_NAME,
                         ISNULL(@DYNAMICS_PRODUCT, 'ALL'),
                         0,
                         2,
                         24,
						 60,
						 2,
						 90,
						 7,
						 -1,
						 0,
						 100,
						 100,
						 100,
						 100,
						 60)
              END
     END 


	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END



---------------------------------------------------------------------------------------------
--
--  Insert Capture_log entry with paramater values used for the run
--
----------------------------------------------------------------------------------------------

INSERT CAPTURE_LOG  SELECT @TASK_TYPE, @STATS_DATE, 'SP_PROCESS_STATS PARMS PASSED @SERVER_NAME = ' + ISNULL(@SERVER_NAME,'NOT PASSED') + ' @DATABASE_NAME = ' + ISNULL(@DATABASE_NAME,'NOT PASSED') +  ' @DEBUG = ' + @DEBUG + '  ' + CHAR(10) + CHAR(13)



SET @RETURN_CODE = 0

DELETE FROM  COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH Default is 'COLLECT' for this sproc.  CAN'T TRUNCATE MULTIPLE SPROCS USING THIS TABLE




IF @DATABASE_NAME IS NULL  --REH AKA, not a manual capture
  BEGIN
      INSERT COLLECTIONDATABASES
      SELECT ISNULL(LINKED_SERVER, @@SERVERNAME),
             [DATABASE_NAME],
             [DYNAMICS_PRODUCT],
             [AZURE_DB],
             [ENABLED],
			 @TASK_TYPE
      FROM   DATABASES_2_COLLECT
      WHERE  ENABLED = 1 -- db must be enabled for autostats collection to work with it
  END
ELSE
  BEGIN   --REH  Insert DBname of the manual capture
      INSERT COLLECTIONDATABASES
      VALUES(ISNULL(@SERVER_NAME, @@SERVERNAME),
             @DATABASE_NAME,
             @DYNAMICS_PRODUCT,
             @AZURE_DB,
             1,
			 @TASK_TYPE)
  END 


--REH Insert any missing task history records in case it's a new database being collected, so we don't fail to capture against the db because of no records
-- yes, this is a cartesian join between these 2 tables

INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE	--REH default is 'PROCESS' in parm definition of this sproc
       AND NOT EXISTS (SELECT 'X'
                       FROM   DYNPERF_TASK_HISTORY DTH
                       WHERE  DTS.TASK_ID = DTH.TASK_ID
                              AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                              AND CD.DATABASE_NAME = DTH.DATABASE_NAME)
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 0 --REH Ok, to put 1 record per database in for DB type tasks


	   
--REH Need to insert 1 bogus record for each server level task, or the join on the cursor will fail

INSERT COLLECTIONDATABASES 
 SELECT	DISTINCT [LINKED_SERVER],
             'N/A',
            'ALL',
             [AZURE_DB],
             [ENABLED],
			 [TASK_TYPE]
FROM COLLECTIONDATABASES CD
WHERE DATABASE_NAME <> 'N/A'
AND TASK_TYPE = @TASK_TYPE
AND NOT EXISTS (SELECT 'X' FROM COLLECTIONDATABASES CD2 WHERE CD2.LINKED_SERVER = CD.LINKED_SERVER AND CD2.DATABASE_NAME = 'N/A')



--REH now lets insert server level tasks with a blank DB name so we only do them once per server
INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       'N/A',
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE  --REH default is 'COLLECT' in parm definition of this sproc
		AND CD.DATABASE_NAME <> 'N/A'
       AND NOT EXISTS (SELECT 'X'
                   FROM   DYNPERF_TASK_HISTORY DTH
                   WHERE  DTS.TASK_ID = DTH.TASK_ID
                          AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                          AND DTH.DATABASE_NAME = 'N/A') --REH making the db name = 'N/A' for server level tasks
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 1 





	IF @DEBUG = 'Y'
	BEGIN
		PRINT 'MANUAL_CAPTURE = ' + @MANUAL_CAPTURE
	END

	--REH Create here and truncate table in each loop
	 --  CREATE TABLE #SQL_INFO
  --   (
  --      SQL_STARTTIME DATETIME,
  --      SQL_BUILD NVARCHAR(20),
		--TZ_OFFSET INT
  --   )
   

/********************************************************************************
Rod Hansen

Added a trigger to DATABASES_2_COLLECT so that we always have a 
DYNPERF_TASK_HISTORY record for this code 

********************************************************************************/

DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT DISTINCT DTS.TASK_ID,
       CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_PROCEDURE,
       DTS.TASK_PARAMETERS,
       DTS.TASK_DESCRIPTION,
       DTS.SERVER_LEVEL_TASK,
       CD.AZURE_DB,
       ISNULL(DTH.LAST_RUN, '1/1/1900'),
	   COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)  -- Need this to do calculations after task is run

FROM   DynamicsPerf..[DYNPERF_TASK_SCHEDULER] DTS
       LEFT OUTER JOIN DynamicsPerf..[DYNPERF_TASK_HISTORY] DTH
                    ON DTH.TASK_ID = DTS.TASK_ID
       INNER JOIN DynamicsPerf..COLLECTIONDATABASES CD
               ON CD.DATABASE_NAME = DTH.DATABASE_NAME
                  AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
WHERE
  --REH Task is enabled
  DTS.ENABLED = 1
  AND
  --REH It's the correct task type C = COLLECTOR, P = PROCESS, M = MONITOR, ETC
  DTS.TASK_TYPE = @TASK_TYPE
  AND
  --REH database is enabled
  CD.ENABLED = 1
  AND
  --REH Azure_db, if Azure db, then task must support it
  ( CD.AZURE_DB = DTS.AZURE_DB_SUPPORTED
     OR CD.AZURE_DB = 0 )
  --REH Either its an Azure Task, all Azure tasks will run locally, so if task supports AZ and we pass 0, run it anyways
  AND ( DTS.AZURE_DB_SUPPORTED = @AZURE_DB
         OR ( DTS.AZURE_DB_SUPPORTED = 1
              AND @AZURE_DB = 0 ) )
  AND
  --REH it's either All products or matches the Dynamics Product
  ( DTS.DYNAMICS_PRODUCT = 'ALL'
     OR DTS.DYNAMICS_PRODUCT = CD.DYNAMICS_PRODUCT )
  AND
  --REH Scheduling options now
(
  --REH In the case of minutes or hous, we ignore schedule time and just figure out if it's time to run again
  ( @MANUAL_CAPTURE = 'Y'
     OR ( @MANUAL_CAPTURE = 'N'
          AND ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                  WHEN 'MI' THEN DATEADD(MINUTE, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                END ) <= GETDATE()
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'HH' THEN DATEADD(HOUR, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                --REH and it is on the hour
                AND ( ABS(DATEDIFF(MI, DATEADD(Hour, DATEDIFF(Hour, 0, GETDATE()), 0), GETDATE())) <= 1 ) )
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'DD' THEN DATEADD(DAY, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'WK' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'MM' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'QQ' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'YY' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                AND ( --REH TIME IS NULL SO IGNORE IT
                    COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) IS NULL
                     OR --REH Current time = Scheduled time 
                    ( SUBSTRING((SELECT REPLACE(CONVERT(VARCHAR(10), GETDATE(), 108), ':', '')), 1, 4) = (SELECT REPLICATE('0', 4 - LEN( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME)))
                                                                                                                 + CAST( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) AS VARCHAR(4))) ) ) )
         --REH and last_run < current time
         )--AND CONVERT(VARCHAR(10), LAST_RUN, 108) <= CONVERT(VARCHAR(10), Getdate(), 108) ) 
   )
)
ORDER  BY CD.LINKED_SERVER,
          CD.DATABASE_NAME,
          DTS.TASK_ID 



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN, @C_SCHED_UNITS


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

	SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                    WHEN @@SERVERNAME THEN 'N'
                    ELSE 'Y'
                    END

--Insert new STATS_COLLECTION_SUMMARY RECORD, we want 1 RUN_NAME per server not per database
IF @C_SERVER_NAME <> @LAST_SERVER_NAME OR @C_DATABASE_NAME <> @LAST_DATABASE_NAME
BEGIN
    SET @RUN_NAME = ISNULL(@C_SERVER_NAME, @@SERVERNAME)+ ' '
                    + CAST(@STATS_DATE AS VARCHAR(30))


TRUNCATE TABLE WRK_PS_SQL_INFO   

 DELETE FROM COLLECTIONDATABASES WHERE LINKED_SERVER = @LAST_SERVER_NAME AND DATABASE_NAME = @LAST_DATABASE_NAME AND TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
 
SELECT @SQL = 'SELECT create_date AS SQL_STARTTIME,
       CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))    AS SQL_BUILD,
	   DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
		FROM sys.databases WHERE name = ''TempDB'''

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


   SET NOCOUNT ON
 
IF @REMOTE_SERVER = 'N'
BEGIN
		   INSERT WRK_PS_SQL_INFO
		EXEC( @SQL)
END


 IF @REMOTE_SERVER = 'Y'
 BEGIN
			IF @C_AZURE_DB = 0
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT create_date AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROM sys.databases WHERE name = ''TempDB''"	)'
			END
			IF @C_AZURE_DB = 1
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT DATEADD(ms,AVG(-wait_time_ms), GETDATE()) AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROMsys.dm_os_wait_stats w WHEREwait_type
IN(''DIRTY_PAGE_POLL'',''HADR_FILESTREAM_IOMGR_IOCOMPLETION'',''LAZYWRITER_SLEEP'',''LOGMGR_QUEUE'',''REQUEST_FOR_DEADLOCK_SEARCH'',''XE_DISPATCHER_WAIT'',''XE_TIMER_EVENT'') "	)'
			END


				IF @DEBUG = 'Y'
                  BEGIN
                      PRINT '@SQL= ' + @SQL2
                  END 
                
			INSERT WRK_PS_SQL_INFO
				EXEC (@SQL2) 
 
 END
 
 SELECT @SQL_STARTTIME = SQL_STARTTIME, @SQL_BUILD = SQL_BUILD, @SQL_TZ_OFFSET = TZ_OFFSET FROM WRK_PS_SQL_INFO
 TRUNCATE TABLE WRK_PS_SQL_INFO  -- REH cleanout for next pass


  --REH NOT Collecting so don't need this code in this sproc


		--INSERT INTO [DynamicsPerf].[dbo].[STATS_COLLECTION_SUMMARY]
		--			([SERVER_NAME],
		--			 [STATS_TIME],
		--			 [RUN_NAME],
		--			 [DATABASE_NAME],
		--			 [SQL_VERSION],
		--			 [DYNAMICS_VERSION],
		--			 [RUN_DESCRIPTION],
		--			 [SQL_SERVER_STARTTIME],
		--			 [SQL_SERVER_TZ_OFFSET] ,
		--			 [DPA_TZ_OFFSET])
		--VALUES      (@C_SERVER_NAME,
		--			 @STATS_DATE,
		--			 @RUN_NAME,
		--			 @C_DATABASE_NAME,
		--			 @SQL_BUILD,--<SQL_VERSION>
		--			 '',--<DYNAMICS_VERSION>
		--			 '',--<RUN_DESCRIPTION>
		--			 @SQL_STARTTIME, -- <SQL_SERVER_STARTTIME>
		--			 @SQL_TZ_OFFSET,  -- Time Zone offset in minutes of database collected
		--			 @DPA_TZ_OFFSET  -- Time Zone of the DynamicsPerf database
		--			) 
				
END 

SET @LAST_SERVER_NAME = @C_SERVER_NAME
SET @LAST_DATABASE_NAME = @C_DATABASE_NAME


SET @REMOTE_SERVER = CASE @C_SERVER_NAME
                       WHEN @@SERVERNAME THEN 'N'
                       ELSE 'Y'
                     END 



--Create synonyms for the sproc

--IF  EXISTS (SELECT * FROM sys.synonyms WHERE name = 'DYN_PS_CAPTURE_SPROC')
--DROP SYNONYM [dbo].[DYN_PS_CAPTURE_SPROC]
--SET @SQL = '
--CREATE SYNONYM DYN_PS_CAPTURE_SPROC
--FOR [DynamicsPerf].dbo.[' + @C_TASK_PROCEDURE + ']'

--IF @DEBUG = 'Y' 
--BEGIN
--PRINT '@SQL= ' + @SQL
--END

--EXEC(@SQL) 

IF @DEBUG = 'Y' 
BEGIN
PRINT 'TASK ID = ' + CAST(@C_TASK_ID AS VARCHAR(10))
PRINT 'SERVER NAME = ' + @C_SERVER_NAME 
PRINT 'DATABASE NAME = ' + @C_DATABASE_NAME
PRINT 'TASK PARMS = ' + ISNULL(@C_TASK_PARAMS, '')
PRINT 'TASK DESC = ' + ISNULL(@C_TASK_DESC,'')
PRINT 'LAST RUN = ' + ISNULL(CAST(@C_LAST_RUN AS VARCHAR(30)),'')
PRINT 'RUN NAME = ' + ISNULL(@RUN_NAME,'')
PRINT 'STATS DATE = ' + CAST(@STATS_DATE AS VARCHAR(30))
PRINT 'REMNOTE SERVER FLAG = ' + ISNULL(@REMOTE_SERVER,'')
PRINT 'AZURE DB = ' + CAST(@C_AZURE_DB AS CHAR(1))


END
			
	

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@C_TASK_DESC, '') + CONVERT(VARCHAR, GETDATE(), 109)
PRINT ''


SET @TASK_STARTTIME = GETDATE()
SET @C_TASK_PARAMS = ISNULL(@C_TASK_PARAMS,'')


IF @DEBUG = 'Y'
BEGIN

	PRINT 'SERVER TIME ZONE OFFSET = ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
	PRINT 'AT LAST RUN  = ' + CAST(@C_LAST_RUN AS VARCHAR(30))

END

--REH Adjust the last_run time to UTC Time, the called sproc's will adjust it to local time unless we've never collected
IF @C_LAST_RUN > '1/1/1901'
BEGIN
SET @C_LAST_RUN = DATEADD(MI,@DPA_TZ_OFFSET *-1 ,@C_LAST_RUN)
END



IF @DEBUG = 'Y'
BEGIN
	PRINT 'AT LAST RUN TIME BEING PASSED TO SPROC ' + CAST(@C_LAST_RUN AS VARCHAR(30))
END

SELECT @SQL = 'EXEC ' + @C_TASK_PROCEDURE + '  @TASK_ID=' + CAST(@C_TASK_ID AS NVARCHAR(10)) + 
' ,@SERVER_NAME = ' + '''' +  @C_SERVER_NAME + '''' +
' ,@DATABASE_NAME = ' + '''' +  @C_DATABASE_NAME + '''' +
' ,@TASK_PARAMS = ' +  '''' +  @C_TASK_PARAMS + '''' +
' ,@TASK_DESC = ' + '''' +  @C_TASK_DESC + '''' +
' ,@LAST_RUN = ' + '''' + CONVERT(VARCHAR, @C_LAST_RUN, 109) + '''' +
' ,@RUN_NAME = ' + '''' +  @RUN_NAME + '''' +
' ,@STATS_DATE = ' + '''' + CONVERT(VARCHAR, @STATS_DATE, 109) + '''' +
' ,@REMOTE_SERVER = ' + '''' +  @REMOTE_SERVER + '''' +
' ,@AZURE_DB = ' + CAST(@C_AZURE_DB AS NVARCHAR(10)) + 
' ,@SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET AS NVARCHAR(10)) + 
' ,@DPA_TZ_OFFSET = ' + CAST(@DPA_TZ_OFFSET AS NVARCHAR(10)) + 


' ,@DEBUG = '  + '''' +  @DEBUG + ''''


UPDATE CAPTURE_LOG
SET    TEXT = TEXT  + CHAR(13) + CHAR(10) + '***** ' + @C_TASK_PROCEDURE
			+ CHAR(13) + CHAR(10)
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE



EXECUTE @RC = sp_executesql @SQL

   					  
SET @TASK_ENDTIME = GETDATE()

SET @TASK_TIME = DATEDIFF(ss,@TASK_STARTTIME, @TASK_ENDTIME)



 /*************** RETRY LOGIC ************************/ 
 IF @RC = 1
   AND @TASK_TIME < 10 -- IT FAILED AND WAS LESS THEN 10 SECONDS
  BEGIN
      WAITFOR DELAY '00:00:02' -- REH Wait 2 seconds and try again if sproc trapped the error
      EXECUTE @RC = Sp_executesql
        @SQL

      SET @TASK_ENDTIME = Getdate()
      SET @TASK_TIME = Datediff(ss, @TASK_STARTTIME, @TASK_ENDTIME)
  END 


--REH update last  [DYNPERF_TASK_HISTORY] IF THE TASK WAS SUCCESSFUL


  
 IF @RC = 0
      BEGIN
          PRINT ''
 
          PRINT 'SUCCESSFULLY CAPTURED '
                + ISNULL(@C_TASK_DESC, '') +  ' for SERVER
	'
              + ISNULL(@C_SERVER_NAME, '') + ' on database '
              + ISNULL(@C_DATABASE_NAME, '') + ' in ' + cast(@TASK_TIME AS VARCHAR(20)) + ' SECONDS '
 
  -- REH set last run for daily tasks to previous day so that they will run at midnight from here forward
 SET @STATS_DATE_HOLD = @STATS_DATE
 IF @C_SCHED_UNITS IN ('DD','WK','MM','QQ', 'YY') 

 BEGIN
	--REH Adjust to midnight the previous night if last run was 1/1/1900 so that all daily tasks will then run at midnight

		--REH floor it to today then subtract 2 mins so that its before midnight so that daily tasks will run at 
		-- midnight from now on and not run when we installed DynamicsPerf

	 SET @STATS_DATE_HOLD = DATEADD(MI,-2,dateadd(DAY,datediff(DAY,0,@STATS_DATE),0))


 END



       --REH if a manual capture don't update last run so we don't mess up the scheduling engine
				 IF @MANUAL_CAPTURE = 'N'
				 BEGIN
						  MERGE DynamicsPerf..[DYNPERF_TASK_HISTORY] AS target
						  USING (SELECT @C_SERVER_NAME   AS SERVER_NAME,
										@C_DATABASE_NAME AS DATABASE_NAME,
										@C_TASK_ID       AS TASK_ID,
										@STATS_DATE_HOLD      AS LAST_RUN,
										@TASK_TIME	AS LAST_EXECUTION_TIME_SECS 
												) AS source
						  ON ( source.SERVER_NAME = target.LINKEDSERVER_NAME
							   AND source.DATABASE_NAME = target.DATABASE_NAME
							   AND source.TASK_ID = target.TASK_ID )
						  WHEN MATCHED THEN
							UPDATE SET LAST_RUN = source.LAST_RUN, [LAST_EXECUTION_TIME_SECS] = source.[LAST_EXECUTION_TIME_SECS]
						  WHEN NOT MATCHED THEN
							INSERT ( [LINKEDSERVER_NAME],
									 [DATABASE_NAME],
									 [TASK_ID],
									 [LAST_RUN],
									 [LAST_EXECUTION_TIME_SECS])
							VALUES (source.SERVER_NAME,
									source.DATABASE_NAME,
									source.TASK_ID,
									source.LAST_RUN,
									source.LAST_EXECUTION_TIME_SECS );
				END
      END
 ELSE
	IF @RC = 1  --REH SPROC HANDLED THE ERROR
      BEGIN
          PRINT ''
 
          PRINT 'FAILED !!!!!! ' + ISNULL(@C_TASK_DESC, '')
 
          PRINT ''
      END 
 

 
 

           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_QUERY_SYSDATABASES')

  
END TRY 

BEGIN CATCH


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PROCEDURE FAILED !!! '
              + ISNULL(@C_TASK_DESC, 'TASK') + ' for SERVER
        '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) + ', '
                          + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX)) 
WHERE  STATS_TIME = @STATS_DATE  AND TASK_TYPE = @TASK_TYPE 


PRINT 'ERROR WHILE COLLECTING ' + ISNULL(@C_TASK_DESC, '') +' !!!!!!!!!!!!!!'


           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_QUERY_SYSDATABASES')


END CATCH



FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN, @C_SCHED_UNITS


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
 DELETE FROM COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
 
			

ENDPROC:
PRINT 'RUN NAME = '+ @RUN_NAME
GO
PRINT N'Altering [dbo].[SP_PROCESS_STATS_LOW_PRIORITY]...';


GO
ALTER PROCEDURE [dbo].[SP_PROCESS_STATS_LOW_PRIORITY]
	@SERVER_NAME	NVARCHAR(128) = NULL,
		@DATABASE_NAME	NVARCHAR(128) = NULL ,
		@DYNAMICS_PRODUCT NVARCHAR(3)  = NULL,
		@TASK_TYPE		VARCHAR(50) = 'PROCESS_LP',
		@AZURE_DB		BIT = 0,
		@TOP_ROWS		INT = 0,
		@TOP_COLUMN		NVARCHAR(128) = 'total_elapsed_time',
		@RUN_NAME		NVARCHAR(128) = NULL,
		@INDEX_PHYSICAL_STATS 	NCHAR(1)= 'N',
		@DEBUG			NVARCHAR(1)= 'N'

AS


SET NOCOUNT ON
SET DATEFORMAT MDY

DECLARE @STATS_DATE		DATETIME,
		@STATS_DATE_HOLD DATETIME,
		@C_SCHED_UNITS CHAR(2), 
		@SQL_VERSION	NVARCHAR(1000), 
		@DYNAMICS_VERSION NVARCHAR(MAX),
		@DATABASE_ID	INT,
		@RETURN_CODE	INT,
		@SQL			NVARCHAR(MAX),
		@RUN_DESCRIPTION NVARCHAR(1000),
		@SQL_TOP_CLAUSE	NVARCHAR(128),
		@SQL_ORDERBY_CLAUSE	NVARCHAR(128),
		@PARM			NVARCHAR(500),
		@SQL_SERVER_STARTTIME DATETIME,
		@RC INT,
		@TASK_PROCEDURE NVARCHAR(128),
		@TASK_PARAMETERS NVARCHAR(1024),
		@TASK_DESCRIPTION NVARCHAR(256),
		@LAST_SERVER_NAME NVARCHAR(128) = 'ZZZ',  --REH This is used to trigger inserting a new STATS_COLLECTION_SUMMARY record
		@LAST_DATABASE_NAME NVARCHAR(128) = 'ZZZ',
		@LAST_STATS_DATE DATETIME,
		@REMOTE_SERVER NVARCHAR(1) = 'N',
		@TASK_STARTTIME DATETIME,
		@TASK_ENDTIME DATETIME,
		@TASK_TIME BIGINT,
		@SQL_STARTTIME DATETIME,
		@SQL_BUILD NVARCHAR(20),
		@SQL2 NVARCHAR(MAX),
		@MANUAL_CAPTURE NVARCHAR(1) = 'N',
		@SQL_TZ_OFFSET INT,
		@DPA_TZ_OFFSET INT 

		
		
DECLARE
	@C_SERVER_NAME NVARCHAR(128),
	@C_DATABASE_NAME NVARCHAR(128),
	@C_TASK_ID INT,
	@C_TASK_PROCEDURE NVARCHAR(128),
	@C_TASK_PARAMS NVARCHAR(1024),
	@C_TASK_DESC NVARCHAR(256),
	@C_SERVER_LEVEL_TASK BIT,
	@C_AZURE_DB  BIT,
	@C_LAST_RUN DATETIME
	
		
--REH Time zone off set for the DynamicsPerf database at time of collection
		SET @DPA_TZ_OFFSET = DATEDIFF(MI,GETUTCDATE(),GETDATE())

	IF @DATABASE_NAME IS NOT NULL SET @MANUAL_CAPTURE = 'Y'

	SET @STATS_DATE = GETDATE()
--REH  Verify database exists if being manually passed, skip check if Azure DB, no access to sys.databases catalogue

IF ( @AZURE_DB = 0 and ( @SERVER_NAME IS NOT NULL
      OR @DATABASE_NAME IS NOT NULL ))
     BEGIN

	 
	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_LP_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_LP_QUERY_SYSDATABASES')

         IF @REMOTE_SERVER = 'Y'
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_PS_LP_QUERY_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_PS_LP_QUERY_SYSDATABASES
				FOR master.sys.databases'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END

         EXEC (@SQL) -- SELECT * FROM DYN_PS_LP_QUERY_SYSDATABASES

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_PS_LP_QUERY_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

         --REH Make sure there is a record in DATABASES_2_COLLECT or insert if new combination
         IF (SELECT COUNT(*)
             FROM   DATABASES_2_COLLECT
             WHERE  LINKED_SERVER = ISNULL(@SERVER_NAME, @@SERVERNAME)
                    AND DATABASE_NAME = @DATABASE_NAME) < 1
              BEGIN
                  INSERT DATABASES_2_COLLECT
                  VALUES(ISNULL(@SERVER_NAME,@@SERVERNAME),
                         @DATABASE_NAME,
                         ISNULL(@DYNAMICS_PRODUCT, 'ALL'),
                         0,
                         2,
                         24,
						 60,
						 2,
						 90,
						 7,
						 -1,
						 0,
						 100,
						 100,
						 100,
						 100,
						 60)
              END
     END 


	          SET @REMOTE_SERVER = CASE ISNULL(@SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END



---------------------------------------------------------------------------------------------
--
--  Insert Capture_log entry with paramater values used for the run
--
----------------------------------------------------------------------------------------------

INSERT CAPTURE_LOG  SELECT @TASK_TYPE, @STATS_DATE, 'SP_PROCESS_STATS PARMS PASSED @SERVER_NAME = ' + ISNULL(@SERVER_NAME,'NOT PASSED') + ' @DATABASE_NAME = ' + ISNULL(@DATABASE_NAME,'NOT PASSED') +  ' @DEBUG = ' + @DEBUG + '  ' + CHAR(10) + CHAR(13)



SET @RETURN_CODE = 0

DELETE FROM  COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH Default is 'COLLECT' for this sproc.  CAN'T TRUNCATE MULTIPLE SPROCS USING THIS TABLE




IF @DATABASE_NAME IS NULL  --REH AKA, not a manual capture
  BEGIN
      INSERT COLLECTIONDATABASES
      SELECT ISNULL(LINKED_SERVER, @@SERVERNAME),
             [DATABASE_NAME],
             [DYNAMICS_PRODUCT],
             [AZURE_DB],
             [ENABLED],
			 @TASK_TYPE
      FROM   DATABASES_2_COLLECT
      WHERE  ENABLED = 1 -- db must be enabled for autostats collection to work with it
  END
ELSE
  BEGIN   --REH  Insert DBname of the manual capture
      INSERT COLLECTIONDATABASES
      VALUES(ISNULL(@SERVER_NAME, @@SERVERNAME),
             @DATABASE_NAME,
             @DYNAMICS_PRODUCT,
             @AZURE_DB,
             1,
			 @TASK_TYPE)
  END 


--REH Insert any missing task history records in case it's a new database being collected, so we don't fail to capture against the db because of no records
-- yes, this is a cartesian join between these 2 tables

INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE	--REH default is 'PROCESS' in parm definition of this sproc
       AND NOT EXISTS (SELECT 'X'
                       FROM   DYNPERF_TASK_HISTORY DTH
                       WHERE  DTS.TASK_ID = DTH.TASK_ID
                              AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                              AND CD.DATABASE_NAME = DTH.DATABASE_NAME)
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 0 --REH Ok, to put 1 record per database in for DB type tasks


	   
--REH Need to insert 1 bogus record for each server level task, or the join on the cursor will fail

INSERT COLLECTIONDATABASES 
 SELECT	DISTINCT [LINKED_SERVER],
             'N/A',
            'ALL',
             [AZURE_DB],
             [ENABLED],
			 [TASK_TYPE]
FROM COLLECTIONDATABASES CD
WHERE DATABASE_NAME <> 'N/A'
AND TASK_TYPE = @TASK_TYPE
AND NOT EXISTS (SELECT 'X' FROM COLLECTIONDATABASES CD2 WHERE CD2.LINKED_SERVER = CD.LINKED_SERVER AND CD2.DATABASE_NAME = 'N/A')



--REH now lets insert server level tasks with a blank DB name so we only do them once per server
INSERT DYNPERF_TASK_HISTORY
SELECT CD.LINKED_SERVER,
       'N/A',
       DTS.TASK_ID,
       NULL,
       NULL,
       NULL,
       '1/1/1900',
       0
FROM   DYNPERF_TASK_SCHEDULER DTS
       CROSS APPLY COLLECTIONDATABASES CD
WHERE  CD.TASK_TYPE = @TASK_TYPE  --REH default is 'COLLECT' in parm definition of this sproc
		AND CD.DATABASE_NAME <> 'N/A'
       AND NOT EXISTS (SELECT 'X'
                   FROM   DYNPERF_TASK_HISTORY DTH
                   WHERE  DTS.TASK_ID = DTH.TASK_ID
                          AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
                          AND DTH.DATABASE_NAME = 'N/A') --REH making the db name = 'N/A' for server level tasks
       --REH IF DB is Azure then task must support Azure, otherwise all tasks for Non-Azure dbs
       AND ( ( DTS.AZURE_DB_SUPPORTED = 1
               AND CD.AZURE_DB = 1 )
              OR CD.AZURE_DB = 0 )
       AND DTS.TASK_TYPE = @TASK_TYPE
       AND DTS.SERVER_LEVEL_TASK = 1 





	IF @DEBUG = 'Y'
	BEGIN
		PRINT 'MANUAL_CAPTURE = ' + @MANUAL_CAPTURE
	END

	--REH Create here and truncate table in each loop
	 --  CREATE TABLE #SQL_INFO
  --   (
  --      SQL_STARTTIME DATETIME,
  --      SQL_BUILD NVARCHAR(20),
		--TZ_OFFSET INT
  --   )
   

/********************************************************************************
Rod Hansen

Added a trigger to DATABASES_2_COLLECT so that we always have a 
DYNPERF_TASK_HISTORY record for this code 

********************************************************************************/

DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT DISTINCT DTS.TASK_ID,
       CD.LINKED_SERVER,
       CD.DATABASE_NAME,
       DTS.TASK_PROCEDURE,
       DTS.TASK_PARAMETERS,
       DTS.TASK_DESCRIPTION,
       DTS.SERVER_LEVEL_TASK,
       CD.AZURE_DB,
       ISNULL(DTH.LAST_RUN, '1/1/1900'),
	   COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)  -- Need this to do calculations after task is run

FROM   DynamicsPerf..[DYNPERF_TASK_SCHEDULER] DTS
       LEFT OUTER JOIN DynamicsPerf..[DYNPERF_TASK_HISTORY] DTH
                    ON DTH.TASK_ID = DTS.TASK_ID
       INNER JOIN DynamicsPerf..COLLECTIONDATABASES CD
               ON CD.DATABASE_NAME = DTH.DATABASE_NAME
                  AND CD.LINKED_SERVER = DTH.LINKEDSERVER_NAME
WHERE
  --REH Task is enabled
  DTS.ENABLED = 1
  AND
  --REH It's the correct task type C = COLLECTOR, P = PROCESS, M = MONITOR, ETC
  DTS.TASK_TYPE = @TASK_TYPE
  AND
  --REH database is enabled
  CD.ENABLED = 1
  AND
  --REH Azure_db, if Azure db, then task must support it
  ( CD.AZURE_DB = DTS.AZURE_DB_SUPPORTED
     OR CD.AZURE_DB = 0 )
  --REH Either its an Azure Task, all Azure tasks will run locally, so if task supports AZ and we pass 0, run it anyways
  AND ( DTS.AZURE_DB_SUPPORTED = @AZURE_DB
         OR ( DTS.AZURE_DB_SUPPORTED = 1
              AND @AZURE_DB = 0 ) )
  AND
  --REH it's either All products or matches the Dynamics Product
  ( DTS.DYNAMICS_PRODUCT = 'ALL'
     OR DTS.DYNAMICS_PRODUCT = CD.DYNAMICS_PRODUCT )
  AND
  --REH Scheduling options now
(
  --REH In the case of minutes or hous, we ignore schedule time and just figure out if it's time to run again
  ( @MANUAL_CAPTURE = 'Y'
     OR ( @MANUAL_CAPTURE = 'N'
          AND ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                  WHEN 'MI' THEN DATEADD(MINUTE, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                END ) <= GETDATE()
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'HH' THEN DATEADD(HOUR, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                --REH and it is on the hour
                AND ( ABS(DATEDIFF(MI, DATEADD(Hour, DATEDIFF(Hour, 0, GETDATE()), 0), GETDATE())) <= 1 ) )
           OR ( ( CASE COALESCE(DTH.SCHEDULE_UNITS, DTS.SCHEDULE_UNITS)
                    WHEN 'DD' THEN DATEADD(DAY, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'WK' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'MM' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'QQ' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                    WHEN 'YY' THEN DATEADD(WEEK, COALESCE(DTH.SCHEDULE_QTY_PER_UNIT, DTS.SCHEDULE_QTY_PER_UNIT), ISNULL(LAST_RUN, '1/1/1900'))
                  END ) <= GETDATE()
                AND ( --REH TIME IS NULL SO IGNORE IT
                    COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) IS NULL
                     OR --REH Current time = Scheduled time 
                    ( SUBSTRING((SELECT REPLACE(CONVERT(VARCHAR(10), GETDATE(), 108), ':', '')), 1, 4) = (SELECT REPLICATE('0', 4 - LEN( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME)))
                                                                                                                 + CAST( COALESCE(DTH.SCHEDULE_TIME, DTS.SCHEDULE_TIME) AS VARCHAR(4))) ) ) )
         --REH and last_run < current time
         )--AND CONVERT(VARCHAR(10), LAST_RUN, 108) <= CONVERT(VARCHAR(10), Getdate(), 108) ) 
   )
)
ORDER  BY CD.LINKED_SERVER,
          CD.DATABASE_NAME,
          DTS.TASK_ID 



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN, @C_SCHED_UNITS


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

	SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                    WHEN @@SERVERNAME THEN 'N'
                    ELSE 'Y'
                    END

--Insert new STATS_COLLECTION_SUMMARY RECORD, we want 1 RUN_NAME per server not per database
IF @C_SERVER_NAME <> @LAST_SERVER_NAME OR @C_DATABASE_NAME <> @LAST_DATABASE_NAME
BEGIN
    SET @RUN_NAME = ISNULL(@C_SERVER_NAME, @@SERVERNAME)+ ' '
                    + CAST(@STATS_DATE AS VARCHAR(30))


TRUNCATE TABLE WRK_LP_SQL_INFO   

 DELETE FROM COLLECTIONDATABASES WHERE LINKED_SERVER = @LAST_SERVER_NAME AND DATABASE_NAME = @LAST_DATABASE_NAME AND TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
 
SELECT @SQL = 'SELECT create_date AS SQL_STARTTIME,
       CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))    AS SQL_BUILD,
	   DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
		FROM sys.databases WHERE name = ''TempDB'''

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


   SET NOCOUNT ON
 
IF @REMOTE_SERVER = 'N'
BEGIN
		   INSERT WRK_LP_SQL_INFO
		EXEC( @SQL)
END


 IF @REMOTE_SERVER = 'Y'
 BEGIN
			IF @C_AZURE_DB = 0
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT create_date AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROM sys.databases WHERE name = ''TempDB''"	)'
			END
			IF @C_AZURE_DB = 1
			BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT DATEADD(ms,AVG(-wait_time_ms), GETDATE()) AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROMsys.dm_os_wait_stats w WHEREwait_type
IN(''DIRTY_PAGE_POLL'',''HADR_FILESTREAM_IOMGR_IOCOMPLETION'',''LAZYWRITER_SLEEP'',''LOGMGR_QUEUE'',''REQUEST_FOR_DEADLOCK_SEARCH'',''XE_DISPATCHER_WAIT'',''XE_TIMER_EVENT'') "	)'
			END


				IF @DEBUG = 'Y'
                  BEGIN
                      PRINT '@SQL= ' + @SQL2
                  END 
                
			INSERT WRK_LP_SQL_INFO
				EXEC (@SQL2) 
 
 END
 
 SELECT @SQL_STARTTIME = SQL_STARTTIME, @SQL_BUILD = SQL_BUILD, @SQL_TZ_OFFSET = TZ_OFFSET FROM WRK_LP_SQL_INFO
 TRUNCATE TABLE WRK_LP_SQL_INFO  -- REH cleanout for next pass


  --REH NOT Collecting so don't need this code in this sproc


		--INSERT INTO [DynamicsPerf].[dbo].[STATS_COLLECTION_SUMMARY]
		--			([SERVER_NAME],
		--			 [STATS_TIME],
		--			 [RUN_NAME],
		--			 [DATABASE_NAME],
		--			 [SQL_VERSION],
		--			 [DYNAMICS_VERSION],
		--			 [RUN_DESCRIPTION],
		--			 [SQL_SERVER_STARTTIME],
		--			 [SQL_SERVER_TZ_OFFSET] ,
		--			 [DPA_TZ_OFFSET])
		--VALUES      (@C_SERVER_NAME,
		--			 @STATS_DATE,
		--			 @RUN_NAME,
		--			 @C_DATABASE_NAME,
		--			 @SQL_BUILD,--<SQL_VERSION>
		--			 '',--<DYNAMICS_VERSION>
		--			 '',--<RUN_DESCRIPTION>
		--			 @SQL_STARTTIME, -- <SQL_SERVER_STARTTIME>
		--			 @SQL_TZ_OFFSET,  -- Time Zone offset in minutes of database collected
		--			 @DPA_TZ_OFFSET  -- Time Zone of the DynamicsPerf database
		--			) 
				
END 

SET @LAST_SERVER_NAME = @C_SERVER_NAME
SET @LAST_DATABASE_NAME = @C_DATABASE_NAME


SET @REMOTE_SERVER = CASE @C_SERVER_NAME
                       WHEN @@SERVERNAME THEN 'N'
                       ELSE 'Y'
                     END 



--Create synonyms for the sproc

--IF  EXISTS (SELECT * FROM sys.synonyms WHERE name = 'DYN_PS_LP_CAPTURE_SPROC')
--DROP SYNONYM [dbo].[DYN_PS_LP_CAPTURE_SPROC]
--SET @SQL = '
--CREATE SYNONYM DYN_PS_LP_CAPTURE_SPROC
--FOR [DynamicsPerf].dbo.[' + @C_TASK_PROCEDURE + ']'

--IF @DEBUG = 'Y' 
--BEGIN
--PRINT '@SQL= ' + @SQL
--END

--EXEC(@SQL) 

IF @DEBUG = 'Y' 
BEGIN
PRINT 'TASK ID = ' + CAST(@C_TASK_ID AS VARCHAR(10))
PRINT 'SERVER NAME = ' + @C_SERVER_NAME 
PRINT 'DATABASE NAME = ' + @C_DATABASE_NAME
PRINT 'TASK PARMS = ' + ISNULL(@C_TASK_PARAMS, '')
PRINT 'TASK DESC = ' + ISNULL(@C_TASK_DESC,'')
PRINT 'LAST RUN = ' + ISNULL(CAST(@C_LAST_RUN AS VARCHAR(30)),'')
PRINT 'RUN NAME = ' + ISNULL(@RUN_NAME,'')
PRINT 'STATS DATE = ' + CAST(@STATS_DATE AS VARCHAR(30))
PRINT 'REMNOTE SERVER FLAG = ' + ISNULL(@REMOTE_SERVER,'')
PRINT 'AZURE DB = ' + CAST(@C_AZURE_DB AS CHAR(1))


END
			
	

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@C_TASK_DESC, '') + CONVERT(VARCHAR, GETDATE(), 109)
PRINT ''


SET @TASK_STARTTIME = GETDATE()
SET @C_TASK_PARAMS = ISNULL(@C_TASK_PARAMS,'')


IF @DEBUG = 'Y'
BEGIN

	PRINT 'SERVER TIME ZONE OFFSET = ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(10))
	PRINT 'AT LAST RUN  = ' + CAST(@C_LAST_RUN AS VARCHAR(30))

END

--REH Adjust the last_run time to UTC Time, the called sproc's will adjust it to local time unless we've never collected
IF @C_LAST_RUN > '1/1/1901'
BEGIN
SET @C_LAST_RUN = DATEADD(MI,@DPA_TZ_OFFSET *-1 ,@C_LAST_RUN)
END



IF @DEBUG = 'Y'
BEGIN
	PRINT 'AT LAST RUN TIME BEING PASSED TO SPROC ' + CAST(@C_LAST_RUN AS VARCHAR(30))
END

SELECT @SQL = 'EXEC ' + @C_TASK_PROCEDURE + '  @TASK_ID=' + CAST(@C_TASK_ID AS NVARCHAR(10)) + 
' ,@SERVER_NAME = ' + '''' +  @C_SERVER_NAME + '''' +
' ,@DATABASE_NAME = ' + '''' +  @C_DATABASE_NAME + '''' +
' ,@TASK_PARAMS = ' +  '''' +  @C_TASK_PARAMS + '''' +
' ,@TASK_DESC = ' + '''' +  @C_TASK_DESC + '''' +
' ,@LAST_RUN = ' + '''' + CONVERT(VARCHAR, @C_LAST_RUN, 109) + '''' +
' ,@RUN_NAME = ' + '''' +  @RUN_NAME + '''' +
' ,@STATS_DATE = ' + '''' + CONVERT(VARCHAR, @STATS_DATE, 109) + '''' +
' ,@REMOTE_SERVER = ' + '''' +  @REMOTE_SERVER + '''' +
' ,@AZURE_DB = ' + CAST(@C_AZURE_DB AS NVARCHAR(10)) + 
' ,@SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET AS NVARCHAR(10)) + 
' ,@DPA_TZ_OFFSET = ' + CAST(@DPA_TZ_OFFSET AS NVARCHAR(10)) + 


' ,@DEBUG = '  + '''' +  @DEBUG + ''''


UPDATE CAPTURE_LOG
SET    TEXT = TEXT  + CHAR(13) + CHAR(10) + '***** ' + @C_TASK_PROCEDURE
			+ CHAR(13) + CHAR(10)
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = @TASK_TYPE



EXECUTE @RC = sp_executesql @SQL

   					  
SET @TASK_ENDTIME = GETDATE()

SET @TASK_TIME = DATEDIFF(ss,@TASK_STARTTIME, @TASK_ENDTIME)



 /*************** RETRY LOGIC ************************/ 
 IF @RC = 1
   AND @TASK_TIME < 10 -- IT FAILED AND WAS LESS THEN 10 SECONDS
  BEGIN
      WAITFOR DELAY '00:00:02' -- REH Wait 2 seconds and try again if sproc trapped the error
      EXECUTE @RC = Sp_executesql
        @SQL

      SET @TASK_ENDTIME = Getdate()
      SET @TASK_TIME = Datediff(ss, @TASK_STARTTIME, @TASK_ENDTIME)
  END 


--REH update last  [DYNPERF_TASK_HISTORY] IF THE TASK WAS SUCCESSFUL


  
 IF @RC = 0
      BEGIN
          PRINT ''
 
          PRINT 'SUCCESSFULLY CAPTURED '
                + ISNULL(@C_TASK_DESC, '') +  ' for SERVER
	'
              + ISNULL(@C_SERVER_NAME, '') + ' on database '
              + ISNULL(@C_DATABASE_NAME, '') + ' in ' + cast(@TASK_TIME AS VARCHAR(20)) + ' SECONDS '


  -- REH set last run for daily tasks to previous day so that they will run at midnight from here forward
 SET @STATS_DATE_HOLD = @STATS_DATE
 IF @C_SCHED_UNITS IN ('DD','WK','MM','QQ', 'YY') 

 BEGIN
	--REH Adjust to midnight the previous night if last run was 1/1/1900 so that all daily tasks will then run at midnight

		--REH floor it to today then subtract 2 mins so that its before midnight so that daily tasks will run at 
		-- midnight from now on and not run when we installed DynamicsPerf

	 SET @STATS_DATE_HOLD = DATEADD(MI,-2,dateadd(DAY,datediff(DAY,0,@STATS_DATE),0))


 END


       --REH if a manual capture don't update last run so we don't mess up the scheduling engine
				 IF @MANUAL_CAPTURE = 'N'
				 BEGIN
						  MERGE DynamicsPerf..[DYNPERF_TASK_HISTORY] AS target
						  USING (SELECT @C_SERVER_NAME   AS SERVER_NAME,
										@C_DATABASE_NAME AS DATABASE_NAME,
										@C_TASK_ID       AS TASK_ID,
										@STATS_DATE_HOLD      AS LAST_RUN,
										@TASK_TIME	AS LAST_EXECUTION_TIME_SECS 
												) AS source
						  ON ( source.SERVER_NAME = target.LINKEDSERVER_NAME
							   AND source.DATABASE_NAME = target.DATABASE_NAME
							   AND source.TASK_ID = target.TASK_ID )
						  WHEN MATCHED THEN
							UPDATE SET LAST_RUN = source.LAST_RUN, [LAST_EXECUTION_TIME_SECS] = source.[LAST_EXECUTION_TIME_SECS]
						  WHEN NOT MATCHED THEN
							INSERT ( [LINKEDSERVER_NAME],
									 [DATABASE_NAME],
									 [TASK_ID],
									 [LAST_RUN],
									 [LAST_EXECUTION_TIME_SECS])
							VALUES (source.SERVER_NAME,
									source.DATABASE_NAME,
									source.TASK_ID,
									source.LAST_RUN,
									source.LAST_EXECUTION_TIME_SECS );
				END
      END
 ELSE
	IF @RC = 1  --REH SPROC HANDLED THE ERROR
      BEGIN
          PRINT ''
 
          PRINT 'FAILED !!!!!! ' + ISNULL(@C_TASK_DESC, '')
 
          PRINT ''
      END 
 

 
 

           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_LP_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_LP_QUERY_SYSDATABASES')

  
END TRY 

BEGIN CATCH


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PROCEDURE FAILED !!! '
              + ISNULL(@C_TASK_DESC, 'TASK') + ' for SERVER
	'
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) + ', '
WHERE  STATS_TIME = @STATS_DATE  AND TASK_TYPE = @TASK_TYPE

PRINT 'ERROR WHILE COLLECTING ' + ISNULL(@C_TASK_DESC, '') +' !!!!!!!!!!!!!!'


           IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_PS_LP_QUERY_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_PS_LP_QUERY_SYSDATABASES')


END CATCH



FETCH NEXT FROM TASK_CURSOR INTO @C_TASK_ID, @C_SERVER_NAME, @C_DATABASE_NAME, @C_TASK_PROCEDURE, @C_TASK_PARAMS, @C_TASK_DESC, @C_SERVER_LEVEL_TASK,@C_AZURE_DB, @C_LAST_RUN, @C_SCHED_UNITS


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
 DELETE FROM COLLECTIONDATABASES WHERE TASK_TYPE = @TASK_TYPE  --REH CLEANUP IN CASE SOMEBODY ELSE RUNS MANUAL CAPTURE
 
			

ENDPROC:
PRINT 'RUN NAME = '+ @RUN_NAME
GO
PRINT N'Altering [dbo].[DYNPERF_COLLECT_SSRS_EXECUTIONLOG]...';


GO

ALTER PROCEDURE DYNPERF_COLLECT_SSRS_EXECUTIONLOG (
											  @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

DECLARE @SQL              NVARCHAR(MAX),
        @SQL2             NVARCHAR(MAX),
        @C_SERVER_NAME    NVARCHAR(128),
        @C_LAST_COLLECTED DATETIME,
        @UTC_TIME         DATETIME,
        @ROW_COUNT        BIGINT = 0,
        @C_DATABASE_NAME  NVARCHAR(128),
        @REMOTE_SERVER    NVARCHAR(1) = 'Y',
        @STATS_DATE       DATETIME = GETDATE(),
        @SQL_TZ_OFFSET    INT,
        @DPA_TZ_OFFSET    INT,
        @TASK_ID          INT,
        @SERVER_NAME      NVARCHAR(128),
        @DATABASE_NAME    NVARCHAR(128),
        @LAST_RUN         DATETIME 

		

    
 INSERT CAPTURE_LOG  SELECT 'SSRS', @STATS_DATE, 'STARTING to COLLECT SSRS ExecutionLog2  @DEBUG = ' + @DEBUG + '  ' + CHAR(10) + CHAR(13)

   
    
/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

SET @DPA_TZ_OFFSET = DATEDIFF(MI,GETUTCDATE(),GETDATE())

SET @UTC_TIME = DATEADD(MI,@DPA_TZ_OFFSET,@STATS_DATE)




BEGIN TRY
PRINT 'STARTING to COLLECT SSRS Data'
PRINT ''


DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT SERVER_NAME,
       Isnull(LAST_COLLECTED, '1/1/1900'), 
	   DATABASE_NAME
FROM   DynamicsPerf..SSRS_CONFIG SSRS
WHERE LAST_COLLECTED < @UTC_TIME



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_SERVER_NAME, @C_LAST_COLLECTED, @C_DATABASE_NAME



/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */

	          SET @REMOTE_SERVER = CASE ISNULL(@C_SERVER_NAME, @@SERVERNAME)
                                WHEN @@SERVERNAME THEN 'N'
                                ELSE 'Y'
                              END


  -- CREATE TABLE #SQL_INFO
  --   (
  --      SQL_STARTTIME DATETIME,
  --      SQL_BUILD NVARCHAR(20),
		--SQL_TZ_OFFSET INT
  --   )
   
   SET NOCOUNT ON
   

   
TRUNCATE TABLE WRK_TZ_SQL_INFO   --REH clear out table to repopulate

 
SELECT @SQL = 'SELECT create_date AS SQL_STARTTIME,
       CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))    AS SQL_BUILD,
	   DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
		FROM sys.databases WHERE name = ''TempDB'''

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END

SET @REMOTE_SERVER = 'N'
IF @C_SERVER_NAME <> @@SERVERNAME  SET @REMOTE_SERVER = 'Y'
   
   SET NOCOUNT ON
 
IF @REMOTE_SERVER = 'N'
BEGIN
		   INSERT WRK_TZ_SQL_INFO
		EXEC( @SQL)
END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
				SET @SQL2 = ' 
				SET QUOTED_IDENTIFIER OFF
					SELECT  * FROM OPENQUERY(['+@C_SERVER_NAME+ '],"
				SELECT create_date AS SQL_STARTTIME,
				CAST(Serverproperty(''ProductVersion'') AS NVARCHAR(20))  AS SQL_BUILD,
				DATEDIFF(MI,GETUTCDATE(),GETDATE()) AS TZ_OFFSET
				FROMsys.databases WHERE name = ''TempDB'' "	)'
		


				IF @DEBUG = 'Y'
                  BEGIN
                      PRINT '@SQL= ' + @SQL2
                  END 
                
			INSERT WRK_TZ_SQL_INFO
				EXEC (@SQL2) 
 
 END
 
 --INSERT @SQL_INFO SELECT SQL_STARTTIME,  SQL_BUILD,TZ_OFFSET FROM WRK_TZ_SQL_INFO


 SET @SQL_TZ_OFFSET = (SELECT TZ_OFFSET FROM WRK_TZ_SQL_INFO)


   --INSERT #SQL_INFO
   --EXECUTE SP_TZOFFSET
   --  @SERVER_NAME = @C_SERVER_NAME,
   --  @DATABASE_NAME = @C_DATABASE_NAME--, @DEBUG = 'N'





--REH LAST_COLLECTED IS STORE IN UTC TIME, NEED TO CONVERT BACK TO LOCAL TIME AS TIMEEND IN EXECUTIONLOG2 IS LOCAL SQL TIME

IF @C_LAST_COLLECTED > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @C_LAST_COLLECTED = DATEADD(MI, @DPA_TZ_OFFSET*-1, @C_LAST_COLLECTED) --REH STORED AS UTC TIME, NEED TO CONVERT TO LOCAL TIME
        END
      ELSE
        BEGIN
            SET @C_LAST_COLLECTED = DATEADD(MI, @SQL_TZ_OFFSET*-1, @C_LAST_COLLECTED)  --REH STORED AS UTC TIME, NEED TO CONVERT TO LOCAL TIME
        END
  END 

  --PRINT '@C_LAST_COLLECTED ' + CAST(@C_LAST_COLLECTED AS VARCHAR(50))



IF @REMOTE_SERVER = 'N'
BEGIN

	
		SET @SQL = 'SET DATEFORMAT MDY 
		INSERT INTO DynamicsPerf.dbo.SSRS_EXECUTIONLOG

	SELECT '
	+ QUOTENAME( @C_SERVER_NAME,'''') + ', '
	+ '''' +  CONVERT(NVARCHAR(24), @STATS_DATE, 121) + '''' + ', '
	+ '''' + @C_DATABASE_NAME + '''' + ', ' 
	+'InstanceName, 
	REPLACE(COALESCE(C.Path, ''Unknown''),C.Name,'+'''' + ''''+') AS ReportPath, 
	C.Name,
	''Removed for security reason'', --UserName,
	ExecutionId, 
	CASE(RequestType)
		WHEN 0 THEN ''Interactive''
		WHEN 1 THEN ''Subscription''
		ELSE ''Unknown''
		END AS RequestType, 
	-- SubscriptionId, 
	Format, 
	Parameters, 
	CASE(ReportAction)		
		WHEN 1 THEN ''Render''
		WHEN 2 THEN ''BookmarkNavigation''
		WHEN 3 THEN ''DocumentMapNavigation''
		WHEN 4 THEN ''DrillThrough''
		WHEN 5 THEN ''FindString''
		WHEN 6 THEN ''GetDocumentMap''
		WHEN 7 THEN ''Toggle''
		WHEN 8 THEN ''Sort''
		ELSE ''Unknown''
		END AS ReportAction,
	TimeStart, 
	TimeEnd, 
	TimeDataRetrieval, 
	TimeProcessing, 
	TimeRendering,
	CASE(Source)
		WHEN 1 THEN ''Live''
		WHEN 2 THEN ''Cache''
		WHEN 3 THEN ''Snapshot'' 
		WHEN 4 THEN ''History''
		WHEN 5 THEN ''AdHoc''
		WHEN 6 THEN ''Session''
		WHEN 7 THEN ''Rdce''
		ELSE ''Unknown''
		END AS Source,
	Status,
	ByteCount,
	[RowCount]
FROM ['+@C_DATABASE_NAME + '].dbo.ExecutionLogStorage EL WITH(NOLOCK)
LEFT OUTER JOIN ['+@C_DATABASE_NAME + '].dbo.Catalog C WITH(NOLOCK) ON (EL.ReportID = C.ItemID)
WHERE TimeEnd >= ' +'''' + CONVERT(NVARCHAR(24), @C_LAST_COLLECTED, 121) +''''

	EXEC (@sql)
	
	
END

 IF @REMOTE_SERVER = 'Y'
 BEGIN
 
 
		SET @SQL = 'SET DATEFORMAT MDY 
	SELECT '
		+ QUOTENAME( @C_SERVER_NAME,'''') +  ', '
	+ '''' +  CONVERT(NVARCHAR(24), @STATS_DATE, 121) + '''' + ', '
	+ '''' + @C_DATABASE_NAME + '''' + ', ' +
	'InstanceName, 
	REPLACE(COALESCE(C.Path, ''Unknown''),C.Name,'+'''' + ''''+') AS ReportPath, 
	C.Name,
	''Removed for security reason'', --UserName,
	ExecutionId, 
	CASE(RequestType)
		WHEN 0 THEN ''Interactive''
		WHEN 1 THEN ''Subscription''
		ELSE ''Unknown''
		END AS RequestType, 
	-- SubscriptionId, 
	Format, 
	Parameters, 
	CASE(ReportAction)		
		WHEN 1 THEN ''Render''
		WHEN 2 THEN ''BookmarkNavigation''
		WHEN 3 THEN ''DocumentMapNavigation''
		WHEN 4 THEN ''DrillThrough''
		WHEN 5 THEN ''FindString''
		WHEN 6 THEN ''GetDocumentMap''
		WHEN 7 THEN ''Toggle''
		WHEN 8 THEN ''Sort''
		ELSE ''Unknown''
		END AS ReportAction,
	TimeStart, 
	TimeEnd, 
	TimeDataRetrieval, 
	TimeProcessing, 
	TimeRendering,
	CASE(Source)
		WHEN 1 THEN ''Live''
		WHEN 2 THEN ''Cache''
		WHEN 3 THEN ''Snapshot'' 
		WHEN 4 THEN ''History''
		WHEN 5 THEN ''AdHoc''
		WHEN 6 THEN ''Session''
		WHEN 7 THEN ''Rdce''
		ELSE ''Unknown''
		END AS Source,
	Status,
	ByteCount,
	[RowCount]
FROM ['+@C_DATABASE_NAME + '].dbo.ExecutionLogStorage EL WITH(NOLOCK)
LEFT OUTER JOIN ['+@C_DATABASE_NAME + '].dbo.Catalog C WITH(NOLOCK) ON (EL.ReportID = C.ItemID)
WHERE TimeEnd >= ' +'''' + CONVERT(NVARCHAR(24), @C_LAST_COLLECTED, 121) +''''



		                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  INSERT INTO DynamicsPerf.dbo.SSRS_EXECUTIONLOG
				 SELECT * FROM OPENQUERY([' + @C_SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '
                    
                    EXEC (@SQL2)
           
               
 
 
 END
 
 SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT


 UPDATE SSRS_CONFIG SET LAST_COLLECTED = @UTC_TIME WHERE SERVER_NAME = @C_SERVER_NAME

 --PRINT '@DPA_TZ_OFFSET ' + CAST(@DPA_TZ_OFFSET AS VARCHAR(50))
 --PRINT '@STATS_DATE ' + CAST(@STATS_DATE AS VARCHAR(50))
 --PRINT '@UTC_TIME ' + CAST(@UTC_TIME AS VARCHAR(50))

 
UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY collected SSRS data for SERVER ' + @C_SERVER_NAME 
              + ' on database ' + @C_DATABASE_NAME
             +  CHAR(10) + CHAR(13)
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = 'SSRS'


 TRUNCATE TABLE WRK_TZ_SQL_INFO --REH Cleanout the table for next loop

FETCH NEXT FROM TASK_CURSOR INTO @C_SERVER_NAME, @C_LAST_COLLECTED, @C_DATABASE_NAME



END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
 


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY collected SSRS Data'
WHERE  STATS_TIME = @STATS_DATE AND TASK_TYPE = 'SSRS'


PRINT ''
PRINT 'SUCCESSFULLY COLLECTED SSRS DATA'
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/



BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to collect SSRS Data '
				  + ' TRYING TO PROCESS REPORT SERVER ' + ISNULL(@C_SERVER_NAME,'') + '  '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE ='SSRS'



    PRINT 'ERROR WHILE COLLECTING SSRS DATA'
          

   -- RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_PROCESS_AXSQLTRACE]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PROCESS_AXSQLTRACE]
		(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

SELECT TOP 10 SERVER_NAME,
              DATABASE_NAME,
              QUERY_HASH,
              SQL_TEXT,
              ROW_NUM
INTO   #AX_SQLTRACE
FROM   AX_SQLTRACE AST
WHERE  SERVER_NAME = @SERVER_NAME
       AND DATABASE_NAME = @DATABASE_NAME
       AND AST.CANPROCESS = 1 --REH This is a computed column on the AX_SQLTRACE table
--   AND AST.QUERY_HASH IS NULL 
--   AND LEN(AST.SQL_TEXT) < 4000
ORDER  BY ROW_NUM DESC 



UPDATE AST
SET    QUERY_HASH = COALESCE(A.QUERY_HASH, 0X00) --REH There could be several. We are only getting the first
FROM   #AX_SQLTRACE AST
       CROSS APPLY (SELECT QUERY_HASH
                    FROM   (SELECT TOP 1 QUERY_HASH,
                                         SQL_TEXT
                            FROM   QUERY_TEXT QT WITH (NOLOCK)
                            WHERE  QT.SERVER_NAME = AST.SERVER_NAME
                                   AND QT.DATABASE_NAME = AST.DATABASE_NAME
                                   AND QT.SQL_TEXT LIKE Substring(AST.SQL_TEXT, 1, 10) + '%') AS B
                    WHERE  B.SQL_TEXT LIKE Replace(AST.SQL_TEXT, '?', '%')) AS A 




--WHERE  SERVER_NAME = @SERVER_NAME
--       AND DATABASE_NAME = @DATABASE_NAME
--       AND AST.QUERY_HASH IS NULL 
--	   AND LEN(AST.SQL_TEXT) < 4000 --REH LIKE command is limited to 8k characters

UPDATE AST
SET QUERY_HASH = ASTEMP.QUERY_HASH
FROM AX_SQLTRACE AST
INNER JOIN #AX_SQLTRACE ASTEMP ON AST.ROW_NUM = ASTEMP.ROW_NUM

DROP TABLE #AX_SQLTRACE

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_PROCESS_QUERY_ALERTS]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PROCESS_QUERY_ALERTS]
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @PCT_AVG_TIME_CHANGE_DAY int, @PCT_AVG_TIME_CHANGE_MONTH INT
	DECLARE @MIN_EXECUTION_COUNTS INT, @MIN_AVG_TIME_MS INT
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




SELECT @PCT_AVG_TIME_CHANGE_DAY = PCT_AVG_TIME_CHANGE_DAY,
       @PCT_AVG_TIME_CHANGE_MONTH = PCT_AVG_TIME_CHANGE_MONTH,
       @MIN_EXECUTION_COUNTS = MIN_EXECUTION_COUNTS,
       @MIN_AVG_TIME_MS = MIN_AVG_TIME_MS
FROM   QUERY_ALERTS_CONFIG
WHERE  SERVER_NAME = @SERVER_NAME
       AND DATABASE_NAME = @DATABASE_NAME 


--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
  --REH in this case, we are going to compare to STATS_TIME which is the DynamicsPerf Time Zone so convert last_run back into that time

     SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset

  END 


IF @PCT_AVG_TIME_CHANGE_DAY IS NULL 
  BEGIN
                --MJP Log no alerts
                UPDATE CAPTURE_LOG
                 SET    TEXT = TEXT + 'No Alerts Configured! '
                  WHERE  STATS_TIME = @STATS_DATE 
                  AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)
                RETURN(0)  --REH No settings for this server/db just return and do nothing
  END


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH SAME QUERY_HASH/PLAN_HASH , true parm sniffing query issue

INSERT QUERY_ALERTS
SELECT DISTINCT QS_CTE.SERVER_NAME,
       QS_CTE.STATS_TIME,
       QS_CTE.DATABASE_NAME,
       QS_CTE.QUERY_HASH,
       QS_CTE.QUERY_PLAN_HASH
FROM    (SELECT SERVER_NAME,
					   DATABASE_NAME,
					   STATS_TIME,
					   QUERY_HASH,
					   QUERY_PLAN_HASH,
					   SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                               AS TOTAL_TIME_MS,
					   SUM(EXECUTIONS_THIS_PERIOD)                                                            AS TOTAL_EXECUTIONS,
					   CASE SUM(EXECUTIONS_THIS_PERIOD)
						 WHEN 0 THEN 0
						 ELSE ( SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3))) / SUM(EXECUTIONS_THIS_PERIOD) )
					   END                                                                                    AS AVG_TIME_MS,
					   SUM(CAST(WORKER_TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                        AS WORK_TIME,
					   SUM(CAST(( TIME_THIS_PERIOD - WORKER_TIME_THIS_PERIOD ) / 1000.000 AS DECIMAL(14, 3))) AS WAIT_TIME
			FROM   QUERY_STATS_CTE_VW CTE WITH (NOLOCK)
			WHERE  
				--QS.SERVER_NAME = CTE.SERVER_NAME AND QS.DATABASE_NAME=CTE.DATABASE_NAME AND
				--QS.STATS_TIME = CTE.STATS_TIME 
				--AND QS.QUERY_HASH = CTE.QUERY_HASH AND QS.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH AND
				 CTE.DATABASE_NAME = @DATABASE_NAME AND CTE.SERVER_NAME = @SERVER_NAME
				AND CTE.STATS_TIME > @LAST_RUN

			GROUP  BY SERVER_NAME,
						DATABASE_NAME,
				         STATS_TIME,
						QUERY_HASH,
						QUERY_PLAN_HASH) AS QS_CTE

       INNER JOIN QUERY_HISTORY QHD 
               ON QHD.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHD.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHD.QUERY_HASH = QS_CTE.QUERY_HASH
                  AND QHD.QUERY_PLAN_HASH = QS_CTE.QUERY_PLAN_HASH
                  AND QHD.FLAG = 'D'
                  AND QHD.DATE = DATEADD(DAY, DATEDIFF(DAY, 0, QS_CTE.STATS_TIME), 0)
       INNER JOIN QUERY_HISTORY QHM
               ON QHM.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHM.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHM.QUERY_HASH = QS_CTE.QUERY_HASH
                  AND QHM.QUERY_PLAN_HASH = QS_CTE.QUERY_PLAN_HASH
                  AND QHM.FLAG = 'M'
                  AND QHM.DATE = DATEADD(MONTH, DATEDIFF(MONTH, 0, QS_CTE.STATS_TIME), 0)
WHERE  QS_CTE.SERVER_NAME = @SERVER_NAME
       AND QS_CTE.DATABASE_NAME = @DATABASE_NAME
       AND QS_CTE.STATS_TIME > @LAST_RUN
       AND ( ( QS_CTE.AVG_TIME_MS  > QHD.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_DAY/100
                OR QS_CTE.AVG_TIME_MS   > QHM.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_MONTH/100 )
             AND QS_CTE.AVG_TIME_MS   > @MIN_AVG_TIME_MS
             AND QS_CTE.TOTAL_EXECUTIONS > @MIN_EXECUTION_COUNTS ) 
			 option (maxdop 1)
--REH any variation 
INSERT QUERY_ALERTS
SELECT DISTINCT QS_CTE.SERVER_NAME,
       QS_CTE.STATS_TIME,
       QS_CTE.DATABASE_NAME,
       QS_CTE.QUERY_HASH,
       QS_CTE.QUERY_PLAN_HASH
FROM    (SELECT TOP 100 SERVER_NAME,
					   DATABASE_NAME,
					   STATS_TIME,
					   QUERY_HASH,
					   QUERY_PLAN_HASH,
					   SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                               AS TOTAL_TIME_MS,
					   SUM(EXECUTIONS_THIS_PERIOD)                                                            AS TOTAL_EXECUTIONS,
					   CASE SUM(EXECUTIONS_THIS_PERIOD)
						 WHEN 0 THEN 0
						 ELSE ( SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3))) / SUM(EXECUTIONS_THIS_PERIOD) )
					   END                                                                                    AS AVG_TIME_MS,
					   SUM(CAST(WORKER_TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                        AS WORK_TIME,
					   SUM(CAST(( TIME_THIS_PERIOD - WORKER_TIME_THIS_PERIOD ) / 1000.000 AS DECIMAL(14, 3))) AS WAIT_TIME
			FROM   QUERY_STATS_CTE_VW CTE WITH (NOLOCK)
			WHERE  
				--QS.SERVER_NAME = CTE.SERVER_NAME AND QS.DATABASE_NAME=CTE.DATABASE_NAME AND
				--QS.STATS_TIME = CTE.STATS_TIME 
				--AND QS.QUERY_HASH = CTE.QUERY_HASH AND QS.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH AND
				 CTE.DATABASE_NAME = @DATABASE_NAME AND CTE.SERVER_NAME = @SERVER_NAME
				AND CTE.STATS_TIME > @LAST_RUN

			GROUP  BY SERVER_NAME,
						DATABASE_NAME,
				         STATS_TIME,
						QUERY_HASH,
						QUERY_PLAN_HASH) AS QS_CTE

       CROSS APPLY (SELECT SERVER_NAME, DATABASE_NAME, QUERY_HASH, MAX(QHD.AVG_TIME_TODAY_MS) AS AVG_TIME_TODAY_MS
				FROM  QUERY_HISTORY QHD
               WHERE QHD.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHD.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHD.QUERY_HASH = QS_CTE.QUERY_HASH
				  AND QHD.QUERY_PLAN_HASH <> QS_CTE.QUERY_PLAN_HASH
                  AND QHD.FLAG = 'D'
                  AND QHD.DATE = DATEADD(DAY, DATEDIFF(DAY, 0, QS_CTE.STATS_TIME), 0)
				  GROUP BY SERVER_NAME, DATABASE_NAME, QUERY_HASH
				  ) AS QHDAILY
       CROSS APPLY ( SELECT SERVER_NAME, DATABASE_NAME, QUERY_HASH, MAX(QHM.AVG_TIME_TODAY_MS) AS AVG_TIME_TODAY_MS
				FROM  QUERY_HISTORY QHM
               WHERE QHM.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHM.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHM.QUERY_HASH = QS_CTE.QUERY_HASH
				  AND QHM.QUERY_PLAN_HASH <> QS_CTE.QUERY_PLAN_HASH
                  AND QHM.FLAG = 'M'
                  AND QHM.DATE = DATEADD(MONTH, DATEDIFF(MONTH, 0, QS_CTE.STATS_TIME), 0)
				  GROUP BY SERVER_NAME, DATABASE_NAME, QUERY_HASH
				  ) AS QHMONTHLY
WHERE  QS_CTE.SERVER_NAME = @SERVER_NAME
       AND QS_CTE.DATABASE_NAME = @DATABASE_NAME
       AND QS_CTE.STATS_TIME > @LAST_RUN
       AND ( ( QS_CTE.AVG_TIME_MS  > QHDAILY.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_DAY/100
                OR QS_CTE.AVG_TIME_MS   > QHMONTHLY.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_MONTH/100 )
             AND QS_CTE.AVG_TIME_MS   > @MIN_AVG_TIME_MS
             AND QS_CTE.TOTAL_EXECUTIONS > @MIN_EXECUTION_COUNTS ) 
option (maxdop 1)



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_SERVER_ACTIVITY]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_SERVER_ACTIVITY]
	(@SERVER_NAME NVARCHAR(128) = @@SERVERNAME,
	@AX_DATABASE_NAME NVARCHAR(128) = NULL,
	@DEBUG CHAR(1) = 'N')

AS


SET QUOTED_IDENTIFIER OFF
DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @REMOTE_SERVER CHAR(1), @AX2012 CHAR(1) = 'N'


IF @AX_DATABASE_NAME IS NOT NULL  --This MUST be an AX database
BEGIN 

--REH Get AX version
DECLARE @HANDLE INT

DECLARE @AX_SERVER_NAME   NVARCHAR(128) = NULL,
        @AX_APP_BUILD     NVARCHAR(120),
        @KERNEL_BUILD     NVARCHAR(20)

   
   CREATE TABLE #AX_VERSION_NUM
     (
        AX_APP_BUILD NVARCHAR(120),
        KERNEL_BUILD NVARCHAR(20)
     )
   
   SET NOCOUNT ON
   
   INSERT #AX_VERSION_NUM
   EXECUTE DYNPERF_AX_VERSION_INFO
     @AX_SERVER_NAME = @SERVER_NAME,
     @AX_DATABASE_NAME = @AX_DATABASE_NAME--, @DEBUG = 'N'
   SELECT @AX_APP_BUILD = AX_APP_BUILD,
          @KERNEL_BUILD = KERNEL_BUILD
   FROM   #AX_VERSION_NUM
   
   
   IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = '#AX_VERSION_NUM') 
	BEGIN
	  DROP TABLE #AX_VERSION_NUM 
	END

	IF @AX_APP_BUILD > '6.' SET @AX2012 = 'Y'



	IF @SERVER_NAME <> @@SERVERNAME
	BEGIN
		--PUT  the context info function in the remote database if it doesn't exist


				 SET @SQL = ''
					SET @SQL = 'USE [' + 'master' + '];' + CHAR(10)  

					SET @SQL = @SQL + '

					DECLARE @SQL NVARCHAR(MAX)
					SET @SQL = ''

					
						IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N''''[dbo].[FN_RETURN_AXID_FROM_CONTEXT]''''))
						 DROP FUNCTION [dbo].[FN_RETURN_AXID_FROM_CONTEXT]
						 ''

					 EXEC(@SQL)
					' 

					

						  SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
																	  EXEC (' + '"' + @SQL + '"' + ') AT ['
									  + @SERVER_NAME + ']'

						  IF @DEBUG = 'Y'
							BEGIN
								PRINT '@SQL= ' + @SQL2
							END

						  EXEC (@SQL2)


				 SET @SQL = ''
					SET @SQL = 'USE [' + 'master' + '];' + CHAR(10)  

					SET @SQL = @SQL + '

					DECLARE @SQL NVARCHAR(MAX)
					SET @SQL = ''

					
						IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N''''[dbo].[FN_RETURN_AXSESSION_FROM_CONTEXT]''''))
						 DROP FUNCTION [dbo].[FN_RETURN_AXSESSION_FROM_CONTEXT]
						 ''

					 EXEC(@SQL)
					' 

					

						  SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
																	  EXEC (' + '"' + @SQL + '"' + ') AT ['
									  + @SERVER_NAME + ']'

						  IF @DEBUG = 'Y'
							BEGIN
								PRINT '@SQL= ' + @SQL2
							END

						  EXEC (@SQL2)


			 --IF NOT EXISTS (SELECT * FROM DYN_ACTIVITY_SYSOBJECTS WHERE object_id = OBJECT_ID(N'[dbo].[FN_RETURN_AXID_FROM_CONTEXT]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
				--BEGIN
				 SET @SQL = ''
					SET @SQL = 'USE [' + 'master' + '];' + CHAR(10)  

					SET @SQL = @SQL + '

					DECLARE @SQL NVARCHAR(MAX)
					SET @SQL = ''

					
					CREATE FUNCTION [dbo].[FN_RETURN_AXID_FROM_CONTEXT] (@CONTEXT_INFO AS VARBINARY(128))
					RETURNS NVARCHAR(8)
					WITH EXECUTE AS CALLER
					AS
						BEGIN
							DECLARE	@CONTEXT_INFO_CHAR	VARCHAR(128),
											@AXID								NVARCHAR(8)
							SET @CONTEXT_INFO_CHAR = CAST(@CONTEXT_INFO AS VARCHAR(128))
							SET @CONTEXT_INFO_CHAR = LTRIM(@CONTEXT_INFO_CHAR)

							IF CHARINDEX('''' '''', @CONTEXT_INFO_CHAR,1) > 1
								SET @AXID = SUBSTRING(@CONTEXT_INFO_CHAR, 1, (CHARINDEX('''' '''', @CONTEXT_INFO_CHAR,1)-1))
							ELSE
								SET @AXID=''''N/A''''

						  RETURN ( @AXID );
					  END''

					 EXEC(@SQL)
					' 

					

						  SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
																	  EXEC (' + '"' + @SQL + '"' + ') AT ['
									  + @SERVER_NAME + ']'

						  IF @DEBUG = 'Y'
							BEGIN
								PRINT '@SQL= ' + @SQL2
							END

						  EXEC (@SQL2)
			


					


		 SET @SQL = ''
					SET @SQL = 'USE [' + 'master' + '];' + CHAR(10)  

					SET @SQL = @SQL + '

					DECLARE @SQL NVARCHAR(MAX)
					SET @SQL = ''

					
					CREATE FUNCTION [dbo].[FN_RETURN_AXSESSION_FROM_CONTEXT] (@CONTEXT_INFO AS VARBINARY(128))
					RETURNS NVARCHAR(8)
					WITH EXECUTE AS CALLER
					AS
					BEGIN
						DECLARE	@CONTEXT_INFO_CHAR	VARCHAR(128),
										@AXSESSION					NVARCHAR(8),
										@SESSION_START_POS	INT			

						SET @CONTEXT_INFO_CHAR = CAST(@CONTEXT_INFO AS VARCHAR(128))
						SET @CONTEXT_INFO_CHAR = LTRIM(@CONTEXT_INFO_CHAR)
						SET @SESSION_START_POS = CHARINDEX('''' '''', @CONTEXT_INFO_CHAR,1)+1

						IF @SESSION_START_POS > 1
							SET @AXSESSION = SUBSTRING(@CONTEXT_INFO_CHAR, @SESSION_START_POS, (CHARINDEX('''' '''', @CONTEXT_INFO_CHAR,@SESSION_START_POS)-(@SESSION_START_POS)))
						ELSE 
							SET @AXSESSION = ''''0''''

					RETURN ( @AXSESSION );
					END
					  ''

					 EXEC(@SQL)
					' 

					

				SET @SQL2 = 'SET QUOTED_IDENTIFIER OFF
															EXEC (' + '"' + @SQL + '"' + ') AT ['
							+ @SERVER_NAME + ']'

				IF @DEBUG = 'Y'
				BEGIN
					PRINT '@SQL= ' + @SQL2
				END

				EXEC (@SQL2)
			

	END


END


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SERVER_ACTIVITY]') AND type in (N'U'))
DROP TABLE [dbo].[SERVER_ACTIVITY]



      
 SET @SQL = '
SELECT r.session_id                                     AS SPID,
       r.blocking_session_id                            AS BLOCKED_BY_SPID,
       se.host_name                                     AS HOSTNAME,
       se.login_name                                    AS LOGIN_NAME,
       DB_NAME(r.database_id)                           AS DATABASE_NAME,
       r.status                                         AS STATUS,
       r.command                                        AS COMMAND,
       r.cpu_time                                       AS CPU_TIME,
       r.total_elapsed_time                             AS TOTAL_ELAPSED_TIME,
       r.reads                                          AS READS,
       r.logical_reads                                  AS LOGICAL_READS,
       r.writes                                         AS WRITES,
       r.context_info                                   AS AX_SESSION_ID,
       r.context_info                                   AS AX_USER_ID,'
	  IF @AX_DATABASE_NAME IS NOT NULL 
	   BEGIN
	   SET @SQL = @SQL + 'U.NAME AS AX_USER_NAME,'
	   END
SET @SQL = @SQL + '
       CAST(r.context_info AS VARCHAR(128))             AS CONTEXT_INFO,'
	   IF @AX_DATABASE_NAME IS NOT NULL 
	   BEGIN
	   SET @SQL = @SQL + '
	   
       CASE SC.SESSIONTYPE
            WHEN 0 THEN ''User''
            WHEN 1 THEN ''Business Connector''
            WHEN 3 THEN ''RunAs Worker / Batch''
            WHEN 0 THEN ''Web user''
            END                                               AS SESSION_TYPE,

        CASE SC.STATUS
            WHEN 0 THEN ''Inactive''
            WHEN 1 THEN ''Running''
            WHEN 2 THEN ''Ending Waiting for AOS''
            WHEN 3 THEN ''Ending  Block''
            END                                           AS SESSION_STATUS,                                    
		 B.CAPTION AS BATCH_NAME,
		 J.CAPTION AS BATCH_JOB_NAME,
			 CASE B.STATUS
				WHEN 2 THEN ''Executing''
				when 7 then ''Cancelling''
				else null
			 END AS BATCH_STATUS,
		B.STARTDATETIME,'
		END

	IF @AX_DATABASE_NAME IS NOT NULL AND @AX2012 = 'Y'
	   BEGIN
	   SET @SQL = @SQL + '
		me.name AS BATCH_CLASS_NAME,
	   '
	   END

SET @SQL = @SQL + '
       s.text                                           AS SQL_TEXT,
       CAST(p.query_plan AS NVARCHAR(MAX))              AS QUERY_PLAN,
       SQL_CURSORSQL.text                               AS CURSOR_SQL_TEXT,
       CAST(SQL_CURSORPLAN.query_plan AS NVARCHAR(MAX)) AS CURSOR_QUERY_PLAN,
       BLOCKING_DATA.ctext                              AS BLOCKING_TEXT,
       BLOCKING_DATA.BLOCKING_CONTEXT                   AS BLOCKING_CONTEXT,
       BLOCKING_DATA.BLOCKING_QUERY_PLAN                AS BLOCKING_QUERY_PLAN,
       BLOCKING_DATA.BLOCKING_CURSOR_PLAN               AS BLOCKING_CURSOR_PLAN,
       r.wait_time                                      AS WAIT_TIME,
       r.wait_type                                      AS WAIT_TYPE,
       r.open_transaction_count                         AS OPEN_TRANS_COUNT,
       r.estimated_completion_time                      AS ESTIMATED_COMPLETION_TIME,
       TSU.TEMPDBUSEROBJECTSALLOCATED                   AS TEMPDB_USER_OBJECTS_ALLOCATED,
       TSU.TEMPDBUSEROBJECTSDEALLOCATED                 AS TEMPDB_USER_OBJECTS_DEALLOCATED,
       TSU.TEMPDBINTERNALOBJECTSALLOCATED               AS TEMPDB_INTERNAL_OBJECTS_ALLOCATED,
       TSU.TEMPDBINTERNALOBJECTSDEALLOCATED             AS TEMPDB_INTERNAL_OBJECTS_DEALLOCATED'
         
         
SELECT @SQL = @SQL + '

FROM   sys.dm_exec_requests AS r
       INNER JOIN sys.dm_exec_sessions AS se
               ON r.session_id = se.session_id
       OUTER APPLY sys.dm_exec_sql_text(r.sql_handle) AS s
       OUTER APPLY sys.dm_exec_query_plan(r.plan_handle) AS p
       OUTER APPLY sys.dm_exec_cursors(r.session_id) AS SQL_CURSORS
       OUTER APPLY sys.dm_exec_sql_text(SQL_CURSORS.sql_handle) AS SQL_CURSORSQL
       LEFT JOIN sys.dm_exec_query_stats AS SQL_CURSORSTATS
              ON SQL_CURSORSTATS.sql_handle = SQL_CURSORS.sql_handle
       OUTER APPLY sys.dm_exec_query_plan(SQL_CURSORSTATS.plan_handle) AS SQL_CURSORPLAN
       OUTER APPLY (SELECT r.session_id,
                           CAST(r_blk.context_info AS VARCHAR(128))         AS BLOCKING_CONTEXT,
                           s.text,
                           SQL_CURSORSQL.text                               AS CTEXT,
                           CAST(SQL_CURSORPLAN.query_plan AS NVARCHAR(MAX)) AS BLOCKING_CURSOR_PLAN,
                           CAST(p.query_plan AS NVARCHAR(MAX))              AS BLOCKING_QUERY_PLAN
                    FROM   sys.dm_exec_requests AS r_blk
                           INNER JOIN sys.dm_exec_sessions AS se
                                   ON r.session_id = se.session_id
                           OUTER APPLY sys.dm_exec_sql_text(r.sql_handle) AS s
                           OUTER APPLY sys.dm_exec_query_plan(r.plan_handle) AS p
                           OUTER APPLY sys.dm_exec_cursors(r.session_id) AS SQL_CURSORS
                           OUTER APPLY sys.dm_exec_sql_text(SQL_CURSORS.sql_handle) AS SQL_CURSORSQL
                           LEFT JOIN sys.dm_exec_query_stats AS SQL_CURSORSTATS
                                  ON SQL_CURSORSTATS.sql_handle = SQL_CURSORS.sql_handle
                           OUTER APPLY sys.dm_exec_query_plan(SQL_CURSORSTATS.plan_handle) AS SQL_CURSORPLAN
                    WHERE  r_blk.session_id = r.blocking_session_id) AS BLOCKING_DATA
       LEFT JOIN (SELECT SESSIONID = session_id,
                         REQUESTID = request_id,
                         TEMPDBUSEROBJECTSALLOCATED = SUM (user_objects_alloc_page_count),
                         TEMPDBUSEROBJECTSDEALLOCATED = SUM(user_objects_dealloc_page_count),
                         TEMPDBINTERNALOBJECTSALLOCATED = SUM (internal_objects_alloc_page_count),
                         TEMPDBINTERNALOBJECTSDEALLOCATED = SUM (internal_objects_dealloc_page_count)
                  FROM   sys.dm_db_task_space_usage
                  GROUP  BY session_id,
                            request_id) AS TSU
              ON TSU.SESSIONID = r.session_id
                 AND TSU.REQUESTID = r.request_id'

IF @AX_DATABASE_NAME IS NOT NULL
BEGIN
	SET @SQL = @SQL + '
			LEFT JOIN   [' + @AX_DATABASE_NAME + '].dbo.SYSCLIENTSESSIONS SC 
            ON  SC.SESSIONID = dbo.FN_RETURN_AXSESSION_FROM_CONTEXT(r.context_info)
            AND SC.USERID = dbo.FN_RETURN_AXID_FROM_CONTEXT(r.context_info)
		LEFT JOIN    [' + @AX_DATABASE_NAME + '].dbo.BATCH B
            ON  B.SESSIONIDX = dbo.FN_RETURN_AXSESSION_FROM_CONTEXT(r.context_info)
            AND B.STATUS IN (2,7)
		LEFT JOIN   [' + @AX_DATABASE_NAME + '].dbo.BATCHJOB J ON B.BATCHJOBID = J.RECID
		LEFT JOIN	[' + @AX_DATABASE_NAME + '].dbo.USERINFO U ON U.ID =  dbo.FN_RETURN_AXID_FROM_CONTEXT(r.context_info) '

	IF @AX_DATABASE_NAME IS NOT NULL AND @AX2012 = 'Y'
	   BEGIN
	   SET @SQL = @SQL + '
		LEFT JOIN [' + @AX_DATABASE_NAME + '_model'+  '].dbo.MODELELEMENT ME ON B.CLASSNUMBER = ME.axid AND Me.elementtype = 45
	   
	   '
	   END

		
		
END

SET @SQL = @SQL + '
WHERE  r.session_Id > 50 AND r.session_id <> @@SPID
       AND se.host_name IS NOT NULL 			   
				   
				   '
                    

IF @SERVER_NAME <> @@SERVERNAME
BEGIN

                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF

				 SELECT RH.*
                    INTO SERVER_ACTIVITY
                     FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH '

		IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL2
		END
				 
				 EXECUTE (@SQL2)
END
ELSE
BEGIN

		SET @SQL2 = '
		SELECT RH.*
			INTO SERVER_ACTIVITY
				FROM (' +@SQL + ') RH'
		
		IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL2
		END

		EXECUTE (@SQL2)
END



SET @SQL = '
SELECT [SPID],
       [BLOCKED_BY_SPID],
       [HOSTNAME],
       [LOGIN_NAME],
       [DATABASE_NAME],
       [STATUS],
       [COMMAND],
       [CPU_TIME],
       [TOTAL_ELAPSED_TIME],
       [READS],
       [LOGICAL_READS],
       [WRITES],
       dbo.FN_RETURN_AXSESSION_FROM_CONTEXT([AX_SESSION_ID]) AS AX_SESSION_ID,
       dbo.FN_RETURN_AXID_FROM_CONTEXT([AX_USER_ID])         AS AX_USER_ID,'
	   IF @AX_DATABASE_NAME IS NOT NULL 
	   BEGIN
	   SET @SQL = @SQL + 'AX_USER_NAME,'
	   END
	SET @SQL = @SQL + '
       [CONTEXT_INFO],'
	   IF @AX_DATABASE_NAME IS NOT NULL 
	   BEGIN
	   SET @SQL = @SQL + '
	   
        SESSION_TYPE,
		 SESSION_STATUS,                                    
		  BATCH_NAME,
		 BATCH_JOB_NAME,
		 BATCH_STATUS,
		STARTDATETIME,'
		END
	   IF @AX_DATABASE_NAME IS NOT NULL AND @AX2012 = 'Y'
	   BEGIN
	   SET @SQL = @SQL + '
		BATCH_CLASS_NAME,
	   '
	   END

SET @SQL = @SQL + '
       [SQL_TEXT],
       Cast([QUERY_PLAN] AS XML)                             AS QUERY_PLAN,
       [CURSOR_SQL_TEXT],
       Cast([CURSOR_QUERY_PLAN] AS XML)                      AS CURSOR_QUERY_PLAN,
       BLOCKING_TEXT,
       BLOCKING_CONTEXT,
       BLOCKING_QUERY_PLAN,
       BLOCKING_CURSOR_PLAN,
       [WAIT_TIME],
       [WAIT_TYPE],
       [OPEN_TRANS_COUNT],
       [ESTIMATED_COMPLETION_TIME],
       [TEMPDB_USER_OBJECTS_ALLOCATED],
       [TEMPDB_USER_OBJECTS_DEALLOCATED],
       [TEMPDB_INTERNAL_OBJECTS_ALLOCATED],
       [TEMPDB_INTERNAL_OBJECTS_DEALLOCATED]
FROM   [dbo].[SERVER_ACTIVITY]
ORDER  BY [TOTAL_ELAPSED_TIME] DESC '


		IF @DEBUG = 'Y' 
		BEGIN
		PRINT '@SQL= ' + @SQL
		END


EXEC (@SQL)


DROP TABLE SERVER_ACTIVITY
GO
PRINT N'Altering [dbo].[DYNPERF_UPDATE_INDEX_HISTORY]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_UPDATE_INDEX_HISTORY]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @ROW_COUNT BIGINT = 0
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


  --REH need to figure out if it's midnight DB time for DB being rolled up
  --	Take stats_time which is time at DPA server and convert it to local time of the DB

  DECLARE @SERVER_TIME SMALLDATETIME, @SERVER_TIME_MIDNIGHT SMALLDATETIME, @TIME_DIFF INT, @SERVER_TIME_START SMALLDATETIME, @PREV_DAY SMALLDATETIME


   SET @SERVER_TIME = DATEADD(MI,@SQL_TZ_OFFSET,DATEADD(MI,@DPA_TZ_OFFSET*-1,@STATS_DATE))
  SET @SERVER_TIME_MIDNIGHT = (SELECT dateadd(DAY,datediff(DAY,-1,@SERVER_TIME),0))  --REH MIDNIGHT, NEXT DAY, SO HAVE TO BE LESS THAN THIS VALUE FOR TODAY
  SET @SERVER_TIME_START = (SELECT dateadd(DAY,datediff(DAY,0,@SERVER_TIME),0))  --REH MIDNIGHT, NEXT DAY, SO HAVE TO BE LESS THAN THIS VALUE FOR TODAY
  SET @PREV_DAY = DATEADD(DD,-1, @SERVER_TIME_START)
  SET @TIME_DIFF = DATEDIFF(MI, @SERVER_TIME, @SERVER_TIME_MIDNIGHT)


  UPDATE CAPTURE_LOG
SET    TEXT = TEXT + '  CURRENT SERVER TIME ' + CAST( @SERVER_TIME AS VARCHAR(50))
              + '  MIDNIGHT SERVER TIME ' + CAST(@SERVER_TIME_MIDNIGHT AS VARCHAR(50))
              + '  START OF TODAY ' + CAST(@SERVER_TIME_START AS VARCHAR(50))
              +'  FLOORED PREVIOUS DAY ' + CAST(@PREV_DAY AS VARCHAR(50))
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




  --REH Giving a 5 minute leaway after midnight to run this code, job will be scheduled to run hourly
 -- IF ABS(@TIME_DIFF)> 5  RETURN(0) ;  -- If it's not midnight Server time ont he DB being rolled up, then do nothing

BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



/******************************************************************************
NEED TO SUBTRACT OUT PREVIOUS DAYS AMOUNTS IF COMPILE_TIME WAS BEFORE TODAY

SUBTRACT THE LAST QUERY_STATS RECORD FROM PREVIOUS DAY WITH SAME COMPILE_TIME


*******************************************************************************/



		--REH This sums up to the totals of the day
		MERGE INDEX_HISTORY AS target
		USING (SELECT T1.SERVER_NAME,
					  T1.DATABASE_NAME,
					  T1.DDATE                                                                AS [DATE],
					  T1.TABLE_NAME,
					  T1.INDEX_NAME,
					  MAX(T1.INDEX_DESCRIPTION)                                               AS INDEX_DESCRIPTION,
					  MAX(T1.INDEX_KEYS)                                                      AS INDEX_KEYS,
					  MAX(T1.DATA_COMPRESSION)                                                AS COMPRESSION_TYPE,
					  SUM(T1.USER_SEEKS - COALESCE(T2.USER_SEEKS, 0))                         AS USER_SEEKS_DELTA,
					  SUM(T1.USER_SCANS - COALESCE(T2.USER_SCANS, 0))                         AS USER_SCANS_DELTA,
					  SUM(T1.USER_LOOKUPS - COALESCE(T2.USER_LOOKUPS, 0))                     AS USER_LOOKUPS_DELTA,
					  SUM(T1.USER_UPDATES - COALESCE(T2.USER_UPDATES, 0))                     AS USER_UPDATES_DELTA,
					  SUM(T1.RANGE_SCAN_COUNT - COALESCE(T2.RANGE_SCAN_COUNT, 0))             AS RANGE_SCAN_COUNT_DELTA,
					  SUM(T1.PAGE_COUNT - COALESCE(T2.PAGE_COUNT, 0))                         AS PAGE_COUNT_DELTA,
					  SUM(T1.ROW_COUNT - COALESCE(T2.ROW_COUNT, 0))                           AS ROW_COUNT_DELTA,
					  MAX(T1.ROW_COUNT)                                                       AS ROW_COUNT,
					  MAX(T1.PAGE_COUNT)                                                      AS PAGE_COUNT,
					  SUM(T1.SINGLETON_LOOKUP_COUNT - COALESCE(T2.SINGLETON_LOOKUP_COUNT, 0)) AS SINGLETON_LOOKUP_COUNT,
					  MAX('D')                                                                AS FLAG --REH Mark the record as a DAILY record
			   FROM   (
					  --REH is meant to be run once per day at midnight
					  SELECT SERVER_NAME,
							 DATABASE_NAME,
							 SQL_SERVER_STARTTIME,
							 TABLE_NAME,
							 INDEX_NAME,
							 MAX(@SERVER_TIME_START)     AS DDATE,
							 MAX(INDEX_DESCRIPTION)      AS INDEX_DESCRIPTION,
							 MAX(INDEX_KEYS)             AS INDEX_KEYS,
							 MAX(DATA_COMPRESSION)       AS DATA_COMPRESSION,
							 MAX(USER_SEEKS)             AS USER_SEEKS,
							 MAX(USER_SCANS)             AS USER_SCANS,
							 MAX(USER_LOOKUPS)           AS USER_LOOKUPS,
							 MAX(USER_UPDATES)           AS USER_UPDATES,
							 MAX(RANGE_SCAN_COUNT)       AS RANGE_SCAN_COUNT,
							 MAX(PAGE_COUNT)             AS PAGE_COUNT,
							 MAX(ROW_COUNT)              AS ROW_COUNT,
							 MAX(SINGLETON_LOOKUP_COUNT) AS SINGLETON_LOOKUP_COUNT
					   FROM   INDEX_STATS_VW
					   --REH STATS_TIME IS Dynperf local time, convert it to UTC TIME then convert it to local time for the server
					   WHERE  DATEADD(MI, @SQL_TZ_OFFSET, DATEADD(MI, @DPA_TZ_OFFSET * -1, STATS_TIME)) >= @SERVER_TIME_START --REH 12AM THIS MORNING
							  AND DATEADD(MI, @SQL_TZ_OFFSET, DATEADD(MI, @DPA_TZ_OFFSET * -1, STATS_TIME)) < @SERVER_TIME_MIDNIGHT --REH LESS THEN 12M NEXT DAY
							  AND SERVER_NAME = @SERVER_NAME
					   GROUP  BY SERVER_NAME,
								 DATABASE_NAME,
								 SQL_SERVER_STARTTIME,
								 TABLE_NAME,
								 INDEX_NAME) AS T1
					  LEFT JOIN (
								--REH This gives us the previous record when we rolled up the last time
								SELECT SERVER_NAME,
									   DATABASE_NAME,
									   SQL_SERVER_STARTTIME,
									   TABLE_NAME,
									   INDEX_NAME,
									   MAX(DATEADD(DAY, DATEDIFF(DAY, 0, STATS_TIME), 0)) AS DDATE,
									   MAX(INDEX_DESCRIPTION)                             AS INDEX_DESCRIPTION,
									   MAX(INDEX_KEYS)                                    AS INDEX_KEYS,
									   MAX(DATA_COMPRESSION)                              AS DATA_COMPRESSION,
									   MAX(USER_SEEKS)                                    AS USER_SEEKS,
									   MAX(USER_SCANS)                                    AS USER_SCANS,
									   MAX(USER_LOOKUPS)                                  AS USER_LOOKUPS,
									   MAX(USER_UPDATES)                                  AS USER_UPDATES,
									   MAX(RANGE_SCAN_COUNT)                              AS RANGE_SCAN_COUNT,
									   MAX(PAGE_COUNT)                                    AS PAGE_COUNT,
									   MAX(ROW_COUNT)                                     AS ROW_COUNT,
									   MAX(SINGLETON_LOOKUP_COUNT)                        AS SINGLETON_LOOKUP_COUNT
								 FROM   INDEX_STATS_VW
								 WHERE  DATEADD(DAY, DATEDIFF(DAY, 0, DATEADD(MI, @SQL_TZ_OFFSET, DATEADD(MI, @DPA_TZ_OFFSET * -1, STATS_TIME))), 0) = @PREV_DAY --REH SUBTRACT TOTAL FROM PREV DAY , FLOORING THE STATS TIME HERE TO STRIP OUT TIME
										AND SERVER_NAME = @SERVER_NAME
								 GROUP  BY SERVER_NAME,
										   DATABASE_NAME,
										   SQL_SERVER_STARTTIME,
										   TABLE_NAME,
										   INDEX_NAME) AS T2
							 ON T1.SERVER_NAME = T2.SERVER_NAME
								AND T1.DATABASE_NAME = T2.DATABASE_NAME
								AND T1.SQL_SERVER_STARTTIME = T2.SQL_SERVER_STARTTIME
								AND T1.TABLE_NAME = T2.TABLE_NAME
								AND T1.INDEX_NAME = T2.INDEX_NAME --REH sql_server_starttime is how we are linking to the stats for the same compiled query
			   GROUP  BY T1.SERVER_NAME,
						 T1.DATABASE_NAME,
						 T1.DDATE,
						 T1.TABLE_NAME,
						 T1.INDEX_NAME) AS source
		ON ( source.SERVER_NAME = target.SERVER_NAME
			 AND source.DATABASE_NAME = target.DATABASE_NAME
			 AND source.DATE = target.DATE
			 AND source.TABLE_NAME = target.TABLE_NAME
			 AND source.INDEX_NAME = target.INDEX_NAME
			 AND source.FLAG = target.FLAG )
		WHEN MATCHED THEN
		  UPDATE SET COMPRESSION_TYPE = source.COMPRESSION_TYPE,
					 USER_SEEKS_DELTA = source.USER_SEEKS_DELTA,
					 USER_SCANS_DELTA = source.USER_SCANS_DELTA,
					 USER_LOOKUPS_DELTA = source.USER_LOOKUPS_DELTA,
					 USER_UPDATES_DELTA = source.USER_UPDATES_DELTA,
					 RANGE_SCAN_COUNT_DELTA = source.RANGE_SCAN_COUNT_DELTA,
					 PAGE_COUNT_DELTA = source.PAGE_COUNT_DELTA,
					 ROW_COUNT_DELTA = source.ROW_COUNT_DELTA,
					 ROW_COUNT = source.ROW_COUNT,
					 PAGE_COUNT = source.PAGE_COUNT,
					 SINGLETON_LOOKUP_COUNT = source.SINGLETON_LOOKUP_COUNT
		WHEN NOT MATCHED THEN
		  INSERT ( [SERVER_NAME],
				   [DATABASE_NAME],
				   [DATE],
				   [TABLE_NAME],
				   [INDEX_NAME],
				   [INDEX_DESCRIPTION],
				   [INDEX_KEYS],
				   [COMPRESSION_TYPE],
				   [USER_SEEKS_DELTA],
				   [USER_SCANS_DELTA],
				   [USER_LOOKUPS_DELTA],
				   [USER_UPDATES_DELTA],
				   [RANGE_SCAN_COUNT_DELTA],
				   [PAGE_COUNT_DELTA],
				   [ROW_COUNT_DELTA],
				   [ROW_COUNT],
				   [PAGE_COUNT],
				   [SINGLETON_LOOKUP_COUNT],
				   [FLAG] )
		  VALUES (source.[SERVER_NAME],
				  source.[DATABASE_NAME],
				  source.[DATE],
				  source.[TABLE_NAME],
				  source.[INDEX_NAME],
				  source.[INDEX_DESCRIPTION],
				  source.[INDEX_KEYS],
				  source.[COMPRESSION_TYPE],
				  source.[USER_SEEKS_DELTA],
				  source.[USER_SCANS_DELTA],
				  source.[USER_LOOKUPS_DELTA],
				  source.[USER_UPDATES_DELTA],
				  source.[RANGE_SCAN_COUNT_DELTA],
				  source.[PAGE_COUNT_DELTA],
				  source.[ROW_COUNT_DELTA],
				  source.[ROW_COUNT],
				  source.[PAGE_COUNT],
				  source.[SINGLETON_LOOKUP_COUNT],
				  'D'); 


				  SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT


 --REH Rollup the daily total into the Monthly total
		MERGE INDEX_HISTORY AS target
        USING (SELECT [SERVER_NAME],
                      [DATABASE_NAME],
                      DATEADD(MONTH, DATEDIFF(MONTH, 0, [DATE]), 0) AS MDATE,
                      [TABLE_NAME]                                  AS TABLE_NAME,
                      [INDEX_NAME]                                  AS INDEX_NAME,
                      MAX(INDEX_DESCRIPTION)                        AS INDEX_DESCRIPTION,
                      MAX(INDEX_KEYS)                               AS INDEX_KEYS,
                      MAX(COMPRESSION_TYPE)                         AS COMPRESSION_TYPE,
                      SUM(CASE
                            WHEN ISNULL(USER_SEEKS_DELTA, 0) <= 0 THEN 0
                            ELSE USER_SEEKS_DELTA
                          END)                                      AS USER_SEEKS_DELTA,
                      SUM(CASE
                            WHEN ISNULL(USER_SCANS_DELTA, 0) <= 0 THEN 0
                            ELSE USER_SCANS_DELTA
                          END)                                      AS USER_SCANS_DELTA,
                      SUM(CASE
                            WHEN ISNULL(USER_LOOKUPS_DELTA, 0) <= 0 THEN 0
                            ELSE USER_LOOKUPS_DELTA
                          END)                                      AS USER_LOOKUPS_DELTA,
                      SUM(CASE
                            WHEN ISNULL(USER_UPDATES_DELTA, 0) <= 0 THEN 0
                            ELSE USER_UPDATES_DELTA
                          END)                                      AS USER_UPDATES_DELTA,
                      SUM(CASE
                            WHEN ISNULL(RANGE_SCAN_COUNT_DELTA, 0) <= 0 THEN 0
                            ELSE RANGE_SCAN_COUNT_DELTA
                          END)                                      AS RANGE_SCAN_COUNT_DELTA,
                      SUM(CASE
                            WHEN ISNULL(PAGE_COUNT_DELTA, 0) <= 0 THEN 0
                            ELSE PAGE_COUNT_DELTA
                          END)                                      AS PAGE_COUNT_DELTA,
                      SUM(CASE
                            WHEN ISNULL(ROW_COUNT_DELTA, 0) <= 0 THEN 0
                            ELSE ROW_COUNT_DELTA
                          END)                                      AS ROW_COUNT_DELTA,
                      MAX(ISNULL(ROW_COUNT, 0))                     AS ROW_COUNT,
                      MAX(ISNULL(PAGE_COUNT, 0))                    AS PAGE_COUNT,
                      SUM(CASE
                            WHEN ISNULL(SINGLETON_LOOKUP_COUNT, 0) <= 0 THEN 0
                            ELSE SINGLETON_LOOKUP_COUNT
                          END)                                      AS SINGLETON_LOOKUP_COUNT,
                      'M'                                           AS FLAG
               FROM   [dbo].[INDEX_HISTORY]
               WHERE  FLAG = 'D'
                      AND DATEADD(MONTH, DATEDIFF(MONTH, 0, [DATE]), 0) >= DATEADD(MONTH, DATEDIFF(MONTH, 0, @SERVER_TIME_START), 0) --REH Prevent us from rolling up old months, possibly changing totals
                      AND SERVER_NAME = @SERVER_NAME
               GROUP  BY SERVER_NAME,
                         DATABASE_NAME,
                         DATEADD(MONTH, DATEDIFF(MONTH, 0, [DATE]), 0),
                         TABLE_NAME,
                         INDEX_NAME) AS source
        ON ( source.SERVER_NAME = target.SERVER_NAME
             AND source.DATABASE_NAME = target.DATABASE_NAME
             AND source.MDATE = target.DATE
             AND source.TABLE_NAME = target.TABLE_NAME
             AND source.INDEX_NAME = target.INDEX_NAME
             AND source.FLAG = target.FLAG )
        WHEN MATCHED THEN
          UPDATE SET COMPRESSION_TYPE = source.COMPRESSION_TYPE,
                     USER_SEEKS_DELTA = source.USER_SEEKS_DELTA,
                     USER_SCANS_DELTA = source.USER_SCANS_DELTA,
                     USER_LOOKUPS_DELTA = source.USER_LOOKUPS_DELTA,
                     USER_UPDATES_DELTA = source.USER_UPDATES_DELTA,
                     RANGE_SCAN_COUNT_DELTA = source.RANGE_SCAN_COUNT_DELTA,
                     PAGE_COUNT_DELTA = source.PAGE_COUNT_DELTA,
                     ROW_COUNT_DELTA = source.ROW_COUNT_DELTA,
                     ROW_COUNT = source.ROW_COUNT,
                     PAGE_COUNT = source.PAGE_COUNT,
                     SINGLETON_LOOKUP_COUNT = source.SINGLETON_LOOKUP_COUNT
        WHEN NOT MATCHED THEN
          INSERT ( [SERVER_NAME],
                   [DATABASE_NAME],
                   [DATE],
                   [TABLE_NAME],
                   [INDEX_NAME],
                   [INDEX_DESCRIPTION],
                   [INDEX_KEYS],
                   [COMPRESSION_TYPE],
                   [USER_SEEKS_DELTA],
                   [USER_SCANS_DELTA],
                   [USER_LOOKUPS_DELTA],
                   [USER_UPDATES_DELTA],
                   [RANGE_SCAN_COUNT_DELTA],
                   [PAGE_COUNT_DELTA],
                   [ROW_COUNT_DELTA],
                   [ROW_COUNT],
                   [PAGE_COUNT],
                   [SINGLETON_LOOKUP_COUNT],
                   [FLAG] )
          VALUES (source.[SERVER_NAME],
                  source.[DATABASE_NAME],
                  source.[MDATE],
                  source.[TABLE_NAME],
                  source.[INDEX_NAME],
                  source.[INDEX_DESCRIPTION],
                  source.[INDEX_KEYS],
                  source.[COMPRESSION_TYPE],
                  source.[USER_SEEKS_DELTA],
                  source.[USER_SCANS_DELTA],
                  source.[USER_LOOKUPS_DELTA],
                  source.[USER_UPDATES_DELTA],
                  source.[RANGE_SCAN_COUNT_DELTA],
                  source.[PAGE_COUNT_DELTA],
                  source.[ROW_COUNT_DELTA],
                  source.[ROW_COUNT],
                  source.[PAGE_COUNT],
                  source.[SINGLETON_LOOKUP_COUNT],
                  'M'); 
        

 SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
  

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[SET_AX_SQLTRACE]...';


GO


ALTER PROCEDURE [dbo].[SET_AX_SQLTRACE] @SERVER_NAME NVARCHAR(128) = @@SERVERNAME,
								@DATABASE_NAME    NVARCHAR(128),
                                 @QUERY_TIME_LIMIT INT = 5000,
                                 @AX_ID            NVARCHAR(10) = NULL,
                                 @TRACE_STATUS     NVARCHAR(3) = 'ON', 
                               --  @CLIENTACESSLOG   INT = 0,
								 @OVERRIDE		INT = 0
AS

  DECLARE @SQL NVARCHAR(1000),
          @RC  INT

  SET @RC = 0



         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_AXT_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_AXT_SYSDATABASES')

         IF @SERVER_NAME <> @@SERVERNAME
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_AXT_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_AXT_SYSDATABASES
				FOR master.sys.databases'


         EXEC (@SQL) -- CREATE SYNONYM

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_AXT_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

IF @OVERRIDE = 0 AND @QUERY_TIME_LIMIT < 5000 SET @QUERY_TIME_LIMIT = 5000

  IF @TRACE_STATUS = 'ON'
    BEGIN
        
          SET @SQL = 'UPDATE [' +@SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO
				SET QUERYTIMELIMIT = ' + Str(@QUERY_TIME_LIMIT) + ',
					DEBUGINFO = DEBUGINFO & 256,
					TRACEINFO =  TRACEINFO & 2048'
			IF @AX_ID IS NOT NULL	
			SET @SQL = @SQL + 	' WHERE ID = ''' + @AX_ID + ''''	
			

				MERGE AX_SQLTRACE_CONFIG AS target
				USING (SELECT @SERVER_NAME AS SERVER_NAME,
							  @DATABASE_NAME AS DATABASE_NAME,
							  @QUERY_TIME_LIMIT AS SQL_DURATION,
							  1                 AS TRACE_ON,		--REH Turns it ON
							  14 AS AXDB_DELETION_DAYS
) AS source
				ON ( source.SERVER_NAME = target.SERVER_NAME
					 AND source.DATABASE_NAME = target.DATABASE_NAME )
				WHEN MATCHED THEN
				  UPDATE SET SQL_DURATION = source.SQL_DURATION,
							 TRACE_ON = source.TRACE_ON
				WHEN NOT MATCHED THEN
				  INSERT ( [SERVER_NAME],
						   [DATABASE_NAME],
						   [SQL_DURATION],
						   [TRACE_ON],
						   [AXDB_DELETION_DAYS])
				  VALUES (source.[SERVER_NAME],
						  source.[DATABASE_NAME],
						  source.[SQL_DURATION],
						  source.[TRACE_ON],
						  14);		--REH default 14 days, DYNPERF_SET_AX_SQLTRACE sproc will delete from systracetable in the AX database using this value
									-- setting it to 0 disables this feature
			
			END
  ELSE
    IF @TRACE_STATUS = 'OFF'
      BEGIN
          IF @AX_ID IS NULL
            SET @SQL = 'UPDATE [' +@SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO
				SET QUERYTIMELIMIT = 0,
					DEBUGINFO = DEBUGINFO & 2147483391,
					TRACEINFO & 2147481599'
					
			IF @AX_ID IS NOT NULL	
			SET @SQL = @SQL + 	' WHERE ID = ''' + @AX_ID + ''''	

        	--REH Insert a record so that our scheduled job auto updates it
MERGE AX_SQLTRACE_CONFIG AS target
				USING (SELECT @SERVER_NAME AS SERVER_NAME,
							  @DATABASE_NAME AS DATABASE_NAME,
							  @QUERY_TIME_LIMIT AS SQL_DURATION,
							  0                 AS TRACE_ON,		--REH Turns it OFF
							  14 AS AXDB_DELETION_DAYS
					  ) AS source
				ON ( source.SERVER_NAME = target.SERVER_NAME
					 AND source.DATABASE_NAME = target.DATABASE_NAME )
				WHEN MATCHED THEN
				  UPDATE SET SQL_DURATION = source.SQL_DURATION,
							 TRACE_ON = source.TRACE_ON
				WHEN NOT MATCHED THEN
				  INSERT ( [SERVER_NAME],
						   [DATABASE_NAME],
						   [SQL_DURATION],
						   [TRACE_ON],
						   [AXDB_DELETION_DAYS])
				  VALUES (source.[SERVER_NAME],
						  source.[DATABASE_NAME],
						  source.[SQL_DURATION],
						  source.[TRACE_ON],
						  14); --REH default 14 days, DYNPERF_SET_AX_SQLTRACE sproc will delete from systracetable in the AX database using this value
								-- setting it to 0 disables this feature
      END
    ELSE
      PRINT 'Invalid @TRACE_STATUS option; must be ON or OFF'

  PRINT @SQL
  EXEC (@SQL)
 

 
  ENDPROC:

  ERROR:

  RETURN @RC
GO
PRINT N'Refreshing [dbo].[DYNPERF_COLLECT_QUERY_PLANS]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[DYNPERF_COLLECT_QUERY_PLANS]';


GO
PRINT N'Refreshing [dbo].[DYNPERF_COLLECT_QUERY_STATS]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[DYNPERF_COLLECT_QUERY_STATS]';


GO
PRINT N'Refreshing [dbo].[DYNPERF_REFRESH_QUERY_PLANS]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[DYNPERF_REFRESH_QUERY_PLANS]';


GO
PRINT N'Refreshing [dbo].[DYNPERF_REFRESH_QUERY_TEXT]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[DYNPERF_REFRESH_QUERY_TEXT]';



GO


--REH Set the defaults back to base. 
UPDATE DATABASES_2_COLLECT SET KEEP_TOP_X_PLANS_BY_MONTH = 50, PURGE_PLANS_AFTER_X_DAYS = 61, 
COLLECT_TOP_X_PLANS = 50, KEEP_TOP_X_QUERIES_BY_MONTH = 100

GO

--REH  Purge the bottom 50% of plans now 

WITH CTE_STATS (SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH, PctRank)
	 AS (
		SELECT TOP 100 PERCENT QH.SERVER_NAME, QH.DATABASE_NAME, QH.QUERY_PLAN_HASH,
	   PERCENT_RANK() OVER (PARTITION BY QH.SERVER_NAME, QH.DATABASE_NAME ORDER BY QH.ELAPSED_TIME_TODAY  ) * 100.00 AS PctRank
FROM QUERY_HISTORY QH INNER JOIN DATABASES_2_COLLECT D2 ON QH.SERVER_NAME = D2.LINKED_SERVER AND QH.DATABASE_NAME = D2.DATABASE_NAME
WHERE FLAG = 'M' and DATE =  DATEADD(MM,-1,DATEDIFF(MONTH, 0, GETDATE()))  --REH Previous Month
--AND < 100 - D2.KEEP_TOP_X_PLANS_BY_MONTH  --REH The rank is less than the rank we want to keep (based on total time)
ORDER BY QH.SERVER_NAME, QH.DATABASE_NAME, QH.ELAPSED_TIME_TODAY DESC)

DELETE QP FROM QUERY_PLANS QP 
INNER JOIN CTE_STATS CTE ON QP.SERVER_NAME = CTE.SERVER_NAME AND CTE.DATABASE_NAME = QP.DATABASE_NAME AND CTE.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
INNER JOIN DATABASES_2_COLLECT D2  ON D2.LINKED_SERVER = CTE.SERVER_NAME AND CTE.DATABASE_NAME = D2.DATABASE_NAME 
WHERE CTE.PCTRANK < 100 - D2.KEEP_TOP_X_QUERIES_BY_MONTH  --REH The rank is less than the rank we want to keep (based on total time)



--REH  Reenable Jobs

    EXEC msdb.dbo.sp_update_job  @job_name = N'DYNPERF_CAPTURE_SSRS', @enabled = 1 ; 
    EXEC msdb.dbo.sp_update_job  @job_name = N'DYNPERF_CAPTURE_STATS', @enabled = 1 ; 
    EXEC msdb.dbo.sp_update_job  @job_name = N'DYNPERF_COLLECT_AOS_CONFIG', @enabled = 1 ; 
    EXEC msdb.dbo.sp_update_job  @job_name = N'DYNPERF_PROCESS_TASKS', @enabled = 1 ; 
    EXEC msdb.dbo.sp_update_job  @job_name = N'DYNPERF_PROCESS_TASKS_LOW_PRIORITY', @enabled = 1 ; 
        
   		

		UPDATE DYNAMICSPERF_SETUP SET VERSION = '2.00 RTM', INSTALLED_DATE = GETDATE()


GO
PRINT N'Update complete.';


GO
