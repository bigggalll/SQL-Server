/*
Deployment script for DynamicsPerfRTM

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;



GO
PRINT N'Dropping [dbo].[QUERY_PLANS].[IX_QUERY_MI_FLAG_PLAN_HANDLE]...';


GO

/****** Object:  Index [IX_QUERY_MI_FLAG_PLAN_HANDLE]    Script Date: 04/05/2017 10:55:13 ******/
IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[QUERY_PLANS]') AND name = N'IX_QUERY_MI_FLAG_PLAN_HANDLE')
DROP INDEX [IX_QUERY_MI_FLAG_PLAN_HANDLE] ON [dbo].[QUERY_PLANS] WITH ( ONLINE = OFF )
GO




GO
PRINT N'Creating [dbo].[QUERY_PLANS].[IX_QUERY_MI_FLAG_PLAN_HANDLE]...';


GO
CREATE NONCLUSTERED INDEX [IX_QUERY_MI_FLAG_PLAN_HANDLE]
    ON [dbo].[QUERY_PLANS]([MI_FLAG] ASC, [QUERY_PLAN_HASH] ASC, [SERVER_NAME] ASC, [DATABASE_NAME] ASC, [DATE_UPDATED] ASC) WITH (DATA_COMPRESSION = ROW);


GO
PRINT N'Creating [dbo].[QUERY_PLANS].[IX_QUERY_PLANS_DATE_UPDATED]...';


/****** Object:  Index [IX_QUERY_PLANS_DATE_UPDATED]    Script Date: 04/05/2017 10:55:49 ******/
IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[dbo].[QUERY_PLANS]') AND name = N'IX_QUERY_PLANS_DATE_UPDATED')
DROP INDEX [IX_QUERY_PLANS_DATE_UPDATED] ON [dbo].[QUERY_PLANS] WITH ( ONLINE = OFF )
GO


GO
CREATE NONCLUSTERED INDEX [IX_QUERY_PLANS_DATE_UPDATED]
    ON [dbo].[QUERY_PLANS]([DATE_UPDATED] ASC, [SERVER_NAME] ASC, [DATABASE_NAME] ASC) WITH (DATA_COMPRESSION = ROW);


GO
PRINT N'Creating [dbo].[FN_COLUMN_COUNT]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


/****** Object:  UserDefinedFunction [dbo].[FN_COLUMN_COUNT]    Script Date: 04/05/2017 10:56:21 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[FN_COLUMN_COUNT]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [dbo].[FN_COLUMN_COUNT]
GO


GO
CREATE FUNCTION [dbo].[FN_COLUMN_COUNT]
(@COLUMNS NVARCHAR(MAX))
RETURNS INT
WITH EXECUTE AS CALLER
AS
	BEGIN
		DECLARE	@STARTING_POSITION	INT = 1,
				@COLUMN_COUNT		INT = 0
		IF @COLUMNS IS NOT NULL
			BEGIN
				WHILE @STARTING_POSITION <>0 
					BEGIN
						SET @STARTING_POSITION = CHARINDEX(',',@COLUMNS, @STARTING_POSITION)
						IF @STARTING_POSITION <> 0 
							SET @STARTING_POSITION = @STARTING_POSITION+1
						
						SET @COLUMN_COUNT = @COLUMN_COUNT+1
					END
			END
		RETURN (@COLUMN_COUNT);
	END
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[INDEX_STATS_CURR_VW]...';


GO


ALTER VIEW [dbo].[INDEX_STATS_CURR_VW]
AS

WITH CTE_SERVER(SERVER_NAME, DATABASE_NAME)
     AS (SELECT LINKED_SERVER,
                DATABASE_NAME
         FROM   [dbo].[DATABASES_2_COLLECT]),


     MAX_STATS_CTE (SERVER_NAME, DATABASE_NAME, STATS_TIME)
     AS (
       
        SELECT SERVER_NAME,
                     DATABASE_NAME,
                     MAX(STATS_TIME)
         FROM   INDEX_DETAIL --STATS_COLLECTION_SUMMARY
		 GROUP BY SERVER_NAME, 
				  DATABASE_NAME
)


SELECT D.SERVER_NAME,
       S.SQL_SERVER_STARTTIME,
       D.DATABASE_NAME,
       D.TABLE_NAME,
       D.INDEX_NAME,
       INDEX_DESCRIPTION,
       D.DATA_COMPRESSION,
	   dbo.FN_COLUMN_COUNT(INDEX_KEYS) AS NUM_KEY_COLS,
       INDEX_KEYS,
	   dbo.FN_COLUMN_COUNT(INCLUDED_COLUMNS) AS NUM_INCLUDED_COLS,
       INCLUDED_COLUMNS,
       USER_SEEKS,
       USER_SCANS,
       USER_LOOKUPS,
       USER_UPDATES,
       RANGE_SCAN_COUNT,
       PAGE_COUNT,
       ROW_COUNT,
       SINGLETON_LOOKUP_COUNT,
       FORWARDED_FETCH_COUNT,
       INDEX_DEPTH,
       AVG_FRAGMENTATION_IN_PERCENT,
       FRAGMENT_COUNT,
       ROW_LOCK_WAIT_IN_MS,
       PAGE_LOCK_WAIT_IN_MS,
       INDEX_LOCK_PROMOTION_ATTEMPT_COUNT,
       INDEX_LOCK_PROMOTION_COUNT,
       PAGE_LATCH_WAIT_IN_MS,
       PAGE_IO_LATCH_WAIT_IN_MS,
       LEAF_INSERT_COUNT,
       LEAF_DELETE_COUNT,
       LEAF_UPDATE_COUNT,
       LEAF_GHOST_COUNT,
       NONLEAF_INSERT_COUNT,
       NONLEAF_DELETE_COUNT,
       NONLEAF_UPDATE_COUNT,
       LEAF_ALLOCATION_COUNT,
       NONLEAF_ALLOCATION_COUNT,
       LEAF_PAGE_MERGE_COUNT,
       NONLEAF_PAGE_MERGE_COUNT,
       LOB_FETCH_IN_PAGES,
       LOB_FETCH_IN_BYTES,
       LOB_ORPHAN_CREATE_COUNT,
       LOB_ORPHAN_INSERT_COUNT,
       ROW_OVERFLOW_FETCH_IN_PAGES,
       ROW_OVERFLOW_FETCH_IN_BYTES,
       COLUMN_VALUE_PUSH_OFF_ROW_COUNT,
       COLUMN_VALUE_PULL_IN_ROW_COUNT,
       ROW_LOCK_COUNT,
       ROW_LOCK_WAIT_COUNT,
       PAGE_LOCK_COUNT,
       PAGE_LOCK_WAIT_COUNT,
       PAGE_LATCH_WAIT_COUNT,
       PAGE_IO_LATCH_WAIT_COUNT,
       D.STATS_TIME,
       D.INDEX_ID
FROM   CTE_SERVER -- FOR EVERY SERVER & DATABASE
       CROSS APPLY(SELECT *
                   FROM   MAX_STATS_CTE CTE WITH (NOLOCK)
                   WHERE  CTE.SERVER_NAME = CTE_SERVER.SERVER_NAME
                          AND CTE.DATABASE_NAME = CTE_SERVER.DATABASE_NAME) AS CTE -- GET MAX OF STATS_DATE
       OUTER APPLY(SELECT ID.*
                   FROM   INDEX_DETAIL ID WITH (NOLOCK)
                   WHERE  ID.STATS_TIME = CTE.STATS_TIME
                          AND ID.DATABASE_NAME = CTE.DATABASE_NAME
                          AND ID.SERVER_NAME = CTE.SERVER_NAME) AS D --AND GET ALL THE INDEX_DETAILS
       JOIN STATS_COLLECTION_SUMMARY S
         ON S.SERVER_NAME = D.SERVER_NAME
            AND S.STATS_TIME = D.STATS_TIME
            AND S.DATABASE_NAME = D.DATABASE_NAME
       LEFT JOIN INDEX_USAGE_STATS U WITH (NOLOCK)
              ON U.SERVER_NAME = D.SERVER_NAME
                 AND U.STATS_TIME = D.STATS_TIME
                 AND U.DATABASE_NAME = D.DATABASE_NAME
                 AND U.OBJECT_ID = D.OBJECT_ID
                 AND U.INDEX_ID = D.INDEX_ID
       LEFT JOIN INDEX_PHYSICAL_STATS P WITH (NOLOCK)
              ON D.SERVER_NAME = P.SERVER_NAME
                 AND D.STATS_TIME = P.STATS_TIME
                 AND D.DATABASE_NAME = P.DATABASE_NAME
                 AND D.OBJECT_ID = P.OBJECT_ID
                 AND D.INDEX_ID = P.INDEX_ID
       LEFT JOIN INDEX_OPERATIONAL_STATS O WITH (NOLOCK)
              ON D.SERVER_NAME = O.SERVER_NAME
                 AND D.STATS_TIME = O.STATS_TIME
                 AND D.DATABASE_NAME = O.DATABASE_NAME
                 AND D.OBJECT_ID = O.OBJECT_ID
                 AND D.INDEX_ID = O.INDEX_ID
GO
PRINT N'Refreshing [dbo].[INDEX_KEY_ORDER_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[INDEX_KEY_ORDER_VW]';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Refreshing [dbo].[QUERY_PLANS_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[QUERY_PLANS_VW]';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Refreshing [dbo].[MISSING_INDEXES_HISTORY_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[MISSING_INDEXES_HISTORY_VW]';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Refreshing [dbo].[QUERY_ALERTS_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[QUERY_ALERTS_VW]';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Refreshing [dbo].[QUERY_HISTORY_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[QUERY_HISTORY_VW]';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Refreshing [dbo].[QUERY_STATS_CTE_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[QUERY_STATS_CTE_VW]';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[QUERY_STATS_CURR_VW]...';


GO

ALTER VIEW [dbo].[QUERY_STATS_CURR_VW]
AS

WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT Q.SERVER_NAME,
       Q.DATABASE_NAME,
       CREATION_TIME                                                                                                AS COMPILED_TIME,
       EXECUTION_COUNT,
       EXECUTION_COUNT / CASE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                           WHEN 0 THEN 1
                           ELSE ( datediff(HOUR, CREATION_TIME, S.STATS_TIME) )
                         END                                                                                        AS EXECUTION_PER_HOUR,
       cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                        AS TOTAL_ELAPSED_TIME,
       Q.AVG_TIME_MS                                                                                                AS AVG_ELAPSED_TIME,
       cast(MAX_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS MAX_ELAPSED_TIME,
       AVG_LOGICAL_READS = TOTAL_LOGICAL_READS / EXECUTION_COUNT,
       AVG_LOGICAL_READS_MB = (TOTAL_LOGICAL_READS / EXECUTION_COUNT)*8/1024,
	   cast(TOTAL_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3)) - cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3)) AS TOTAL_WAIT_TIME,
       AVG_ROWS_RETURNED = TOTAL_ROWS / EXECUTION_COUNT,
       REPLACE(REPLACE(REPLACE(QT.SQL_TEXT, 'SELECT ', CHAR(10)+'SELECT '), ' FROM', CHAR(10)+' FROM'), ' WHERE', CHAR(10)+ ' WHERE')+
	   REPLICATE('-',50)+'TABLE NODES FROM QUERY PLAN' + REPLICATE('-',50) + CHAR(10) + ISNULL((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE Q.SERVER_NAME = QPV.SERVER_NAME AND Q.DATABASE_NAME = QPV.DATABASE_NAME AND Q.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS QUERY_PLAN_PARSED,
        ISNULL((SELECT MISSING_INDEX_INFO FROM QUERY_PLANS_MISSING_INDEX_VW QPV WHERE Q.SERVER_NAME = QPV.SERVER_NAME AND Q.DATABASE_NAME = QPV.DATABASE_NAME AND Q.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH),'')   AS MISSING_INDEXES,
	   
	   CASE  QP.SQL_PARMS WHEN NULL THEN 
	   CONVERT (NVARCHAR(MAX), index_node.query('for $qplan in //sp:QueryPlan, $plist in $qplan/sp:ParameterList, $colref in $plist/sp:ColumnReference  return concat(string($colref/@Column),":",string($colref/@ParameterCompiledValue),",   "),"  "')) 
		ELSE QP.SQL_PARMS END  AS QUERY_PARAMETER_VALUES,
	  
	   -- QP.SQL_PARMS  AS QUERY_PARAMETER_VALUES,                                                                                                                                                                   
       QUERY_PLAN,
       Q.ROW_NUM,
       Q.QUERY_HASH,
       QT.SQL_TEXT AS SQL_TEXT,
	   TOTAL_ROWS,
       MAX_ROWS,
       MIN_ROWS,
       PLAN_GENERATION_NUM,
       Q.LAST_EXECUTION_TIME,
       cast(TOTAL_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                         AS TOTAL_WORKER_TIME,
       AVG_PHYSICAL_READS = TOTAL_PHYSICAL_READS / EXECUTION_COUNT,
       AVG_LOGICAL_WRITES = TOTAL_LOGICAL_WRITES / EXECUTION_COUNT,
       cast(LAST_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                         AS LAST_ELAPSED_TIME,
       cast(MIN_ELAPSED_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS MIN_ELAPSED_TIME,
       TOTAL_PHYSICAL_READS,
       LAST_PHYSICAL_READS,
       MIN_PHYSICAL_READS,
       MAX_PHYSICAL_READS,
       TOTAL_LOGICAL_READS,
       LAST_LOGICAL_READS,
       MIN_LOGICAL_READS,
       MAX_LOGICAL_READS,
       TOTAL_LOGICAL_WRITES,
       LAST_LOGICAL_WRITES,
       MIN_LOGICAL_WRITES,
       MAX_LOGICAL_WRITES,
       cast(LAST_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                          AS LAST_WORKER_TIME,
       cast(MIN_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS MIN_WORKER_TIME,
       cast(MAX_WORKER_TIME / 1000.000 AS DECIMAL(29, 3))                                                           AS MAX_WORKER_TIME,
       QUERY_PLAN_TEXT = CONVERT(NVARCHAR(MAX), QUERY_PLAN),
       S.STATS_TIME,
       SQL_VERSION,
       S.SQL_SERVER_STARTTIME,
       Q.QUERY_PLAN_HASH,
       C.COMMENT
FROM   (SELECT QS2.SERVER_NAME,
               QS2.DATABASE_NAME,
               QUERY_HASH,
               max(QS2.STATS_TIME)      AS STATS_TIME,
               max(LAST_EXECUTION_TIME) AS LAST_EXECUTION_TIME
        FROM   QUERY_STATS QS2
               INNER JOIN STATS_COLLECTION_SUMMARY S2 WITH (NOLOCK)
                       ON QS2.STATS_TIME = S2.STATS_TIME
                          AND QS2.DATABASE_NAME = S2.DATABASE_NAME
                          AND QS2.SERVER_NAME = S2.SERVER_NAME
                          
        GROUP  BY QS2.SERVER_NAME,
                  QS2.DATABASE_NAME,
                  QUERY_HASH,
				  QUERY_PLAN_HASH) AS A
       INNER LOOP JOIN QUERY_STATS Q WITH (NOLOCK)
                    ON A.SERVER_NAME = Q.SERVER_NAME
                       AND A.DATABASE_NAME = Q.DATABASE_NAME
                       AND A.QUERY_HASH = Q.QUERY_HASH
                       AND A.LAST_EXECUTION_TIME = Q.LAST_EXECUTION_TIME
                       AND A.STATS_TIME = Q.STATS_TIME
       LEFT OUTER JOIN QUERY_PLANS QP WITH (NOLOCK)
               ON QP.QUERY_PLAN_HASH = Q.QUERY_PLAN_HASH
                  AND QP.SERVER_NAME = Q.SERVER_NAME
                  AND QP.DATABASE_NAME = Q.DATABASE_NAME
       INNER JOIN STATS_COLLECTION_SUMMARY S WITH (NOLOCK)
               ON Q.STATS_TIME = S.STATS_TIME
                  AND Q.DATABASE_NAME = S.DATABASE_NAME
                  AND Q.SERVER_NAME = S.SERVER_NAME
       LEFT OUTER JOIN QUERY_TEXT AS QT
                    ON Q.QUERY_HASH = QT.QUERY_HASH
                       AND Q.DATABASE_NAME = QT.DATABASE_NAME
                       AND Q.SERVER_NAME = QT.SERVER_NAME
       LEFT OUTER JOIN COMMENTS C
                    ON Q.QUERY_HASH = C.QUERY_HASH
                       AND Q.SERVER_NAME = C.SERVER_NAME
                       AND Q.DATABASE_NAME = C.DATABASE_NAME
		OUTER APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node)
GO
PRINT N'Refreshing [dbo].[QUERY_STATS_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[QUERY_STATS_VW]';


GO
PRINT N'Refreshing [dbo].[HIDDEN_SCANS_CURR_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[HIDDEN_SCANS_CURR_VW]';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Refreshing [dbo].[USER_SCANS_CURR_VW]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[USER_SCANS_CURR_VW]';


GO
PRINT N'Altering [dbo].[INDEX_STATS_VW]...';


GO


ALTER VIEW [dbo].[INDEX_STATS_VW]
AS



SELECT D.SERVER_NAME,
       S.SQL_SERVER_STARTTIME,
       D.DATABASE_NAME,
       D.TABLE_NAME,
       D.INDEX_NAME,
       INDEX_DESCRIPTION,
       D.DATA_COMPRESSION,
	   dbo.FN_COLUMN_COUNT(INDEX_KEYS) AS NUM_KEY_COLS,
       INDEX_KEYS,
	   dbo.FN_COLUMN_COUNT(INCLUDED_COLUMNS) AS NUM_INCLUDED_COLS,
       INCLUDED_COLUMNS,
       USER_SEEKS,
       USER_SCANS,
       USER_LOOKUPS,
       USER_UPDATES,
       RANGE_SCAN_COUNT,
       PAGE_COUNT,
       ROW_COUNT,
       SINGLETON_LOOKUP_COUNT,
       FORWARDED_FETCH_COUNT,
       INDEX_DEPTH,
       AVG_FRAGMENTATION_IN_PERCENT,
       FRAGMENT_COUNT,
       ROW_LOCK_WAIT_IN_MS,
       PAGE_LOCK_WAIT_IN_MS,
       INDEX_LOCK_PROMOTION_ATTEMPT_COUNT,
       INDEX_LOCK_PROMOTION_COUNT,
       PAGE_LATCH_WAIT_IN_MS,
       PAGE_IO_LATCH_WAIT_IN_MS,
       LEAF_INSERT_COUNT,
       LEAF_DELETE_COUNT,
       LEAF_UPDATE_COUNT,
       LEAF_GHOST_COUNT,
       NONLEAF_INSERT_COUNT,
       NONLEAF_DELETE_COUNT,
       NONLEAF_UPDATE_COUNT,
       LEAF_ALLOCATION_COUNT,
       NONLEAF_ALLOCATION_COUNT,
       LEAF_PAGE_MERGE_COUNT,
       NONLEAF_PAGE_MERGE_COUNT,
       LOB_FETCH_IN_PAGES,
       LOB_FETCH_IN_BYTES,
       LOB_ORPHAN_CREATE_COUNT,
       LOB_ORPHAN_INSERT_COUNT,
       ROW_OVERFLOW_FETCH_IN_PAGES,
       ROW_OVERFLOW_FETCH_IN_BYTES,
       COLUMN_VALUE_PUSH_OFF_ROW_COUNT,
       COLUMN_VALUE_PULL_IN_ROW_COUNT,
       ROW_LOCK_COUNT,
       ROW_LOCK_WAIT_COUNT,
       PAGE_LOCK_COUNT,
       PAGE_LOCK_WAIT_COUNT,
       PAGE_LATCH_WAIT_COUNT,
       PAGE_IO_LATCH_WAIT_COUNT,
       D.STATS_TIME,
	   D.INDEX_ID
FROM   INDEX_DETAIL D WITH (NOLOCK)
       JOIN STATS_COLLECTION_SUMMARY S
         ON S.SERVER_NAME = D.SERVER_NAME
            AND S.STATS_TIME = D.STATS_TIME
            AND S.DATABASE_NAME = D.DATABASE_NAME
       LEFT JOIN INDEX_USAGE_STATS U WITH (NOLOCK)
              ON U.SERVER_NAME = D.SERVER_NAME
                 AND U.STATS_TIME = D.STATS_TIME
                 AND U.DATABASE_NAME = D.DATABASE_NAME
                 AND U.OBJECT_ID = D.OBJECT_ID
                 AND U.INDEX_ID = D.INDEX_ID
       LEFT JOIN INDEX_PHYSICAL_STATS P WITH (NOLOCK)
              ON D.SERVER_NAME = P.SERVER_NAME
                 AND D.STATS_TIME = P.STATS_TIME
                 AND D.DATABASE_NAME = P.DATABASE_NAME
                 AND D.OBJECT_ID = P.OBJECT_ID
                 AND D.INDEX_ID = P.INDEX_ID
       LEFT JOIN INDEX_OPERATIONAL_STATS O WITH (NOLOCK)
              ON D.SERVER_NAME = O.SERVER_NAME
                 AND D.STATS_TIME = O.STATS_TIME
                 AND D.DATABASE_NAME = O.DATABASE_NAME
                 AND D.OBJECT_ID = O.OBJECT_ID
                 AND D.INDEX_ID = O.INDEX_ID
GO
PRINT N'Creating [dbo].[HISTORICAL_INDEX_USAGE_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


/****** Object:  View [dbo].[HISTORICAL_INDEX_USAGE_VW]    Script Date: 04/05/2017 10:57:19 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[HISTORICAL_INDEX_USAGE_VW]'))
DROP VIEW [dbo].[HISTORICAL_INDEX_USAGE_VW]
GO


GO
CREATE VIEW [dbo].[HISTORICAL_INDEX_USAGE_VW]
	AS 
		
	SELECT  SERVER_NAME,
		   DATABASE_NAME,
		   TABLE_NAME,
		   INDEX_NAME,
		   
		  		   MAX(PAGE_COUNT * 8 / 1024)         AS SIZE_MB,
		   		   MIN(DATEDIFF(DD, DATE, GETDATE())) AS DAYS,
	   SUM(USER_SEEKS_DELTA) AS USER_SEEKS,
	   SUM(USER_SCANS_DELTA) AS USER_SCANS,
	   SUM(USER_LOOKUPS_DELTA) AS LOOKUPS,
	   SUM(USER_UPDATES_DELTA)                           AS USER_UPDATES,
	   (SELECT MAX(DATE) FROM INDEX_HISTORY D WHERE M.SERVER_NAME = D.SERVER_NAME AND M.DATABASE_NAME = D.DATABASE_NAME 
		AND M.TABLE_NAME= D.TABLE_NAME AND M.INDEX_NAME = D.INDEX_NAME 
		AND FLAG = 'D'
		AND USER_SEEKS_DELTA + USER_SCANS_DELTA + USER_LOOKUPS_DELTA > 0) AS LAST_DAY_READ
		FROM INDEX_HISTORY AS  M
	WHERE  FLAG = 'M' --Monthly records only
		 
	GROUP  BY SERVER_NAME,
			  DATABASE_NAME,
			  TABLE_NAME,
			  INDEX_NAME
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Creating [dbo].[QUERY_PLANS_PARSED_VW]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


/****** Object:  View [dbo].[QUERY_PLANS_PARSED_VW]    Script Date: 04/05/2017 10:57:42 ******/
IF  EXISTS (SELECT * FROM sys.views WHERE object_id = OBJECT_ID(N'[dbo].[QUERY_PLANS_PARSED_VW]'))
DROP VIEW [dbo].[QUERY_PLANS_PARSED_VW]
GO


GO
CREATE VIEW [dbo].[QUERY_PLANS_PARSED_VW]
	AS 
	
   SELECT CTE.SERVER_NAME,
          CTE.DATABASE_NAME,
          CTE.QUERY_HASH,
          CTE.QUERY_PLAN_HASH,
          QT.SQL_TEXT,
          QP.QUERY_PLAN,


          REPLACE(REPLACE(REPLACE(QT.SQL_TEXT, 'SELECT ', CHAR(10)+'SELECT '), ' FROM', CHAR(10)+' FROM'), ' WHERE', CHAR(10)+ ' WHERE')
          + CHAR(10) + CHAR(10) + REPLICATE('-', 50)
          + 'QUERY PARAMETERS' + REPLICATE('-', 61)
          + CHAR(10) + QP.SQL_PARMS + CHAR(10) + CHAR(10)
          + REPLICATE('-', 50)
          + 'TABLE NODES FROM QUERY PLAN'
          + REPLICATE('-', 50) + CHAR(10)
          + ISNULL((SELECT QUERY_NODES FROM QUERY_PLANS_VW QPV WHERE CTE.SERVER_NAME = QPV.SERVER_NAME AND CTE.DATABASE_NAME = QPV.DATABASE_NAME AND CTE.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '') AS QUERY_PLAN_PARSED,
         
		 
		  ISNULL((SELECT MISSING_INDEX_INFO
                  FROM   QUERY_PLANS_MISSING_INDEX_VW QPV
                  WHERE  CTE.SERVER_NAME = QPV.SERVER_NAME
                         AND CTE.DATABASE_NAME = QPV.DATABASE_NAME
                         AND CTE.QUERY_PLAN_HASH = QPV.QUERY_PLAN_HASH), '')      AS MISSING_INDEXES


   FROM   QUERY_HISTORY CTE
          LEFT OUTER LOOP JOIN QUERY_TEXT QT
                            ON QT.QUERY_HASH = CTE.QUERY_HASH
                               AND QT.SERVER_NAME = CTE.SERVER_NAME
          LEFT OUTER LOOP JOIN QUERY_PLANS QP WITH (NOLOCK)
                            ON QP.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH
                               AND QP.SERVER_NAME = CTE.SERVER_NAME
                               AND QP.DATABASE_NAME = CTE.DATABASE_NAME
WHERE CTE.FLAG = 'M'
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[DYNPERF_PROCESS_AXSQLTRACE]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PROCESS_AXSQLTRACE]
		(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX)
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

SELECT TOP 10 SERVER_NAME,
              DATABASE_NAME,
              QUERY_HASH,
              SQL_TEXT,
              ROW_NUM
INTO   #AX_SQLTRACE
FROM   AX_SQLTRACE AST WITH (NOLOCK)
WHERE  SERVER_NAME = @SERVER_NAME
       AND DATABASE_NAME = @DATABASE_NAME
       AND AST.CANPROCESS = 1 --REH This is a computed column on the AX_SQLTRACE table
--   AND AST.QUERY_HASH IS NULL 
--   AND LEN(AST.SQL_TEXT) < 4000
ORDER  BY ROW_NUM DESC 



UPDATE AST
SET    QUERY_HASH = COALESCE(A.QUERY_HASH, 0X00) --REH There could be several. We are only getting the first
FROM   #AX_SQLTRACE AST
       CROSS APPLY (SELECT QUERY_HASH
                    FROM   (SELECT TOP 1 QUERY_HASH,
                                         SQL_TEXT
                            FROM   QUERY_TEXT QT WITH (NOLOCK)
                            WHERE  QT.SERVER_NAME = AST.SERVER_NAME
                                   AND QT.DATABASE_NAME = AST.DATABASE_NAME
                                   AND QT.SQL_TEXT LIKE Substring(AST.SQL_TEXT, 1, 10) + '%') AS B
                    WHERE  B.SQL_TEXT LIKE Replace(AST.SQL_TEXT, '?', '%')) AS A 




--WHERE  SERVER_NAME = @SERVER_NAME
--       AND DATABASE_NAME = @DATABASE_NAME
--       AND AST.QUERY_HASH IS NULL 
--	   AND LEN(AST.SQL_TEXT) < 4000 --REH LIKE command is limited to 8k characters

UPDATE AST
SET QUERY_HASH = ASTEMP.QUERY_HASH
FROM AX_SQLTRACE AST WITH (ROWLOCK)
INNER JOIN #AX_SQLTRACE ASTEMP ON AST.ROW_NUM = ASTEMP.ROW_NUM

DROP TABLE #AX_SQLTRACE

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_PROCESS_QUERY_ALERTS]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PROCESS_QUERY_ALERTS]
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @PCT_AVG_TIME_CHANGE_DAY int, @PCT_AVG_TIME_CHANGE_MONTH INT
	DECLARE @MIN_EXECUTION_COUNTS INT, @MIN_AVG_TIME_MS INT
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




SELECT @PCT_AVG_TIME_CHANGE_DAY = PCT_AVG_TIME_CHANGE_DAY,
       @PCT_AVG_TIME_CHANGE_MONTH = PCT_AVG_TIME_CHANGE_MONTH,
       @MIN_EXECUTION_COUNTS = MIN_EXECUTION_COUNTS,
       @MIN_AVG_TIME_MS = MIN_AVG_TIME_MS
FROM   QUERY_ALERTS_CONFIG
WHERE  SERVER_NAME = @SERVER_NAME
       AND DATABASE_NAME = @DATABASE_NAME 


--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
  --REH in this case, we are going to compare to STATS_TIME which is the DynamicsPerf Time Zone so convert last_run back into that time

     SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset

  END 


IF @PCT_AVG_TIME_CHANGE_DAY IS NULL 
  BEGIN
                --MJP Log no alerts
                UPDATE CAPTURE_LOG
                 SET    TEXT = TEXT + 'No Alerts Configured! '
                  WHERE  STATS_TIME = @STATS_DATE 
                  AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)
                RETURN(0)  --REH No settings for this server/db just return and do nothing
  END


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH SAME QUERY_HASH/PLAN_HASH , true parm sniffing query issue



;WITH CTE_STATS (SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME, STATS_TIME, PREV_STATS_TIME, PREV_CREATION_TIME, PREV_ELAPSED_TIME, PREV_EXECUTION_COUNT, EXECUTION_COUNT, TOTAL_WORKER_TIME, TOTAL_ELAPSED_TIME, PREV_TOTAL_WORKER_TIME, TIME_THIS_PERIOD, WORKER_TIME_THIS_PERIOD, EXECUTIONS_THIS_PERIOD)
     AS (SELECT  SERVER_NAME,
                         DATABASE_NAME,
                         QUERY_HASH,
                         QUERY_PLAN_HASH,

                         CREATION_TIME,
                         [STATS_TIME],
                         LAG(STATS_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_STATS_TIME,
                         LAG(CREATION_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_CREATION_TIME,
                         
                         LAG(TOTAL_ELAPSED_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_ELAPSED_TIME,
                         LAG(EXECUTION_COUNT, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_EXECUTION_COUNT,
                         EXECUTION_COUNT,
                         TOTAL_WORKER_TIME,
                         TOTAL_ELAPSED_TIME,
                         LAG(TOTAL_WORKER_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_TOTAL_WORKER_TIME,
                         TOTAL_ELAPSED_TIME - LAG(TOTAL_ELAPSED_TIME, 1, 0)
                                                OVER (
                                                  PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                                                  ORDER BY STATS_TIME ) AS TIME_THIS_PERIOD,
                         TOTAL_WORKER_TIME - LAG(TOTAL_WORKER_TIME, 1, 0)
                                               OVER (
                                                 PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                                                 ORDER BY STATS_TIME )  AS WORKER_TIME_THIS_PERIOD,
                         EXECUTION_COUNT - LAG(EXECUTION_COUNT, 1, 0)
                                             OVER (
                                               PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                                               ORDER BY STATS_TIME )    AS EXECUTIONS_THIS_PERIOD
         FROM   QUERY_STATS QS
		where SERVER_NAME = @SERVER_NAME
       AND DATABASE_NAME = @DATABASE_NAME
       AND STATS_TIME > @LAST_RUN
		 )


INSERT QUERY_ALERTS
SELECT DISTINCT QS_CTE.SERVER_NAME,
       QS_CTE.STATS_TIME,
       QS_CTE.DATABASE_NAME,
       QS_CTE.QUERY_HASH,
       QS_CTE.QUERY_PLAN_HASH
FROM    (SELECT SERVER_NAME,
					   DATABASE_NAME,
					   STATS_TIME,
					   QUERY_HASH,
					   QUERY_PLAN_HASH,
					   SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                               AS TOTAL_TIME_MS,
					   SUM(EXECUTIONS_THIS_PERIOD)                                                            AS TOTAL_EXECUTIONS,
					   CASE SUM(EXECUTIONS_THIS_PERIOD)
						 WHEN 0 THEN 0
						 ELSE ( SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3))) / SUM(EXECUTIONS_THIS_PERIOD) )
					   END                                                                                    AS AVG_TIME_MS,
					   SUM(CAST(WORKER_TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                        AS WORK_TIME,
					   SUM(CAST(( TIME_THIS_PERIOD - WORKER_TIME_THIS_PERIOD ) / 1000.000 AS DECIMAL(14, 3))) AS WAIT_TIME
			FROM  (select * from CTE_STATS) as CTE 
			WHERE  
				--QS.SERVER_NAME = CTE.SERVER_NAME AND QS.DATABASE_NAME=CTE.DATABASE_NAME AND
				--QS.STATS_TIME = CTE.STATS_TIME 
				--AND QS.QUERY_HASH = CTE.QUERY_HASH AND QS.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH AND
				 CTE.DATABASE_NAME = @DATABASE_NAME AND CTE.SERVER_NAME = @SERVER_NAME
				AND CTE.STATS_TIME > @LAST_RUN

			GROUP  BY SERVER_NAME,
						DATABASE_NAME,
				         STATS_TIME,
						QUERY_HASH,
						QUERY_PLAN_HASH) AS QS_CTE

       INNER JOIN QUERY_HISTORY QHD 
               ON QHD.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHD.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHD.QUERY_HASH = QS_CTE.QUERY_HASH
                  AND QHD.QUERY_PLAN_HASH = QS_CTE.QUERY_PLAN_HASH
                  AND QHD.FLAG = 'D'
                  AND QHD.DATE = DATEADD(DAY, DATEDIFF(DAY, 0, QS_CTE.STATS_TIME), 0)
       INNER JOIN QUERY_HISTORY QHM
               ON QHM.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHM.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHM.QUERY_HASH = QS_CTE.QUERY_HASH
                  AND QHM.QUERY_PLAN_HASH = QS_CTE.QUERY_PLAN_HASH
                  AND QHM.FLAG = 'M'
                  AND QHM.DATE = DATEADD(MONTH, DATEDIFF(MONTH, 0, QS_CTE.STATS_TIME), 0)
WHERE  
        ( ( QS_CTE.AVG_TIME_MS  > QHD.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_DAY/100
                OR QS_CTE.AVG_TIME_MS   > QHM.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_MONTH/100 )
             AND QS_CTE.AVG_TIME_MS   > @MIN_AVG_TIME_MS
             AND QS_CTE.TOTAL_EXECUTIONS > @MIN_EXECUTION_COUNTS ) 
			 option (maxdop 1)


--REH any variation 






;WITH CTE_STATS (SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME, STATS_TIME, PREV_STATS_TIME, PREV_CREATION_TIME, PREV_ELAPSED_TIME, PREV_EXECUTION_COUNT, EXECUTION_COUNT, TOTAL_WORKER_TIME, TOTAL_ELAPSED_TIME, PREV_TOTAL_WORKER_TIME, TIME_THIS_PERIOD, WORKER_TIME_THIS_PERIOD, EXECUTIONS_THIS_PERIOD)
     AS (SELECT  SERVER_NAME,
                         DATABASE_NAME,
                         QUERY_HASH,
                         QUERY_PLAN_HASH,

                         CREATION_TIME,
                         [STATS_TIME],
                         LAG(STATS_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_STATS_TIME,
                         LAG(CREATION_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_CREATION_TIME,
                         
                         LAG(TOTAL_ELAPSED_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_ELAPSED_TIME,
                         LAG(EXECUTION_COUNT, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_EXECUTION_COUNT,
                         EXECUTION_COUNT,
                         TOTAL_WORKER_TIME,
                         TOTAL_ELAPSED_TIME,
                         LAG(TOTAL_WORKER_TIME, 1, 0)
                           OVER (
                             PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                             ORDER BY STATS_TIME )                      AS PREV_TOTAL_WORKER_TIME,
                         TOTAL_ELAPSED_TIME - LAG(TOTAL_ELAPSED_TIME, 1, 0)
                                                OVER (
                                                  PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                                                  ORDER BY STATS_TIME ) AS TIME_THIS_PERIOD,
                         TOTAL_WORKER_TIME - LAG(TOTAL_WORKER_TIME, 1, 0)
                                               OVER (
                                                 PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                                                 ORDER BY STATS_TIME )  AS WORKER_TIME_THIS_PERIOD,
                         EXECUTION_COUNT - LAG(EXECUTION_COUNT, 1, 0)
                                             OVER (
                                               PARTITION BY SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, CREATION_TIME
                                               ORDER BY STATS_TIME )    AS EXECUTIONS_THIS_PERIOD
         FROM   QUERY_STATS QS
		where SERVER_NAME = @SERVER_NAME
       AND DATABASE_NAME = @DATABASE_NAME
       AND STATS_TIME > @LAST_RUN
		 )




INSERT QUERY_ALERTS
SELECT DISTINCT QS_CTE.SERVER_NAME,
       QS_CTE.STATS_TIME,
       QS_CTE.DATABASE_NAME,
       QS_CTE.QUERY_HASH,
       QS_CTE.QUERY_PLAN_HASH
FROM    (SELECT TOP 100 SERVER_NAME,
					   DATABASE_NAME,
					   STATS_TIME,
					   QUERY_HASH,
					   QUERY_PLAN_HASH,
					   SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                               AS TOTAL_TIME_MS,
					   SUM(EXECUTIONS_THIS_PERIOD)                                                            AS TOTAL_EXECUTIONS,
					   CASE SUM(EXECUTIONS_THIS_PERIOD)
						 WHEN 0 THEN 0
						 ELSE ( SUM(CAST(TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3))) / SUM(EXECUTIONS_THIS_PERIOD) )
					   END                                                                                    AS AVG_TIME_MS,
					   SUM(CAST(WORKER_TIME_THIS_PERIOD / 1000.000 AS DECIMAL(20, 3)))                        AS WORK_TIME,
					   SUM(CAST(( TIME_THIS_PERIOD - WORKER_TIME_THIS_PERIOD ) / 1000.000 AS DECIMAL(14, 3))) AS WAIT_TIME
			FROM  (select * from CTE_STATS) as CTE 
			WHERE  
				--QS.SERVER_NAME = CTE.SERVER_NAME AND QS.DATABASE_NAME=CTE.DATABASE_NAME AND
				--QS.STATS_TIME = CTE.STATS_TIME 
				--AND QS.QUERY_HASH = CTE.QUERY_HASH AND QS.QUERY_PLAN_HASH = CTE.QUERY_PLAN_HASH AND
				 CTE.DATABASE_NAME = @DATABASE_NAME AND CTE.SERVER_NAME = @SERVER_NAME
				AND CTE.STATS_TIME > @LAST_RUN

			GROUP  BY SERVER_NAME,
						DATABASE_NAME,
				         STATS_TIME,
						QUERY_HASH,
						QUERY_PLAN_HASH) AS QS_CTE

       CROSS APPLY (SELECT SERVER_NAME, DATABASE_NAME, QUERY_HASH, MAX(QHD.AVG_TIME_TODAY_MS) AS AVG_TIME_TODAY_MS
				FROM  QUERY_HISTORY QHD
               WHERE QHD.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHD.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHD.QUERY_HASH = QS_CTE.QUERY_HASH
				  AND QHD.QUERY_PLAN_HASH <> QS_CTE.QUERY_PLAN_HASH
                  AND QHD.FLAG = 'D'
                  AND QHD.DATE = DATEADD(DAY, DATEDIFF(DAY, 0, QS_CTE.STATS_TIME), 0)
				  GROUP BY SERVER_NAME, DATABASE_NAME, QUERY_HASH
				  ) AS QHDAILY
       CROSS APPLY ( SELECT SERVER_NAME, DATABASE_NAME, QUERY_HASH, MAX(QHM.AVG_TIME_TODAY_MS) AS AVG_TIME_TODAY_MS
				FROM  QUERY_HISTORY QHM
               WHERE QHM.SERVER_NAME = QS_CTE.SERVER_NAME
                  AND QHM.DATABASE_NAME = QS_CTE.DATABASE_NAME
                  AND QHM.QUERY_HASH = QS_CTE.QUERY_HASH
				  AND QHM.QUERY_PLAN_HASH <> QS_CTE.QUERY_PLAN_HASH
                  AND QHM.FLAG = 'M'
                  AND QHM.DATE = DATEADD(MONTH, DATEDIFF(MONTH, 0, QS_CTE.STATS_TIME), 0)
				  GROUP BY SERVER_NAME, DATABASE_NAME, QUERY_HASH
				  ) AS QHMONTHLY
WHERE   ( ( QS_CTE.AVG_TIME_MS  > QHDAILY.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_DAY/100
                OR QS_CTE.AVG_TIME_MS   > QHMONTHLY.AVG_TIME_TODAY_MS * @PCT_AVG_TIME_CHANGE_MONTH/100 )
             AND QS_CTE.AVG_TIME_MS   > @MIN_AVG_TIME_MS
             AND QS_CTE.TOTAL_EXECUTIONS > @MIN_EXECUTION_COUNTS ) 
option (maxdop 1)



UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_PROCESS_QUERY_PLANS]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PROCESS_QUERY_PLANS]
       (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
                                                                             @AZURE_DB           BIT,
                                                                             @SQL_TZ_OFFSET INT,
                                                                             @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @CPU INT
    



/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

--REH Need to delete any old data in case QUERY_PLAN refresh updates the flag.  We need to delete old parsed plans

DELETE QPP
FROM   QUERY_PLANS_PARSED QPP WITH (ROWLOCK)
       INNER JOIN QUERY_PLANS QP WITH (NOLOCK)
               ON QPP.SERVER_NAME = QP.SERVER_NAME
                  AND QPP.DATABASE_NAME = QP.DATABASE_NAME
                  AND QPP.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
WHERE  QP.PARSED_FLAG = 0 and QP.SERVER_NAME = @SERVER_NAME and QP.DATABASE_NAME = @DATABASE_NAME

IF EXISTS (SELECT * FROM [tempdb].sys.objects WHERE name = '#PARSE_PLANS')
DROP TABLE #PARSE_PLANS

;WITH XMLNAMESPACES ('http://schemas.microsoft.com/sqlserver/2004/07/showplan' AS sp)
SELECT	TOP 10000	QT.SERVER_NAME, QT.DATABASE_NAME, QT.[QUERY_PLAN_HASH],
 CONVERT (NVARCHAR(MAX), index_node.query('for $qplan in //sp:QueryPlan, $plist in $qplan/sp:ParameterList, $colref in $plist/sp:ColumnReference  return concat(string($colref/@Column),":",string($colref/@ParameterCompiledValue),",   "),"  "')) as SQL_PARAMS
  
INTO #PARSE_PLANS

  FROM [QUERY_PLANS] QT WITH (NOLOCK)
  	INNER LOOP JOIN QUERY_STATS QS WITH (NOLOCK) ON QT.SERVER_NAME = QS.SERVER_NAME AND QT.DATABASE_NAME = QS.DATABASE_NAME
		AND QT.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
      OUTER APPLY QUERY_PLAN.nodes('//sp:Batch') AS Batch(index_node)
    
WHERE PARSED_FLAG = 0 AND QT.SERVER_NAME = @SERVER_NAME AND QT.DATABASE_NAME = @DATABASE_NAME
	AND QT.QUERY_PLAN_HASH > 0X000000000000000  --REH Don't process the 0 hash values
	ORDER BY QS.TOTAL_ELAPSED_TIME DESC  --REH do the top execution times first, most likely to show up in query views


--REH Parse out the QUERY_PLANS table into it's vital statistics

SET QUOTED_IDENTIFIER OFF
SELECT @CPU = cpu_count * .25 FROM sys.dm_os_sys_info

IF @CPU < 2 SET @CPU = 2

SET @SQL = '
 ;WITH XMLNAMESPACES (''http://schemas.microsoft.com/sqlserver/2004/07/showplan'' AS sp)

 INSERT QUERY_PLANS_PARSED
 SELECT DISTINCT *
FROM   (SELECT QUERY_PLANS.SERVER_NAME, QUERY_PLANS.DATABASE_NAME, QUERY_PLANS.QUERY_PLAN_HASH,
			   CAST(isnull(index_node.value(''(..//@NodeId)[1]'', ''nvarchar(128)''),''0'') AS INT) AS NodeID,
               CAST(Replace(Replace(index_node.value(''(.//@Table)[1]'', ''NVARCHAR(128)''), ''['', ''''), '']'', '''') AS NVARCHAR(128))  AS TABLE_NAME,
               CAST(Replace(Replace(index_node.value(''(.//@Index)[1]'', ''NVARCHAR(128)''), ''['', ''''), '']'', '''') AS NVARCHAR(128)) AS INDEX_NAME,
			   CAST(isnull(index_node.value(''(.//@Lookup)[1]'', ''nvarchar(128)''),''0'') AS INT) AS LOOKUP,
			   CAST(isnull(index_node.value(''(..//@Parallel)[1]'', ''nvarchar(128)''),''0'') AS INT) AS PARALLEL,
			   CAST(index_node.value(''(..//@PhysicalOp)[1]'', ''nvarchar(128)'') AS NVARCHAR(128)) AS PHYSICALOP,
			   CAST(index_node.value(''(..//@LogicalOp)[1]'', ''nvarchar(128)'') AS NVARCHAR(128)) AS LOGICALOP,
			   CAST(str(ISNULL(index_node.value(''(..//@EstimateRows)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(14,0)) AS ESTIMATEROWS,
			   CAST(str(ISNULL(index_node.value(''(..//@EstimateIO)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(20,7)) AS EstimateIO,
			   CAST(str(ISNULL(index_node.value(''(..//@EstimateCPU)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(20,7)) AS ESTIMATECPU,
			   CAST(str(ISNULL(index_node.value(''(..//@AvgRowSize)[1]'', ''nvarchar(128)''),''0.0''),30,17) AS DECIMAL(14,0)) AS AVGROWSIZE,
			   CAST(str(isnull(index_node.value(''(..//@EstimatedTotalSubtreeCost)[1]'', ''nvarchar(128)'') ,''0.0''),30,17) AS DECIMAL (20,7)) AS ESTIMATEDTOTALSUBTREECOST,
               CONVERT(NVARCHAR(MAX), index_node.query(''for $seekpredicate in ./sp:SeekPredicates,
                                                            $rangecolumns in $seekpredicate//sp:RangeColumns,
                                                            $columnreference in $rangecolumns/sp:ColumnReference
                                        return string($columnreference/@Column)''))        AS SEEK_COLUMNS,

              CONVERT(NVARCHAR(MAX), index_node.query(''for $predicate2 in ./sp:Predicate,
                                                           $Ident in  $predicate2//sp:Identifier,
														   $COLREF2 in  $Ident/sp:ColumnReference
                                                            
                                        return string($COLREF2/@Column)'')) AS PREDICATES,

		    REPLACE( REPLACE( CONVERT(NVARCHAR(MAX), index_node.query(''for $predicate in ./sp:Predicate,
                                                $rangecolumn in $predicate//sp:ScalarOperator
                                                            
                            return string($rangecolumn/@ScalarString)''))
							,''&lt;'', ''<'')   ,''&gt;'', ''>'')         AS PREDICATE_TEXT
        FROM   QUERY_PLANS WITH (NOLOCK)
			INNER JOIN #PARSE_PLANS ON QUERY_PLANS.SERVER_NAME = #PARSE_PLANS.SERVER_NAME
					AND QUERY_PLANS.DATABASE_NAME = #PARSE_PLANS.DATABASE_NAME
					AND QUERY_PLANS.QUERY_PLAN_HASH = #PARSE_PLANS.QUERY_PLAN_HASH
			OUTER APPLY QUERY_PLAN.nodes(''//sp:RelOp/sp:IndexScan'') AS SeekPredicates(index_node)
               --CROSS APPLY QUERY_PLAN.nodes(''//sp:Batch'') AS Batch(index_node2)
			WHERE QUERY_PLANS.SERVER_NAME = ' + '''' + @SERVER_NAME + '''' +'  AND QUERY_PLANS.DATABASE_NAME = '+ '''' +  @DATABASE_NAME +'''' + ' 
			   AND QUERY_PLANS.PARSED_FLAG = 0

			   ) A
			   OPTION(MAXDOP ' + CAST(@CPU AS VARCHAR(4)) + ')'

			   IF @DEBUG = 'Y'
			   BEGIN
				 PRINT @SQL
			   END


			   EXEC (@SQL)



UPDATE QP SET SQL_PARMS = PP.SQL_PARAMS
, PARSED_FLAG = 1

FROM QUERY_PLANS QP WITH (ROWLOCK, READPAST)
INNER JOIN #PARSE_PLANS PP ON QP.SERVER_NAME = PP.SERVER_NAME
			AND QP.DATABASE_NAME = PP.DATABASE_NAME
			AND QP.QUERY_PLAN_HASH = PP.QUERY_PLAN_HASH

 WHERE QP.SERVER_NAME = @SERVER_NAME AND QP.DATABASE_NAME = @DATABASE_NAME AND QP.PARSED_FLAG = 0 
 OPTION(MAXDOP 1)
 

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_PURGE_DATA]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_PURGE_DATA]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


SET NOCOUNT ON
SET DATEFORMAT MDY
DECLARE @PURGE_DATE smalldatetime, @PURGE_DAYS INT, @SQL NVARCHAR(MAX), @ROW_COUNT BIGINT = 0


DECLARE  @C_TABLE_NAME NVARCHAR(128), @C_TIME_COLUMN NVARCHAR(128), @C_SERVER_FLAG BIT, @C_DATABASE_FLAG BIT, @C_PURGE_DAYS INT
DECLARE @DC_SERVER_NAME NVARCHAR(128), @DC_DATABASE_NAME NVARCHAR(128), @DC_HISTORY_MONTHS INT, @DC_HISTORY_DAYS INT, @DC_DETAILS_DAYS INT






/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''




DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT TABLE_NAME, TIME_COLUMN, SERVER_NAME_FLAG, DATABASE_NAME_FLAG, RETENTION_DAYS
FROM   DynamicsPerf..[DYNPERF_PURGETABLES] WHERE TIME_COLUMN > ''  ---REH Ignore tables without some form of time column.  The collection sproc will handle deletion of data in those tables
ORDER BY RETENTION_DAYS, TABLE_NAME    --REH this sort is to force QUERY_STATS to delete before QUERY_PLANS/QUERY_TEXT so we don't wait a day to delete records not attached to data



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TABLE_NAME, @C_TIME_COLUMN, @C_SERVER_FLAG, @C_DATABASE_FLAG, @C_PURGE_DAYS


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */



	SET @PURGE_DAYS = @C_PURGE_DAYS * -1  --set to negative so we go back in time not forward in time
	SET @PURGE_DATE = DATEADD(DAY,@PURGE_DAYS,GETDATE())



	UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PURGING TABLE ' + ISNULL(@C_TABLE_NAME, 'TABLE ')
              + ' using PURGE_DAYS ' + CAST(@PURGE_DAYS AS VARCHAR(10)) + ' on DATE '
              + CONVERT(VARCHAR, @PURGE_DATE, 109) + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




IF @C_TABLE_NAME IN ('QUERY_PLANS', 'QUERY_TEXT')  --REH Use special handling for QUERY_PLANS and QUERY_TEXT TABLE delete based on no dependent records
BEGIN
--REH All associated records in other tables must be deleted first, QUERY_STATS, QUERY_HISTORY, ETC

		IF @C_TABLE_NAME = 'QUERY_PLANS'
		BEGIN

				SELECT DISTINCT QP.SERVER_NAME, QP.DATABASE_NAME, QP.QUERY_PLAN_HASH
				INTO #QP1
					 FROM QUERY_PLANS QP WITH (NOLOCK) WHERE QP.SERVER_NAME = @SERVER_NAME AND
				 NOT EXISTS (SELECT QS.QUERY_PLAN_HASH FROM QUERY_STATS QS WITH (NOLOCK) WHERE QS.DATABASE_NAME = QP.DATABASE_NAME AND QS.SERVER_NAME = QP.SERVER_NAME AND QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH) 
					AND NOT EXISTS (SELECT QUERY_PLAN_HASH FROM QUERY_HISTORY QH WITH (NOLOCK) WHERE QH.DATABASE_NAME = QP.DATABASE_NAME AND QH.SERVER_NAME = QP.SERVER_NAME AND QP.QUERY_PLAN_HASH = QH.QUERY_PLAN_HASH) 
				
				DELETE QP FROM QUERY_PLANS QP WITH (ROWLOCK, READPAST) INNER JOIN #QP1 ON  QP.SERVER_NAME = #QP1.SERVER_NAME 
					AND QP.DATABASE_NAME = #QP1.DATABASE_NAME AND QP.QUERY_PLAN_HASH = #QP1.QUERY_PLAN_HASH
		
				DROP TABLE #QP1


			--REH Delete any plans over the minimum number of plans to keep
				
				SELECT A.*
				INTO #DEL_PLANS
				FROM (
				SELECT DISTINCT QV.SERVER_NAME,
										QV.DATABASE_NAME,
										QUERY_HASH,
										QV.QUERY_PLAN_HASH,
										RN = ROW_NUMBER()
									  OVER (
										PARTITION BY QV.QUERY_HASH
										ORDER BY QV.QUERY_HASH DESC, QP.DATE_UPDATED DESC)
						FROM   QUERY_HISTORY_VW QV WITH (NOLOCK) INNER JOIN QUERY_PLANS QP WITH (NOLOCK) ON QV.SERVER_NAME=QP.SERVER_NAME
						AND QV.DATABASE_NAME = QP.DATABASE_NAME AND QV.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
						WHERE QV.DATE = DATEADD(MONTH, DATEDIFF(MONTH, 0, GETDATE()  ), 0) 

				   ) AS A 
				  -- INNER JOIN QUERY_PLANS QP WITH (NOLOCK) ON QP.SERVER_NAME = A.SERVER_NAME AND QP.DATABASE_NAME = A.DATABASE_NAME AND QP.QUERY_PLAN_HASH = A.QUERY_PLAN_HASH
				   WHERE A.RN> (SELECT D2.NUM_PLANS_TO_KEEP FROM DATABASES_2_COLLECT D2 WHERE D2.LINKED_SERVER=A.SERVER_NAME AND D2.DATABASE_NAME = A.DATABASE_NAME)

					DELETE QP FROM QUERY_PLANS QP WITH (ROWLOCK, READPAST) INNER JOIN #DEL_PLANS DP ON QP.SERVER_NAME = DP.SERVER_NAME
					AND QP.DATABASE_NAME = DP.DATABASE_NAME AND QP.QUERY_PLAN_HASH = DP.QUERY_PLAN_HASH

				   DROP TABLE #DEL_PLANS

			SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT


			--REH Delete any plans over the retention data

			DELETE QP FROM QUERY_PLANS QP WITH (ROWLOCK, READPAST) 
			INNER JOIN DATABASES_2_COLLECT DC ON QP.SERVER_NAME = DC.LINKED_SERVER AND DC.DATABASE_NAME = QP.DATABASE_NAME
			WHERE QP.DATE_UPDATED < DATEADD(DAY, DC.PURGE_PLANS_AFTER_X_DAYS * -1, GETDATE() )
			
			--REH Delete the bottom % of query_plans  RUN this task on the first day of the month
			

			IF DATEPART(DAY,GETDATE()) = 1 --REH Only run this part on first day of month
			BEGIN 
				WITH CTE_STATS (SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH, PctRank)
					 AS (
	 					SELECT TOP 100 PERCENT QH.SERVER_NAME, QH.DATABASE_NAME, QH.QUERY_PLAN_HASH,
					   PERCENT_RANK() OVER (PARTITION BY QH.SERVER_NAME, QH.DATABASE_NAME ORDER BY QH.ELAPSED_TIME_TODAY  ) * 100.00 AS PctRank
				FROM QUERY_HISTORY QH INNER JOIN DATABASES_2_COLLECT D2 ON QH.SERVER_NAME = D2.LINKED_SERVER AND QH.DATABASE_NAME = D2.DATABASE_NAME
				WHERE FLAG = 'M' and DATE =  DATEADD(MONTH, DATEDIFF(MONTH, 0, GETDATE())-1, 0) --REH Previous Month
				--AND < 100 - D2.KEEP_TOP_X_PLANS_BY_MONTH  --REH The rank is less than the rank we want to keep (based on total time)
				ORDER BY QH.SERVER_NAME, QH.DATABASE_NAME, QH.ELAPSED_TIME_TODAY DESC)

				DELETE QP
				FROM   QUERY_PLANS QP WITH (ROWLOCK, READPAST)
					   INNER JOIN CTE_STATS CTE
							   ON QP.SERVER_NAME = CTE.SERVER_NAME
								  AND CTE.DATABASE_NAME = QP.DATABASE_NAME
								  AND CTE.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
					   INNER JOIN DATABASES_2_COLLECT D2
							   ON D2.LINKED_SERVER = CTE.SERVER_NAME
								  AND CTE.DATABASE_NAME = D2.DATABASE_NAME
				WHERE  CTE.PCTRANK < 100 - D2.KEEP_TOP_X_QUERIES_BY_MONTH --REH The rank is less than the rank we want to keep (based on total time)

			
			END

		END

				

	   IF @C_TABLE_NAME = 'QUERY_TEXT'
		BEGIN
			SELECT QT.SERVER_NAME, QT.DATABASE_NAME, QT.QUERY_HASH 
			INTO #QT 
			FROM QUERY_TEXT QT WHERE QT.SERVER_NAME = @SERVER_NAME AND
			 NOT EXISTS (SELECT QS.QUERY_HASH FROM QUERY_STATS QS WITH (NOLOCK) WHERE QS.DATABASE_NAME = QT.DATABASE_NAME AND QS.SERVER_NAME = QT.SERVER_NAME AND QT.QUERY_HASH = QS.QUERY_HASH) 
				AND NOT EXISTS (SELECT QUERY_HASH FROM QUERY_HISTORY QH WITH (NOLOCK) WHERE QH.DATABASE_NAME = QT.DATABASE_NAME AND QH.SERVER_NAME = QT.SERVER_NAME AND QT.QUERY_HASH = QH.QUERY_HASH) 

				DELETE QT FROM QUERY_TEXT QT WITH (ROWLOCK, READPAST) INNER JOIN #QT TMP ON QT.SERVER_NAME = TMP.SERVER_NAME
				AND QT.DATABASE_NAME = TMP.DATABASE_NAME AND QT.QUERY_HASH = TMP.QUERY_HASH

				SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
				
				DROP TABLE #QT
		END
END
ELSE
IF @C_TABLE_NAME IN ('QUERY_STATS', 'INDEX_DETAIL')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE

		BEGIN

				IF @C_TABLE_NAME = 'QUERY_STATS'
					DELETE QS FROM QUERY_STATS QS WITH (ROWLOCK, READPAST) INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE QS.SERVER_NAME = @SERVER_NAME AND QS.STATS_TIME < DATEADD(DAY,DC.RETAIN_DETAILS_DAYS * -1, GETDATE())

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

				IF @C_TABLE_NAME = 'INDEX_DETAIL'
					DELETE ID FROM INDEX_DETAIL ID WITH (ROWLOCK, READPAST) INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.STATS_TIME < DATEADD(DAY,DC.RETAIN_DETAILS_DAYS * -1, GETDATE())

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
		
				
		END

ELSE
IF @C_TABLE_NAME IN ('CAPTURE_LOG')


	BEGIN

	
	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE  ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

	END
ELSE

IF @C_TABLE_NAME IN ('INDEX_HISTORY', 'QUERY_HISTORY')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE

		BEGIN

				IF @C_TABLE_NAME = 'QUERY_HISTORY'
				BEGIN
					--REH DELETE MONTHLY QUERY TOTALS 
					DELETE QS FROM QUERY_HISTORY QS WITH (ROWLOCK, READPAST) INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE  QS.SERVER_NAME = @SERVER_NAME AND QS.DATE < DATEADD(MONTH,DC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) AND QS.FLAG = 'M'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



					--REH DELETE DAYS TOTALS FROM QUERY_HISTORY		
					DELETE QS FROM QUERY_HISTORY QS WITH (ROWLOCK, READPAST) INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE  QS.SERVER_NAME = @SERVER_NAME AND QS.DATE < DATEADD(DAY,DC.RETAIN_HISTORY_DAYS * -1, GETDATE()) AND QS.FLAG = 'D'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

		--REH STALE QUERY delete

							;WITH CTE_HIST (SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, MAX_DATE)
								 AS (SELECT SERVER_NAME,
											DATABASE_NAME,
											QUERY_HASH,
											QUERY_PLAN_HASH,
											MAX(DATE)
									 FROM   QUERY_HISTORY WITH (NOLOCK)
									 GROUP  BY SERVER_NAME,
											   DATABASE_NAME,
											   QUERY_HASH,
											   QUERY_PLAN_HASH)
							DELETE QS
							FROM   QUERY_HISTORY QS WITH (ROWLOCK, READPAST)
								   INNER JOIN DATABASES_2_COLLECT DC
										   ON QS.SERVER_NAME = DC.LINKED_SERVER
											  AND QS.DATABASE_NAME = DC.DATABASE_NAME
								   INNER JOIN CTE_HIST CTE
										   ON CTE.SERVER_NAME = QS.SERVER_NAME
											  AND CTE.DATABASE_NAME = QS.DATABASE_NAME
											  AND CTE.QUERY_HASH = QS.QUERY_HASH
											  AND CTE.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
							WHERE  QS.SERVER_NAME = @SERVER_NAME
								   AND CTE.MAX_DATE < DATEADD(DAY, DC.PURGE_STALE_QUERIES_DAYS * -1, GETDATE()) 


						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



						IF DATEPART(DAY,GETDATE()) = 1 --REH Only run this part on first day of month
							BEGIN 
								WITH CTE_STATS (SERVER_NAME, DATABASE_NAME, QUERY_HASH, PctRank)
									 AS (
	 									SELECT TOP 100 PERCENT QH.SERVER_NAME, QH.DATABASE_NAME, QH.QUERY_HASH,
									   PERCENT_RANK() OVER (PARTITION BY QH.SERVER_NAME, QH.DATABASE_NAME ORDER BY QH.ELAPSED_TIME_TODAY  ) * 100.00 AS PctRank
								FROM QUERY_HISTORY QH INNER JOIN DATABASES_2_COLLECT D2 ON QH.SERVER_NAME = D2.LINKED_SERVER AND QH.DATABASE_NAME = D2.DATABASE_NAME
								WHERE FLAG = 'M' and DATE =  DATEADD(MONTH, DATEDIFF(MONTH, 0, GETDATE())-1, 0)  --REH Previous Month
								--AND < 100 - D2.KEEP_TOP_X_PLANS_BY_MONTH  --REH The rank is less than the rank we want to keep (based on total time)
								ORDER BY QH.SERVER_NAME, QH.DATABASE_NAME, QH.ELAPSED_TIME_TODAY DESC)

								DELETE QH FROM QUERY_HISTORY QH WITH (ROWLOCK, READPAST)
								INNER JOIN CTE_STATS CTE WITH (NOLOCK) ON QH.SERVER_NAME = CTE.SERVER_NAME AND CTE.DATABASE_NAME = QH.DATABASE_NAME AND CTE.QUERY_HASH = QH.QUERY_HASH
								INNER JOIN DATABASES_2_COLLECT D2  ON D2.LINKED_SERVER = CTE.SERVER_NAME AND CTE.DATABASE_NAME = D2.DATABASE_NAME 
								WHERE CTE.PCTRANK < 100 - D2.KEEP_TOP_X_QUERIES_BY_MONTH  --REH The rank is less than the rank we want to keep (based on total time)
								AND QH.FLAG = 'M' and QH.DATE =  DATEADD(MONTH, DATEDIFF(MONTH, 0, GETDATE())-1, 0)
							END







				END

				IF @C_TABLE_NAME = 'INDEX_HISTORY'
				BEGIN
					DELETE ID FROM INDEX_HISTORY ID WITH (ROWLOCK, READPAST) INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.DATE < DATEADD(MONTH,DC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) 
							AND ID.FLAG = 'M'

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

					DELETE ID FROM INDEX_HISTORY ID WITH (ROWLOCK, READPAST) INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.DATE < DATEADD(DAY,DC.RETAIN_HISTORY_DAYS * -1, GETDATE()) 
							AND ID.FLAG = 'D'

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

				END	
			
		END

ELSE

IF @C_TABLE_NAME IN ('SSRS_EXECUTIONLOG', 'SSRS_HISTORY')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE
BEGIN
			IF @C_TABLE_NAME = 'SSRS_EXECUTIONLOG'
				BEGIN
					--REH DELETE MONTHLY QUERY TOTALS 
					DELETE EL FROM SSRS_EXECUTIONLOG EL WITH (ROWLOCK, READPAST)
					INNER JOIN SSRS_CONFIG SC ON EL.SERVER_NAME = SC.SERVER_NAME AND EL.DATABASE_NAME = SC.DATABASE_NAME
						WHERE  EL.TIMEEND < DATEADD(DAY,SC.RETAIN_DETAILS_DAYS * -1, GETDATE()) 

					SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
				END
			IF @C_TABLE_NAME = 'SSRS_HISTORY'
				BEGIN
					--REH DELETE MONTHLY QUERY TOTALS 
					DELETE SH FROM SSRS_HISTORY SH WITH (ROWLOCK, READPAST)
						INNER JOIN SSRS_CONFIG SC ON SH.SERVER_NAME = SC.SERVER_NAME AND SH.DATABASE_NAME = SC.DATABASE_NAME
						WHERE   SH.REPORT_DATE < DATEADD(MONTH,SC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) AND SH.FLAG = 'M'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



					--REH DELETE DAYS TOTALS FROM QUERY_HISTORY	
					DELETE SH FROM SSRS_HISTORY SH WITH (ROWLOCK, READPAST)
						INNER JOIN SSRS_CONFIG SC ON SH.SERVER_NAME = SC.SERVER_NAME AND SH.DATABASE_NAME = SC.DATABASE_NAME
						WHERE   SH.REPORT_DATE < DATEADD(DAY,SC.RETAIN_HISTORY_DAYS * -1, GETDATE()) AND SH.FLAG = 'D'
	
					SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
				END
				
END


ELSE


IF @C_TABLE_NAME IN ('QUERY_PLANS_PARSED')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE
BEGIN
	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WITH (ROWLOCK, READPAST) WHERE ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SELECT QPP.SERVER_NAME, QPP.DATABASE_NAME, QPP.QUERY_PLAN_HASH 
	INTO #QPP FROM QUERY_PLANS_PARSED QPP 
	WHERE NOT EXISTS (SELECT 'X' FROM QUERY_HISTORY QH WHERE QPP.SERVER_NAME = QH.SERVER_NAME
	AND QPP.DATABASE_NAME = QH.DATABASE_NAME AND QPP.QUERY_PLAN_HASH = QH.QUERY_PLAN_HASH)

	DELETE QPP FROM QUERY_PLANS_PARSED QPP WITH (ROWLOCK, READPAST) INNER JOIN #QPP TMP ON QPP.SERVER_NAME = TMP.SERVER_NAME
		AND QPP.DATABASE_NAME = TMP.DATABASE_NAME AND QPP.QUERY_PLAN_HASH = TMP.QUERY_PLAN_HASH


	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
	
	DROP TABLE #QPP
END


ELSE


BEGIN



	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WITH (ROWLOCK, READPAST) WHERE SERVER_NAME =  ' + ''''+ @SERVER_NAME + '''' + ' AND ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

END




FETCH NEXT FROM TASK_CURSOR INTO @C_TABLE_NAME, @C_TIME_COLUMN, @C_SERVER_FLAG, @C_DATABASE_FLAG, @C_PURGE_DAYS


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
	


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Deleted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_REFRESH_QUERY_PLANS]...';


GO
ALTER PROCEDURE [dbo].DYNPERF_REFRESH_QUERY_PLANS
(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/


    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @REFRESH_PLAN_DAYS INT
    
/*************************************************

--REH Template for creating a synonym, 
--Will help avoid having to use EXEC (@SQL) code
-- and make the code more dynamic to the inputs


***************************************************/

IF EXISTS (SELECT *
           FROM   sys.synonyms
           WHERE  name = 'DYN_RQP_STATS')
  EXEC ('DROP SYNONYM [dbo].DYN_RQP_STATS')


IF @REMOTE_SERVER = 'Y'
     BEGIN
         SET @SQL = '
				CREATE SYNONYM DYN_RQP_STATS
				FOR [' + @SERVER_NAME + '].[' + @DATABASE_NAME + '].sys.dm_exec_query_stats'
     END
ELSE

         SET @SQL = '
				CREATE SYNONYM DYN_RQP_STATS
				FOR [' + @DATABASE_NAME + '].sys.dm_exec_query_stats'

EXEC (@SQL)


/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


  SELECT @REFRESH_PLAN_DAYS = REFRESH_PLAN_DAYS FROM DATABASES_2_COLLECT WHERE LINKED_SERVER = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''

IF @REMOTE_SERVER = 'N'
BEGIN
;WITH Query_Stats_CTE (SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH, PLAN_HANDLE )
     AS
     -- Define the CTE query.
     (SELECT TOP 10000 * FROM 
     (SELECT DISTINCT SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH,
                      PLAN_HANDLE
      FROM   QUERY_STATS AS QS WITH (NOLOCK)
      WHERE  STATS_TIME > DATEADD(D,-1,GETDATE())  --REH ANY QUERIES COLLECTED IN THE LAST DAY
             AND DATABASE_NAME = @DATABASE_NAME
             AND SERVER_NAME = @SERVER_NAME 
             AND QUERY_PLAN_HASH > 0x00000000
             AND  EXISTS (SELECT 'X'
                             FROM   QUERY_PLANS QP WITH (NOLOCK)
                             WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
                                    AND QS.DATABASE_NAME = QP.DATABASE_NAME
                                    AND QS.SERVER_NAME = QP.SERVER_NAME 
									AND QP.DATE_UPDATED <= DATEADD(D,-@REFRESH_PLAN_DAYS,GETDATE() ) --REH ANY PLANS THAT HAVEN'T BEEN UPDATED IN THE LAST 7 DAYS
									)) AS A )
									 
UPDATE QP 
SET QUERY_PLAN = COALESCE(RH.QUERY_PLAN,QP.QUERY_PLAN), DATE_UPDATED = GETDATE(), PARSED_FLAG = 0
FROM   QUERY_PLANS QP WITH (ROWLOCK, READPAST)
INNER JOIN (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_PLAN_HASH
                        ORDER BY CTE.QUERY_PLAN_HASH DESC),
                        SERVER_NAME, 
                        DATABASE_NAME,
               CTE.QUERY_PLAN_HASH,
               query_plan AS QUERY_PLAN
        FROM   Query_Stats_CTE CTE WITH (NOLOCK)
               OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH ON RH.SERVER_NAME = QP.SERVER_NAME AND RH.DATABASE_NAME = QP.DATABASE_NAME
               AND RH.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
WHERE  RN = 1 AND QP.SERVER_NAME = @SERVER_NAME AND QP.DATABASE_NAME = @DATABASE_NAME AND QP.QUERY_PLAN_HASH <> 0x0000000000000000


END

IF @REMOTE_SERVER = 'Y'
     BEGIN
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)


         SET @SQL = '
				CREATE TABLE [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH
				(
				QUERY_PLAN_HASH VARBINARY(64), 
				PLAN_HANDLE VARBINARY(64)
				)'

		IF @DEBUG = 'Y'
		BEGIN
         PRINT @SQL
		 END


         SET @SQL2 = ' 
				  SET QUOTED_IDENTIFIER OFF
				  EXEC (' + '"' + @SQL + '"' + ') AT [' + @SERVER_NAME
									 + ']'

         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

         SET @SQL = '

					;WITH Query_Stats_CTE ( QUERY_PLAN_HASH, PLAN_HANDLE)
						 AS (SELECT DISTINCT TOP 10000 QUERY_PLAN_HASH,
										  PLAN_HANDLE
							 FROM   QUERY_STATS QS WITH (NOLOCK)
							 WHERE  QS.STATS_TIME >=  DATEADD(D,-1,GETDATE()) 
							  AND QUERY_PLAN_HASH > 0x00000000
									AND DATABASE_NAME = '
										+ '''' + @DATABASE_NAME + ''''
										+ '
									AND SERVER_NAME = ' + '''' +
										+ @SERVER_NAME + ''''
										+ ' 
									AND EXISTS (SELECT ''X''
													FROM   QUERY_PLANS QP WITH (NOLOCK)
												 WHERE  QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
														AND QS.DATABASE_NAME = QP.DATABASE_NAME
														AND QS.SERVER_NAME = QP.SERVER_NAME 
															AND QP.DATE_UPDATED <= DATEADD(D,-' + CAST(@REFRESH_PLAN_DAYS AS VARCHAR(4)) +',GETDATE() ) 
													))
						INSERT INTO OPENQUERY([' + @SERVER_NAME
										+ '], ''SELECT QUERY_PLAN_HASH, PLAN_HANDLE FROM [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH'')
					                            
					  
					SELECT QUERY_PLAN_HASH, PLAN_HANDLE 
					FROM   (SELECT RN = ROW_NUMBER()
										  OVER (
											PARTITION BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE
											ORDER BY CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE DESC),
								   CTE.QUERY_PLAN_HASH, CTE.PLAN_HANDLE 
					            
								FROM   Query_Stats_CTE CTE
							   ) AS RH
					WHERE  RN = 1 '

		IF @DEBUG = 'Y'
			 BEGIN
				 PRINT '@SQL= ' + @SQL
			 END 


         EXEC(@SQL)



			SET @SQL = 'SELECT 
				   QUERY_PLAN_HASH,
				   cast(query_plan as nvarchar(max)) as QUERY_PLAN

			FROM   (SELECT RN = ROW_NUMBER()
								  OVER (
									PARTITION BY QUERY_PLAN_HASH
									ORDER BY QUERY_PLAN_HASH DESC),
						   QUERY_PLAN_HASH,
						   query_plan 
					FROM   [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH CTE
						   OUTER APPLY sys.dm_exec_query_plan(CTE.PLAN_HANDLE)) AS RH
			WHERE  RN = 1 ' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL
              END
              
              
		SET @SQL2 = ' 
		  SET QUOTED_IDENTIFIER OFF
		  UPDATE DynamicsPerf.dbo.QUERY_PLANS WITH (ROWLOCK, READPAST)
						 SET QUERY_PLAN =  COALESCE( RH.QUERY_PLAN, QUERY_PLANS.QUERY_PLAN), PARSED_FLAG = 0, DATE_UPDATED = ' + '''' + CAST(GETDATE() AS VARCHAR(20)) + '''' 
						 + 'FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') AS RH
						 WHERE SERVER_NAME = ' + '''' + @SERVER_NAME + '''' +
						  '   AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + 
						  '  AND RH.QUERY_PLAN_HASH = QUERY_PLANS.QUERY_PLAN_HASH' 

		 IF @DEBUG = 'Y'
			  BEGIN
				  PRINT '@SQL= ' + @SQL2
			  END 
		 

         EXEC(@SQL2)
         

		 --REH Drop the table at the end of the process

         SET @SQL = '

				IF EXISTS (SELECT * FROM  [' + @DATABASE_NAME + '].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
				 DROP TABLE  [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)
     
     END 




UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)

	
         SET @SQL = '

				IF EXISTS (SELECT * FROM  [' + @DATABASE_NAME + '].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
				 DROP TABLE  [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 

				EXEC(@SQL2)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[DYNPERF_REFRESH_QUERY_TEXT]...';


GO
ALTER PROCEDURE [dbo].[DYNPERF_REFRESH_QUERY_TEXT]
 (@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS

/************************************************************************************************************
*  SETUP
*		DECLARE VARIABLES, CREATE SYNONYMS, ETC
*
*************************************************************************************************************/

    SET NOCOUNT ON
    SET DATEFORMAT MDY

    DECLARE @SQL NVARCHAR(MAX), @SQL2 NVARCHAR(MAX), @REFRESH_PLAN_DAYS INT
    
/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)





--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 


  SELECT @REFRESH_PLAN_DAYS = REFRESH_PLAN_DAYS FROM DATABASES_2_COLLECT WHERE LINKED_SERVER = @SERVER_NAME AND DATABASE_NAME = @DATABASE_NAME


BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''



IF @REMOTE_SERVER = 'N'
     BEGIN ;
         WITH Query_Stats_CTE ( QUERY_HASH)
              AS (SELECT  QUERY_HASH
                  FROM   QUERY_STATS QS WITH (NOLOCK)
                  WHERE  QS.STATS_TIME >= DATEADD(D,-1,GETDATE())
                         AND DATABASE_NAME = @DATABASE_NAME
                         AND SERVER_NAME = @SERVER_NAME 
						 AND QUERY_HASH > 0x0000000000
                         AND  EXISTS (SELECT 'X'
                                         FROM   QUERY_TEXT QT WITH (NOLOCK)
                                         WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                                AND QS.SERVER_NAME = QT.SERVER_NAME
												AND QT.DATE_UPDATED <= DATEADD(D,-@REFRESH_PLAN_DAYS,GETDATE() ) --REH ANY PLANS THAT HAVEN'T BEEN UPDATED IN THE LAST 7 DAYS
												 ))
    --     INSERT QUERY_TEXT
    --     SELECT @SERVER_NAME,
    --            @DATABASE_NAME,
    --            QUERY_HASH,
    --            SQL_TEXT,
				--@STATS_DATE
				
	UPDATE QT 
	SET SQL_TEXT = COALESCE(RH.SQL_TEXT, QT.SQL_TEXT), DATE_UPDATED = @STATS_DATE
         FROM   
         QUERY_TEXT QT WITH (ROWLOCK, READPAST) INNER JOIN 
         (SELECT RN = ROW_NUMBER()
                               OVER (
                                 PARTITION BY CTE.QUERY_HASH
                                 ORDER BY CTE.QUERY_HASH DESC),
                        qs.query_hash                                                                                              AS QUERY_HASH,
                        SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                        WHEN -1 THEN DATALENGTH(st.text)
                                                                                        ELSE qs.statement_end_offset
                                                                                      END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
                 FROM   Query_Stats_CTE CTE
                        INNER JOIN sys.dm_exec_query_stats AS qs
                                ON CTE.QUERY_HASH = qs.query_hash
                        OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                        CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
                 WHERE  attribute = N'dbid'
                        AND DB_NAME(CONVERT(INT, value)) = @DATABASE_NAME
                        AND last_execution_time >= @LAST_RUN
						) AS RH ON RH.QUERY_HASH = QT.QUERY_HASH AND QT.SERVER_NAME = @SERVER_NAME AND QT.DATABASE_NAME = @DATABASE_NAME
         WHERE  RN = 1
     END 


 IF @REMOTE_SERVER = 'Y'
 BEGIN
 


				 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)



 SET @SQL = '
CREATE TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH
(
QUERY_HASH VARBINARY(64)
)' 



 SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  EXEC ('+'"' + @SQL +'"' + ') AT [' + @SERVER_NAME + ']'
  
 IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END

EXEC (@SQL2)


SET @SQL = '

;WITH Query_Stats_CTE ( QUERY_HASH)
     AS (SELECT  QUERY_HASH
         FROM   QUERY_STATS QS
         WHERE  QS.STATS_TIME >= DATEADD(D,-1, GETDATE()  )
                AND DATABASE_NAME = ' + '''' + @DATABASE_NAME + '''' + '
                AND SERVER_NAME = ' + '''' + +@SERVER_NAME + '''' + ' 
				AND QUERY_HASH > 0x0000000000
                AND  EXISTS (SELECT ''X''
                                FROM   QUERY_TEXT QT WITH (NOLOCK)
                                WHERE  QS.QUERY_HASH = QT.QUERY_HASH
                                AND QS.DATABASE_NAME = QT.DATABASE_NAME
                                AND QS.SERVER_NAME = QT.SERVER_NAME 
								AND QT.DATE_UPDATED <= DATEADD(D,-'+CAST(@REFRESH_PLAN_DAYS AS VARCHAR(4))+',GETDATE() )
                                ))
INSERT INTO OPENQUERY([' + @SERVER_NAME + '], ''SELECT QUERY_HASH FROM  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH'')

SELECT QUERY_HASH
FROM   (SELECT RN = ROW_NUMBER()
                      OVER (
                        PARTITION BY CTE.QUERY_HASH
                        ORDER BY CTE.QUERY_HASH DESC),
               QUERY_HASH 
            
            FROM   Query_Stats_CTE CTE
           ) AS RH
WHERE  RN = 1 '

IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


EXEC (@SQL)


        
 SET @SQL = '
         SELECT QUERY_HASH, SQL_TEXT
         FROM (
         SELECT RN = ROW_NUMBER() OVER (PARTITION BY CTE.QUERY_HASH ORDER BY CTE.QUERY_HASH DESC),
          qs.query_hash AS QUERY_HASH,
                         SUBSTRING(st.text, ( qs.statement_start_offset / 2 ) + 1, ( ( CASE qs.statement_end_offset
                                                                                         WHEN -1 THEN DATALENGTH(st.text)
                                                                                         ELSE qs.statement_end_offset
                                                                                       END - qs.statement_start_offset ) / 2 ) + 1) AS SQL_TEXT
         FROM    [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH CTE
                INNER JOIN sys.dm_exec_query_stats AS qs
                        ON CTE.QUERY_HASH = qs.query_hash
                OUTER APPLY sys.dm_exec_plan_attributes (qs.plan_handle)
                CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
         WHERE  attribute = N''dbid''
                AND DB_NAME(CONVERT(INT, value)) = ' + QUOTENAME(@DATABASE_NAME, '''') + '
                ) AS RH  
                WHERE RN = 1 '
PRINT ''
PRINT ''
                  
IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL
END


                    SET @SQL2 = ' 
  SET QUOTED_IDENTIFIER OFF
  	UPDATE QT 
	SET SQL_TEXT = COALESCE(A.SQL_TEXT,QT.SQL_TEXT), DATE_UPDATED =' + '''' + CONVERT(NVARCHAR(24), @STATS_DATE, 121) +'''' +
	' FROM QUERY_TEXT QT WITH (ROWLOCK, READPAST) INNER JOIN  (' +
				 '  SELECT RH.* FROM OPENQUERY([' + @SERVER_NAME + '], ' +'"' + @SQL +'"' + ') RH
                    ) AS A ON A.QUERY_HASH = QT.QUERY_HASH AND QT.SERVER_NAME = ' +'''' + @SERVER_NAME + '''' +
                    '   AND QT.DATABASE_NAME = ' + '''' + @DATABASE_NAME +''''
                   


IF @DEBUG = 'Y' 
BEGIN
PRINT '@SQL= ' + @SQL2
END
				 
				 EXECUTE (@SQL2)
				 
 --REH  Delete the table back out
 
 
SET @SQL = '

IF EXISTS (SELECT * FROM  [tempdb].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
 DROP TABLE  [tempdb].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 


         IF @DEBUG = 'Y'
              BEGIN
                  PRINT '@SQL= ' + @SQL2
              END

         EXEC (@SQL2)

 
 END
 
    

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Inserted ' + CAST(@@ROWCOUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)

	
         SET @SQL = '

				IF EXISTS (SELECT * FROM  [' + @DATABASE_NAME + '].sys.objects WHERE name = ''DYNPERF_QUERY_HASH_REFRESH'') 
				 DROP TABLE  [' + @DATABASE_NAME + '].dbo.DYNPERF_QUERY_HASH_REFRESH '
				 
			SET @SQL2 = ' 
							  SET QUOTED_IDENTIFIER OFF
							  EXEC (' + '"' + @SQL + '"' + ') AT ['
						+ @SERVER_NAME + ']' 

			EXEC (@SQL2)


    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH
GO
PRINT N'Altering [dbo].[SET_AX_SQLTRACE]...';


GO


ALTER PROCEDURE [dbo].[SET_AX_SQLTRACE] @SERVER_NAME NVARCHAR(128) = @@SERVERNAME,
								@DATABASE_NAME    NVARCHAR(128),
                                 @QUERY_TIME_LIMIT INT = 5000,
                                 @AX_ID            NVARCHAR(10) = NULL,
                                 @TRACE_STATUS     NVARCHAR(3) = 'ON', 
                               --  @CLIENTACESSLOG   INT = 0,
								 @OVERRIDE		INT = 0
AS

  DECLARE @SQL NVARCHAR(1000),
          @RC  INT

  SET @RC = 0



         IF EXISTS (SELECT *
                    FROM   sys.synonyms
                    WHERE  name = 'DYN_AXT_SYSDATABASES')
           EXEC ('DROP SYNONYM [dbo].DYN_AXT_SYSDATABASES')

         IF @SERVER_NAME <> @@SERVERNAME
              BEGIN
                  --REH  You CANNOT use synonms for queries that pull XML or use FUNCTIONS
                  SET @SQL = '
				CREATE SYNONYM DYN_AXT_SYSDATABASES
				FOR [' + @SERVER_NAME
                             + '].master.sys.databases'
              END
         ELSE
           SET @SQL = '
				CREATE SYNONYM DYN_AXT_SYSDATABASES
				FOR master.sys.databases'


         EXEC (@SQL) -- CREATE SYNONYM

         IF (SELECT COUNT(*)
             FROM   DynamicsPerf.dbo.DYN_AXT_SYSDATABASES
             WHERE  name = @DATABASE_NAME) < 1
              BEGIN
                  PRINT 'DATABASE ' + ISNULL(@DATABASE_NAME, 'NULL')
                        + ' does not exist on server '
                        + ISNULL(@SERVER_NAME, 'NULL')

                  RETURN( 0 );
              END

IF @OVERRIDE = 0 AND @QUERY_TIME_LIMIT < 5000 SET @QUERY_TIME_LIMIT = 5000

  IF @TRACE_STATUS = 'ON'
    BEGIN
        
          SET @SQL = 'UPDATE [' +@SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO
				SET QUERYTIMELIMIT = ' + Str(@QUERY_TIME_LIMIT) + ',
					DEBUGINFO = DEBUGINFO & 256,
					TRACEINFO =  TRACEINFO & 2048'
			IF @AX_ID IS NOT NULL	
			SET @SQL = @SQL + 	' WHERE ID = ''' + @AX_ID + ''''	
			

				MERGE AX_SQLTRACE_CONFIG AS target
				USING (SELECT @SERVER_NAME AS SERVER_NAME,
							  @DATABASE_NAME AS DATABASE_NAME,
							  @QUERY_TIME_LIMIT AS SQL_DURATION,
							  1                 AS TRACE_ON,		--REH Turns it ON
							  14 AS AXDB_DELETION_DAYS
) AS source
				ON ( source.SERVER_NAME = target.SERVER_NAME
					 AND source.DATABASE_NAME = target.DATABASE_NAME )
				WHEN MATCHED THEN
				  UPDATE SET SQL_DURATION = source.SQL_DURATION,
							 TRACE_ON = source.TRACE_ON
				WHEN NOT MATCHED THEN
				  INSERT ( [SERVER_NAME],
						   [DATABASE_NAME],
						   [SQL_DURATION],
						   [TRACE_ON],
						   [AXDB_DELETION_DAYS])
				  VALUES (source.[SERVER_NAME],
						  source.[DATABASE_NAME],
						  source.[SQL_DURATION],
						  source.[TRACE_ON],
						  14);		--REH default 14 days, DYNPERF_SET_AX_SQLTRACE sproc will delete from systracetable in the AX database using this value
									-- setting it to 0 disables this feature
			
			END
  ELSE
    IF @TRACE_STATUS = 'OFF'
      BEGIN
          IF @AX_ID IS NULL
            SET @SQL = 'UPDATE [' +@SERVER_NAME + '].[' + @DATABASE_NAME + '].dbo.USERINFO
				SET QUERYTIMELIMIT = 0,
                    DEBUGINFO = DEBUGINFO & 2147483391,
                    TRACEINFO = TRACEINFO & 2147481599'
					
			IF @AX_ID IS NOT NULL	
			SET @SQL = @SQL + 	' WHERE ID = ''' + @AX_ID + ''''	

        	--REH Insert a record so that our scheduled job auto updates it
MERGE AX_SQLTRACE_CONFIG AS target
				USING (SELECT @SERVER_NAME AS SERVER_NAME,
							  @DATABASE_NAME AS DATABASE_NAME,
							  @QUERY_TIME_LIMIT AS SQL_DURATION,
							  0                 AS TRACE_ON,		--REH Turns it OFF
							  14 AS AXDB_DELETION_DAYS
					  ) AS source
				ON ( source.SERVER_NAME = target.SERVER_NAME
					 AND source.DATABASE_NAME = target.DATABASE_NAME )
				WHEN MATCHED THEN
				  UPDATE SET SQL_DURATION = source.SQL_DURATION,
							 TRACE_ON = source.TRACE_ON
				WHEN NOT MATCHED THEN
				  INSERT ( [SERVER_NAME],
						   [DATABASE_NAME],
						   [SQL_DURATION],
						   [TRACE_ON],
						   [AXDB_DELETION_DAYS])
				  VALUES (source.[SERVER_NAME],
						  source.[DATABASE_NAME],
						  source.[SQL_DURATION],
						  source.[TRACE_ON],
						  14); --REH default 14 days, DYNPERF_SET_AX_SQLTRACE sproc will delete from systracetable in the AX database using this value
								-- setting it to 0 disables this feature
      END
    ELSE
      PRINT 'Invalid @TRACE_STATUS option; must be ON or OFF'

  PRINT @SQL
  EXEC (@SQL)
 

 
  ENDPROC:

  ERROR:

  RETURN @RC
GO
PRINT N'Altering [dbo].[SP_LOGBLOCKS_MS]...';


GO


ALTER PROCEDURE [dbo].[SP_LOGBLOCKS_MS]
AS



SET nocount ON
SET DATEFORMAT MDY 


-- ***********************************************************************
-- Copyright  Microsoft Corporation. All rights reserved.
-- This script is made available to you without any express, implied or statutory warranty, 
-- not even the implied warranty of merchantability or fitness for a particular purpose, 
-- or the warranty of title or non-infringement. 
-- The entire risk of the use or the results from the use of this script remains with you.
-- ***********************************************************************

DECLARE @BLOCKED TABLE(
  BLOCKER_LOGIN          NVARCHAR(128) COLLATE database_default,
  BLOCKER_PROGRAM        NVARCHAR(128) COLLATE database_default,
  BLOCKER_HOSTNAME       NVARCHAR(128) COLLATE database_default,
  BLOCKED_LOGIN          NVARCHAR(128) COLLATE database_default,
  BLOCKED_PROGRAM        NVARCHAR(128) COLLATE database_default,
  BLOCKED_HOSTNAME       NVARCHAR(128) COLLATE database_default,
  BLOCKER_SESSION_ID     SMALLINT,
  BLOCKER_CONTEXT_INFO	 BINARY (128),
  BLOCKER_CONTEXT        NVARCHAR(MAX) COLLATE database_default,
  BLOCKER_TRAN_ISOLATION NVARCHAR(20) COLLATE database_default,
  BLOCKER_STATUS         NVARCHAR(18) COLLATE database_default,
  BLOCKED_SESSION_ID     SMALLINT,
  BLOCKED_CONTEXT_INFO	 BINARY(128),
  BLOCKED_CONTEXT        NVARCHAR(MAX) COLLATE database_default,
  BLOCKED_TRAN_ISOLATION NVARCHAR(20) COLLATE database_default,
  TRANSACTION_ID		 BIGINT,
  WAIT_TIME              BIGINT,
  LOCK_MODE              NVARCHAR(60) COLLATE database_default,
  LOCK_SIZE              NVARCHAR(6) COLLATE database_default,
  DATABASE_NAME          NVARCHAR(128) COLLATE database_default,
  OBJECT_NAME            NVARCHAR(128) COLLATE database_default,
  INDEX_ID               INT,
  BLOCKER_SQL            NVARCHAR(MAX) COLLATE database_default,
  BLOCKER_PLAN           XML,
  BLOCKED_SQL            NVARCHAR(MAX) COLLATE database_default,
  BLOCKED_PLAN           XML ) 




DECLARE @BLOCKER_SESSION_ID     SMALLINT,
        @BLOCKER_CONTEXT        NVARCHAR(MAX),
        @BLOCKER_CONTEXT_INFO	BINARY(128),
        @BLOCKER_TRAN_ISOLATION NVARCHAR(20),
        @BLOCKER_STATUS         NVARCHAR(18),
        @BLOCKED_SESSION_ID     SMALLINT,
        @BLOCKED_CONTEXT        NVARCHAR(MAX),
        @BLOCKED_CONTEXT_INFO	BINARY(128),
        @BLOCKED_TRAN_ISOLATION NVARCHAR(20),
        @WAITTIME               BIGINT,
        @LOCK_MODE              NVARCHAR(60),
        @LOCK_SIZE              CHAR(6),
        @DATABASE_NAME          NVARCHAR(128),
        @ASSOCIATEDOBJECTID     BIGINT,
        @OBJECT_NAME            NVARCHAR(128),
        @INDEX_ID               INT,
        @BLOCKER_SQL            NVARCHAR(MAX),
        @BLOCKER_PLAN           XML,
        @BLOCKED_SQL            NVARCHAR(MAX),
        @BLOCKED_PLAN           XML,
        @SQL                    NVARCHAR(4000),
        @PARM                   NVARCHAR(500),
        @BLOCKED_LOGIN          NVARCHAR(128),
        @BLOCKED_PROGRAM        NVARCHAR(128),
        @BLOCKED_HOSTNAME       NVARCHAR(128),
        @BLOCKER_LOGIN          NVARCHAR(128),
        @BLOCKER_PROGRAM        NVARCHAR(128),
        @BLOCKER_HOSTNAME       NVARCHAR(128),
        @TRANSACTION_ID			BIGINT,
        @rows                   BIGINT 



SET NOCOUNT ON
SET DATEFORMAT MDY
--	-------------------------------------------------------------------------------------
--	Populate temporary table #BLOCKED from sysindexes for blocked and blocking processes
--	-------------------------------------------------------------------------------------
DECLARE BLOCKED CURSOR FOR
SELECT WAIT.blocking_session_id,
       WAIT.session_id,
       Rtrim(CONVERT(NVARCHAR(MAX), BLOCKED.context_info)),
       CASE BLOCKED.transaction_isolation_level
         WHEN 1 THEN 'Read Uncommitted'
         WHEN 2 THEN 'Read Committed'
         WHEN 3 THEN 'Repeatable Read'
         WHEN 4 THEN 'Serializable'
         WHEN 5 THEN 'Snapshot'
         ELSE Str(BLOCKED.transaction_isolation_level)
       END,
       WAIT.wait_duration_ms,
       WAIT.wait_type,
       CASE
         WHEN resource_description LIKE 'objectlock%' THEN 'Object'
         WHEN resource_description LIKE 'pagelock%' THEN 'Page'
         WHEN resource_description LIKE 'keylock%' THEN 'Key'
         WHEN resource_description LIKE 'ridlock%' THEN 'Row'
         ELSE 'N/A'
       END,
       Db_name(BLOCKED.database_id),
       CASE
         WHEN resource_description LIKE '%associatedObjectId%' THEN CONVERT(BIGINT, Substring (resource_description, Charindex('associatedObjectId=', resource_description)
                                                                                                                     + 19, ( Len(resource_description) + 1 ) - ( Charindex('associatedObjectId=', resource_description)
                                                                                                                                                                 + 19 )))
         ELSE 0
       END,
       BLOCKEDSQL.text,
       BLOCKEDPLAN.query_plan,
       BLOCKED.transaction_id
FROM   sys.dm_os_waiting_tasks WAIT
       INNER LOOP JOIN sys.dm_exec_requests AS BLOCKED
                    ON WAIT.session_id = BLOCKED.session_id
       OUTER APPLY sys.dm_exec_sql_text(BLOCKED.sql_handle) AS BLOCKEDSQL
       OUTER APPLY sys.dm_exec_query_plan(BLOCKED.plan_handle) AS BLOCKEDPLAN
WHERE  WAIT.wait_type LIKE 'LCK%' 


--AND			database_id = db_id()


OPEN BLOCKED

FETCH BLOCKED INTO 
	@BLOCKER_SESSION_ID		,
	@BLOCKED_SESSION_ID		,
	@BLOCKED_CONTEXT		, 
	@BLOCKED_TRAN_ISOLATION		,
	@WAITTIME				,
	@LOCK_MODE				,
	@LOCK_SIZE				,
	@DATABASE_NAME			,
	@ASSOCIATEDOBJECTID		,
	@BLOCKED_SQL			,
	@BLOCKED_PLAN			,
	@TRANSACTION_ID		

WHILE @@FETCH_STATUS = 0
	BEGIN
		IF EXISTS (SELECT * FROM sys.dm_exec_requests where session_id = @BLOCKER_SESSION_ID)
			
			BEGIN
				SELECT @BLOCKER_CONTEXT = '; Waiting on ' + wait_type,
                       @BLOCKER_TRAN_ISOLATION = CASE transaction_isolation_level
                                                   WHEN 1 THEN 'Read Uncommitted'
                                                   WHEN 2 THEN 'Read Committed'
                                                   WHEN 3 THEN 'Repeatable Read'
                                                   WHEN 4 THEN 'Serializable'
                                                   WHEN 5 THEN 'Snapshot'
                                                   ELSE Str(transaction_isolation_level)
                                                 END,
                       --	-------------------------------------------------------------------------------------
                       --	If blocking process is not waiting on a lock, it is a lead blocker
                       --	-------------------------------------------------------------------------------------
                       @BLOCKER_STATUS = CASE
                                           WHEN blocking_session_id = 0 THEN 'Lead Blocker'
                                           WHEN REQUESTS.session_id = blocking_session_id THEN 'Lead Blocker'
                                           ELSE 'In Blocking Chain'
                                         END,
                       @BLOCKER_SQL = BLOCKERSQL.text,
                       @BLOCKER_PLAN = query_plan
                FROM   sys.dm_exec_requests AS REQUESTS
                       OUTER APPLY sys.dm_exec_sql_text(sql_handle) AS BLOCKERSQL
                       OUTER APPLY sys.dm_exec_query_plan(plan_handle)
                WHERE  REQUESTS.session_id = @BLOCKER_SESSION_ID 
                
		END
	ELSE IF EXISTS (SELECT * FROM  sys.dm_exec_connections WHERE session_id = @BLOCKER_SESSION_ID)
--	-------------------------------------------------------------------------------------
--	If blocker does not have an active request, retrieve most recent information from
--      sys.dm_exec_connections.  
--	SQL txt is via sys.dm_exec_connections.most_recent_sql_handle
--	and the query plan via sys.dm_exec_query_stats.plan_handle
--	-------------------------------------------------------------------------------------
		BEGIN
			SELECT @BLOCKER_CONTEXT = '',
				   @BLOCKER_TRAN_ISOLATION = 'n/a',
				   @BLOCKER_STATUS = 'Lead Blocker',
				   @BLOCKER_SQL = text,
				   @BLOCKER_PLAN = query_plan
			FROM   sys.dm_exec_connections AS CONNECTIONS
				   OUTER APPLY sys.dm_exec_sql_text(CONNECTIONS.most_recent_sql_handle)
				   LEFT JOIN sys.dm_exec_query_stats AS QUERYSTATS
						  ON most_recent_sql_handle = sql_handle
				   OUTER APPLY sys.dm_exec_query_plan(QUERYSTATS.plan_handle)
			WHERE  session_id = @BLOCKER_SESSION_ID 


--	-------------------------------------------------------------------------------------
--	Retrieve blocker's session INFORMATION
--	-------------------------------------------------------------------------------------
			SELECT
			--	@BLOCKER_CONTEXT = '',
			@BLOCKER_TRAN_ISOLATION = CASE transaction_isolation_level
										WHEN 1 THEN 'Read Uncommitted'
										WHEN 2 THEN 'Read Committed'
										WHEN 3 THEN 'Repeatable Read'
										WHEN 4 THEN 'Serializable'
										WHEN 5 THEN 'Snapshot'
										ELSE Str(transaction_isolation_level)
									  END,
			@BLOCKER_LOGIN = login_name,
			@BLOCKER_PROGRAM = program_name,
			@BLOCKER_HOSTNAME = host_name
			FROM   sys.dm_exec_sessions
			WHERE  session_id = @BLOCKER_SESSION_ID 

		END
		
--	-------------------------------------------------------------------------------------
--	Determine User INformation 
--	-------------------------------------------------------------------------------------

			SELECT @BLOCKER_LOGIN = login_name,
				   @BLOCKER_PROGRAM = program_name,
				   @BLOCKER_HOSTNAME = host_name,
				   @BLOCKER_CONTEXT_INFO = context_info 
			FROM   sys.dm_exec_sessions
			WHERE  session_id = @BLOCKER_SESSION_ID

			SELECT @BLOCKED_LOGIN = login_name,
				   @BLOCKED_PROGRAM = program_name,
				   @BLOCKED_HOSTNAME = host_name,
				   @BLOCKED_CONTEXT_INFO = context_info
			FROM   sys.dm_exec_sessions
			WHERE  session_id = @BLOCKED_SESSION_ID 
			

			

		
--	-------------------------------------------------------------------------------------
--	Determine Object ID of lock request
--	-------------------------------------------------------------------------------------


	IF @LOCK_SIZE IN('Row','Key','Page')
		 BEGIN
			SET @SQL=	'USE ['+ @DATABASE_NAME + '] SELECT @OBJECT_NAME_OUT = OBJECT_NAME(object_id),@INDEX_ID_OUT = index_id, @rows_out = 0	FROM '+
						@DATABASE_NAME+
						'.sys.partitions PAR with (NOLOCK)  JOIN ' +@DATABASE_NAME+ + '.sys.sysobjects OBJ ON OBJ.ID = PAR.OBJECT_ID	WHERE partition_id = ' + cast(@ASSOCIATEDOBJECTID as varchar(MAX))
			SET	@PARM = '@OBJECT_NAME_OUT NVARCHAR(128) OUTPUT, @INDEX_ID_OUT INT OUTPUT,@rows_out bigint OUTPUT'

			EXEC sp_executesql	@SQL, 
								@PARM,
								@OBJECT_NAME_OUT    = @OBJECT_NAME OUTPUT,
								@INDEX_ID_OUT = @INDEX_ID OUTPUT,
								@rows_out = @rows OUTPUT
								
								--print @SQL
		END
	ELSE
		BEGIN
			SET @SQL=	'USE ['+ @DATABASE_NAME + '] SELECT @OBJECT_NAME_OUT  = name,@INDEX_ID_OUT = 0, @rows_out = 0	FROM '+
						@DATABASE_NAME+
						'.sys.objects with (NOLOCK)	WHERE object_id = '+ cast(@ASSOCIATEDOBJECTID as varchar(MAX))
			SET	@PARM = '@OBJECT_NAME_OUT NVARCHAR(128) OUTPUT, @INDEX_ID_OUT INT OUTPUT, @rows_out BIGINT OUTPUT'

			EXEC sp_executesql	@SQL, 
								@PARM,
								@OBJECT_NAME_OUT    = @OBJECT_NAME OUTPUT,
								@INDEX_ID_OUT		= @INDEX_ID OUTPUT,
								@rows_out = @rows OUTPUT
		END
		
		--print @SQL
--	-------------------------------------------------------------------------------------

		INSERT INTO @BLOCKED VALUES (
			@BLOCKER_LOGIN			,
			@BLOCKER_PROGRAM		,
			@BLOCKER_HOSTNAME		,
			@BLOCKED_LOGIN			,
			@BLOCKED_PROGRAM		,
			@BLOCKED_HOSTNAME		,
			@BLOCKER_SESSION_ID		,
			@BLOCKER_CONTEXT_INFO   ,
			@BLOCKER_CONTEXT		,
			@BLOCKER_TRAN_ISOLATION	,
			@BLOCKER_STATUS			,
			@BLOCKED_SESSION_ID		,
			@BLOCKED_CONTEXT_INFO   ,
			@BLOCKED_CONTEXT		,
			@BLOCKED_TRAN_ISOLATION	,
			@TRANSACTION_ID			,
			@WAITTIME				,
			@LOCK_MODE				,
			@LOCK_SIZE				,
			@DATABASE_NAME			,
			@OBJECT_NAME			,
			@INDEX_ID				,
			@BLOCKER_SQL			,
			@BLOCKER_PLAN			,
			@BLOCKED_SQL			,
			@BLOCKED_PLAN			)

	FETCH BLOCKED INTO 
		@BLOCKER_SESSION_ID		,
		@BLOCKED_SESSION_ID		,
		@BLOCKED_CONTEXT		, 
		@BLOCKED_TRAN_ISOLATION		,
		@WAITTIME				,
		@LOCK_MODE				,
		@LOCK_SIZE				,
		@DATABASE_NAME			,
		@ASSOCIATEDOBJECTID		,
		@BLOCKED_SQL			,
		@BLOCKED_PLAN			,
		@TRANSACTION_ID	
			
	END

DEALLOCATE BLOCKED;

--print @ASSOCIATEDOBJECTID


SELECT 
    @@SERVERNAME as SERVER_NAME,
	GETDATE() AS BLOCKED_DTTM,
	BLOCKER_LOGIN			,
	BLOCKER_PROGRAM		,
	BLOCKER_HOSTNAME		,
	BLOCKED_LOGIN			,
	BLOCKED_PROGRAM		,
	BLOCKED_HOSTNAME		,
	BLOCKER_SESSION_ID		,
	BLOCKER_CONTEXT_INFO	,
	BLOCKER_CONTEXT	= 
		CASE
				WHEN BLOCKER_CURSORS.properties IS NULL THEN BLOCKER_CONTEXT
				ELSE BLOCKER_CURSORS.properties+'; Dormant for '+ltrim(str(BLOCKER_CURSORS.dormant_duration))+' milleseconds'+BLOCKER_CONTEXT
		END
	
		,
	BLOCKER_TRAN_ISOLATION	,
	BLOCKER_STATUS			,
	BLOCKED_SESSION_ID		,
	BLOCKED_CONTEXT_INFO	,
	BLOCKED_CONTEXT			= 
	
		CASE
				WHEN BLOCKED_CURSORS.properties IS NULL THEN BLOCKED_CONTEXT
				ELSE BLOCKED_CURSORS.properties+'; Dormant for '+ltrim(str(BLOCKED_CURSORS.dormant_duration))+' milleseconds'+BLOCKED_CONTEXT
		END	
		,
	BLOCKED_TRAN_ISOLATION	,
	TRANSACTION_ID			,
	WAIT_TIME				,
	LOCK_MODE				,
	LOCK_SIZE				,
	DATABASE_NAME			,
	ALLOW_SNAPSHOT_ISOLATION = snapshot_isolation_state_desc,
	READ_COMMITTED_SNAPSHOT = 
		CASE is_read_committed_snapshot_on
			WHEN 0 THEN 'OFF'
			WHEN 1 THEN 'ON'
		END,
	OBJECT_NAME				,
	INDEX_ID				,
	BLOCKER_SQL =	
		CASE
				WHEN BLOCKER_SQL LIKE 'FETCH API_CURSOR%' THEN isnull( BLOCKER_CURSORSQL.text, BLOCKER_SQL)
				WHEN BLOCKER_SQL IS NULL THEN BLOCKER_CURSORSQL.text
				ELSE BLOCKER_SQL
		END
			,
	BLOCKER_PLAN = 
		CASE
				WHEN BLOCKER_SQL LIKE 'FETCH API_CURSOR%' THEN isnull (BLOCKER_CURSORPLAN.query_plan, BLOCKER_PLAN)
				WHEN BLOCKER_SQL IS NULL THEN BLOCKER_CURSORPLAN.query_plan
				ELSE BLOCKER_PLAN	
			END,
	BLOCKED_SQL = 
		CASE
				WHEN BLOCKED_SQL LIKE 'FETCH API_CURSOR%' THEN isnull('Cursor: '+BLOCKED_CURSORSQL.text, BLOCKED_SQL)
				ELSE	BLOCKED_SQL
		END,
	BLOCKED_PLAN = 
	   CASE
				WHEN BLOCKED_SQL LIKE 'FETCH API_CURSOR%' THEN isnull(BLOCKED_CURSORPLAN.query_plan, BLOCKED_PLAN)
				ELSE BLOCKED_PLAN	
	   END
FROM	@BLOCKED
JOIN	sys.databases ON name = DATABASE_NAME COLLATE database_default
--	-------------------------------------------------------------------------------------
--	Special Handling for Cursors
--	If the blocking process is a cursor, get SQL text via  sys.dm_exec_cursors.sql_handle
--	and the query plan via sys.dm_exec_query_stats.plan_handle
--	-------------------------------------------------------------------------------------

OUTER APPLY		sys.dm_exec_cursors(BLOCKER_SESSION_ID) AS BLOCKER_CURSORS 

OUTER APPLY		sys.dm_exec_sql_text(BLOCKER_CURSORS.sql_handle) AS BLOCKER_CURSORSQL
LEFT JOIN		sys.dm_exec_query_stats AS BLOCKER_CURSORSTATS ON BLOCKER_CURSORSTATS.sql_handle = BLOCKER_CURSORS.sql_handle
OUTER APPLY		sys.dm_exec_query_plan(BLOCKER_CURSORSTATS.plan_handle) AS BLOCKER_CURSORPLAN

--	-------------------------------------------------------------------------------------
--	Special Handling for Cursors
--	If the blocked process is a cursor, get SQL text via  sys.dm_exec_cursors.sql_handle
--	and the query plan via sys.dm_exec_query_stats.plan_handle
--	-------------------------------------------------------------------------------------

OUTER APPLY		sys.dm_exec_cursors(BLOCKED_SESSION_ID) AS BLOCKED_CURSORS

OUTER APPLY		sys.dm_exec_sql_text(BLOCKED_CURSORS.sql_handle) AS BLOCKED_CURSORSQL
LEFT JOIN		sys.dm_exec_query_stats AS BLOCKED_CURSORSTATS ON BLOCKED_CURSORSTATS.sql_handle = BLOCKED_CURSORS.sql_handle
OUTER APPLY		sys.dm_exec_query_plan(BLOCKED_CURSORSTATS.plan_handle) AS BLOCKED_CURSORPLAN

--WHERE BLOCKER_CURSORS.is_open = 1
--AND		BLOCKED_CURSORS.is_open = 1
ORDER BY WAIT_TIME DESC
GO
PRINT N'Creating [dbo].[SP_UPDATE_AOTEXPORT_DATA]...';


GO
SET ANSI_NULLS, QUOTED_IDENTIFIER OFF;


/****** Object:  StoredProcedure [dbo].[SP_UPDATE_AOTEXPORT_DATA]    Script Date: 04/05/2017 11:00:14 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[SP_UPDATE_AOTEXPORT_DATA]') AND type in (N'P', N'PC'))
DROP PROCEDURE [dbo].[SP_UPDATE_AOTEXPORT_DATA]
GO


GO
CREATE PROCEDURE [dbo].[SP_UPDATE_AOTEXPORT_DATA] @SERVERNAME          NVARCHAR(128),
                                                  @DATABASENAME        NVARCHAR(128),
                                                  @SERVERNAMEUPDATED   NVARCHAR(128),
                                                  @DATABASENAMEUPDATED NVARCHAR(128)
AS
  BEGIN TRY
      UPDATE AX_TABLE_DETAIL
      SET    SERVER_NAME = @SERVERNAMEUPDATED,
             DATABASE_NAME = @DATABASENAMEUPDATED
      WHERE  SERVER_NAME = @SERVERNAME
             AND DATABASE_NAME = @DATABASENAME

      UPDATE AX_INDEX_DETAIL
      SET    SERVER_NAME = @SERVERNAMEUPDATED,
             DATABASE_NAME = @DATABASENAMEUPDATED
      WHERE  SERVER_NAME = @SERVERNAME
             AND DATABASE_NAME = @DATABASENAME

      UPDATE AX_CONFIGURATIONKEY_DETAIL
      SET    SERVER_NAME = @SERVERNAMEUPDATED,
             DATABASE_NAME = @DATABASENAMEUPDATED
      WHERE  SERVER_NAME = @SERVERNAME
             AND DATABASE_NAME = @DATABASENAME

      UPDATE AX_LICENSEKEY_DETAIL
      SET    SERVER_NAME = @SERVERNAMEUPDATED,
             DATABASE_NAME = @DATABASENAMEUPDATED
      WHERE  SERVER_NAME = @SERVERNAME
             AND DATABASE_NAME = @DATABASENAME

      UPDATE AX_BATCHJOB_DETAIL
      SET    SERVER_NAME = @SERVERNAMEUPDATED,
             DATABASE_NAME = @DATABASENAMEUPDATED
      WHERE  SERVER_NAME = @SERVERNAME
             AND DATABASE_NAME = @DATABASENAME

      UPDATE AX_SERVER_CONFIG
      SET    SERVER_NAME = @SERVERNAMEUPDATED,
             DATABASE_NAME = @DATABASENAMEUPDATED
      WHERE  SERVER_NAME = @SERVERNAME
             AND DATABASE_NAME = @DATABASENAME

      UPDATE AX_BATCHSERVERGROUP_CONFIG
      SET    SERVER_NAME = @SERVERNAMEUPDATED,
             DATABASE_NAME = @DATABASENAMEUPDATED
      WHERE  SERVER_NAME = @SERVERNAME
             AND DATABASE_NAME = @DATABASENAME

      RETURN 0
  END TRY

  BEGIN CATCH
      RETURN 1
  END CATCH
GO
SET ANSI_NULLS, QUOTED_IDENTIFIER ON;


GO
PRINT N'Altering [dbo].[SP_LOCKS_MS]...';


GO



ALTER PROCEDURE [dbo].[SP_LOCKS_MS] @delay VARCHAR(10)
 AS
 
SET quoted_identifier OFF
--truncate table DynamicsPerf20..blocks  --delete all previous records
DECLARE  @cmd NVARCHAR(100)



/****** Object:  Table [dbo].[BLOCKS]    Script Date: 04/17/2012 14:10:13 ******/
IF  OBJECT_ID('tempdb..#BLOCKS') IS NOT NULL
          DROP TABLE [dbo].[#BLOCKS]



CREATE TABLE [dbo].[#BLOCKS](
    [SERVER_NAME] [nvarchar] (128) NULL, 
	[BLOCKED_DTTM] [datetime] NOT NULL,
	[BLOCKER_LOGIN] [nvarchar](128) NULL,
	[BLOCKER_PROGRAM] [nvarchar](128) NULL,
	[BLOCKER_HOSTNAME] [nvarchar](128) NULL,
	[BLOCKED_LOGIN] [nvarchar](128) NULL,
	[BLOCKED_PROGRAM] [nvarchar](128) NULL,
	[BLOCKED_HOSTNAME] [nvarchar](128) NULL,
	[BLOCKER_SESSION_ID] [smallint] NULL,
	[BLOCKER_CONTEXT_INFO] [binary](128) NULL,
	[BLOCKER_CONTEXT] [nvarchar](max) NULL,
	[BLOCKER_TRAN_ISOLATION] [varchar](20) NULL,
	[BLOCKER_STATUS] [varchar](18) NULL,
	[BLOCKED_SESSION_ID] [smallint] NULL,
	[BLOCKED_CONTEXT_INFO] [binary](128) NULL,
	[BLOCKED_CONTEXT] [nvarchar](max) NULL,
	[BLOCKED_TRAN_ISOLATION] [varchar](20) NULL,
	[TRANSACTION_ID] [bigint] NULL,
	[WAIT_TIME] [bigint] NULL,
	[LOCK_MODE] [nvarchar](60) NULL,
	[LOCK_SIZE] [nvarchar](6) NULL,
	[DATABASE_NAME] [nvarchar](128) NULL,
	[ALLOW_SNAPSHOT_ISOLATION] [nvarchar](60) NULL,
	[READ_COMMITTED_SNAPSHOT] [nvarchar](3) NULL,
	[OBJECT_NAME] [nvarchar](128) NULL,
	[INDEX_ID] [int] NULL,
	[BLOCKER_SQL] [nvarchar](max) NULL,
	[BLOCKER_PLAN] [xml] NULL,
	[BLOCKED_SQL] [nvarchar](max) NULL,
	[BLOCKED_PLAN] [xml] NULL
) ON [PRIMARY]

TOP_LOOP:
BEGIN TRY

TRUNCATE TABLE #BLOCKS

INSERT #BLOCKS
EXEC [SP_LOGBLOCKS_MS]



 MERGE DynamicsPerf..BLOCKS AS target
    USING (
SELECT 
    SERVER_NAME,
	BLOCKED_DTTM,
	BLOCKER_LOGIN			,
	BLOCKER_PROGRAM		,
	BLOCKER_HOSTNAME		,
	BLOCKED_LOGIN			,
	BLOCKED_PROGRAM		,
	BLOCKED_HOSTNAME		,
	BLOCKER_SESSION_ID		,
	BLOCKER_CONTEXT_INFO	,
	BLOCKER_CONTEXT			,
	BLOCKER_TRAN_ISOLATION	,
	BLOCKER_STATUS			,
	BLOCKED_SESSION_ID		,
	BLOCKED_CONTEXT_INFO	,
	BLOCKED_CONTEXT			,
	BLOCKED_TRAN_ISOLATION	,
	TRANSACTION_ID			,
	WAIT_TIME				,
	LOCK_MODE				,
	LOCK_SIZE				,
	DATABASE_NAME			,
	ALLOW_SNAPSHOT_ISOLATION,
	READ_COMMITTED_SNAPSHOT ,
	OBJECT_NAME				,
	INDEX_ID				,
	BLOCKER_SQL				,
			
	BLOCKER_PLAN = BLOCKER_PLAN	,
	BLOCKED_SQL = 	BLOCKED_SQL ,
	BLOCKED_PLAN =  BLOCKED_PLAN	
				
FROM	#BLOCKS
) as source

ON (source.TRANSACTION_ID = target.TRANSACTION_ID 
AND source.BLOCKED_SESSION_ID = target.BLOCKED_SESSION_ID 
AND source.BLOCKER_SESSION_ID = target.BLOCKER_SESSION_ID)

    WHEN MATCHED THEN 
        UPDATE SET WAIT_TIME = source.WAIT_TIME, BLOCKED_DTTM = source.BLOCKED_DTTM
	WHEN NOT MATCHED THEN	
	    INSERT (
		    [SERVER_NAME]
		   ,[BLOCKED_DTTM]
           ,[BLOCKER_LOGIN]
           ,[BLOCKER_PROGRAM]
           ,[BLOCKER_HOSTNAME]
           ,[BLOCKED_LOGIN]
           ,[BLOCKED_PROGRAM]
           ,[BLOCKED_HOSTNAME]
           ,[BLOCKER_SESSION_ID]
           ,[BLOCKER_CONTEXT_INFO]
           ,[BLOCKER_CONTEXT]
           ,[BLOCKER_TRAN_ISOLATION]
           ,[BLOCKER_STATUS]
           ,[BLOCKED_SESSION_ID]
           ,[BLOCKED_CONTEXT_INFO]
           ,[BLOCKED_CONTEXT]
           ,[BLOCKED_TRAN_ISOLATION]
           ,[TRANSACTION_ID]
           ,[WAIT_TIME]
           ,[LOCK_MODE]
           ,[LOCK_SIZE]
           ,[DATABASE_NAME]
           ,[ALLOW_SNAPSHOT_ISOLATION]
           ,[READ_COMMITTED_SNAPSHOT]
           ,[OBJECT_NAME]
           ,[INDEX_ID]
           ,[BLOCKER_SQL]
           ,[BLOCKER_PLAN]
           ,[BLOCKED_SQL]
           ,[BLOCKED_PLAN])
           
           VALUES (
		    source.[SERVER_NAME]
		   ,source.[BLOCKED_DTTM]
           ,source.[BLOCKER_LOGIN]
           ,source.[BLOCKER_PROGRAM]
           ,source.[BLOCKER_HOSTNAME]
           ,source.[BLOCKED_LOGIN]
           ,source.[BLOCKED_PROGRAM]
           ,source.[BLOCKED_HOSTNAME]
           ,source.[BLOCKER_SESSION_ID]
           ,source.[BLOCKER_CONTEXT_INFO]
           ,source.[BLOCKER_CONTEXT]
           ,source.[BLOCKER_TRAN_ISOLATION]
           ,source.[BLOCKER_STATUS]
           ,source.[BLOCKED_SESSION_ID]
           ,source.[BLOCKED_CONTEXT_INFO]
           ,source.[BLOCKED_CONTEXT]
           ,source.[BLOCKED_TRAN_ISOLATION]
           ,source.[TRANSACTION_ID]
           ,source.[WAIT_TIME]
           ,source.[LOCK_MODE]
           ,source.[LOCK_SIZE]
           ,source.[DATABASE_NAME]
           ,source.[ALLOW_SNAPSHOT_ISOLATION]
           ,source.[READ_COMMITTED_SNAPSHOT]
           ,source.[OBJECT_NAME]
           ,source.[INDEX_ID]
           ,source.[BLOCKER_SQL]
           ,source.[BLOCKER_PLAN]
           ,source.[BLOCKED_SQL]
           ,source.[BLOCKED_PLAN]);
           
   

END TRY
BEGIN CATCH
 --ignore the error
END catch
 
SELECT @cmd = 'waitfor delay ' +Quotename(@delay,'''')
EXEC sp_executesql @cmd

GOTO TOP_LOOP


ABORT:
RETURN(0)
GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[dbo].[DYNPERF_SERVER_ACTIVITY] TO PUBLIC
    AS [dbo];


GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[dbo].[SP_DELETE_AOTEXPORT] TO PUBLIC
    AS [dbo];


GO
PRINT N'Refreshing [dbo].[fn_getnonclusteredcount]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[fn_getnonclusteredcount]';


GO
PRINT N'Refreshing [dbo].[DYNPERF_UPDATE_INDEX_HISTORY]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[DYNPERF_UPDATE_INDEX_HISTORY]';

UPDATE DYNAMICSPERF_SETUP SET VERSION = '2.00 RTM 20170405'
GO
GO
PRINT N'Update complete.';


GO
