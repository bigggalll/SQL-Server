
--REH Purge sproc for SQL2008R@ removed delete bottom 50% of plans at end of month since it uses SQL2012 code


CREATE PROCEDURE [dbo].[DYNPERF_PURGE_DATA]
	(@TASK_ID       INT,
                                              @SERVER_NAME   NVARCHAR(128),
                                              @DATABASE_NAME NVARCHAR(128),
                                              @TASK_PARAMS   NVARCHAR(1024),
                                              @TASK_DESC     NVARCHAR(256),
                                              @LAST_RUN      DATETIME,
                                              @RUN_NAME      NVARCHAR(255),
                                              @STATS_DATE    DATETIME,
                                              @REMOTE_SERVER NVARCHAR(1),
											  @AZURE_DB		 BIT,
											  @SQL_TZ_OFFSET INT,
											  @DPA_TZ_OFFSET INT,
                                              @DEBUG         NVARCHAR(1))
AS


SET NOCOUNT ON
SET DATEFORMAT MDY
DECLARE @PURGE_DATE smalldatetime, @PURGE_DAYS INT, @SQL NVARCHAR(MAX), @ROW_COUNT BIGINT = 0


DECLARE  @C_TABLE_NAME NVARCHAR(128), @C_TIME_COLUMN NVARCHAR(128), @C_SERVER_FLAG BIT, @C_DATABASE_FLAG BIT, @C_PURGE_DAYS INT
DECLARE @DC_SERVER_NAME NVARCHAR(128), @DC_DATABASE_NAME NVARCHAR(128), @DC_HISTORY_MONTHS INT, @DC_HISTORY_DAYS INT, @DC_DETAILS_DAYS INT






/********************************************************************************************************************************
*   STARTING TASK
*********************************************************************************************************************************/

UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'STARTING to ' + ISNULL(@TASK_DESC, 'TASK')
              + ' for SERVER ' + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' USING PARMS @LAST_RUN ' + CAST(@LAST_RUN AS VARCHAR(30)) 
			  + ' @DPA_TZ_OFFSET = ' + CAST (@DPA_TZ_OFFSET AS VARCHAR(10))
			  + ' @SQL_TZ_OFFSET = ' + CAST(@SQL_TZ_OFFSET  AS VARCHAR(10))
			  + ' @STATS_DATE = ' + CAST(@STATS_DATE AS VARCHAR(30)) 
			  + ' @AZURE_DB = ' + CAST(@AZURE_DB AS VARCHAR(10))
			  + ' @REMOTE = ' + @REMOTE_SERVER
			  + ' @PARMS = ' + ISNULL(@TASK_PARAMS, '')
			  + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



--REH  Time Zone code for all procedures
IF @LAST_RUN > '1/1/1901'
  BEGIN
      IF @REMOTE_SERVER = 'N'
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @DPA_TZ_OFFSET, @LAST_RUN) --REH DPA and DB are on same server so use DPA Time Zone Offset
        END
      ELSE
        BEGIN
            SET @LAST_RUN = DATEADD(MI, @SQL_TZ_OFFSET, @LAST_RUN)  --REH DPA and DB are on different servers so use DB Time Zone Offset
        END
  END 



BEGIN TRY
PRINT 'STARTING ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''




DECLARE TASK_CURSOR CURSOR  LOCAL
FOR
SELECT TABLE_NAME, TIME_COLUMN, SERVER_NAME_FLAG, DATABASE_NAME_FLAG, RETENTION_DAYS
FROM   DynamicsPerf..[DYNPERF_PURGETABLES] WHERE TIME_COLUMN > ''  ---REH Ignore tables without some form of time column.  The collection sproc will handle deletion of data in those tables
ORDER BY RETENTION_DAYS, TABLE_NAME    --REH this sort is to force QUERY_STATS to delete before QUERY_PLANS/QUERY_TEXT so we don't wait a day to delete records not attached to data



/* Open the cursor */
/*if the cursor isn't open you will get an error when you fetch the record*/
OPEN TASK_CURSOR 

/* Get the first record */
/* you can FETCH NEXT, FIRST, LAST, PREVIOUS */
FETCH NEXT FROM TASK_CURSOR INTO @C_TABLE_NAME, @C_TIME_COLUMN, @C_SERVER_FLAG, @C_DATABASE_FLAG, @C_PURGE_DAYS


/* Verify that we got a record*/
/* status 0 means we got a good record*/

WHILE @@fetch_status = 0  /* no errors */
BEGIN /* Top of Loop */



	SET @PURGE_DAYS = @C_PURGE_DAYS * -1  --set to negative so we go back in time not forward in time
	SET @PURGE_DATE = DATEADD(DD,@PURGE_DAYS,GETDATE())



	UPDATE CAPTURE_LOG
SET    TEXT = TEXT + ' PURGING TABLE ' + ISNULL(@C_TABLE_NAME, 'TABLE ')
              + ' using PURGE_DAYS ' + CAST(@PURGE_DAYS AS VARCHAR(10)) + ' on DATE '
              + CONVERT(VARCHAR, @PURGE_DATE, 109) + ', '
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)




IF @C_TABLE_NAME IN ('QUERY_PLANS', 'QUERY_TEXT')  --REH Use special handling for QUERY_PLANS and QUERY_TEXT TABLE delete based on no dependent records
BEGIN
--REH All associated records in other tables must be deleted first, QUERY_STATS, QUERY_HISTORY, ETC

		IF @C_TABLE_NAME = 'QUERY_PLANS'
		BEGIN

				SELECT DISTINCT QP.SERVER_NAME, QP.DATABASE_NAME, QP.QUERY_PLAN_HASH
				INTO #QP1
					 FROM QUERY_PLANS QP WHERE QP.SERVER_NAME = @SERVER_NAME AND
				 NOT EXISTS (SELECT QS.QUERY_PLAN_HASH FROM QUERY_STATS QS WHERE QS.DATABASE_NAME = QP.DATABASE_NAME AND QS.SERVER_NAME = QP.SERVER_NAME AND QP.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH) 
					AND NOT EXISTS (SELECT QUERY_PLAN_HASH FROM QUERY_HISTORY QH WHERE QH.DATABASE_NAME = QP.DATABASE_NAME AND QH.SERVER_NAME = QP.SERVER_NAME AND QP.QUERY_PLAN_HASH = QH.QUERY_PLAN_HASH) 
				
				DELETE QP FROM QUERY_PLANS QP INNER JOIN #QP1 ON  QP.SERVER_NAME = #QP1.SERVER_NAME 
					AND QP.DATABASE_NAME = #QP1.DATABASE_NAME AND QP.QUERY_PLAN_HASH = #QP1.QUERY_PLAN_HASH
		
				DROP TABLE #QP1


			--REH Delete any plans over the minimum number of plans to keep
				
				SELECT A.*
				INTO #DEL_PLANS
				FROM (
				SELECT DISTINCT QV.SERVER_NAME,
										QV.DATABASE_NAME,
										QUERY_HASH,
										QV.QUERY_PLAN_HASH,
										RN = ROW_NUMBER()
									  OVER (
										PARTITION BY QV.QUERY_HASH
										ORDER BY QV.QUERY_HASH DESC, QP.DATE_UPDATED DESC)
						FROM   QUERY_HISTORY_VW QV INNER JOIN QUERY_PLANS QP ON QV.SERVER_NAME=QP.SERVER_NAME
						AND QV.DATABASE_NAME = QP.DATABASE_NAME AND QV.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
						WHERE QV.DATE = DATEADD(MONTH, DATEDIFF(MONTH, 0, GETDATE()  ), 0) 

				   ) AS A 
				   INNER JOIN QUERY_PLANS QP ON QP.SERVER_NAME = A.SERVER_NAME AND QP.DATABASE_NAME = A.DATABASE_NAME AND QP.QUERY_PLAN_HASH = A.QUERY_PLAN_HASH
				   WHERE A.RN> (SELECT D2.NUM_PLANS_TO_KEEP FROM DATABASES_2_COLLECT D2 WHERE D2.LINKED_SERVER=A.SERVER_NAME AND D2.DATABASE_NAME = A.DATABASE_NAME)

					DELETE QP FROM QUERY_PLANS QP INNER JOIN #DEL_PLANS DP ON QP.SERVER_NAME = DP.SERVER_NAME
					AND QP.DATABASE_NAME = DP.DATABASE_NAME AND QP.QUERY_PLAN_HASH = DP.QUERY_PLAN_HASH

				   DROP TABLE #DEL_PLANS

			SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT


			--REH Delete any plans over the retention data

			DELETE QP FROM QUERY_PLANS QP INNER JOIN DATABASES_2_COLLECT DC ON QP.SERVER_NAME = DC.LINKED_SERVER AND DC.DATABASE_NAME = QP.DATABASE_NAME
			WHERE QP.DATE_UPDATED < DATEADD(DD, DC.PURGE_PLANS_AFTER_X_DAYS, GETDATE() )
			
			--REH Delete the bottom % of query_plans  RUN this task on the first day of the month
			

			--IF DATEPART(D,GETDATE()) = 1 --REH Only run this part on first day of month
			--BEGIN 
			--	WITH CTE_STATS (SERVER_NAME, DATABASE_NAME, QUERY_PLAN_HASH, PctRank)
			--		 AS (
	 	--				SELECT TOP 100 PERCENT QH.SERVER_NAME, QH.DATABASE_NAME, QH.QUERY_PLAN_HASH,
			--		   PERCENT_RANK() OVER (PARTITION BY QH.SERVER_NAME, QH.DATABASE_NAME ORDER BY QH.ELAPSED_TIME_TODAY  ) * 100.00 AS PctRank
			--	FROM QUERY_HISTORY QH INNER JOIN DATABASES_2_COLLECT D2 ON QH.SERVER_NAME = D2.LINKED_SERVER AND QH.DATABASE_NAME = D2.DATABASE_NAME
			--	WHERE FLAG = 'M' and DATE =  DATEADD(MM,-1,DATEDIFF(MONTH, 0, GETDATE()))  --REH Previous Month
			--	--AND < 100 - D2.KEEP_TOP_X_PLANS_BY_MONTH  --REH The rank is less than the rank we want to keep (based on total time)
			--	ORDER BY QH.SERVER_NAME, QH.DATABASE_NAME, QH.ELAPSED_TIME_TODAY DESC)

			--	DELETE QP FROM QUERY_PLANS QP 
			--	INNER JOIN CTE_STATS CTE ON QP.SERVER_NAME = CTE.SERVER_NAME AND CTE.DATABASE_NAME = QP.DATABASE_NAME AND CTE.QUERY_PLAN_HASH = QP.QUERY_PLAN_HASH
			--	INNER JOIN DATABASES_2_COLLECT D2  ON D2.LINKED_SERVER = CTE.SERVER_NAME AND CTE.DATABASE_NAME = D2.DATABASE_NAME 
			--	WHERE CTE.PCTRANK < 100 - D2.KEEP_TOP_X_QUERIES_BY_MONTH  --REH The rank is less than the rank we want to keep (based on total time)
			
			
			--END

		END

				

	   IF @C_TABLE_NAME = 'QUERY_TEXT'
		BEGIN
			SELECT QT.SERVER_NAME, QT.DATABASE_NAME, QT.QUERY_HASH 
			INTO #QT 
			FROM QUERY_TEXT QT WHERE QT.SERVER_NAME = @SERVER_NAME AND
			 NOT EXISTS (SELECT QS.QUERY_HASH FROM QUERY_STATS QS WHERE QS.DATABASE_NAME = QT.DATABASE_NAME AND QS.SERVER_NAME = QT.SERVER_NAME AND QT.QUERY_HASH = QS.QUERY_HASH) 
				AND NOT EXISTS (SELECT QUERY_HASH FROM QUERY_HISTORY QH WHERE QH.DATABASE_NAME = QT.DATABASE_NAME AND QH.SERVER_NAME = QT.SERVER_NAME AND QT.QUERY_HASH = QH.QUERY_HASH) 

				DELETE QT FROM QUERY_TEXT QT INNER JOIN #QT TMP ON QT.SERVER_NAME = TMP.SERVER_NAME
				AND QT.DATABASE_NAME = TMP.DATABASE_NAME AND QT.QUERY_HASH = TMP.QUERY_HASH


				SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
		END
END
ELSE
IF @C_TABLE_NAME IN ('QUERY_STATS', 'INDEX_DETAIL')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE

		BEGIN

				IF @C_TABLE_NAME = 'QUERY_STATS'
					DELETE QS FROM QUERY_STATS QS WITH (ROWLOCK) INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE QS.SERVER_NAME = @SERVER_NAME AND QS.STATS_TIME < DATEADD(D,DC.RETAIN_DETAILS_DAYS * -1, GETDATE())

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

				IF @C_TABLE_NAME = 'INDEX_DETAIL'
					DELETE ID FROM INDEX_DETAIL ID WITH (ROWLOCK) INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.STATS_TIME < DATEADD(D,DC.RETAIN_DETAILS_DAYS * -1, GETDATE())

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
		
				
		END

ELSE
IF @C_TABLE_NAME IN ('CAPTURE_LOG')


	BEGIN

	
	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE  ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

	END
ELSE

IF @C_TABLE_NAME IN ('INDEX_HISTORY', 'QUERY_HISTORY')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE

		BEGIN

				IF @C_TABLE_NAME = 'QUERY_HISTORY'
				BEGIN
					--REH DELETE MONTHLY QUERY TOTALS 
					DELETE QS FROM QUERY_HISTORY QS INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE  QS.SERVER_NAME = @SERVER_NAME AND QS.DATE < DATEADD(MM,DC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) AND QS.FLAG = 'M'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



					--REH DELETE DAYS TOTALS FROM QUERY_HISTORY		
					DELETE QS FROM QUERY_HISTORY QS INNER JOIN DATABASES_2_COLLECT DC ON QS.SERVER_NAME = DC.LINKED_SERVER AND QS.DATABASE_NAME = DC.DATABASE_NAME
						WHERE  QS.SERVER_NAME = @SERVER_NAME AND QS.DATE < DATEADD(MM,DC.RETAIN_HISTORY_DAYS * -1, GETDATE()) AND QS.FLAG = 'D'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

		--REH STALE QUERY delete

							;WITH CTE_HIST (SERVER_NAME, DATABASE_NAME, QUERY_HASH, QUERY_PLAN_HASH, MAX_DATE)
								 AS (SELECT SERVER_NAME,
											DATABASE_NAME,
											QUERY_HASH,
											QUERY_PLAN_HASH,
											MAX(DATE)
									 FROM   QUERY_HISTORY
									 GROUP  BY SERVER_NAME,
											   DATABASE_NAME,
											   QUERY_HASH,
											   QUERY_PLAN_HASH)
							DELETE QS
							FROM   QUERY_HISTORY QS
								   INNER JOIN DATABASES_2_COLLECT DC
										   ON QS.SERVER_NAME = DC.LINKED_SERVER
											  AND QS.DATABASE_NAME = DC.DATABASE_NAME
								   INNER JOIN CTE_HIST CTE
										   ON CTE.SERVER_NAME = QS.SERVER_NAME
											  AND CTE.DATABASE_NAME = QS.DATABASE_NAME
											  AND CTE.QUERY_HASH = QS.QUERY_HASH
											  AND CTE.QUERY_PLAN_HASH = QS.QUERY_PLAN_HASH
							WHERE  QS.SERVER_NAME = @SERVER_NAME
								   AND CTE.MAX_DATE < DATEADD(MM, DC.PURGE_STALE_QUERIES_DAYS * -1, GETDATE()) 


						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



						IF DATEPART(D,GETDATE()) = 1 --REH Only run this part on first day of month
							BEGIN 
								WITH CTE_STATS (SERVER_NAME, DATABASE_NAME, QUERY_HASH, PctRank)
									 AS (
	 									SELECT TOP 100 PERCENT QH.SERVER_NAME, QH.DATABASE_NAME, QH.QUERY_HASH,
									   PERCENT_RANK() OVER (PARTITION BY QH.SERVER_NAME, QH.DATABASE_NAME ORDER BY QH.ELAPSED_TIME_TODAY  ) * 100.00 AS PctRank
								FROM QUERY_HISTORY QH INNER JOIN DATABASES_2_COLLECT D2 ON QH.SERVER_NAME = D2.LINKED_SERVER AND QH.DATABASE_NAME = D2.DATABASE_NAME
								WHERE FLAG = 'M' and DATE =  DATEADD(MM,-1,DATEDIFF(MONTH, 0, GETDATE()))  --REH Previous Month
								--AND < 100 - D2.KEEP_TOP_X_PLANS_BY_MONTH  --REH The rank is less than the rank we want to keep (based on total time)
								ORDER BY QH.SERVER_NAME, QH.DATABASE_NAME, QH.ELAPSED_TIME_TODAY DESC)

								DELETE QP FROM QUERY_HISTORY QH
								INNER JOIN CTE_STATS CTE ON QH.SERVER_NAME = CTE.SERVER_NAME AND CTE.DATABASE_NAME = QH.DATABASE_NAME AND CTE.QUERY_HASH = QH.QUERY_HASH
								INNER JOIN DATABASES_2_COLLECT D2  ON D2.LINKED_SERVER = CTE.SERVER_NAME AND CTE.DATABASE_NAME = D2.DATABASE_NAME 
								WHERE CTE.PCTRANK < 100 - D2.KEEP_TOP_X_QUERIES_BY_MONTH  --REH The rank is less than the rank we want to keep (based on total time)
			
							END







				END

				IF @C_TABLE_NAME = 'INDEX_HISTORY'
				BEGIN
					DELETE ID FROM INDEX_HISTORY ID INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.DATE < DATEADD(MM,DC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) AND ID.FLAG = 'M'

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

					DELETE ID FROM INDEX_HISTORY ID INNER JOIN DATABASES_2_COLLECT DC ON ID.SERVER_NAME = DC.LINKED_SERVER AND ID.DATABASE_NAME = DC.DATABASE_NAME 
							WHERE ID.SERVER_NAME = @SERVER_NAME AND ID.DATE < DATEADD(MM,DC.RETAIN_HISTORY_DAYS * -1, GETDATE()) AND ID.FLAG = 'D'

							SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

				END	
			
		END

ELSE

IF @C_TABLE_NAME IN ('SSRS_EXECUTIONLOG', 'SSRS_HISTORY')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE
BEGIN
			IF @C_TABLE_NAME = 'SSRS_EXECUTIONLOG'
				BEGIN
					--REH DELETE MONTHLY QUERY TOTALS 
					DELETE EL FROM SSRS_EXECUTIONLOG EL 
					INNER JOIN SSRS_CONFIG SC ON EL.SERVER_NAME = SC.SERVER_NAME AND EL.DATABASE_NAME = SC.DATABASE_NAME
						WHERE  EL.TIMEEND < DATEADD(MM,SC.RETAIN_DETAILS_DAYS * -1, GETDATE()) 

					SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
				END
			IF @C_TABLE_NAME = 'SSRS_HISTORY'
				BEGIN
					--REH DELETE MONTHLY QUERY TOTALS 
					DELETE SH FROM SSRS_HISTORY SH 
						INNER JOIN SSRS_CONFIG SC ON SH.SERVER_NAME = SC.SERVER_NAME AND SH.DATABASE_NAME = SC.DATABASE_NAME
						WHERE   SH.REPORT_DATE < DATEADD(MM,SC.RETAIN_HISTORY_MONTHS * -1, GETDATE()) AND SH.FLAG = 'M'

						SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT



					--REH DELETE DAYS TOTALS FROM QUERY_HISTORY	
					DELETE SH FROM SSRS_HISTORY SH 
						INNER JOIN SSRS_CONFIG SC ON SH.SERVER_NAME = SC.SERVER_NAME AND SH.DATABASE_NAME = SC.DATABASE_NAME
						WHERE   SH.REPORT_DATE < DATEADD(MM,SC.RETAIN_HISTORY_DAYS * -1, GETDATE()) AND SH.FLAG = 'M'
	
					SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
				END
				
END


ELSE


IF @C_TABLE_NAME IN ('QUERY_PLANS_PARSED')  --RETAINED BASED ON FIELDS IN THE DATABASES_2_COLLECT TABLE
BEGIN
	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SELECT QPP.SERVER_NAME, QPP.DATABASE_NAME, QPP.QUERY_PLAN_HASH 
	INTO #QPP FROM QUERY_PLANS_PARSED QPP 
	WHERE NOT EXISTS (SELECT 'X' FROM QUERY_HISTORY QH WHERE QPP.SERVER_NAME = QH.SERVER_NAME
	AND QPP.DATABASE_NAME = QH.DATABASE_NAME AND QPP.QUERY_PLAN_HASH = QH.QUERY_PLAN_HASH)

	DELETE QPP FROM QUERY_PLANS_PARSED QPP INNER JOIN #QPP TMP ON QPP.SERVER_NAME = TMP.SERVER_NAME
		AND QPP.DATABASE_NAME = TMP.DATABASE_NAME AND QPP.QUERY_PLAN_HASH = TMP.QUERY_PLAN_HASH

	DROP TABLE #QPP

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT
END


ELSE


BEGIN



	SET @SQL = 'DELETE FROM ' + @C_TABLE_NAME + ' WHERE SERVER_NAME =  ' + ''''+ @SERVER_NAME + '''' + ' AND ' + @C_TIME_COLUMN + ' <= ' + '''' + CONVERT(VARCHAR, @PURGE_DATE, 109) + ''''
			IF @DEBUG = 'Y'
			 BEGIN
				 PRINT @SQL
			 END
	EXEC(@SQL)

	SET @ROW_COUNT = @ROW_COUNT + @@ROWCOUNT

END




FETCH NEXT FROM TASK_CURSOR INTO @C_TABLE_NAME, @C_TIME_COLUMN, @C_SERVER_FLAG, @C_DATABASE_FLAG, @C_PURGE_DAYS


END  /*End of the loop */
CLOSE TASK_CURSOR  /*close the cursor to free memory in SQL*/
DEALLOCATE TASK_CURSOR /*Must deallocate the cursor to destroy it and free SQL resources*/
 
	


UPDATE CAPTURE_LOG
SET    TEXT = TEXT + 'SUCCESSFULLY '
              + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
              + ISNULL(@SERVER_NAME, '') + ' on database '
              + ISNULL(@DATABASE_NAME, '') + ' at '
              + CONVERT(VARCHAR, GETDATE(), 109) 
			  + ' Deleted ' + CAST(@ROW_COUNT AS VARCHAR(10)) + ' ROWS ' +  CHAR(10) 
WHERE  STATS_TIME = @STATS_DATE 
AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



PRINT ''
PRINT 'SUCCESSFULLY CAPTURED ' + ISNULL(@TASK_DESC, 'TASK')
PRINT ''


RETURN(0)  --REH RETURN SUCCESS


END TRY 


/********************************************************************************************************************************
*   END OF TASK
*********************************************************************************************************************************/


BEGIN CATCH
    UPDATE CAPTURE_LOG
    SET    TEXT = TEXT + 'FAILED !!! to '
	      + ISNULL(@TASK_DESC, 'TASK') + ' for SERVER '
                  + ISNULL(@SERVER_NAME, '') + ' on database '
                  + ISNULL(@DATABASE_NAME, '') + ' at '
                  + CONVERT(VARCHAR, GETDATE(), 109) 
				  + ' ERROR = ' + CAST(@@ERROR AS VARCHAR(MAX))
				  + ', ' 
				  + CHAR(10)
    WHERE  STATS_TIME = @STATS_DATE
	AND TASK_TYPE = (SELECT TOP 1 TASK_TYPE FROM DYNPERF_TASK_SCHEDULER WHERE TASK_ID = @TASK_ID)



    PRINT 'ERROR WHILE COLLECTING '
          + ISNULL(@TASK_DESC, '') + ' !!!!!!!!!!!!!!'

    RETURN(1) --REH RETURN ERROR, TRAPPED BY SPROC
END CATCH

